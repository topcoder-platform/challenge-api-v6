
/**
 * Client
**/

import * as runtime from './runtime/library.js';
import $Types = runtime.Types // general types
import $Public = runtime.Types.Public
import $Utils = runtime.Types.Utils
import $Extensions = runtime.Types.Extensions
import $Result = runtime.Types.Result

export type PrismaPromise<T> = $Public.PrismaPromise<T>


/**
 * Model Challenge
 * 
 */
export type Challenge = $Result.DefaultSelection<Prisma.$ChallengePayload>
/**
 * Model ChallengeType
 * 
 */
export type ChallengeType = $Result.DefaultSelection<Prisma.$ChallengeTypePayload>
/**
 * Model ChallengeTrack
 * 
 */
export type ChallengeTrack = $Result.DefaultSelection<Prisma.$ChallengeTrackPayload>
/**
 * Model ChallengeTimelineTemplate
 * 
 */
export type ChallengeTimelineTemplate = $Result.DefaultSelection<Prisma.$ChallengeTimelineTemplatePayload>
/**
 * Model AuditLog
 * 
 */
export type AuditLog = $Result.DefaultSelection<Prisma.$AuditLogPayload>
/**
 * Model Attachment
 * 
 */
export type Attachment = $Result.DefaultSelection<Prisma.$AttachmentPayload>
/**
 * Model ChallengeMetadata
 * 
 */
export type ChallengeMetadata = $Result.DefaultSelection<Prisma.$ChallengeMetadataPayload>
/**
 * Model Prize
 * 
 */
export type Prize = $Result.DefaultSelection<Prisma.$PrizePayload>
/**
 * Model ChallengeWinner
 * 
 */
export type ChallengeWinner = $Result.DefaultSelection<Prisma.$ChallengeWinnerPayload>
/**
 * Model ChallengeTerm
 * 
 */
export type ChallengeTerm = $Result.DefaultSelection<Prisma.$ChallengeTermPayload>
/**
 * Model ChallengeSkill
 * 
 */
export type ChallengeSkill = $Result.DefaultSelection<Prisma.$ChallengeSkillPayload>
/**
 * Model ChallengeBilling
 * 
 */
export type ChallengeBilling = $Result.DefaultSelection<Prisma.$ChallengeBillingPayload>
/**
 * Model ChallengeLegacy
 * 
 */
export type ChallengeLegacy = $Result.DefaultSelection<Prisma.$ChallengeLegacyPayload>
/**
 * Model ChallengeEvent
 * 
 */
export type ChallengeEvent = $Result.DefaultSelection<Prisma.$ChallengeEventPayload>
/**
 * Model ChallengeDiscussion
 * 
 */
export type ChallengeDiscussion = $Result.DefaultSelection<Prisma.$ChallengeDiscussionPayload>
/**
 * Model ChallengeDiscussionOption
 * 
 */
export type ChallengeDiscussionOption = $Result.DefaultSelection<Prisma.$ChallengeDiscussionOptionPayload>
/**
 * Model ChallengeConstraint
 * 
 */
export type ChallengeConstraint = $Result.DefaultSelection<Prisma.$ChallengeConstraintPayload>
/**
 * Model Phase
 * 
 */
export type Phase = $Result.DefaultSelection<Prisma.$PhasePayload>
/**
 * Model ChallengePhase
 * 
 */
export type ChallengePhase = $Result.DefaultSelection<Prisma.$ChallengePhasePayload>
/**
 * Model ChallengePhaseConstraint
 * 
 */
export type ChallengePhaseConstraint = $Result.DefaultSelection<Prisma.$ChallengePhaseConstraintPayload>
/**
 * Model ChallengePrizeSet
 * 
 */
export type ChallengePrizeSet = $Result.DefaultSelection<Prisma.$ChallengePrizeSetPayload>
/**
 * Model ChallengeReviewer
 * 
 */
export type ChallengeReviewer = $Result.DefaultSelection<Prisma.$ChallengeReviewerPayload>
/**
 * Model DefaultChallengeReviewer
 * 
 */
export type DefaultChallengeReviewer = $Result.DefaultSelection<Prisma.$DefaultChallengeReviewerPayload>
/**
 * Model TimelineTemplate
 * ///////////////////////////////////////
 * ///////////////////////////////////////
 */
export type TimelineTemplate = $Result.DefaultSelection<Prisma.$TimelineTemplatePayload>
/**
 * Model TimelineTemplatePhase
 * ///////////////////////////////////////
 * ///////////////////////////////////////
 */
export type TimelineTemplatePhase = $Result.DefaultSelection<Prisma.$TimelineTemplatePhasePayload>
/**
 * Model MemberChallengeAccess
 * 
 */
export type MemberChallengeAccess = $Result.DefaultSelection<Prisma.$MemberChallengeAccessPayload>

/**
 * Enums
 */
export namespace $Enums {
  export const ChallengeTrackEnum: {
  DESIGN: 'DESIGN',
  DATA_SCIENCE: 'DATA_SCIENCE',
  DEVELOPMENT: 'DEVELOPMENT',
  QUALITY_ASSURANCE: 'QUALITY_ASSURANCE'
};

export type ChallengeTrackEnum = (typeof ChallengeTrackEnum)[keyof typeof ChallengeTrackEnum]


export const ReviewTypeEnum: {
  COMMUNITY: 'COMMUNITY',
  INTERNAL: 'INTERNAL',
  SYSTEM: 'SYSTEM',
  PROVISIONAL: 'PROVISIONAL',
  EXAMPLE: 'EXAMPLE'
};

export type ReviewTypeEnum = (typeof ReviewTypeEnum)[keyof typeof ReviewTypeEnum]


export const DiscussionTypeEnum: {
  CHALLENGE: 'CHALLENGE'
};

export type DiscussionTypeEnum = (typeof DiscussionTypeEnum)[keyof typeof DiscussionTypeEnum]


export const ChallengeStatusEnum: {
  NEW: 'NEW',
  DRAFT: 'DRAFT',
  APPROVED: 'APPROVED',
  ACTIVE: 'ACTIVE',
  COMPLETED: 'COMPLETED',
  DELETED: 'DELETED',
  CANCELLED: 'CANCELLED',
  CANCELLED_FAILED_REVIEW: 'CANCELLED_FAILED_REVIEW',
  CANCELLED_FAILED_SCREENING: 'CANCELLED_FAILED_SCREENING',
  CANCELLED_ZERO_SUBMISSIONS: 'CANCELLED_ZERO_SUBMISSIONS',
  CANCELLED_WINNER_UNRESPONSIVE: 'CANCELLED_WINNER_UNRESPONSIVE',
  CANCELLED_CLIENT_REQUEST: 'CANCELLED_CLIENT_REQUEST',
  CANCELLED_REQUIREMENTS_INFEASIBLE: 'CANCELLED_REQUIREMENTS_INFEASIBLE',
  CANCELLED_ZERO_REGISTRATIONS: 'CANCELLED_ZERO_REGISTRATIONS',
  CANCELLED_PAYMENT_FAILED: 'CANCELLED_PAYMENT_FAILED'
};

export type ChallengeStatusEnum = (typeof ChallengeStatusEnum)[keyof typeof ChallengeStatusEnum]


export const PrizeSetTypeEnum: {
  PLACEMENT: 'PLACEMENT',
  COPILOT: 'COPILOT',
  REVIEWER: 'REVIEWER',
  PASSED_REVIEW: 'PASSED_REVIEW',
  CHECKPOINT: 'CHECKPOINT'
};

export type PrizeSetTypeEnum = (typeof PrizeSetTypeEnum)[keyof typeof PrizeSetTypeEnum]


export const ReviewOpportunityTypeEnum: {
  REGULAR_REVIEW: 'REGULAR_REVIEW',
  COMPONENT_DEV_REVIEW: 'COMPONENT_DEV_REVIEW',
  SPEC_REVIEW: 'SPEC_REVIEW',
  ITERATIVE_REVIEW: 'ITERATIVE_REVIEW',
  SCENARIOS_REVIEW: 'SCENARIOS_REVIEW'
};

export type ReviewOpportunityTypeEnum = (typeof ReviewOpportunityTypeEnum)[keyof typeof ReviewOpportunityTypeEnum]

}

export type ChallengeTrackEnum = $Enums.ChallengeTrackEnum

export const ChallengeTrackEnum: typeof $Enums.ChallengeTrackEnum

export type ReviewTypeEnum = $Enums.ReviewTypeEnum

export const ReviewTypeEnum: typeof $Enums.ReviewTypeEnum

export type DiscussionTypeEnum = $Enums.DiscussionTypeEnum

export const DiscussionTypeEnum: typeof $Enums.DiscussionTypeEnum

export type ChallengeStatusEnum = $Enums.ChallengeStatusEnum

export const ChallengeStatusEnum: typeof $Enums.ChallengeStatusEnum

export type PrizeSetTypeEnum = $Enums.PrizeSetTypeEnum

export const PrizeSetTypeEnum: typeof $Enums.PrizeSetTypeEnum

export type ReviewOpportunityTypeEnum = $Enums.ReviewOpportunityTypeEnum

export const ReviewOpportunityTypeEnum: typeof $Enums.ReviewOpportunityTypeEnum

/**
 * ##  Prisma Client ʲˢ
 *
 * Type-safe database client for TypeScript & Node.js
 * @example
 * ```
 * const prisma = new PrismaClient()
 * // Fetch zero or more Challenges
 * const challenges = await prisma.challenge.findMany()
 * ```
 *
 *
 * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client).
 */
export class PrismaClient<
  ClientOptions extends Prisma.PrismaClientOptions = Prisma.PrismaClientOptions,
  const U = 'log' extends keyof ClientOptions ? ClientOptions['log'] extends Array<Prisma.LogLevel | Prisma.LogDefinition> ? Prisma.GetEvents<ClientOptions['log']> : never : never,
  ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
> {
  [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['other'] }

    /**
   * ##  Prisma Client ʲˢ
   *
   * Type-safe database client for TypeScript & Node.js
   * @example
   * ```
   * const prisma = new PrismaClient()
   * // Fetch zero or more Challenges
   * const challenges = await prisma.challenge.findMany()
   * ```
   *
   *
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client).
   */

  constructor(optionsArg ?: Prisma.Subset<ClientOptions, Prisma.PrismaClientOptions>);
  $on<V extends U>(eventType: V, callback: (event: V extends 'query' ? Prisma.QueryEvent : Prisma.LogEvent) => void): PrismaClient;

  /**
   * Connect with the database
   */
  $connect(): $Utils.JsPromise<void>;

  /**
   * Disconnect from the database
   */
  $disconnect(): $Utils.JsPromise<void>;

/**
   * Executes a prepared raw query and returns the number of affected rows.
   * @example
   * ```
   * const result = await prisma.$executeRaw`UPDATE User SET cool = ${true} WHERE email = ${'user@email.com'};`
   * ```
   *
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $executeRaw<T = unknown>(query: TemplateStringsArray | Prisma.Sql, ...values: any[]): Prisma.PrismaPromise<number>;

  /**
   * Executes a raw query and returns the number of affected rows.
   * Susceptible to SQL injections, see documentation.
   * @example
   * ```
   * const result = await prisma.$executeRawUnsafe('UPDATE User SET cool = $1 WHERE email = $2 ;', true, 'user@email.com')
   * ```
   *
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $executeRawUnsafe<T = unknown>(query: string, ...values: any[]): Prisma.PrismaPromise<number>;

  /**
   * Performs a prepared raw query and returns the `SELECT` data.
   * @example
   * ```
   * const result = await prisma.$queryRaw`SELECT * FROM User WHERE id = ${1} OR email = ${'user@email.com'};`
   * ```
   *
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $queryRaw<T = unknown>(query: TemplateStringsArray | Prisma.Sql, ...values: any[]): Prisma.PrismaPromise<T>;

  /**
   * Performs a raw query and returns the `SELECT` data.
   * Susceptible to SQL injections, see documentation.
   * @example
   * ```
   * const result = await prisma.$queryRawUnsafe('SELECT * FROM User WHERE id = $1 OR email = $2;', 1, 'user@email.com')
   * ```
   *
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $queryRawUnsafe<T = unknown>(query: string, ...values: any[]): Prisma.PrismaPromise<T>;


  /**
   * Allows the running of a sequence of read/write operations that are guaranteed to either succeed or fail as a whole.
   * @example
   * ```
   * const [george, bob, alice] = await prisma.$transaction([
   *   prisma.user.create({ data: { name: 'George' } }),
   *   prisma.user.create({ data: { name: 'Bob' } }),
   *   prisma.user.create({ data: { name: 'Alice' } }),
   * ])
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/concepts/components/prisma-client/transactions).
   */
  $transaction<P extends Prisma.PrismaPromise<any>[]>(arg: [...P], options?: { isolationLevel?: Prisma.TransactionIsolationLevel }): $Utils.JsPromise<runtime.Types.Utils.UnwrapTuple<P>>

  $transaction<R>(fn: (prisma: Omit<PrismaClient, runtime.ITXClientDenyList>) => $Utils.JsPromise<R>, options?: { maxWait?: number, timeout?: number, isolationLevel?: Prisma.TransactionIsolationLevel }): $Utils.JsPromise<R>


  $extends: $Extensions.ExtendsHook<"extends", Prisma.TypeMapCb<ClientOptions>, ExtArgs, $Utils.Call<Prisma.TypeMapCb<ClientOptions>, {
    extArgs: ExtArgs
  }>>

      /**
   * `prisma.challenge`: Exposes CRUD operations for the **Challenge** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Challenges
    * const challenges = await prisma.challenge.findMany()
    * ```
    */
  get challenge(): Prisma.ChallengeDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.challengeType`: Exposes CRUD operations for the **ChallengeType** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more ChallengeTypes
    * const challengeTypes = await prisma.challengeType.findMany()
    * ```
    */
  get challengeType(): Prisma.ChallengeTypeDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.challengeTrack`: Exposes CRUD operations for the **ChallengeTrack** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more ChallengeTracks
    * const challengeTracks = await prisma.challengeTrack.findMany()
    * ```
    */
  get challengeTrack(): Prisma.ChallengeTrackDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.challengeTimelineTemplate`: Exposes CRUD operations for the **ChallengeTimelineTemplate** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more ChallengeTimelineTemplates
    * const challengeTimelineTemplates = await prisma.challengeTimelineTemplate.findMany()
    * ```
    */
  get challengeTimelineTemplate(): Prisma.ChallengeTimelineTemplateDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.auditLog`: Exposes CRUD operations for the **AuditLog** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more AuditLogs
    * const auditLogs = await prisma.auditLog.findMany()
    * ```
    */
  get auditLog(): Prisma.AuditLogDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.attachment`: Exposes CRUD operations for the **Attachment** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Attachments
    * const attachments = await prisma.attachment.findMany()
    * ```
    */
  get attachment(): Prisma.AttachmentDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.challengeMetadata`: Exposes CRUD operations for the **ChallengeMetadata** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more ChallengeMetadata
    * const challengeMetadata = await prisma.challengeMetadata.findMany()
    * ```
    */
  get challengeMetadata(): Prisma.ChallengeMetadataDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.prize`: Exposes CRUD operations for the **Prize** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Prizes
    * const prizes = await prisma.prize.findMany()
    * ```
    */
  get prize(): Prisma.PrizeDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.challengeWinner`: Exposes CRUD operations for the **ChallengeWinner** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more ChallengeWinners
    * const challengeWinners = await prisma.challengeWinner.findMany()
    * ```
    */
  get challengeWinner(): Prisma.ChallengeWinnerDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.challengeTerm`: Exposes CRUD operations for the **ChallengeTerm** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more ChallengeTerms
    * const challengeTerms = await prisma.challengeTerm.findMany()
    * ```
    */
  get challengeTerm(): Prisma.ChallengeTermDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.challengeSkill`: Exposes CRUD operations for the **ChallengeSkill** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more ChallengeSkills
    * const challengeSkills = await prisma.challengeSkill.findMany()
    * ```
    */
  get challengeSkill(): Prisma.ChallengeSkillDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.challengeBilling`: Exposes CRUD operations for the **ChallengeBilling** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more ChallengeBillings
    * const challengeBillings = await prisma.challengeBilling.findMany()
    * ```
    */
  get challengeBilling(): Prisma.ChallengeBillingDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.challengeLegacy`: Exposes CRUD operations for the **ChallengeLegacy** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more ChallengeLegacies
    * const challengeLegacies = await prisma.challengeLegacy.findMany()
    * ```
    */
  get challengeLegacy(): Prisma.ChallengeLegacyDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.challengeEvent`: Exposes CRUD operations for the **ChallengeEvent** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more ChallengeEvents
    * const challengeEvents = await prisma.challengeEvent.findMany()
    * ```
    */
  get challengeEvent(): Prisma.ChallengeEventDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.challengeDiscussion`: Exposes CRUD operations for the **ChallengeDiscussion** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more ChallengeDiscussions
    * const challengeDiscussions = await prisma.challengeDiscussion.findMany()
    * ```
    */
  get challengeDiscussion(): Prisma.ChallengeDiscussionDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.challengeDiscussionOption`: Exposes CRUD operations for the **ChallengeDiscussionOption** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more ChallengeDiscussionOptions
    * const challengeDiscussionOptions = await prisma.challengeDiscussionOption.findMany()
    * ```
    */
  get challengeDiscussionOption(): Prisma.ChallengeDiscussionOptionDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.challengeConstraint`: Exposes CRUD operations for the **ChallengeConstraint** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more ChallengeConstraints
    * const challengeConstraints = await prisma.challengeConstraint.findMany()
    * ```
    */
  get challengeConstraint(): Prisma.ChallengeConstraintDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.phase`: Exposes CRUD operations for the **Phase** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Phases
    * const phases = await prisma.phase.findMany()
    * ```
    */
  get phase(): Prisma.PhaseDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.challengePhase`: Exposes CRUD operations for the **ChallengePhase** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more ChallengePhases
    * const challengePhases = await prisma.challengePhase.findMany()
    * ```
    */
  get challengePhase(): Prisma.ChallengePhaseDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.challengePhaseConstraint`: Exposes CRUD operations for the **ChallengePhaseConstraint** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more ChallengePhaseConstraints
    * const challengePhaseConstraints = await prisma.challengePhaseConstraint.findMany()
    * ```
    */
  get challengePhaseConstraint(): Prisma.ChallengePhaseConstraintDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.challengePrizeSet`: Exposes CRUD operations for the **ChallengePrizeSet** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more ChallengePrizeSets
    * const challengePrizeSets = await prisma.challengePrizeSet.findMany()
    * ```
    */
  get challengePrizeSet(): Prisma.ChallengePrizeSetDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.challengeReviewer`: Exposes CRUD operations for the **ChallengeReviewer** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more ChallengeReviewers
    * const challengeReviewers = await prisma.challengeReviewer.findMany()
    * ```
    */
  get challengeReviewer(): Prisma.ChallengeReviewerDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.defaultChallengeReviewer`: Exposes CRUD operations for the **DefaultChallengeReviewer** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more DefaultChallengeReviewers
    * const defaultChallengeReviewers = await prisma.defaultChallengeReviewer.findMany()
    * ```
    */
  get defaultChallengeReviewer(): Prisma.DefaultChallengeReviewerDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.timelineTemplate`: Exposes CRUD operations for the **TimelineTemplate** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more TimelineTemplates
    * const timelineTemplates = await prisma.timelineTemplate.findMany()
    * ```
    */
  get timelineTemplate(): Prisma.TimelineTemplateDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.timelineTemplatePhase`: Exposes CRUD operations for the **TimelineTemplatePhase** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more TimelineTemplatePhases
    * const timelineTemplatePhases = await prisma.timelineTemplatePhase.findMany()
    * ```
    */
  get timelineTemplatePhase(): Prisma.TimelineTemplatePhaseDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.memberChallengeAccess`: Exposes CRUD operations for the **MemberChallengeAccess** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more MemberChallengeAccesses
    * const memberChallengeAccesses = await prisma.memberChallengeAccess.findMany()
    * ```
    */
  get memberChallengeAccess(): Prisma.MemberChallengeAccessDelegate<ExtArgs, ClientOptions>;
}

export namespace Prisma {
  export import DMMF = runtime.DMMF

  export type PrismaPromise<T> = $Public.PrismaPromise<T>

  /**
   * Validator
   */
  export import validator = runtime.Public.validator

  /**
   * Prisma Errors
   */
  export import PrismaClientKnownRequestError = runtime.PrismaClientKnownRequestError
  export import PrismaClientUnknownRequestError = runtime.PrismaClientUnknownRequestError
  export import PrismaClientRustPanicError = runtime.PrismaClientRustPanicError
  export import PrismaClientInitializationError = runtime.PrismaClientInitializationError
  export import PrismaClientValidationError = runtime.PrismaClientValidationError

  /**
   * Re-export of sql-template-tag
   */
  export import sql = runtime.sqltag
  export import empty = runtime.empty
  export import join = runtime.join
  export import raw = runtime.raw
  export import Sql = runtime.Sql



  /**
   * Decimal.js
   */
  export import Decimal = runtime.Decimal

  export type DecimalJsLike = runtime.DecimalJsLike

  /**
   * Metrics
   */
  export type Metrics = runtime.Metrics
  export type Metric<T> = runtime.Metric<T>
  export type MetricHistogram = runtime.MetricHistogram
  export type MetricHistogramBucket = runtime.MetricHistogramBucket

  /**
  * Extensions
  */
  export import Extension = $Extensions.UserArgs
  export import getExtensionContext = runtime.Extensions.getExtensionContext
  export import Args = $Public.Args
  export import Payload = $Public.Payload
  export import Result = $Public.Result
  export import Exact = $Public.Exact

  /**
   * Prisma Client JS version: 6.19.0
   * Query Engine version: 2ba551f319ab1df4bc874a89965d8b3641056773
   */
  export type PrismaVersion = {
    client: string
  }

  export const prismaVersion: PrismaVersion

  /**
   * Utility Types
   */


  export import Bytes = runtime.Bytes
  export import JsonObject = runtime.JsonObject
  export import JsonArray = runtime.JsonArray
  export import JsonValue = runtime.JsonValue
  export import InputJsonObject = runtime.InputJsonObject
  export import InputJsonArray = runtime.InputJsonArray
  export import InputJsonValue = runtime.InputJsonValue

  /**
   * Types of the values used to represent different kinds of `null` values when working with JSON fields.
   *
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  namespace NullTypes {
    /**
    * Type of `Prisma.DbNull`.
    *
    * You cannot use other instances of this class. Please use the `Prisma.DbNull` value.
    *
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class DbNull {
      private DbNull: never
      private constructor()
    }

    /**
    * Type of `Prisma.JsonNull`.
    *
    * You cannot use other instances of this class. Please use the `Prisma.JsonNull` value.
    *
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class JsonNull {
      private JsonNull: never
      private constructor()
    }

    /**
    * Type of `Prisma.AnyNull`.
    *
    * You cannot use other instances of this class. Please use the `Prisma.AnyNull` value.
    *
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class AnyNull {
      private AnyNull: never
      private constructor()
    }
  }

  /**
   * Helper for filtering JSON entries that have `null` on the database (empty on the db)
   *
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const DbNull: NullTypes.DbNull

  /**
   * Helper for filtering JSON entries that have JSON `null` values (not empty on the db)
   *
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const JsonNull: NullTypes.JsonNull

  /**
   * Helper for filtering JSON entries that are `Prisma.DbNull` or `Prisma.JsonNull`
   *
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const AnyNull: NullTypes.AnyNull

  type SelectAndInclude = {
    select: any
    include: any
  }

  type SelectAndOmit = {
    select: any
    omit: any
  }

  /**
   * Get the type of the value, that the Promise holds.
   */
  export type PromiseType<T extends PromiseLike<any>> = T extends PromiseLike<infer U> ? U : T;

  /**
   * Get the return type of a function which returns a Promise.
   */
  export type PromiseReturnType<T extends (...args: any) => $Utils.JsPromise<any>> = PromiseType<ReturnType<T>>

  /**
   * From T, pick a set of properties whose keys are in the union K
   */
  type Prisma__Pick<T, K extends keyof T> = {
      [P in K]: T[P];
  };


  export type Enumerable<T> = T | Array<T>;

  export type RequiredKeys<T> = {
    [K in keyof T]-?: {} extends Prisma__Pick<T, K> ? never : K
  }[keyof T]

  export type TruthyKeys<T> = keyof {
    [K in keyof T as T[K] extends false | undefined | null ? never : K]: K
  }

  export type TrueKeys<T> = TruthyKeys<Prisma__Pick<T, RequiredKeys<T>>>

  /**
   * Subset
   * @desc From `T` pick properties that exist in `U`. Simple version of Intersection
   */
  export type Subset<T, U> = {
    [key in keyof T]: key extends keyof U ? T[key] : never;
  };

  /**
   * SelectSubset
   * @desc From `T` pick properties that exist in `U`. Simple version of Intersection.
   * Additionally, it validates, if both select and include are present. If the case, it errors.
   */
  export type SelectSubset<T, U> = {
    [key in keyof T]: key extends keyof U ? T[key] : never
  } &
    (T extends SelectAndInclude
      ? 'Please either choose `select` or `include`.'
      : T extends SelectAndOmit
        ? 'Please either choose `select` or `omit`.'
        : {})

  /**
   * Subset + Intersection
   * @desc From `T` pick properties that exist in `U` and intersect `K`
   */
  export type SubsetIntersection<T, U, K> = {
    [key in keyof T]: key extends keyof U ? T[key] : never
  } &
    K

  type Without<T, U> = { [P in Exclude<keyof T, keyof U>]?: never };

  /**
   * XOR is needed to have a real mutually exclusive union type
   * https://stackoverflow.com/questions/42123407/does-typescript-support-mutually-exclusive-types
   */
  type XOR<T, U> =
    T extends object ?
    U extends object ?
      (Without<T, U> & U) | (Without<U, T> & T)
    : U : T


  /**
   * Is T a Record?
   */
  type IsObject<T extends any> = T extends Array<any>
  ? False
  : T extends Date
  ? False
  : T extends Uint8Array
  ? False
  : T extends BigInt
  ? False
  : T extends object
  ? True
  : False


  /**
   * If it's T[], return T
   */
  export type UnEnumerate<T extends unknown> = T extends Array<infer U> ? U : T

  /**
   * From ts-toolbelt
   */

  type __Either<O extends object, K extends Key> = Omit<O, K> &
    {
      // Merge all but K
      [P in K]: Prisma__Pick<O, P & keyof O> // With K possibilities
    }[K]

  type EitherStrict<O extends object, K extends Key> = Strict<__Either<O, K>>

  type EitherLoose<O extends object, K extends Key> = ComputeRaw<__Either<O, K>>

  type _Either<
    O extends object,
    K extends Key,
    strict extends Boolean
  > = {
    1: EitherStrict<O, K>
    0: EitherLoose<O, K>
  }[strict]

  type Either<
    O extends object,
    K extends Key,
    strict extends Boolean = 1
  > = O extends unknown ? _Either<O, K, strict> : never

  export type Union = any

  type PatchUndefined<O extends object, O1 extends object> = {
    [K in keyof O]: O[K] extends undefined ? At<O1, K> : O[K]
  } & {}

  /** Helper Types for "Merge" **/
  export type IntersectOf<U extends Union> = (
    U extends unknown ? (k: U) => void : never
  ) extends (k: infer I) => void
    ? I
    : never

  export type Overwrite<O extends object, O1 extends object> = {
      [K in keyof O]: K extends keyof O1 ? O1[K] : O[K];
  } & {};

  type _Merge<U extends object> = IntersectOf<Overwrite<U, {
      [K in keyof U]-?: At<U, K>;
  }>>;

  type Key = string | number | symbol;
  type AtBasic<O extends object, K extends Key> = K extends keyof O ? O[K] : never;
  type AtStrict<O extends object, K extends Key> = O[K & keyof O];
  type AtLoose<O extends object, K extends Key> = O extends unknown ? AtStrict<O, K> : never;
  export type At<O extends object, K extends Key, strict extends Boolean = 1> = {
      1: AtStrict<O, K>;
      0: AtLoose<O, K>;
  }[strict];

  export type ComputeRaw<A extends any> = A extends Function ? A : {
    [K in keyof A]: A[K];
  } & {};

  export type OptionalFlat<O> = {
    [K in keyof O]?: O[K];
  } & {};

  type _Record<K extends keyof any, T> = {
    [P in K]: T;
  };

  // cause typescript not to expand types and preserve names
  type NoExpand<T> = T extends unknown ? T : never;

  // this type assumes the passed object is entirely optional
  type AtLeast<O extends object, K extends string> = NoExpand<
    O extends unknown
    ? | (K extends keyof O ? { [P in K]: O[P] } & O : O)
      | {[P in keyof O as P extends K ? P : never]-?: O[P]} & O
    : never>;

  type _Strict<U, _U = U> = U extends unknown ? U & OptionalFlat<_Record<Exclude<Keys<_U>, keyof U>, never>> : never;

  export type Strict<U extends object> = ComputeRaw<_Strict<U>>;
  /** End Helper Types for "Merge" **/

  export type Merge<U extends object> = ComputeRaw<_Merge<Strict<U>>>;

  /**
  A [[Boolean]]
  */
  export type Boolean = True | False

  // /**
  // 1
  // */
  export type True = 1

  /**
  0
  */
  export type False = 0

  export type Not<B extends Boolean> = {
    0: 1
    1: 0
  }[B]

  export type Extends<A1 extends any, A2 extends any> = [A1] extends [never]
    ? 0 // anything `never` is false
    : A1 extends A2
    ? 1
    : 0

  export type Has<U extends Union, U1 extends Union> = Not<
    Extends<Exclude<U1, U>, U1>
  >

  export type Or<B1 extends Boolean, B2 extends Boolean> = {
    0: {
      0: 0
      1: 1
    }
    1: {
      0: 1
      1: 1
    }
  }[B1][B2]

  export type Keys<U extends Union> = U extends unknown ? keyof U : never

  type Cast<A, B> = A extends B ? A : B;

  export const type: unique symbol;



  /**
   * Used by group by
   */

  export type GetScalarType<T, O> = O extends object ? {
    [P in keyof T]: P extends keyof O
      ? O[P]
      : never
  } : never

  type FieldPaths<
    T,
    U = Omit<T, '_avg' | '_sum' | '_count' | '_min' | '_max'>
  > = IsObject<T> extends True ? U : T

  type GetHavingFields<T> = {
    [K in keyof T]: Or<
      Or<Extends<'OR', K>, Extends<'AND', K>>,
      Extends<'NOT', K>
    > extends True
      ? // infer is only needed to not hit TS limit
        // based on the brilliant idea of Pierre-Antoine Mills
        // https://github.com/microsoft/TypeScript/issues/30188#issuecomment-478938437
        T[K] extends infer TK
        ? GetHavingFields<UnEnumerate<TK> extends object ? Merge<UnEnumerate<TK>> : never>
        : never
      : {} extends FieldPaths<T[K]>
      ? never
      : K
  }[keyof T]

  /**
   * Convert tuple to union
   */
  type _TupleToUnion<T> = T extends (infer E)[] ? E : never
  type TupleToUnion<K extends readonly any[]> = _TupleToUnion<K>
  type MaybeTupleToUnion<T> = T extends any[] ? TupleToUnion<T> : T

  /**
   * Like `Pick`, but additionally can also accept an array of keys
   */
  type PickEnumerable<T, K extends Enumerable<keyof T> | keyof T> = Prisma__Pick<T, MaybeTupleToUnion<K>>

  /**
   * Exclude all keys with underscores
   */
  type ExcludeUnderscoreKeys<T extends string> = T extends `_${string}` ? never : T


  export type FieldRef<Model, FieldType> = runtime.FieldRef<Model, FieldType>

  type FieldRefInputType<Model, FieldType> = Model extends never ? never : FieldRef<Model, FieldType>


  export const ModelName: {
    Challenge: 'Challenge',
    ChallengeType: 'ChallengeType',
    ChallengeTrack: 'ChallengeTrack',
    ChallengeTimelineTemplate: 'ChallengeTimelineTemplate',
    AuditLog: 'AuditLog',
    Attachment: 'Attachment',
    ChallengeMetadata: 'ChallengeMetadata',
    Prize: 'Prize',
    ChallengeWinner: 'ChallengeWinner',
    ChallengeTerm: 'ChallengeTerm',
    ChallengeSkill: 'ChallengeSkill',
    ChallengeBilling: 'ChallengeBilling',
    ChallengeLegacy: 'ChallengeLegacy',
    ChallengeEvent: 'ChallengeEvent',
    ChallengeDiscussion: 'ChallengeDiscussion',
    ChallengeDiscussionOption: 'ChallengeDiscussionOption',
    ChallengeConstraint: 'ChallengeConstraint',
    Phase: 'Phase',
    ChallengePhase: 'ChallengePhase',
    ChallengePhaseConstraint: 'ChallengePhaseConstraint',
    ChallengePrizeSet: 'ChallengePrizeSet',
    ChallengeReviewer: 'ChallengeReviewer',
    DefaultChallengeReviewer: 'DefaultChallengeReviewer',
    TimelineTemplate: 'TimelineTemplate',
    TimelineTemplatePhase: 'TimelineTemplatePhase',
    MemberChallengeAccess: 'MemberChallengeAccess'
  };

  export type ModelName = (typeof ModelName)[keyof typeof ModelName]


  export type Datasources = {
    db?: Datasource
  }

  interface TypeMapCb<ClientOptions = {}> extends $Utils.Fn<{extArgs: $Extensions.InternalArgs }, $Utils.Record<string, any>> {
    returns: Prisma.TypeMap<this['params']['extArgs'], ClientOptions extends { omit: infer OmitOptions } ? OmitOptions : {}>
  }

  export type TypeMap<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> = {
    globalOmitOptions: {
      omit: GlobalOmitOptions
    }
    meta: {
      modelProps: "challenge" | "challengeType" | "challengeTrack" | "challengeTimelineTemplate" | "auditLog" | "attachment" | "challengeMetadata" | "prize" | "challengeWinner" | "challengeTerm" | "challengeSkill" | "challengeBilling" | "challengeLegacy" | "challengeEvent" | "challengeDiscussion" | "challengeDiscussionOption" | "challengeConstraint" | "phase" | "challengePhase" | "challengePhaseConstraint" | "challengePrizeSet" | "challengeReviewer" | "defaultChallengeReviewer" | "timelineTemplate" | "timelineTemplatePhase" | "memberChallengeAccess"
      txIsolationLevel: Prisma.TransactionIsolationLevel
    }
    model: {
      Challenge: {
        payload: Prisma.$ChallengePayload<ExtArgs>
        fields: Prisma.ChallengeFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ChallengeFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ChallengePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ChallengeFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ChallengePayload>
          }
          findFirst: {
            args: Prisma.ChallengeFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ChallengePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ChallengeFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ChallengePayload>
          }
          findMany: {
            args: Prisma.ChallengeFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ChallengePayload>[]
          }
          create: {
            args: Prisma.ChallengeCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ChallengePayload>
          }
          createMany: {
            args: Prisma.ChallengeCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.ChallengeCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ChallengePayload>[]
          }
          delete: {
            args: Prisma.ChallengeDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ChallengePayload>
          }
          update: {
            args: Prisma.ChallengeUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ChallengePayload>
          }
          deleteMany: {
            args: Prisma.ChallengeDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.ChallengeUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.ChallengeUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ChallengePayload>[]
          }
          upsert: {
            args: Prisma.ChallengeUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ChallengePayload>
          }
          aggregate: {
            args: Prisma.ChallengeAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateChallenge>
          }
          groupBy: {
            args: Prisma.ChallengeGroupByArgs<ExtArgs>
            result: $Utils.Optional<ChallengeGroupByOutputType>[]
          }
          count: {
            args: Prisma.ChallengeCountArgs<ExtArgs>
            result: $Utils.Optional<ChallengeCountAggregateOutputType> | number
          }
        }
      }
      ChallengeType: {
        payload: Prisma.$ChallengeTypePayload<ExtArgs>
        fields: Prisma.ChallengeTypeFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ChallengeTypeFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ChallengeTypePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ChallengeTypeFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ChallengeTypePayload>
          }
          findFirst: {
            args: Prisma.ChallengeTypeFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ChallengeTypePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ChallengeTypeFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ChallengeTypePayload>
          }
          findMany: {
            args: Prisma.ChallengeTypeFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ChallengeTypePayload>[]
          }
          create: {
            args: Prisma.ChallengeTypeCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ChallengeTypePayload>
          }
          createMany: {
            args: Prisma.ChallengeTypeCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.ChallengeTypeCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ChallengeTypePayload>[]
          }
          delete: {
            args: Prisma.ChallengeTypeDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ChallengeTypePayload>
          }
          update: {
            args: Prisma.ChallengeTypeUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ChallengeTypePayload>
          }
          deleteMany: {
            args: Prisma.ChallengeTypeDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.ChallengeTypeUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.ChallengeTypeUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ChallengeTypePayload>[]
          }
          upsert: {
            args: Prisma.ChallengeTypeUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ChallengeTypePayload>
          }
          aggregate: {
            args: Prisma.ChallengeTypeAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateChallengeType>
          }
          groupBy: {
            args: Prisma.ChallengeTypeGroupByArgs<ExtArgs>
            result: $Utils.Optional<ChallengeTypeGroupByOutputType>[]
          }
          count: {
            args: Prisma.ChallengeTypeCountArgs<ExtArgs>
            result: $Utils.Optional<ChallengeTypeCountAggregateOutputType> | number
          }
        }
      }
      ChallengeTrack: {
        payload: Prisma.$ChallengeTrackPayload<ExtArgs>
        fields: Prisma.ChallengeTrackFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ChallengeTrackFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ChallengeTrackPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ChallengeTrackFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ChallengeTrackPayload>
          }
          findFirst: {
            args: Prisma.ChallengeTrackFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ChallengeTrackPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ChallengeTrackFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ChallengeTrackPayload>
          }
          findMany: {
            args: Prisma.ChallengeTrackFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ChallengeTrackPayload>[]
          }
          create: {
            args: Prisma.ChallengeTrackCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ChallengeTrackPayload>
          }
          createMany: {
            args: Prisma.ChallengeTrackCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.ChallengeTrackCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ChallengeTrackPayload>[]
          }
          delete: {
            args: Prisma.ChallengeTrackDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ChallengeTrackPayload>
          }
          update: {
            args: Prisma.ChallengeTrackUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ChallengeTrackPayload>
          }
          deleteMany: {
            args: Prisma.ChallengeTrackDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.ChallengeTrackUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.ChallengeTrackUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ChallengeTrackPayload>[]
          }
          upsert: {
            args: Prisma.ChallengeTrackUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ChallengeTrackPayload>
          }
          aggregate: {
            args: Prisma.ChallengeTrackAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateChallengeTrack>
          }
          groupBy: {
            args: Prisma.ChallengeTrackGroupByArgs<ExtArgs>
            result: $Utils.Optional<ChallengeTrackGroupByOutputType>[]
          }
          count: {
            args: Prisma.ChallengeTrackCountArgs<ExtArgs>
            result: $Utils.Optional<ChallengeTrackCountAggregateOutputType> | number
          }
        }
      }
      ChallengeTimelineTemplate: {
        payload: Prisma.$ChallengeTimelineTemplatePayload<ExtArgs>
        fields: Prisma.ChallengeTimelineTemplateFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ChallengeTimelineTemplateFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ChallengeTimelineTemplatePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ChallengeTimelineTemplateFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ChallengeTimelineTemplatePayload>
          }
          findFirst: {
            args: Prisma.ChallengeTimelineTemplateFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ChallengeTimelineTemplatePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ChallengeTimelineTemplateFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ChallengeTimelineTemplatePayload>
          }
          findMany: {
            args: Prisma.ChallengeTimelineTemplateFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ChallengeTimelineTemplatePayload>[]
          }
          create: {
            args: Prisma.ChallengeTimelineTemplateCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ChallengeTimelineTemplatePayload>
          }
          createMany: {
            args: Prisma.ChallengeTimelineTemplateCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.ChallengeTimelineTemplateCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ChallengeTimelineTemplatePayload>[]
          }
          delete: {
            args: Prisma.ChallengeTimelineTemplateDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ChallengeTimelineTemplatePayload>
          }
          update: {
            args: Prisma.ChallengeTimelineTemplateUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ChallengeTimelineTemplatePayload>
          }
          deleteMany: {
            args: Prisma.ChallengeTimelineTemplateDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.ChallengeTimelineTemplateUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.ChallengeTimelineTemplateUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ChallengeTimelineTemplatePayload>[]
          }
          upsert: {
            args: Prisma.ChallengeTimelineTemplateUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ChallengeTimelineTemplatePayload>
          }
          aggregate: {
            args: Prisma.ChallengeTimelineTemplateAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateChallengeTimelineTemplate>
          }
          groupBy: {
            args: Prisma.ChallengeTimelineTemplateGroupByArgs<ExtArgs>
            result: $Utils.Optional<ChallengeTimelineTemplateGroupByOutputType>[]
          }
          count: {
            args: Prisma.ChallengeTimelineTemplateCountArgs<ExtArgs>
            result: $Utils.Optional<ChallengeTimelineTemplateCountAggregateOutputType> | number
          }
        }
      }
      AuditLog: {
        payload: Prisma.$AuditLogPayload<ExtArgs>
        fields: Prisma.AuditLogFieldRefs
        operations: {
          findUnique: {
            args: Prisma.AuditLogFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AuditLogPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.AuditLogFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AuditLogPayload>
          }
          findFirst: {
            args: Prisma.AuditLogFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AuditLogPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.AuditLogFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AuditLogPayload>
          }
          findMany: {
            args: Prisma.AuditLogFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AuditLogPayload>[]
          }
          create: {
            args: Prisma.AuditLogCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AuditLogPayload>
          }
          createMany: {
            args: Prisma.AuditLogCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.AuditLogCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AuditLogPayload>[]
          }
          delete: {
            args: Prisma.AuditLogDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AuditLogPayload>
          }
          update: {
            args: Prisma.AuditLogUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AuditLogPayload>
          }
          deleteMany: {
            args: Prisma.AuditLogDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.AuditLogUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.AuditLogUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AuditLogPayload>[]
          }
          upsert: {
            args: Prisma.AuditLogUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AuditLogPayload>
          }
          aggregate: {
            args: Prisma.AuditLogAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateAuditLog>
          }
          groupBy: {
            args: Prisma.AuditLogGroupByArgs<ExtArgs>
            result: $Utils.Optional<AuditLogGroupByOutputType>[]
          }
          count: {
            args: Prisma.AuditLogCountArgs<ExtArgs>
            result: $Utils.Optional<AuditLogCountAggregateOutputType> | number
          }
        }
      }
      Attachment: {
        payload: Prisma.$AttachmentPayload<ExtArgs>
        fields: Prisma.AttachmentFieldRefs
        operations: {
          findUnique: {
            args: Prisma.AttachmentFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AttachmentPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.AttachmentFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AttachmentPayload>
          }
          findFirst: {
            args: Prisma.AttachmentFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AttachmentPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.AttachmentFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AttachmentPayload>
          }
          findMany: {
            args: Prisma.AttachmentFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AttachmentPayload>[]
          }
          create: {
            args: Prisma.AttachmentCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AttachmentPayload>
          }
          createMany: {
            args: Prisma.AttachmentCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.AttachmentCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AttachmentPayload>[]
          }
          delete: {
            args: Prisma.AttachmentDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AttachmentPayload>
          }
          update: {
            args: Prisma.AttachmentUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AttachmentPayload>
          }
          deleteMany: {
            args: Prisma.AttachmentDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.AttachmentUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.AttachmentUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AttachmentPayload>[]
          }
          upsert: {
            args: Prisma.AttachmentUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AttachmentPayload>
          }
          aggregate: {
            args: Prisma.AttachmentAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateAttachment>
          }
          groupBy: {
            args: Prisma.AttachmentGroupByArgs<ExtArgs>
            result: $Utils.Optional<AttachmentGroupByOutputType>[]
          }
          count: {
            args: Prisma.AttachmentCountArgs<ExtArgs>
            result: $Utils.Optional<AttachmentCountAggregateOutputType> | number
          }
        }
      }
      ChallengeMetadata: {
        payload: Prisma.$ChallengeMetadataPayload<ExtArgs>
        fields: Prisma.ChallengeMetadataFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ChallengeMetadataFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ChallengeMetadataPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ChallengeMetadataFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ChallengeMetadataPayload>
          }
          findFirst: {
            args: Prisma.ChallengeMetadataFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ChallengeMetadataPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ChallengeMetadataFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ChallengeMetadataPayload>
          }
          findMany: {
            args: Prisma.ChallengeMetadataFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ChallengeMetadataPayload>[]
          }
          create: {
            args: Prisma.ChallengeMetadataCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ChallengeMetadataPayload>
          }
          createMany: {
            args: Prisma.ChallengeMetadataCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.ChallengeMetadataCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ChallengeMetadataPayload>[]
          }
          delete: {
            args: Prisma.ChallengeMetadataDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ChallengeMetadataPayload>
          }
          update: {
            args: Prisma.ChallengeMetadataUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ChallengeMetadataPayload>
          }
          deleteMany: {
            args: Prisma.ChallengeMetadataDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.ChallengeMetadataUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.ChallengeMetadataUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ChallengeMetadataPayload>[]
          }
          upsert: {
            args: Prisma.ChallengeMetadataUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ChallengeMetadataPayload>
          }
          aggregate: {
            args: Prisma.ChallengeMetadataAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateChallengeMetadata>
          }
          groupBy: {
            args: Prisma.ChallengeMetadataGroupByArgs<ExtArgs>
            result: $Utils.Optional<ChallengeMetadataGroupByOutputType>[]
          }
          count: {
            args: Prisma.ChallengeMetadataCountArgs<ExtArgs>
            result: $Utils.Optional<ChallengeMetadataCountAggregateOutputType> | number
          }
        }
      }
      Prize: {
        payload: Prisma.$PrizePayload<ExtArgs>
        fields: Prisma.PrizeFieldRefs
        operations: {
          findUnique: {
            args: Prisma.PrizeFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PrizePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.PrizeFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PrizePayload>
          }
          findFirst: {
            args: Prisma.PrizeFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PrizePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.PrizeFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PrizePayload>
          }
          findMany: {
            args: Prisma.PrizeFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PrizePayload>[]
          }
          create: {
            args: Prisma.PrizeCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PrizePayload>
          }
          createMany: {
            args: Prisma.PrizeCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.PrizeCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PrizePayload>[]
          }
          delete: {
            args: Prisma.PrizeDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PrizePayload>
          }
          update: {
            args: Prisma.PrizeUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PrizePayload>
          }
          deleteMany: {
            args: Prisma.PrizeDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.PrizeUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.PrizeUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PrizePayload>[]
          }
          upsert: {
            args: Prisma.PrizeUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PrizePayload>
          }
          aggregate: {
            args: Prisma.PrizeAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregatePrize>
          }
          groupBy: {
            args: Prisma.PrizeGroupByArgs<ExtArgs>
            result: $Utils.Optional<PrizeGroupByOutputType>[]
          }
          count: {
            args: Prisma.PrizeCountArgs<ExtArgs>
            result: $Utils.Optional<PrizeCountAggregateOutputType> | number
          }
        }
      }
      ChallengeWinner: {
        payload: Prisma.$ChallengeWinnerPayload<ExtArgs>
        fields: Prisma.ChallengeWinnerFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ChallengeWinnerFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ChallengeWinnerPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ChallengeWinnerFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ChallengeWinnerPayload>
          }
          findFirst: {
            args: Prisma.ChallengeWinnerFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ChallengeWinnerPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ChallengeWinnerFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ChallengeWinnerPayload>
          }
          findMany: {
            args: Prisma.ChallengeWinnerFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ChallengeWinnerPayload>[]
          }
          create: {
            args: Prisma.ChallengeWinnerCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ChallengeWinnerPayload>
          }
          createMany: {
            args: Prisma.ChallengeWinnerCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.ChallengeWinnerCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ChallengeWinnerPayload>[]
          }
          delete: {
            args: Prisma.ChallengeWinnerDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ChallengeWinnerPayload>
          }
          update: {
            args: Prisma.ChallengeWinnerUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ChallengeWinnerPayload>
          }
          deleteMany: {
            args: Prisma.ChallengeWinnerDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.ChallengeWinnerUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.ChallengeWinnerUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ChallengeWinnerPayload>[]
          }
          upsert: {
            args: Prisma.ChallengeWinnerUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ChallengeWinnerPayload>
          }
          aggregate: {
            args: Prisma.ChallengeWinnerAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateChallengeWinner>
          }
          groupBy: {
            args: Prisma.ChallengeWinnerGroupByArgs<ExtArgs>
            result: $Utils.Optional<ChallengeWinnerGroupByOutputType>[]
          }
          count: {
            args: Prisma.ChallengeWinnerCountArgs<ExtArgs>
            result: $Utils.Optional<ChallengeWinnerCountAggregateOutputType> | number
          }
        }
      }
      ChallengeTerm: {
        payload: Prisma.$ChallengeTermPayload<ExtArgs>
        fields: Prisma.ChallengeTermFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ChallengeTermFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ChallengeTermPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ChallengeTermFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ChallengeTermPayload>
          }
          findFirst: {
            args: Prisma.ChallengeTermFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ChallengeTermPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ChallengeTermFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ChallengeTermPayload>
          }
          findMany: {
            args: Prisma.ChallengeTermFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ChallengeTermPayload>[]
          }
          create: {
            args: Prisma.ChallengeTermCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ChallengeTermPayload>
          }
          createMany: {
            args: Prisma.ChallengeTermCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.ChallengeTermCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ChallengeTermPayload>[]
          }
          delete: {
            args: Prisma.ChallengeTermDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ChallengeTermPayload>
          }
          update: {
            args: Prisma.ChallengeTermUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ChallengeTermPayload>
          }
          deleteMany: {
            args: Prisma.ChallengeTermDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.ChallengeTermUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.ChallengeTermUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ChallengeTermPayload>[]
          }
          upsert: {
            args: Prisma.ChallengeTermUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ChallengeTermPayload>
          }
          aggregate: {
            args: Prisma.ChallengeTermAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateChallengeTerm>
          }
          groupBy: {
            args: Prisma.ChallengeTermGroupByArgs<ExtArgs>
            result: $Utils.Optional<ChallengeTermGroupByOutputType>[]
          }
          count: {
            args: Prisma.ChallengeTermCountArgs<ExtArgs>
            result: $Utils.Optional<ChallengeTermCountAggregateOutputType> | number
          }
        }
      }
      ChallengeSkill: {
        payload: Prisma.$ChallengeSkillPayload<ExtArgs>
        fields: Prisma.ChallengeSkillFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ChallengeSkillFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ChallengeSkillPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ChallengeSkillFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ChallengeSkillPayload>
          }
          findFirst: {
            args: Prisma.ChallengeSkillFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ChallengeSkillPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ChallengeSkillFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ChallengeSkillPayload>
          }
          findMany: {
            args: Prisma.ChallengeSkillFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ChallengeSkillPayload>[]
          }
          create: {
            args: Prisma.ChallengeSkillCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ChallengeSkillPayload>
          }
          createMany: {
            args: Prisma.ChallengeSkillCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.ChallengeSkillCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ChallengeSkillPayload>[]
          }
          delete: {
            args: Prisma.ChallengeSkillDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ChallengeSkillPayload>
          }
          update: {
            args: Prisma.ChallengeSkillUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ChallengeSkillPayload>
          }
          deleteMany: {
            args: Prisma.ChallengeSkillDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.ChallengeSkillUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.ChallengeSkillUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ChallengeSkillPayload>[]
          }
          upsert: {
            args: Prisma.ChallengeSkillUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ChallengeSkillPayload>
          }
          aggregate: {
            args: Prisma.ChallengeSkillAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateChallengeSkill>
          }
          groupBy: {
            args: Prisma.ChallengeSkillGroupByArgs<ExtArgs>
            result: $Utils.Optional<ChallengeSkillGroupByOutputType>[]
          }
          count: {
            args: Prisma.ChallengeSkillCountArgs<ExtArgs>
            result: $Utils.Optional<ChallengeSkillCountAggregateOutputType> | number
          }
        }
      }
      ChallengeBilling: {
        payload: Prisma.$ChallengeBillingPayload<ExtArgs>
        fields: Prisma.ChallengeBillingFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ChallengeBillingFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ChallengeBillingPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ChallengeBillingFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ChallengeBillingPayload>
          }
          findFirst: {
            args: Prisma.ChallengeBillingFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ChallengeBillingPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ChallengeBillingFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ChallengeBillingPayload>
          }
          findMany: {
            args: Prisma.ChallengeBillingFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ChallengeBillingPayload>[]
          }
          create: {
            args: Prisma.ChallengeBillingCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ChallengeBillingPayload>
          }
          createMany: {
            args: Prisma.ChallengeBillingCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.ChallengeBillingCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ChallengeBillingPayload>[]
          }
          delete: {
            args: Prisma.ChallengeBillingDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ChallengeBillingPayload>
          }
          update: {
            args: Prisma.ChallengeBillingUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ChallengeBillingPayload>
          }
          deleteMany: {
            args: Prisma.ChallengeBillingDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.ChallengeBillingUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.ChallengeBillingUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ChallengeBillingPayload>[]
          }
          upsert: {
            args: Prisma.ChallengeBillingUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ChallengeBillingPayload>
          }
          aggregate: {
            args: Prisma.ChallengeBillingAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateChallengeBilling>
          }
          groupBy: {
            args: Prisma.ChallengeBillingGroupByArgs<ExtArgs>
            result: $Utils.Optional<ChallengeBillingGroupByOutputType>[]
          }
          count: {
            args: Prisma.ChallengeBillingCountArgs<ExtArgs>
            result: $Utils.Optional<ChallengeBillingCountAggregateOutputType> | number
          }
        }
      }
      ChallengeLegacy: {
        payload: Prisma.$ChallengeLegacyPayload<ExtArgs>
        fields: Prisma.ChallengeLegacyFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ChallengeLegacyFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ChallengeLegacyPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ChallengeLegacyFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ChallengeLegacyPayload>
          }
          findFirst: {
            args: Prisma.ChallengeLegacyFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ChallengeLegacyPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ChallengeLegacyFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ChallengeLegacyPayload>
          }
          findMany: {
            args: Prisma.ChallengeLegacyFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ChallengeLegacyPayload>[]
          }
          create: {
            args: Prisma.ChallengeLegacyCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ChallengeLegacyPayload>
          }
          createMany: {
            args: Prisma.ChallengeLegacyCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.ChallengeLegacyCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ChallengeLegacyPayload>[]
          }
          delete: {
            args: Prisma.ChallengeLegacyDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ChallengeLegacyPayload>
          }
          update: {
            args: Prisma.ChallengeLegacyUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ChallengeLegacyPayload>
          }
          deleteMany: {
            args: Prisma.ChallengeLegacyDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.ChallengeLegacyUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.ChallengeLegacyUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ChallengeLegacyPayload>[]
          }
          upsert: {
            args: Prisma.ChallengeLegacyUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ChallengeLegacyPayload>
          }
          aggregate: {
            args: Prisma.ChallengeLegacyAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateChallengeLegacy>
          }
          groupBy: {
            args: Prisma.ChallengeLegacyGroupByArgs<ExtArgs>
            result: $Utils.Optional<ChallengeLegacyGroupByOutputType>[]
          }
          count: {
            args: Prisma.ChallengeLegacyCountArgs<ExtArgs>
            result: $Utils.Optional<ChallengeLegacyCountAggregateOutputType> | number
          }
        }
      }
      ChallengeEvent: {
        payload: Prisma.$ChallengeEventPayload<ExtArgs>
        fields: Prisma.ChallengeEventFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ChallengeEventFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ChallengeEventPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ChallengeEventFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ChallengeEventPayload>
          }
          findFirst: {
            args: Prisma.ChallengeEventFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ChallengeEventPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ChallengeEventFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ChallengeEventPayload>
          }
          findMany: {
            args: Prisma.ChallengeEventFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ChallengeEventPayload>[]
          }
          create: {
            args: Prisma.ChallengeEventCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ChallengeEventPayload>
          }
          createMany: {
            args: Prisma.ChallengeEventCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.ChallengeEventCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ChallengeEventPayload>[]
          }
          delete: {
            args: Prisma.ChallengeEventDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ChallengeEventPayload>
          }
          update: {
            args: Prisma.ChallengeEventUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ChallengeEventPayload>
          }
          deleteMany: {
            args: Prisma.ChallengeEventDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.ChallengeEventUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.ChallengeEventUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ChallengeEventPayload>[]
          }
          upsert: {
            args: Prisma.ChallengeEventUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ChallengeEventPayload>
          }
          aggregate: {
            args: Prisma.ChallengeEventAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateChallengeEvent>
          }
          groupBy: {
            args: Prisma.ChallengeEventGroupByArgs<ExtArgs>
            result: $Utils.Optional<ChallengeEventGroupByOutputType>[]
          }
          count: {
            args: Prisma.ChallengeEventCountArgs<ExtArgs>
            result: $Utils.Optional<ChallengeEventCountAggregateOutputType> | number
          }
        }
      }
      ChallengeDiscussion: {
        payload: Prisma.$ChallengeDiscussionPayload<ExtArgs>
        fields: Prisma.ChallengeDiscussionFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ChallengeDiscussionFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ChallengeDiscussionPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ChallengeDiscussionFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ChallengeDiscussionPayload>
          }
          findFirst: {
            args: Prisma.ChallengeDiscussionFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ChallengeDiscussionPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ChallengeDiscussionFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ChallengeDiscussionPayload>
          }
          findMany: {
            args: Prisma.ChallengeDiscussionFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ChallengeDiscussionPayload>[]
          }
          create: {
            args: Prisma.ChallengeDiscussionCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ChallengeDiscussionPayload>
          }
          createMany: {
            args: Prisma.ChallengeDiscussionCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.ChallengeDiscussionCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ChallengeDiscussionPayload>[]
          }
          delete: {
            args: Prisma.ChallengeDiscussionDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ChallengeDiscussionPayload>
          }
          update: {
            args: Prisma.ChallengeDiscussionUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ChallengeDiscussionPayload>
          }
          deleteMany: {
            args: Prisma.ChallengeDiscussionDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.ChallengeDiscussionUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.ChallengeDiscussionUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ChallengeDiscussionPayload>[]
          }
          upsert: {
            args: Prisma.ChallengeDiscussionUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ChallengeDiscussionPayload>
          }
          aggregate: {
            args: Prisma.ChallengeDiscussionAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateChallengeDiscussion>
          }
          groupBy: {
            args: Prisma.ChallengeDiscussionGroupByArgs<ExtArgs>
            result: $Utils.Optional<ChallengeDiscussionGroupByOutputType>[]
          }
          count: {
            args: Prisma.ChallengeDiscussionCountArgs<ExtArgs>
            result: $Utils.Optional<ChallengeDiscussionCountAggregateOutputType> | number
          }
        }
      }
      ChallengeDiscussionOption: {
        payload: Prisma.$ChallengeDiscussionOptionPayload<ExtArgs>
        fields: Prisma.ChallengeDiscussionOptionFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ChallengeDiscussionOptionFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ChallengeDiscussionOptionPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ChallengeDiscussionOptionFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ChallengeDiscussionOptionPayload>
          }
          findFirst: {
            args: Prisma.ChallengeDiscussionOptionFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ChallengeDiscussionOptionPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ChallengeDiscussionOptionFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ChallengeDiscussionOptionPayload>
          }
          findMany: {
            args: Prisma.ChallengeDiscussionOptionFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ChallengeDiscussionOptionPayload>[]
          }
          create: {
            args: Prisma.ChallengeDiscussionOptionCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ChallengeDiscussionOptionPayload>
          }
          createMany: {
            args: Prisma.ChallengeDiscussionOptionCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.ChallengeDiscussionOptionCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ChallengeDiscussionOptionPayload>[]
          }
          delete: {
            args: Prisma.ChallengeDiscussionOptionDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ChallengeDiscussionOptionPayload>
          }
          update: {
            args: Prisma.ChallengeDiscussionOptionUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ChallengeDiscussionOptionPayload>
          }
          deleteMany: {
            args: Prisma.ChallengeDiscussionOptionDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.ChallengeDiscussionOptionUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.ChallengeDiscussionOptionUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ChallengeDiscussionOptionPayload>[]
          }
          upsert: {
            args: Prisma.ChallengeDiscussionOptionUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ChallengeDiscussionOptionPayload>
          }
          aggregate: {
            args: Prisma.ChallengeDiscussionOptionAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateChallengeDiscussionOption>
          }
          groupBy: {
            args: Prisma.ChallengeDiscussionOptionGroupByArgs<ExtArgs>
            result: $Utils.Optional<ChallengeDiscussionOptionGroupByOutputType>[]
          }
          count: {
            args: Prisma.ChallengeDiscussionOptionCountArgs<ExtArgs>
            result: $Utils.Optional<ChallengeDiscussionOptionCountAggregateOutputType> | number
          }
        }
      }
      ChallengeConstraint: {
        payload: Prisma.$ChallengeConstraintPayload<ExtArgs>
        fields: Prisma.ChallengeConstraintFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ChallengeConstraintFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ChallengeConstraintPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ChallengeConstraintFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ChallengeConstraintPayload>
          }
          findFirst: {
            args: Prisma.ChallengeConstraintFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ChallengeConstraintPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ChallengeConstraintFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ChallengeConstraintPayload>
          }
          findMany: {
            args: Prisma.ChallengeConstraintFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ChallengeConstraintPayload>[]
          }
          create: {
            args: Prisma.ChallengeConstraintCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ChallengeConstraintPayload>
          }
          createMany: {
            args: Prisma.ChallengeConstraintCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.ChallengeConstraintCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ChallengeConstraintPayload>[]
          }
          delete: {
            args: Prisma.ChallengeConstraintDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ChallengeConstraintPayload>
          }
          update: {
            args: Prisma.ChallengeConstraintUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ChallengeConstraintPayload>
          }
          deleteMany: {
            args: Prisma.ChallengeConstraintDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.ChallengeConstraintUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.ChallengeConstraintUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ChallengeConstraintPayload>[]
          }
          upsert: {
            args: Prisma.ChallengeConstraintUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ChallengeConstraintPayload>
          }
          aggregate: {
            args: Prisma.ChallengeConstraintAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateChallengeConstraint>
          }
          groupBy: {
            args: Prisma.ChallengeConstraintGroupByArgs<ExtArgs>
            result: $Utils.Optional<ChallengeConstraintGroupByOutputType>[]
          }
          count: {
            args: Prisma.ChallengeConstraintCountArgs<ExtArgs>
            result: $Utils.Optional<ChallengeConstraintCountAggregateOutputType> | number
          }
        }
      }
      Phase: {
        payload: Prisma.$PhasePayload<ExtArgs>
        fields: Prisma.PhaseFieldRefs
        operations: {
          findUnique: {
            args: Prisma.PhaseFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PhasePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.PhaseFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PhasePayload>
          }
          findFirst: {
            args: Prisma.PhaseFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PhasePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.PhaseFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PhasePayload>
          }
          findMany: {
            args: Prisma.PhaseFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PhasePayload>[]
          }
          create: {
            args: Prisma.PhaseCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PhasePayload>
          }
          createMany: {
            args: Prisma.PhaseCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.PhaseCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PhasePayload>[]
          }
          delete: {
            args: Prisma.PhaseDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PhasePayload>
          }
          update: {
            args: Prisma.PhaseUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PhasePayload>
          }
          deleteMany: {
            args: Prisma.PhaseDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.PhaseUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.PhaseUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PhasePayload>[]
          }
          upsert: {
            args: Prisma.PhaseUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PhasePayload>
          }
          aggregate: {
            args: Prisma.PhaseAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregatePhase>
          }
          groupBy: {
            args: Prisma.PhaseGroupByArgs<ExtArgs>
            result: $Utils.Optional<PhaseGroupByOutputType>[]
          }
          count: {
            args: Prisma.PhaseCountArgs<ExtArgs>
            result: $Utils.Optional<PhaseCountAggregateOutputType> | number
          }
        }
      }
      ChallengePhase: {
        payload: Prisma.$ChallengePhasePayload<ExtArgs>
        fields: Prisma.ChallengePhaseFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ChallengePhaseFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ChallengePhasePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ChallengePhaseFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ChallengePhasePayload>
          }
          findFirst: {
            args: Prisma.ChallengePhaseFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ChallengePhasePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ChallengePhaseFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ChallengePhasePayload>
          }
          findMany: {
            args: Prisma.ChallengePhaseFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ChallengePhasePayload>[]
          }
          create: {
            args: Prisma.ChallengePhaseCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ChallengePhasePayload>
          }
          createMany: {
            args: Prisma.ChallengePhaseCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.ChallengePhaseCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ChallengePhasePayload>[]
          }
          delete: {
            args: Prisma.ChallengePhaseDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ChallengePhasePayload>
          }
          update: {
            args: Prisma.ChallengePhaseUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ChallengePhasePayload>
          }
          deleteMany: {
            args: Prisma.ChallengePhaseDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.ChallengePhaseUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.ChallengePhaseUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ChallengePhasePayload>[]
          }
          upsert: {
            args: Prisma.ChallengePhaseUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ChallengePhasePayload>
          }
          aggregate: {
            args: Prisma.ChallengePhaseAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateChallengePhase>
          }
          groupBy: {
            args: Prisma.ChallengePhaseGroupByArgs<ExtArgs>
            result: $Utils.Optional<ChallengePhaseGroupByOutputType>[]
          }
          count: {
            args: Prisma.ChallengePhaseCountArgs<ExtArgs>
            result: $Utils.Optional<ChallengePhaseCountAggregateOutputType> | number
          }
        }
      }
      ChallengePhaseConstraint: {
        payload: Prisma.$ChallengePhaseConstraintPayload<ExtArgs>
        fields: Prisma.ChallengePhaseConstraintFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ChallengePhaseConstraintFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ChallengePhaseConstraintPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ChallengePhaseConstraintFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ChallengePhaseConstraintPayload>
          }
          findFirst: {
            args: Prisma.ChallengePhaseConstraintFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ChallengePhaseConstraintPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ChallengePhaseConstraintFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ChallengePhaseConstraintPayload>
          }
          findMany: {
            args: Prisma.ChallengePhaseConstraintFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ChallengePhaseConstraintPayload>[]
          }
          create: {
            args: Prisma.ChallengePhaseConstraintCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ChallengePhaseConstraintPayload>
          }
          createMany: {
            args: Prisma.ChallengePhaseConstraintCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.ChallengePhaseConstraintCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ChallengePhaseConstraintPayload>[]
          }
          delete: {
            args: Prisma.ChallengePhaseConstraintDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ChallengePhaseConstraintPayload>
          }
          update: {
            args: Prisma.ChallengePhaseConstraintUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ChallengePhaseConstraintPayload>
          }
          deleteMany: {
            args: Prisma.ChallengePhaseConstraintDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.ChallengePhaseConstraintUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.ChallengePhaseConstraintUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ChallengePhaseConstraintPayload>[]
          }
          upsert: {
            args: Prisma.ChallengePhaseConstraintUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ChallengePhaseConstraintPayload>
          }
          aggregate: {
            args: Prisma.ChallengePhaseConstraintAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateChallengePhaseConstraint>
          }
          groupBy: {
            args: Prisma.ChallengePhaseConstraintGroupByArgs<ExtArgs>
            result: $Utils.Optional<ChallengePhaseConstraintGroupByOutputType>[]
          }
          count: {
            args: Prisma.ChallengePhaseConstraintCountArgs<ExtArgs>
            result: $Utils.Optional<ChallengePhaseConstraintCountAggregateOutputType> | number
          }
        }
      }
      ChallengePrizeSet: {
        payload: Prisma.$ChallengePrizeSetPayload<ExtArgs>
        fields: Prisma.ChallengePrizeSetFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ChallengePrizeSetFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ChallengePrizeSetPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ChallengePrizeSetFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ChallengePrizeSetPayload>
          }
          findFirst: {
            args: Prisma.ChallengePrizeSetFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ChallengePrizeSetPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ChallengePrizeSetFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ChallengePrizeSetPayload>
          }
          findMany: {
            args: Prisma.ChallengePrizeSetFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ChallengePrizeSetPayload>[]
          }
          create: {
            args: Prisma.ChallengePrizeSetCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ChallengePrizeSetPayload>
          }
          createMany: {
            args: Prisma.ChallengePrizeSetCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.ChallengePrizeSetCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ChallengePrizeSetPayload>[]
          }
          delete: {
            args: Prisma.ChallengePrizeSetDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ChallengePrizeSetPayload>
          }
          update: {
            args: Prisma.ChallengePrizeSetUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ChallengePrizeSetPayload>
          }
          deleteMany: {
            args: Prisma.ChallengePrizeSetDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.ChallengePrizeSetUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.ChallengePrizeSetUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ChallengePrizeSetPayload>[]
          }
          upsert: {
            args: Prisma.ChallengePrizeSetUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ChallengePrizeSetPayload>
          }
          aggregate: {
            args: Prisma.ChallengePrizeSetAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateChallengePrizeSet>
          }
          groupBy: {
            args: Prisma.ChallengePrizeSetGroupByArgs<ExtArgs>
            result: $Utils.Optional<ChallengePrizeSetGroupByOutputType>[]
          }
          count: {
            args: Prisma.ChallengePrizeSetCountArgs<ExtArgs>
            result: $Utils.Optional<ChallengePrizeSetCountAggregateOutputType> | number
          }
        }
      }
      ChallengeReviewer: {
        payload: Prisma.$ChallengeReviewerPayload<ExtArgs>
        fields: Prisma.ChallengeReviewerFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ChallengeReviewerFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ChallengeReviewerPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ChallengeReviewerFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ChallengeReviewerPayload>
          }
          findFirst: {
            args: Prisma.ChallengeReviewerFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ChallengeReviewerPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ChallengeReviewerFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ChallengeReviewerPayload>
          }
          findMany: {
            args: Prisma.ChallengeReviewerFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ChallengeReviewerPayload>[]
          }
          create: {
            args: Prisma.ChallengeReviewerCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ChallengeReviewerPayload>
          }
          createMany: {
            args: Prisma.ChallengeReviewerCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.ChallengeReviewerCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ChallengeReviewerPayload>[]
          }
          delete: {
            args: Prisma.ChallengeReviewerDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ChallengeReviewerPayload>
          }
          update: {
            args: Prisma.ChallengeReviewerUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ChallengeReviewerPayload>
          }
          deleteMany: {
            args: Prisma.ChallengeReviewerDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.ChallengeReviewerUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.ChallengeReviewerUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ChallengeReviewerPayload>[]
          }
          upsert: {
            args: Prisma.ChallengeReviewerUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ChallengeReviewerPayload>
          }
          aggregate: {
            args: Prisma.ChallengeReviewerAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateChallengeReviewer>
          }
          groupBy: {
            args: Prisma.ChallengeReviewerGroupByArgs<ExtArgs>
            result: $Utils.Optional<ChallengeReviewerGroupByOutputType>[]
          }
          count: {
            args: Prisma.ChallengeReviewerCountArgs<ExtArgs>
            result: $Utils.Optional<ChallengeReviewerCountAggregateOutputType> | number
          }
        }
      }
      DefaultChallengeReviewer: {
        payload: Prisma.$DefaultChallengeReviewerPayload<ExtArgs>
        fields: Prisma.DefaultChallengeReviewerFieldRefs
        operations: {
          findUnique: {
            args: Prisma.DefaultChallengeReviewerFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DefaultChallengeReviewerPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.DefaultChallengeReviewerFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DefaultChallengeReviewerPayload>
          }
          findFirst: {
            args: Prisma.DefaultChallengeReviewerFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DefaultChallengeReviewerPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.DefaultChallengeReviewerFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DefaultChallengeReviewerPayload>
          }
          findMany: {
            args: Prisma.DefaultChallengeReviewerFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DefaultChallengeReviewerPayload>[]
          }
          create: {
            args: Prisma.DefaultChallengeReviewerCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DefaultChallengeReviewerPayload>
          }
          createMany: {
            args: Prisma.DefaultChallengeReviewerCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.DefaultChallengeReviewerCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DefaultChallengeReviewerPayload>[]
          }
          delete: {
            args: Prisma.DefaultChallengeReviewerDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DefaultChallengeReviewerPayload>
          }
          update: {
            args: Prisma.DefaultChallengeReviewerUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DefaultChallengeReviewerPayload>
          }
          deleteMany: {
            args: Prisma.DefaultChallengeReviewerDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.DefaultChallengeReviewerUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.DefaultChallengeReviewerUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DefaultChallengeReviewerPayload>[]
          }
          upsert: {
            args: Prisma.DefaultChallengeReviewerUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DefaultChallengeReviewerPayload>
          }
          aggregate: {
            args: Prisma.DefaultChallengeReviewerAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateDefaultChallengeReviewer>
          }
          groupBy: {
            args: Prisma.DefaultChallengeReviewerGroupByArgs<ExtArgs>
            result: $Utils.Optional<DefaultChallengeReviewerGroupByOutputType>[]
          }
          count: {
            args: Prisma.DefaultChallengeReviewerCountArgs<ExtArgs>
            result: $Utils.Optional<DefaultChallengeReviewerCountAggregateOutputType> | number
          }
        }
      }
      TimelineTemplate: {
        payload: Prisma.$TimelineTemplatePayload<ExtArgs>
        fields: Prisma.TimelineTemplateFieldRefs
        operations: {
          findUnique: {
            args: Prisma.TimelineTemplateFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TimelineTemplatePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.TimelineTemplateFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TimelineTemplatePayload>
          }
          findFirst: {
            args: Prisma.TimelineTemplateFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TimelineTemplatePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.TimelineTemplateFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TimelineTemplatePayload>
          }
          findMany: {
            args: Prisma.TimelineTemplateFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TimelineTemplatePayload>[]
          }
          create: {
            args: Prisma.TimelineTemplateCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TimelineTemplatePayload>
          }
          createMany: {
            args: Prisma.TimelineTemplateCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.TimelineTemplateCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TimelineTemplatePayload>[]
          }
          delete: {
            args: Prisma.TimelineTemplateDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TimelineTemplatePayload>
          }
          update: {
            args: Prisma.TimelineTemplateUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TimelineTemplatePayload>
          }
          deleteMany: {
            args: Prisma.TimelineTemplateDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.TimelineTemplateUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.TimelineTemplateUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TimelineTemplatePayload>[]
          }
          upsert: {
            args: Prisma.TimelineTemplateUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TimelineTemplatePayload>
          }
          aggregate: {
            args: Prisma.TimelineTemplateAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateTimelineTemplate>
          }
          groupBy: {
            args: Prisma.TimelineTemplateGroupByArgs<ExtArgs>
            result: $Utils.Optional<TimelineTemplateGroupByOutputType>[]
          }
          count: {
            args: Prisma.TimelineTemplateCountArgs<ExtArgs>
            result: $Utils.Optional<TimelineTemplateCountAggregateOutputType> | number
          }
        }
      }
      TimelineTemplatePhase: {
        payload: Prisma.$TimelineTemplatePhasePayload<ExtArgs>
        fields: Prisma.TimelineTemplatePhaseFieldRefs
        operations: {
          findUnique: {
            args: Prisma.TimelineTemplatePhaseFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TimelineTemplatePhasePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.TimelineTemplatePhaseFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TimelineTemplatePhasePayload>
          }
          findFirst: {
            args: Prisma.TimelineTemplatePhaseFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TimelineTemplatePhasePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.TimelineTemplatePhaseFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TimelineTemplatePhasePayload>
          }
          findMany: {
            args: Prisma.TimelineTemplatePhaseFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TimelineTemplatePhasePayload>[]
          }
          create: {
            args: Prisma.TimelineTemplatePhaseCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TimelineTemplatePhasePayload>
          }
          createMany: {
            args: Prisma.TimelineTemplatePhaseCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.TimelineTemplatePhaseCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TimelineTemplatePhasePayload>[]
          }
          delete: {
            args: Prisma.TimelineTemplatePhaseDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TimelineTemplatePhasePayload>
          }
          update: {
            args: Prisma.TimelineTemplatePhaseUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TimelineTemplatePhasePayload>
          }
          deleteMany: {
            args: Prisma.TimelineTemplatePhaseDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.TimelineTemplatePhaseUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.TimelineTemplatePhaseUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TimelineTemplatePhasePayload>[]
          }
          upsert: {
            args: Prisma.TimelineTemplatePhaseUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TimelineTemplatePhasePayload>
          }
          aggregate: {
            args: Prisma.TimelineTemplatePhaseAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateTimelineTemplatePhase>
          }
          groupBy: {
            args: Prisma.TimelineTemplatePhaseGroupByArgs<ExtArgs>
            result: $Utils.Optional<TimelineTemplatePhaseGroupByOutputType>[]
          }
          count: {
            args: Prisma.TimelineTemplatePhaseCountArgs<ExtArgs>
            result: $Utils.Optional<TimelineTemplatePhaseCountAggregateOutputType> | number
          }
        }
      }
      MemberChallengeAccess: {
        payload: Prisma.$MemberChallengeAccessPayload<ExtArgs>
        fields: Prisma.MemberChallengeAccessFieldRefs
        operations: {
          findFirst: {
            args: Prisma.MemberChallengeAccessFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MemberChallengeAccessPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.MemberChallengeAccessFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MemberChallengeAccessPayload>
          }
          findMany: {
            args: Prisma.MemberChallengeAccessFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MemberChallengeAccessPayload>[]
          }
          aggregate: {
            args: Prisma.MemberChallengeAccessAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateMemberChallengeAccess>
          }
          groupBy: {
            args: Prisma.MemberChallengeAccessGroupByArgs<ExtArgs>
            result: $Utils.Optional<MemberChallengeAccessGroupByOutputType>[]
          }
          count: {
            args: Prisma.MemberChallengeAccessCountArgs<ExtArgs>
            result: $Utils.Optional<MemberChallengeAccessCountAggregateOutputType> | number
          }
        }
      }
    }
  } & {
    other: {
      payload: any
      operations: {
        $executeRaw: {
          args: [query: TemplateStringsArray | Prisma.Sql, ...values: any[]],
          result: any
        }
        $executeRawUnsafe: {
          args: [query: string, ...values: any[]],
          result: any
        }
        $queryRaw: {
          args: [query: TemplateStringsArray | Prisma.Sql, ...values: any[]],
          result: any
        }
        $queryRawUnsafe: {
          args: [query: string, ...values: any[]],
          result: any
        }
      }
    }
  }
  export const defineExtension: $Extensions.ExtendsHook<"define", Prisma.TypeMapCb, $Extensions.DefaultArgs>
  export type DefaultPrismaClient = PrismaClient
  export type ErrorFormat = 'pretty' | 'colorless' | 'minimal'
  export interface PrismaClientOptions {
    /**
     * Overwrites the datasource url from your schema.prisma file
     */
    datasources?: Datasources
    /**
     * Overwrites the datasource url from your schema.prisma file
     */
    datasourceUrl?: string
    /**
     * @default "colorless"
     */
    errorFormat?: ErrorFormat
    /**
     * @example
     * ```
     * // Shorthand for `emit: 'stdout'`
     * log: ['query', 'info', 'warn', 'error']
     * 
     * // Emit as events only
     * log: [
     *   { emit: 'event', level: 'query' },
     *   { emit: 'event', level: 'info' },
     *   { emit: 'event', level: 'warn' }
     *   { emit: 'event', level: 'error' }
     * ]
     * 
     * / Emit as events and log to stdout
     * og: [
     *  { emit: 'stdout', level: 'query' },
     *  { emit: 'stdout', level: 'info' },
     *  { emit: 'stdout', level: 'warn' }
     *  { emit: 'stdout', level: 'error' }
     * 
     * ```
     * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/logging#the-log-option).
     */
    log?: (LogLevel | LogDefinition)[]
    /**
     * The default values for transactionOptions
     * maxWait ?= 2000
     * timeout ?= 5000
     */
    transactionOptions?: {
      maxWait?: number
      timeout?: number
      isolationLevel?: Prisma.TransactionIsolationLevel
    }
    /**
     * Instance of a Driver Adapter, e.g., like one provided by `@prisma/adapter-planetscale`
     */
    adapter?: runtime.SqlDriverAdapterFactory | null
    /**
     * Global configuration for omitting model fields by default.
     * 
     * @example
     * ```
     * const prisma = new PrismaClient({
     *   omit: {
     *     user: {
     *       password: true
     *     }
     *   }
     * })
     * ```
     */
    omit?: Prisma.GlobalOmitConfig
  }
  export type GlobalOmitConfig = {
    challenge?: ChallengeOmit
    challengeType?: ChallengeTypeOmit
    challengeTrack?: ChallengeTrackOmit
    challengeTimelineTemplate?: ChallengeTimelineTemplateOmit
    auditLog?: AuditLogOmit
    attachment?: AttachmentOmit
    challengeMetadata?: ChallengeMetadataOmit
    prize?: PrizeOmit
    challengeWinner?: ChallengeWinnerOmit
    challengeTerm?: ChallengeTermOmit
    challengeSkill?: ChallengeSkillOmit
    challengeBilling?: ChallengeBillingOmit
    challengeLegacy?: ChallengeLegacyOmit
    challengeEvent?: ChallengeEventOmit
    challengeDiscussion?: ChallengeDiscussionOmit
    challengeDiscussionOption?: ChallengeDiscussionOptionOmit
    challengeConstraint?: ChallengeConstraintOmit
    phase?: PhaseOmit
    challengePhase?: ChallengePhaseOmit
    challengePhaseConstraint?: ChallengePhaseConstraintOmit
    challengePrizeSet?: ChallengePrizeSetOmit
    challengeReviewer?: ChallengeReviewerOmit
    defaultChallengeReviewer?: DefaultChallengeReviewerOmit
    timelineTemplate?: TimelineTemplateOmit
    timelineTemplatePhase?: TimelineTemplatePhaseOmit
    memberChallengeAccess?: MemberChallengeAccessOmit
  }

  /* Types for Logging */
  export type LogLevel = 'info' | 'query' | 'warn' | 'error'
  export type LogDefinition = {
    level: LogLevel
    emit: 'stdout' | 'event'
  }

  export type CheckIsLogLevel<T> = T extends LogLevel ? T : never;

  export type GetLogType<T> = CheckIsLogLevel<
    T extends LogDefinition ? T['level'] : T
  >;

  export type GetEvents<T extends any[]> = T extends Array<LogLevel | LogDefinition>
    ? GetLogType<T[number]>
    : never;

  export type QueryEvent = {
    timestamp: Date
    query: string
    params: string
    duration: number
    target: string
  }

  export type LogEvent = {
    timestamp: Date
    message: string
    target: string
  }
  /* End Types for Logging */


  export type PrismaAction =
    | 'findUnique'
    | 'findUniqueOrThrow'
    | 'findMany'
    | 'findFirst'
    | 'findFirstOrThrow'
    | 'create'
    | 'createMany'
    | 'createManyAndReturn'
    | 'update'
    | 'updateMany'
    | 'updateManyAndReturn'
    | 'upsert'
    | 'delete'
    | 'deleteMany'
    | 'executeRaw'
    | 'queryRaw'
    | 'aggregate'
    | 'count'
    | 'runCommandRaw'
    | 'findRaw'
    | 'groupBy'

  // tested in getLogLevel.test.ts
  export function getLogLevel(log: Array<LogLevel | LogDefinition>): LogLevel | undefined;

  /**
   * `PrismaClient` proxy available in interactive transactions.
   */
  export type TransactionClient = Omit<Prisma.DefaultPrismaClient, runtime.ITXClientDenyList>

  export type Datasource = {
    url?: string
  }

  /**
   * Count Types
   */


  /**
   * Count Type ChallengeCountOutputType
   */

  export type ChallengeCountOutputType = {
    events: number
    discussions: number
    metadata: number
    phases: number
    prizeSets: number
    reviewers: number
    winners: number
    attachments: number
    terms: number
    skills: number
    auditLogs: number
    memberAccesses: number
  }

  export type ChallengeCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    events?: boolean | ChallengeCountOutputTypeCountEventsArgs
    discussions?: boolean | ChallengeCountOutputTypeCountDiscussionsArgs
    metadata?: boolean | ChallengeCountOutputTypeCountMetadataArgs
    phases?: boolean | ChallengeCountOutputTypeCountPhasesArgs
    prizeSets?: boolean | ChallengeCountOutputTypeCountPrizeSetsArgs
    reviewers?: boolean | ChallengeCountOutputTypeCountReviewersArgs
    winners?: boolean | ChallengeCountOutputTypeCountWinnersArgs
    attachments?: boolean | ChallengeCountOutputTypeCountAttachmentsArgs
    terms?: boolean | ChallengeCountOutputTypeCountTermsArgs
    skills?: boolean | ChallengeCountOutputTypeCountSkillsArgs
    auditLogs?: boolean | ChallengeCountOutputTypeCountAuditLogsArgs
    memberAccesses?: boolean | ChallengeCountOutputTypeCountMemberAccessesArgs
  }

  // Custom InputTypes
  /**
   * ChallengeCountOutputType without action
   */
  export type ChallengeCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ChallengeCountOutputType
     */
    select?: ChallengeCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * ChallengeCountOutputType without action
   */
  export type ChallengeCountOutputTypeCountEventsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ChallengeEventWhereInput
  }

  /**
   * ChallengeCountOutputType without action
   */
  export type ChallengeCountOutputTypeCountDiscussionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ChallengeDiscussionWhereInput
  }

  /**
   * ChallengeCountOutputType without action
   */
  export type ChallengeCountOutputTypeCountMetadataArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ChallengeMetadataWhereInput
  }

  /**
   * ChallengeCountOutputType without action
   */
  export type ChallengeCountOutputTypeCountPhasesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ChallengePhaseWhereInput
  }

  /**
   * ChallengeCountOutputType without action
   */
  export type ChallengeCountOutputTypeCountPrizeSetsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ChallengePrizeSetWhereInput
  }

  /**
   * ChallengeCountOutputType without action
   */
  export type ChallengeCountOutputTypeCountReviewersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ChallengeReviewerWhereInput
  }

  /**
   * ChallengeCountOutputType without action
   */
  export type ChallengeCountOutputTypeCountWinnersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ChallengeWinnerWhereInput
  }

  /**
   * ChallengeCountOutputType without action
   */
  export type ChallengeCountOutputTypeCountAttachmentsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: AttachmentWhereInput
  }

  /**
   * ChallengeCountOutputType without action
   */
  export type ChallengeCountOutputTypeCountTermsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ChallengeTermWhereInput
  }

  /**
   * ChallengeCountOutputType without action
   */
  export type ChallengeCountOutputTypeCountSkillsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ChallengeSkillWhereInput
  }

  /**
   * ChallengeCountOutputType without action
   */
  export type ChallengeCountOutputTypeCountAuditLogsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: AuditLogWhereInput
  }

  /**
   * ChallengeCountOutputType without action
   */
  export type ChallengeCountOutputTypeCountMemberAccessesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: MemberChallengeAccessWhereInput
  }


  /**
   * Count Type ChallengeTypeCountOutputType
   */

  export type ChallengeTypeCountOutputType = {
    challenges: number
    timelineTemplates: number
    defaultReviewers: number
  }

  export type ChallengeTypeCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    challenges?: boolean | ChallengeTypeCountOutputTypeCountChallengesArgs
    timelineTemplates?: boolean | ChallengeTypeCountOutputTypeCountTimelineTemplatesArgs
    defaultReviewers?: boolean | ChallengeTypeCountOutputTypeCountDefaultReviewersArgs
  }

  // Custom InputTypes
  /**
   * ChallengeTypeCountOutputType without action
   */
  export type ChallengeTypeCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ChallengeTypeCountOutputType
     */
    select?: ChallengeTypeCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * ChallengeTypeCountOutputType without action
   */
  export type ChallengeTypeCountOutputTypeCountChallengesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ChallengeWhereInput
  }

  /**
   * ChallengeTypeCountOutputType without action
   */
  export type ChallengeTypeCountOutputTypeCountTimelineTemplatesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ChallengeTimelineTemplateWhereInput
  }

  /**
   * ChallengeTypeCountOutputType without action
   */
  export type ChallengeTypeCountOutputTypeCountDefaultReviewersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: DefaultChallengeReviewerWhereInput
  }


  /**
   * Count Type ChallengeTrackCountOutputType
   */

  export type ChallengeTrackCountOutputType = {
    challenges: number
    timelineTemplates: number
    defaultReviewers: number
  }

  export type ChallengeTrackCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    challenges?: boolean | ChallengeTrackCountOutputTypeCountChallengesArgs
    timelineTemplates?: boolean | ChallengeTrackCountOutputTypeCountTimelineTemplatesArgs
    defaultReviewers?: boolean | ChallengeTrackCountOutputTypeCountDefaultReviewersArgs
  }

  // Custom InputTypes
  /**
   * ChallengeTrackCountOutputType without action
   */
  export type ChallengeTrackCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ChallengeTrackCountOutputType
     */
    select?: ChallengeTrackCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * ChallengeTrackCountOutputType without action
   */
  export type ChallengeTrackCountOutputTypeCountChallengesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ChallengeWhereInput
  }

  /**
   * ChallengeTrackCountOutputType without action
   */
  export type ChallengeTrackCountOutputTypeCountTimelineTemplatesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ChallengeTimelineTemplateWhereInput
  }

  /**
   * ChallengeTrackCountOutputType without action
   */
  export type ChallengeTrackCountOutputTypeCountDefaultReviewersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: DefaultChallengeReviewerWhereInput
  }


  /**
   * Count Type ChallengeDiscussionCountOutputType
   */

  export type ChallengeDiscussionCountOutputType = {
    options: number
  }

  export type ChallengeDiscussionCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    options?: boolean | ChallengeDiscussionCountOutputTypeCountOptionsArgs
  }

  // Custom InputTypes
  /**
   * ChallengeDiscussionCountOutputType without action
   */
  export type ChallengeDiscussionCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ChallengeDiscussionCountOutputType
     */
    select?: ChallengeDiscussionCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * ChallengeDiscussionCountOutputType without action
   */
  export type ChallengeDiscussionCountOutputTypeCountOptionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ChallengeDiscussionOptionWhereInput
  }


  /**
   * Count Type PhaseCountOutputType
   */

  export type PhaseCountOutputType = {
    challengePhases: number
    ChallengeReviewer: number
    DefaultChallengeReviewer: number
  }

  export type PhaseCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    challengePhases?: boolean | PhaseCountOutputTypeCountChallengePhasesArgs
    ChallengeReviewer?: boolean | PhaseCountOutputTypeCountChallengeReviewerArgs
    DefaultChallengeReviewer?: boolean | PhaseCountOutputTypeCountDefaultChallengeReviewerArgs
  }

  // Custom InputTypes
  /**
   * PhaseCountOutputType without action
   */
  export type PhaseCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PhaseCountOutputType
     */
    select?: PhaseCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * PhaseCountOutputType without action
   */
  export type PhaseCountOutputTypeCountChallengePhasesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ChallengePhaseWhereInput
  }

  /**
   * PhaseCountOutputType without action
   */
  export type PhaseCountOutputTypeCountChallengeReviewerArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ChallengeReviewerWhereInput
  }

  /**
   * PhaseCountOutputType without action
   */
  export type PhaseCountOutputTypeCountDefaultChallengeReviewerArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: DefaultChallengeReviewerWhereInput
  }


  /**
   * Count Type ChallengePhaseCountOutputType
   */

  export type ChallengePhaseCountOutputType = {
    constraints: number
  }

  export type ChallengePhaseCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    constraints?: boolean | ChallengePhaseCountOutputTypeCountConstraintsArgs
  }

  // Custom InputTypes
  /**
   * ChallengePhaseCountOutputType without action
   */
  export type ChallengePhaseCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ChallengePhaseCountOutputType
     */
    select?: ChallengePhaseCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * ChallengePhaseCountOutputType without action
   */
  export type ChallengePhaseCountOutputTypeCountConstraintsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ChallengePhaseConstraintWhereInput
  }


  /**
   * Count Type ChallengePrizeSetCountOutputType
   */

  export type ChallengePrizeSetCountOutputType = {
    prizes: number
  }

  export type ChallengePrizeSetCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    prizes?: boolean | ChallengePrizeSetCountOutputTypeCountPrizesArgs
  }

  // Custom InputTypes
  /**
   * ChallengePrizeSetCountOutputType without action
   */
  export type ChallengePrizeSetCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ChallengePrizeSetCountOutputType
     */
    select?: ChallengePrizeSetCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * ChallengePrizeSetCountOutputType without action
   */
  export type ChallengePrizeSetCountOutputTypeCountPrizesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PrizeWhereInput
  }


  /**
   * Count Type TimelineTemplateCountOutputType
   */

  export type TimelineTemplateCountOutputType = {
    phases: number
    challengeTimelineTemplates: number
    challenges: number
    DefaultChallengeReviewer: number
  }

  export type TimelineTemplateCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    phases?: boolean | TimelineTemplateCountOutputTypeCountPhasesArgs
    challengeTimelineTemplates?: boolean | TimelineTemplateCountOutputTypeCountChallengeTimelineTemplatesArgs
    challenges?: boolean | TimelineTemplateCountOutputTypeCountChallengesArgs
    DefaultChallengeReviewer?: boolean | TimelineTemplateCountOutputTypeCountDefaultChallengeReviewerArgs
  }

  // Custom InputTypes
  /**
   * TimelineTemplateCountOutputType without action
   */
  export type TimelineTemplateCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TimelineTemplateCountOutputType
     */
    select?: TimelineTemplateCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * TimelineTemplateCountOutputType without action
   */
  export type TimelineTemplateCountOutputTypeCountPhasesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: TimelineTemplatePhaseWhereInput
  }

  /**
   * TimelineTemplateCountOutputType without action
   */
  export type TimelineTemplateCountOutputTypeCountChallengeTimelineTemplatesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ChallengeTimelineTemplateWhereInput
  }

  /**
   * TimelineTemplateCountOutputType without action
   */
  export type TimelineTemplateCountOutputTypeCountChallengesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ChallengeWhereInput
  }

  /**
   * TimelineTemplateCountOutputType without action
   */
  export type TimelineTemplateCountOutputTypeCountDefaultChallengeReviewerArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: DefaultChallengeReviewerWhereInput
  }


  /**
   * Models
   */

  /**
   * Model Challenge
   */

  export type AggregateChallenge = {
    _count: ChallengeCountAggregateOutputType | null
    _avg: ChallengeAvgAggregateOutputType | null
    _sum: ChallengeSumAggregateOutputType | null
    _min: ChallengeMinAggregateOutputType | null
    _max: ChallengeMaxAggregateOutputType | null
  }

  export type ChallengeAvgAggregateOutputType = {
    projectId: number | null
    overviewTotalPrizes: number | null
    numOfRegistrants: number | null
    numOfSubmissions: number | null
    numOfCheckpointSubmissions: number | null
    legacyId: number | null
  }

  export type ChallengeSumAggregateOutputType = {
    projectId: number | null
    overviewTotalPrizes: number | null
    numOfRegistrants: number | null
    numOfSubmissions: number | null
    numOfCheckpointSubmissions: number | null
    legacyId: number | null
  }

  export type ChallengeMinAggregateOutputType = {
    id: string | null
    name: string | null
    description: string | null
    privateDescription: string | null
    challengeSource: string | null
    descriptionFormat: string | null
    projectId: number | null
    typeId: string | null
    trackId: string | null
    timelineTemplateId: string | null
    overviewTotalPrizes: number | null
    numOfRegistrants: number | null
    numOfSubmissions: number | null
    numOfCheckpointSubmissions: number | null
    wiproAllowed: boolean | null
    taskIsTask: boolean | null
    taskIsAssigned: boolean | null
    taskMemberId: string | null
    submissionStartDate: Date | null
    submissionEndDate: Date | null
    registrationStartDate: Date | null
    registrationEndDate: Date | null
    startDate: Date | null
    endDate: Date | null
    legacyId: number | null
    status: $Enums.ChallengeStatusEnum | null
    createdAt: Date | null
    createdBy: string | null
    updatedAt: Date | null
    updatedBy: string | null
  }

  export type ChallengeMaxAggregateOutputType = {
    id: string | null
    name: string | null
    description: string | null
    privateDescription: string | null
    challengeSource: string | null
    descriptionFormat: string | null
    projectId: number | null
    typeId: string | null
    trackId: string | null
    timelineTemplateId: string | null
    overviewTotalPrizes: number | null
    numOfRegistrants: number | null
    numOfSubmissions: number | null
    numOfCheckpointSubmissions: number | null
    wiproAllowed: boolean | null
    taskIsTask: boolean | null
    taskIsAssigned: boolean | null
    taskMemberId: string | null
    submissionStartDate: Date | null
    submissionEndDate: Date | null
    registrationStartDate: Date | null
    registrationEndDate: Date | null
    startDate: Date | null
    endDate: Date | null
    legacyId: number | null
    status: $Enums.ChallengeStatusEnum | null
    createdAt: Date | null
    createdBy: string | null
    updatedAt: Date | null
    updatedBy: string | null
  }

  export type ChallengeCountAggregateOutputType = {
    id: number
    name: number
    description: number
    privateDescription: number
    challengeSource: number
    descriptionFormat: number
    projectId: number
    typeId: number
    trackId: number
    timelineTemplateId: number
    overviewTotalPrizes: number
    numOfRegistrants: number
    numOfSubmissions: number
    numOfCheckpointSubmissions: number
    currentPhaseNames: number
    wiproAllowed: number
    tags: number
    groups: number
    taskIsTask: number
    taskIsAssigned: number
    taskMemberId: number
    submissionStartDate: number
    submissionEndDate: number
    registrationStartDate: number
    registrationEndDate: number
    startDate: number
    endDate: number
    legacyId: number
    status: number
    createdAt: number
    createdBy: number
    updatedAt: number
    updatedBy: number
    _all: number
  }


  export type ChallengeAvgAggregateInputType = {
    projectId?: true
    overviewTotalPrizes?: true
    numOfRegistrants?: true
    numOfSubmissions?: true
    numOfCheckpointSubmissions?: true
    legacyId?: true
  }

  export type ChallengeSumAggregateInputType = {
    projectId?: true
    overviewTotalPrizes?: true
    numOfRegistrants?: true
    numOfSubmissions?: true
    numOfCheckpointSubmissions?: true
    legacyId?: true
  }

  export type ChallengeMinAggregateInputType = {
    id?: true
    name?: true
    description?: true
    privateDescription?: true
    challengeSource?: true
    descriptionFormat?: true
    projectId?: true
    typeId?: true
    trackId?: true
    timelineTemplateId?: true
    overviewTotalPrizes?: true
    numOfRegistrants?: true
    numOfSubmissions?: true
    numOfCheckpointSubmissions?: true
    wiproAllowed?: true
    taskIsTask?: true
    taskIsAssigned?: true
    taskMemberId?: true
    submissionStartDate?: true
    submissionEndDate?: true
    registrationStartDate?: true
    registrationEndDate?: true
    startDate?: true
    endDate?: true
    legacyId?: true
    status?: true
    createdAt?: true
    createdBy?: true
    updatedAt?: true
    updatedBy?: true
  }

  export type ChallengeMaxAggregateInputType = {
    id?: true
    name?: true
    description?: true
    privateDescription?: true
    challengeSource?: true
    descriptionFormat?: true
    projectId?: true
    typeId?: true
    trackId?: true
    timelineTemplateId?: true
    overviewTotalPrizes?: true
    numOfRegistrants?: true
    numOfSubmissions?: true
    numOfCheckpointSubmissions?: true
    wiproAllowed?: true
    taskIsTask?: true
    taskIsAssigned?: true
    taskMemberId?: true
    submissionStartDate?: true
    submissionEndDate?: true
    registrationStartDate?: true
    registrationEndDate?: true
    startDate?: true
    endDate?: true
    legacyId?: true
    status?: true
    createdAt?: true
    createdBy?: true
    updatedAt?: true
    updatedBy?: true
  }

  export type ChallengeCountAggregateInputType = {
    id?: true
    name?: true
    description?: true
    privateDescription?: true
    challengeSource?: true
    descriptionFormat?: true
    projectId?: true
    typeId?: true
    trackId?: true
    timelineTemplateId?: true
    overviewTotalPrizes?: true
    numOfRegistrants?: true
    numOfSubmissions?: true
    numOfCheckpointSubmissions?: true
    currentPhaseNames?: true
    wiproAllowed?: true
    tags?: true
    groups?: true
    taskIsTask?: true
    taskIsAssigned?: true
    taskMemberId?: true
    submissionStartDate?: true
    submissionEndDate?: true
    registrationStartDate?: true
    registrationEndDate?: true
    startDate?: true
    endDate?: true
    legacyId?: true
    status?: true
    createdAt?: true
    createdBy?: true
    updatedAt?: true
    updatedBy?: true
    _all?: true
  }

  export type ChallengeAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Challenge to aggregate.
     */
    where?: ChallengeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Challenges to fetch.
     */
    orderBy?: ChallengeOrderByWithRelationInput | ChallengeOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ChallengeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Challenges from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Challenges.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Challenges
    **/
    _count?: true | ChallengeCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: ChallengeAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: ChallengeSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ChallengeMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ChallengeMaxAggregateInputType
  }

  export type GetChallengeAggregateType<T extends ChallengeAggregateArgs> = {
        [P in keyof T & keyof AggregateChallenge]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateChallenge[P]>
      : GetScalarType<T[P], AggregateChallenge[P]>
  }




  export type ChallengeGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ChallengeWhereInput
    orderBy?: ChallengeOrderByWithAggregationInput | ChallengeOrderByWithAggregationInput[]
    by: ChallengeScalarFieldEnum[] | ChallengeScalarFieldEnum
    having?: ChallengeScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ChallengeCountAggregateInputType | true
    _avg?: ChallengeAvgAggregateInputType
    _sum?: ChallengeSumAggregateInputType
    _min?: ChallengeMinAggregateInputType
    _max?: ChallengeMaxAggregateInputType
  }

  export type ChallengeGroupByOutputType = {
    id: string
    name: string
    description: string | null
    privateDescription: string | null
    challengeSource: string | null
    descriptionFormat: string | null
    projectId: number | null
    typeId: string
    trackId: string
    timelineTemplateId: string | null
    overviewTotalPrizes: number | null
    numOfRegistrants: number
    numOfSubmissions: number
    numOfCheckpointSubmissions: number
    currentPhaseNames: string[]
    wiproAllowed: boolean
    tags: string[]
    groups: string[]
    taskIsTask: boolean
    taskIsAssigned: boolean
    taskMemberId: string | null
    submissionStartDate: Date | null
    submissionEndDate: Date | null
    registrationStartDate: Date | null
    registrationEndDate: Date | null
    startDate: Date | null
    endDate: Date | null
    legacyId: number | null
    status: $Enums.ChallengeStatusEnum
    createdAt: Date
    createdBy: string
    updatedAt: Date
    updatedBy: string
    _count: ChallengeCountAggregateOutputType | null
    _avg: ChallengeAvgAggregateOutputType | null
    _sum: ChallengeSumAggregateOutputType | null
    _min: ChallengeMinAggregateOutputType | null
    _max: ChallengeMaxAggregateOutputType | null
  }

  type GetChallengeGroupByPayload<T extends ChallengeGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ChallengeGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ChallengeGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ChallengeGroupByOutputType[P]>
            : GetScalarType<T[P], ChallengeGroupByOutputType[P]>
        }
      >
    >


  export type ChallengeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    description?: boolean
    privateDescription?: boolean
    challengeSource?: boolean
    descriptionFormat?: boolean
    projectId?: boolean
    typeId?: boolean
    trackId?: boolean
    timelineTemplateId?: boolean
    overviewTotalPrizes?: boolean
    numOfRegistrants?: boolean
    numOfSubmissions?: boolean
    numOfCheckpointSubmissions?: boolean
    currentPhaseNames?: boolean
    wiproAllowed?: boolean
    tags?: boolean
    groups?: boolean
    taskIsTask?: boolean
    taskIsAssigned?: boolean
    taskMemberId?: boolean
    submissionStartDate?: boolean
    submissionEndDate?: boolean
    registrationStartDate?: boolean
    registrationEndDate?: boolean
    startDate?: boolean
    endDate?: boolean
    legacyId?: boolean
    status?: boolean
    createdAt?: boolean
    createdBy?: boolean
    updatedAt?: boolean
    updatedBy?: boolean
    billingRecord?: boolean | Challenge$billingRecordArgs<ExtArgs>
    legacyRecord?: boolean | Challenge$legacyRecordArgs<ExtArgs>
    constraintRecord?: boolean | Challenge$constraintRecordArgs<ExtArgs>
    events?: boolean | Challenge$eventsArgs<ExtArgs>
    discussions?: boolean | Challenge$discussionsArgs<ExtArgs>
    metadata?: boolean | Challenge$metadataArgs<ExtArgs>
    phases?: boolean | Challenge$phasesArgs<ExtArgs>
    prizeSets?: boolean | Challenge$prizeSetsArgs<ExtArgs>
    reviewers?: boolean | Challenge$reviewersArgs<ExtArgs>
    winners?: boolean | Challenge$winnersArgs<ExtArgs>
    attachments?: boolean | Challenge$attachmentsArgs<ExtArgs>
    terms?: boolean | Challenge$termsArgs<ExtArgs>
    skills?: boolean | Challenge$skillsArgs<ExtArgs>
    auditLogs?: boolean | Challenge$auditLogsArgs<ExtArgs>
    memberAccesses?: boolean | Challenge$memberAccessesArgs<ExtArgs>
    type?: boolean | ChallengeTypeDefaultArgs<ExtArgs>
    track?: boolean | ChallengeTrackDefaultArgs<ExtArgs>
    timelineTemplate?: boolean | Challenge$timelineTemplateArgs<ExtArgs>
    _count?: boolean | ChallengeCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["challenge"]>

  export type ChallengeSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    description?: boolean
    privateDescription?: boolean
    challengeSource?: boolean
    descriptionFormat?: boolean
    projectId?: boolean
    typeId?: boolean
    trackId?: boolean
    timelineTemplateId?: boolean
    overviewTotalPrizes?: boolean
    numOfRegistrants?: boolean
    numOfSubmissions?: boolean
    numOfCheckpointSubmissions?: boolean
    currentPhaseNames?: boolean
    wiproAllowed?: boolean
    tags?: boolean
    groups?: boolean
    taskIsTask?: boolean
    taskIsAssigned?: boolean
    taskMemberId?: boolean
    submissionStartDate?: boolean
    submissionEndDate?: boolean
    registrationStartDate?: boolean
    registrationEndDate?: boolean
    startDate?: boolean
    endDate?: boolean
    legacyId?: boolean
    status?: boolean
    createdAt?: boolean
    createdBy?: boolean
    updatedAt?: boolean
    updatedBy?: boolean
    type?: boolean | ChallengeTypeDefaultArgs<ExtArgs>
    track?: boolean | ChallengeTrackDefaultArgs<ExtArgs>
    timelineTemplate?: boolean | Challenge$timelineTemplateArgs<ExtArgs>
  }, ExtArgs["result"]["challenge"]>

  export type ChallengeSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    description?: boolean
    privateDescription?: boolean
    challengeSource?: boolean
    descriptionFormat?: boolean
    projectId?: boolean
    typeId?: boolean
    trackId?: boolean
    timelineTemplateId?: boolean
    overviewTotalPrizes?: boolean
    numOfRegistrants?: boolean
    numOfSubmissions?: boolean
    numOfCheckpointSubmissions?: boolean
    currentPhaseNames?: boolean
    wiproAllowed?: boolean
    tags?: boolean
    groups?: boolean
    taskIsTask?: boolean
    taskIsAssigned?: boolean
    taskMemberId?: boolean
    submissionStartDate?: boolean
    submissionEndDate?: boolean
    registrationStartDate?: boolean
    registrationEndDate?: boolean
    startDate?: boolean
    endDate?: boolean
    legacyId?: boolean
    status?: boolean
    createdAt?: boolean
    createdBy?: boolean
    updatedAt?: boolean
    updatedBy?: boolean
    type?: boolean | ChallengeTypeDefaultArgs<ExtArgs>
    track?: boolean | ChallengeTrackDefaultArgs<ExtArgs>
    timelineTemplate?: boolean | Challenge$timelineTemplateArgs<ExtArgs>
  }, ExtArgs["result"]["challenge"]>

  export type ChallengeSelectScalar = {
    id?: boolean
    name?: boolean
    description?: boolean
    privateDescription?: boolean
    challengeSource?: boolean
    descriptionFormat?: boolean
    projectId?: boolean
    typeId?: boolean
    trackId?: boolean
    timelineTemplateId?: boolean
    overviewTotalPrizes?: boolean
    numOfRegistrants?: boolean
    numOfSubmissions?: boolean
    numOfCheckpointSubmissions?: boolean
    currentPhaseNames?: boolean
    wiproAllowed?: boolean
    tags?: boolean
    groups?: boolean
    taskIsTask?: boolean
    taskIsAssigned?: boolean
    taskMemberId?: boolean
    submissionStartDate?: boolean
    submissionEndDate?: boolean
    registrationStartDate?: boolean
    registrationEndDate?: boolean
    startDate?: boolean
    endDate?: boolean
    legacyId?: boolean
    status?: boolean
    createdAt?: boolean
    createdBy?: boolean
    updatedAt?: boolean
    updatedBy?: boolean
  }

  export type ChallengeOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "name" | "description" | "privateDescription" | "challengeSource" | "descriptionFormat" | "projectId" | "typeId" | "trackId" | "timelineTemplateId" | "overviewTotalPrizes" | "numOfRegistrants" | "numOfSubmissions" | "numOfCheckpointSubmissions" | "currentPhaseNames" | "wiproAllowed" | "tags" | "groups" | "taskIsTask" | "taskIsAssigned" | "taskMemberId" | "submissionStartDate" | "submissionEndDate" | "registrationStartDate" | "registrationEndDate" | "startDate" | "endDate" | "legacyId" | "status" | "createdAt" | "createdBy" | "updatedAt" | "updatedBy", ExtArgs["result"]["challenge"]>
  export type ChallengeInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    billingRecord?: boolean | Challenge$billingRecordArgs<ExtArgs>
    legacyRecord?: boolean | Challenge$legacyRecordArgs<ExtArgs>
    constraintRecord?: boolean | Challenge$constraintRecordArgs<ExtArgs>
    events?: boolean | Challenge$eventsArgs<ExtArgs>
    discussions?: boolean | Challenge$discussionsArgs<ExtArgs>
    metadata?: boolean | Challenge$metadataArgs<ExtArgs>
    phases?: boolean | Challenge$phasesArgs<ExtArgs>
    prizeSets?: boolean | Challenge$prizeSetsArgs<ExtArgs>
    reviewers?: boolean | Challenge$reviewersArgs<ExtArgs>
    winners?: boolean | Challenge$winnersArgs<ExtArgs>
    attachments?: boolean | Challenge$attachmentsArgs<ExtArgs>
    terms?: boolean | Challenge$termsArgs<ExtArgs>
    skills?: boolean | Challenge$skillsArgs<ExtArgs>
    auditLogs?: boolean | Challenge$auditLogsArgs<ExtArgs>
    memberAccesses?: boolean | Challenge$memberAccessesArgs<ExtArgs>
    type?: boolean | ChallengeTypeDefaultArgs<ExtArgs>
    track?: boolean | ChallengeTrackDefaultArgs<ExtArgs>
    timelineTemplate?: boolean | Challenge$timelineTemplateArgs<ExtArgs>
    _count?: boolean | ChallengeCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type ChallengeIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    type?: boolean | ChallengeTypeDefaultArgs<ExtArgs>
    track?: boolean | ChallengeTrackDefaultArgs<ExtArgs>
    timelineTemplate?: boolean | Challenge$timelineTemplateArgs<ExtArgs>
  }
  export type ChallengeIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    type?: boolean | ChallengeTypeDefaultArgs<ExtArgs>
    track?: boolean | ChallengeTrackDefaultArgs<ExtArgs>
    timelineTemplate?: boolean | Challenge$timelineTemplateArgs<ExtArgs>
  }

  export type $ChallengePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Challenge"
    objects: {
      billingRecord: Prisma.$ChallengeBillingPayload<ExtArgs> | null
      legacyRecord: Prisma.$ChallengeLegacyPayload<ExtArgs> | null
      constraintRecord: Prisma.$ChallengeConstraintPayload<ExtArgs> | null
      events: Prisma.$ChallengeEventPayload<ExtArgs>[]
      discussions: Prisma.$ChallengeDiscussionPayload<ExtArgs>[]
      metadata: Prisma.$ChallengeMetadataPayload<ExtArgs>[]
      phases: Prisma.$ChallengePhasePayload<ExtArgs>[]
      prizeSets: Prisma.$ChallengePrizeSetPayload<ExtArgs>[]
      reviewers: Prisma.$ChallengeReviewerPayload<ExtArgs>[]
      winners: Prisma.$ChallengeWinnerPayload<ExtArgs>[]
      attachments: Prisma.$AttachmentPayload<ExtArgs>[]
      terms: Prisma.$ChallengeTermPayload<ExtArgs>[]
      skills: Prisma.$ChallengeSkillPayload<ExtArgs>[]
      auditLogs: Prisma.$AuditLogPayload<ExtArgs>[]
      memberAccesses: Prisma.$MemberChallengeAccessPayload<ExtArgs>[]
      type: Prisma.$ChallengeTypePayload<ExtArgs>
      track: Prisma.$ChallengeTrackPayload<ExtArgs>
      timelineTemplate: Prisma.$TimelineTemplatePayload<ExtArgs> | null
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      name: string
      description: string | null
      privateDescription: string | null
      challengeSource: string | null
      descriptionFormat: string | null
      projectId: number | null
      typeId: string
      trackId: string
      timelineTemplateId: string | null
      overviewTotalPrizes: number | null
      numOfRegistrants: number
      numOfSubmissions: number
      numOfCheckpointSubmissions: number
      currentPhaseNames: string[]
      wiproAllowed: boolean
      tags: string[]
      groups: string[]
      taskIsTask: boolean
      taskIsAssigned: boolean
      taskMemberId: string | null
      submissionStartDate: Date | null
      submissionEndDate: Date | null
      registrationStartDate: Date | null
      registrationEndDate: Date | null
      startDate: Date | null
      endDate: Date | null
      legacyId: number | null
      status: $Enums.ChallengeStatusEnum
      createdAt: Date
      createdBy: string
      updatedAt: Date
      updatedBy: string
    }, ExtArgs["result"]["challenge"]>
    composites: {}
  }

  type ChallengeGetPayload<S extends boolean | null | undefined | ChallengeDefaultArgs> = $Result.GetResult<Prisma.$ChallengePayload, S>

  type ChallengeCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<ChallengeFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: ChallengeCountAggregateInputType | true
    }

  export interface ChallengeDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Challenge'], meta: { name: 'Challenge' } }
    /**
     * Find zero or one Challenge that matches the filter.
     * @param {ChallengeFindUniqueArgs} args - Arguments to find a Challenge
     * @example
     * // Get one Challenge
     * const challenge = await prisma.challenge.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends ChallengeFindUniqueArgs>(args: SelectSubset<T, ChallengeFindUniqueArgs<ExtArgs>>): Prisma__ChallengeClient<$Result.GetResult<Prisma.$ChallengePayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Challenge that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {ChallengeFindUniqueOrThrowArgs} args - Arguments to find a Challenge
     * @example
     * // Get one Challenge
     * const challenge = await prisma.challenge.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends ChallengeFindUniqueOrThrowArgs>(args: SelectSubset<T, ChallengeFindUniqueOrThrowArgs<ExtArgs>>): Prisma__ChallengeClient<$Result.GetResult<Prisma.$ChallengePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Challenge that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ChallengeFindFirstArgs} args - Arguments to find a Challenge
     * @example
     * // Get one Challenge
     * const challenge = await prisma.challenge.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends ChallengeFindFirstArgs>(args?: SelectSubset<T, ChallengeFindFirstArgs<ExtArgs>>): Prisma__ChallengeClient<$Result.GetResult<Prisma.$ChallengePayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Challenge that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ChallengeFindFirstOrThrowArgs} args - Arguments to find a Challenge
     * @example
     * // Get one Challenge
     * const challenge = await prisma.challenge.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends ChallengeFindFirstOrThrowArgs>(args?: SelectSubset<T, ChallengeFindFirstOrThrowArgs<ExtArgs>>): Prisma__ChallengeClient<$Result.GetResult<Prisma.$ChallengePayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Challenges that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ChallengeFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Challenges
     * const challenges = await prisma.challenge.findMany()
     * 
     * // Get first 10 Challenges
     * const challenges = await prisma.challenge.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const challengeWithIdOnly = await prisma.challenge.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends ChallengeFindManyArgs>(args?: SelectSubset<T, ChallengeFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ChallengePayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Challenge.
     * @param {ChallengeCreateArgs} args - Arguments to create a Challenge.
     * @example
     * // Create one Challenge
     * const Challenge = await prisma.challenge.create({
     *   data: {
     *     // ... data to create a Challenge
     *   }
     * })
     * 
     */
    create<T extends ChallengeCreateArgs>(args: SelectSubset<T, ChallengeCreateArgs<ExtArgs>>): Prisma__ChallengeClient<$Result.GetResult<Prisma.$ChallengePayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Challenges.
     * @param {ChallengeCreateManyArgs} args - Arguments to create many Challenges.
     * @example
     * // Create many Challenges
     * const challenge = await prisma.challenge.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends ChallengeCreateManyArgs>(args?: SelectSubset<T, ChallengeCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Challenges and returns the data saved in the database.
     * @param {ChallengeCreateManyAndReturnArgs} args - Arguments to create many Challenges.
     * @example
     * // Create many Challenges
     * const challenge = await prisma.challenge.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Challenges and only return the `id`
     * const challengeWithIdOnly = await prisma.challenge.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends ChallengeCreateManyAndReturnArgs>(args?: SelectSubset<T, ChallengeCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ChallengePayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Challenge.
     * @param {ChallengeDeleteArgs} args - Arguments to delete one Challenge.
     * @example
     * // Delete one Challenge
     * const Challenge = await prisma.challenge.delete({
     *   where: {
     *     // ... filter to delete one Challenge
     *   }
     * })
     * 
     */
    delete<T extends ChallengeDeleteArgs>(args: SelectSubset<T, ChallengeDeleteArgs<ExtArgs>>): Prisma__ChallengeClient<$Result.GetResult<Prisma.$ChallengePayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Challenge.
     * @param {ChallengeUpdateArgs} args - Arguments to update one Challenge.
     * @example
     * // Update one Challenge
     * const challenge = await prisma.challenge.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends ChallengeUpdateArgs>(args: SelectSubset<T, ChallengeUpdateArgs<ExtArgs>>): Prisma__ChallengeClient<$Result.GetResult<Prisma.$ChallengePayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Challenges.
     * @param {ChallengeDeleteManyArgs} args - Arguments to filter Challenges to delete.
     * @example
     * // Delete a few Challenges
     * const { count } = await prisma.challenge.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends ChallengeDeleteManyArgs>(args?: SelectSubset<T, ChallengeDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Challenges.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ChallengeUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Challenges
     * const challenge = await prisma.challenge.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends ChallengeUpdateManyArgs>(args: SelectSubset<T, ChallengeUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Challenges and returns the data updated in the database.
     * @param {ChallengeUpdateManyAndReturnArgs} args - Arguments to update many Challenges.
     * @example
     * // Update many Challenges
     * const challenge = await prisma.challenge.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Challenges and only return the `id`
     * const challengeWithIdOnly = await prisma.challenge.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends ChallengeUpdateManyAndReturnArgs>(args: SelectSubset<T, ChallengeUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ChallengePayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Challenge.
     * @param {ChallengeUpsertArgs} args - Arguments to update or create a Challenge.
     * @example
     * // Update or create a Challenge
     * const challenge = await prisma.challenge.upsert({
     *   create: {
     *     // ... data to create a Challenge
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Challenge we want to update
     *   }
     * })
     */
    upsert<T extends ChallengeUpsertArgs>(args: SelectSubset<T, ChallengeUpsertArgs<ExtArgs>>): Prisma__ChallengeClient<$Result.GetResult<Prisma.$ChallengePayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Challenges.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ChallengeCountArgs} args - Arguments to filter Challenges to count.
     * @example
     * // Count the number of Challenges
     * const count = await prisma.challenge.count({
     *   where: {
     *     // ... the filter for the Challenges we want to count
     *   }
     * })
    **/
    count<T extends ChallengeCountArgs>(
      args?: Subset<T, ChallengeCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ChallengeCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Challenge.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ChallengeAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ChallengeAggregateArgs>(args: Subset<T, ChallengeAggregateArgs>): Prisma.PrismaPromise<GetChallengeAggregateType<T>>

    /**
     * Group by Challenge.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ChallengeGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ChallengeGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ChallengeGroupByArgs['orderBy'] }
        : { orderBy?: ChallengeGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ChallengeGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetChallengeGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Challenge model
   */
  readonly fields: ChallengeFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Challenge.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ChallengeClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    billingRecord<T extends Challenge$billingRecordArgs<ExtArgs> = {}>(args?: Subset<T, Challenge$billingRecordArgs<ExtArgs>>): Prisma__ChallengeBillingClient<$Result.GetResult<Prisma.$ChallengeBillingPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    legacyRecord<T extends Challenge$legacyRecordArgs<ExtArgs> = {}>(args?: Subset<T, Challenge$legacyRecordArgs<ExtArgs>>): Prisma__ChallengeLegacyClient<$Result.GetResult<Prisma.$ChallengeLegacyPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    constraintRecord<T extends Challenge$constraintRecordArgs<ExtArgs> = {}>(args?: Subset<T, Challenge$constraintRecordArgs<ExtArgs>>): Prisma__ChallengeConstraintClient<$Result.GetResult<Prisma.$ChallengeConstraintPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    events<T extends Challenge$eventsArgs<ExtArgs> = {}>(args?: Subset<T, Challenge$eventsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ChallengeEventPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    discussions<T extends Challenge$discussionsArgs<ExtArgs> = {}>(args?: Subset<T, Challenge$discussionsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ChallengeDiscussionPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    metadata<T extends Challenge$metadataArgs<ExtArgs> = {}>(args?: Subset<T, Challenge$metadataArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ChallengeMetadataPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    phases<T extends Challenge$phasesArgs<ExtArgs> = {}>(args?: Subset<T, Challenge$phasesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ChallengePhasePayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    prizeSets<T extends Challenge$prizeSetsArgs<ExtArgs> = {}>(args?: Subset<T, Challenge$prizeSetsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ChallengePrizeSetPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    reviewers<T extends Challenge$reviewersArgs<ExtArgs> = {}>(args?: Subset<T, Challenge$reviewersArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ChallengeReviewerPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    winners<T extends Challenge$winnersArgs<ExtArgs> = {}>(args?: Subset<T, Challenge$winnersArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ChallengeWinnerPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    attachments<T extends Challenge$attachmentsArgs<ExtArgs> = {}>(args?: Subset<T, Challenge$attachmentsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AttachmentPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    terms<T extends Challenge$termsArgs<ExtArgs> = {}>(args?: Subset<T, Challenge$termsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ChallengeTermPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    skills<T extends Challenge$skillsArgs<ExtArgs> = {}>(args?: Subset<T, Challenge$skillsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ChallengeSkillPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    auditLogs<T extends Challenge$auditLogsArgs<ExtArgs> = {}>(args?: Subset<T, Challenge$auditLogsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AuditLogPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    memberAccesses<T extends Challenge$memberAccessesArgs<ExtArgs> = {}>(args?: Subset<T, Challenge$memberAccessesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$MemberChallengeAccessPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    type<T extends ChallengeTypeDefaultArgs<ExtArgs> = {}>(args?: Subset<T, ChallengeTypeDefaultArgs<ExtArgs>>): Prisma__ChallengeTypeClient<$Result.GetResult<Prisma.$ChallengeTypePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    track<T extends ChallengeTrackDefaultArgs<ExtArgs> = {}>(args?: Subset<T, ChallengeTrackDefaultArgs<ExtArgs>>): Prisma__ChallengeTrackClient<$Result.GetResult<Prisma.$ChallengeTrackPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    timelineTemplate<T extends Challenge$timelineTemplateArgs<ExtArgs> = {}>(args?: Subset<T, Challenge$timelineTemplateArgs<ExtArgs>>): Prisma__TimelineTemplateClient<$Result.GetResult<Prisma.$TimelineTemplatePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Challenge model
   */
  interface ChallengeFieldRefs {
    readonly id: FieldRef<"Challenge", 'String'>
    readonly name: FieldRef<"Challenge", 'String'>
    readonly description: FieldRef<"Challenge", 'String'>
    readonly privateDescription: FieldRef<"Challenge", 'String'>
    readonly challengeSource: FieldRef<"Challenge", 'String'>
    readonly descriptionFormat: FieldRef<"Challenge", 'String'>
    readonly projectId: FieldRef<"Challenge", 'Int'>
    readonly typeId: FieldRef<"Challenge", 'String'>
    readonly trackId: FieldRef<"Challenge", 'String'>
    readonly timelineTemplateId: FieldRef<"Challenge", 'String'>
    readonly overviewTotalPrizes: FieldRef<"Challenge", 'Float'>
    readonly numOfRegistrants: FieldRef<"Challenge", 'Int'>
    readonly numOfSubmissions: FieldRef<"Challenge", 'Int'>
    readonly numOfCheckpointSubmissions: FieldRef<"Challenge", 'Int'>
    readonly currentPhaseNames: FieldRef<"Challenge", 'String[]'>
    readonly wiproAllowed: FieldRef<"Challenge", 'Boolean'>
    readonly tags: FieldRef<"Challenge", 'String[]'>
    readonly groups: FieldRef<"Challenge", 'String[]'>
    readonly taskIsTask: FieldRef<"Challenge", 'Boolean'>
    readonly taskIsAssigned: FieldRef<"Challenge", 'Boolean'>
    readonly taskMemberId: FieldRef<"Challenge", 'String'>
    readonly submissionStartDate: FieldRef<"Challenge", 'DateTime'>
    readonly submissionEndDate: FieldRef<"Challenge", 'DateTime'>
    readonly registrationStartDate: FieldRef<"Challenge", 'DateTime'>
    readonly registrationEndDate: FieldRef<"Challenge", 'DateTime'>
    readonly startDate: FieldRef<"Challenge", 'DateTime'>
    readonly endDate: FieldRef<"Challenge", 'DateTime'>
    readonly legacyId: FieldRef<"Challenge", 'Int'>
    readonly status: FieldRef<"Challenge", 'ChallengeStatusEnum'>
    readonly createdAt: FieldRef<"Challenge", 'DateTime'>
    readonly createdBy: FieldRef<"Challenge", 'String'>
    readonly updatedAt: FieldRef<"Challenge", 'DateTime'>
    readonly updatedBy: FieldRef<"Challenge", 'String'>
  }
    

  // Custom InputTypes
  /**
   * Challenge findUnique
   */
  export type ChallengeFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Challenge
     */
    select?: ChallengeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Challenge
     */
    omit?: ChallengeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ChallengeInclude<ExtArgs> | null
    /**
     * Filter, which Challenge to fetch.
     */
    where: ChallengeWhereUniqueInput
  }

  /**
   * Challenge findUniqueOrThrow
   */
  export type ChallengeFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Challenge
     */
    select?: ChallengeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Challenge
     */
    omit?: ChallengeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ChallengeInclude<ExtArgs> | null
    /**
     * Filter, which Challenge to fetch.
     */
    where: ChallengeWhereUniqueInput
  }

  /**
   * Challenge findFirst
   */
  export type ChallengeFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Challenge
     */
    select?: ChallengeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Challenge
     */
    omit?: ChallengeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ChallengeInclude<ExtArgs> | null
    /**
     * Filter, which Challenge to fetch.
     */
    where?: ChallengeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Challenges to fetch.
     */
    orderBy?: ChallengeOrderByWithRelationInput | ChallengeOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Challenges.
     */
    cursor?: ChallengeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Challenges from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Challenges.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Challenges.
     */
    distinct?: ChallengeScalarFieldEnum | ChallengeScalarFieldEnum[]
  }

  /**
   * Challenge findFirstOrThrow
   */
  export type ChallengeFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Challenge
     */
    select?: ChallengeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Challenge
     */
    omit?: ChallengeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ChallengeInclude<ExtArgs> | null
    /**
     * Filter, which Challenge to fetch.
     */
    where?: ChallengeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Challenges to fetch.
     */
    orderBy?: ChallengeOrderByWithRelationInput | ChallengeOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Challenges.
     */
    cursor?: ChallengeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Challenges from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Challenges.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Challenges.
     */
    distinct?: ChallengeScalarFieldEnum | ChallengeScalarFieldEnum[]
  }

  /**
   * Challenge findMany
   */
  export type ChallengeFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Challenge
     */
    select?: ChallengeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Challenge
     */
    omit?: ChallengeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ChallengeInclude<ExtArgs> | null
    /**
     * Filter, which Challenges to fetch.
     */
    where?: ChallengeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Challenges to fetch.
     */
    orderBy?: ChallengeOrderByWithRelationInput | ChallengeOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Challenges.
     */
    cursor?: ChallengeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Challenges from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Challenges.
     */
    skip?: number
    distinct?: ChallengeScalarFieldEnum | ChallengeScalarFieldEnum[]
  }

  /**
   * Challenge create
   */
  export type ChallengeCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Challenge
     */
    select?: ChallengeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Challenge
     */
    omit?: ChallengeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ChallengeInclude<ExtArgs> | null
    /**
     * The data needed to create a Challenge.
     */
    data: XOR<ChallengeCreateInput, ChallengeUncheckedCreateInput>
  }

  /**
   * Challenge createMany
   */
  export type ChallengeCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Challenges.
     */
    data: ChallengeCreateManyInput | ChallengeCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Challenge createManyAndReturn
   */
  export type ChallengeCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Challenge
     */
    select?: ChallengeSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Challenge
     */
    omit?: ChallengeOmit<ExtArgs> | null
    /**
     * The data used to create many Challenges.
     */
    data: ChallengeCreateManyInput | ChallengeCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ChallengeIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Challenge update
   */
  export type ChallengeUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Challenge
     */
    select?: ChallengeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Challenge
     */
    omit?: ChallengeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ChallengeInclude<ExtArgs> | null
    /**
     * The data needed to update a Challenge.
     */
    data: XOR<ChallengeUpdateInput, ChallengeUncheckedUpdateInput>
    /**
     * Choose, which Challenge to update.
     */
    where: ChallengeWhereUniqueInput
  }

  /**
   * Challenge updateMany
   */
  export type ChallengeUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Challenges.
     */
    data: XOR<ChallengeUpdateManyMutationInput, ChallengeUncheckedUpdateManyInput>
    /**
     * Filter which Challenges to update
     */
    where?: ChallengeWhereInput
    /**
     * Limit how many Challenges to update.
     */
    limit?: number
  }

  /**
   * Challenge updateManyAndReturn
   */
  export type ChallengeUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Challenge
     */
    select?: ChallengeSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Challenge
     */
    omit?: ChallengeOmit<ExtArgs> | null
    /**
     * The data used to update Challenges.
     */
    data: XOR<ChallengeUpdateManyMutationInput, ChallengeUncheckedUpdateManyInput>
    /**
     * Filter which Challenges to update
     */
    where?: ChallengeWhereInput
    /**
     * Limit how many Challenges to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ChallengeIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * Challenge upsert
   */
  export type ChallengeUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Challenge
     */
    select?: ChallengeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Challenge
     */
    omit?: ChallengeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ChallengeInclude<ExtArgs> | null
    /**
     * The filter to search for the Challenge to update in case it exists.
     */
    where: ChallengeWhereUniqueInput
    /**
     * In case the Challenge found by the `where` argument doesn't exist, create a new Challenge with this data.
     */
    create: XOR<ChallengeCreateInput, ChallengeUncheckedCreateInput>
    /**
     * In case the Challenge was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ChallengeUpdateInput, ChallengeUncheckedUpdateInput>
  }

  /**
   * Challenge delete
   */
  export type ChallengeDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Challenge
     */
    select?: ChallengeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Challenge
     */
    omit?: ChallengeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ChallengeInclude<ExtArgs> | null
    /**
     * Filter which Challenge to delete.
     */
    where: ChallengeWhereUniqueInput
  }

  /**
   * Challenge deleteMany
   */
  export type ChallengeDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Challenges to delete
     */
    where?: ChallengeWhereInput
    /**
     * Limit how many Challenges to delete.
     */
    limit?: number
  }

  /**
   * Challenge.billingRecord
   */
  export type Challenge$billingRecordArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ChallengeBilling
     */
    select?: ChallengeBillingSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ChallengeBilling
     */
    omit?: ChallengeBillingOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ChallengeBillingInclude<ExtArgs> | null
    where?: ChallengeBillingWhereInput
  }

  /**
   * Challenge.legacyRecord
   */
  export type Challenge$legacyRecordArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ChallengeLegacy
     */
    select?: ChallengeLegacySelect<ExtArgs> | null
    /**
     * Omit specific fields from the ChallengeLegacy
     */
    omit?: ChallengeLegacyOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ChallengeLegacyInclude<ExtArgs> | null
    where?: ChallengeLegacyWhereInput
  }

  /**
   * Challenge.constraintRecord
   */
  export type Challenge$constraintRecordArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ChallengeConstraint
     */
    select?: ChallengeConstraintSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ChallengeConstraint
     */
    omit?: ChallengeConstraintOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ChallengeConstraintInclude<ExtArgs> | null
    where?: ChallengeConstraintWhereInput
  }

  /**
   * Challenge.events
   */
  export type Challenge$eventsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ChallengeEvent
     */
    select?: ChallengeEventSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ChallengeEvent
     */
    omit?: ChallengeEventOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ChallengeEventInclude<ExtArgs> | null
    where?: ChallengeEventWhereInput
    orderBy?: ChallengeEventOrderByWithRelationInput | ChallengeEventOrderByWithRelationInput[]
    cursor?: ChallengeEventWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ChallengeEventScalarFieldEnum | ChallengeEventScalarFieldEnum[]
  }

  /**
   * Challenge.discussions
   */
  export type Challenge$discussionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ChallengeDiscussion
     */
    select?: ChallengeDiscussionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ChallengeDiscussion
     */
    omit?: ChallengeDiscussionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ChallengeDiscussionInclude<ExtArgs> | null
    where?: ChallengeDiscussionWhereInput
    orderBy?: ChallengeDiscussionOrderByWithRelationInput | ChallengeDiscussionOrderByWithRelationInput[]
    cursor?: ChallengeDiscussionWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ChallengeDiscussionScalarFieldEnum | ChallengeDiscussionScalarFieldEnum[]
  }

  /**
   * Challenge.metadata
   */
  export type Challenge$metadataArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ChallengeMetadata
     */
    select?: ChallengeMetadataSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ChallengeMetadata
     */
    omit?: ChallengeMetadataOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ChallengeMetadataInclude<ExtArgs> | null
    where?: ChallengeMetadataWhereInput
    orderBy?: ChallengeMetadataOrderByWithRelationInput | ChallengeMetadataOrderByWithRelationInput[]
    cursor?: ChallengeMetadataWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ChallengeMetadataScalarFieldEnum | ChallengeMetadataScalarFieldEnum[]
  }

  /**
   * Challenge.phases
   */
  export type Challenge$phasesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ChallengePhase
     */
    select?: ChallengePhaseSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ChallengePhase
     */
    omit?: ChallengePhaseOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ChallengePhaseInclude<ExtArgs> | null
    where?: ChallengePhaseWhereInput
    orderBy?: ChallengePhaseOrderByWithRelationInput | ChallengePhaseOrderByWithRelationInput[]
    cursor?: ChallengePhaseWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ChallengePhaseScalarFieldEnum | ChallengePhaseScalarFieldEnum[]
  }

  /**
   * Challenge.prizeSets
   */
  export type Challenge$prizeSetsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ChallengePrizeSet
     */
    select?: ChallengePrizeSetSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ChallengePrizeSet
     */
    omit?: ChallengePrizeSetOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ChallengePrizeSetInclude<ExtArgs> | null
    where?: ChallengePrizeSetWhereInput
    orderBy?: ChallengePrizeSetOrderByWithRelationInput | ChallengePrizeSetOrderByWithRelationInput[]
    cursor?: ChallengePrizeSetWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ChallengePrizeSetScalarFieldEnum | ChallengePrizeSetScalarFieldEnum[]
  }

  /**
   * Challenge.reviewers
   */
  export type Challenge$reviewersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ChallengeReviewer
     */
    select?: ChallengeReviewerSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ChallengeReviewer
     */
    omit?: ChallengeReviewerOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ChallengeReviewerInclude<ExtArgs> | null
    where?: ChallengeReviewerWhereInput
    orderBy?: ChallengeReviewerOrderByWithRelationInput | ChallengeReviewerOrderByWithRelationInput[]
    cursor?: ChallengeReviewerWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ChallengeReviewerScalarFieldEnum | ChallengeReviewerScalarFieldEnum[]
  }

  /**
   * Challenge.winners
   */
  export type Challenge$winnersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ChallengeWinner
     */
    select?: ChallengeWinnerSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ChallengeWinner
     */
    omit?: ChallengeWinnerOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ChallengeWinnerInclude<ExtArgs> | null
    where?: ChallengeWinnerWhereInput
    orderBy?: ChallengeWinnerOrderByWithRelationInput | ChallengeWinnerOrderByWithRelationInput[]
    cursor?: ChallengeWinnerWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ChallengeWinnerScalarFieldEnum | ChallengeWinnerScalarFieldEnum[]
  }

  /**
   * Challenge.attachments
   */
  export type Challenge$attachmentsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Attachment
     */
    select?: AttachmentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Attachment
     */
    omit?: AttachmentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AttachmentInclude<ExtArgs> | null
    where?: AttachmentWhereInput
    orderBy?: AttachmentOrderByWithRelationInput | AttachmentOrderByWithRelationInput[]
    cursor?: AttachmentWhereUniqueInput
    take?: number
    skip?: number
    distinct?: AttachmentScalarFieldEnum | AttachmentScalarFieldEnum[]
  }

  /**
   * Challenge.terms
   */
  export type Challenge$termsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ChallengeTerm
     */
    select?: ChallengeTermSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ChallengeTerm
     */
    omit?: ChallengeTermOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ChallengeTermInclude<ExtArgs> | null
    where?: ChallengeTermWhereInput
    orderBy?: ChallengeTermOrderByWithRelationInput | ChallengeTermOrderByWithRelationInput[]
    cursor?: ChallengeTermWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ChallengeTermScalarFieldEnum | ChallengeTermScalarFieldEnum[]
  }

  /**
   * Challenge.skills
   */
  export type Challenge$skillsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ChallengeSkill
     */
    select?: ChallengeSkillSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ChallengeSkill
     */
    omit?: ChallengeSkillOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ChallengeSkillInclude<ExtArgs> | null
    where?: ChallengeSkillWhereInput
    orderBy?: ChallengeSkillOrderByWithRelationInput | ChallengeSkillOrderByWithRelationInput[]
    cursor?: ChallengeSkillWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ChallengeSkillScalarFieldEnum | ChallengeSkillScalarFieldEnum[]
  }

  /**
   * Challenge.auditLogs
   */
  export type Challenge$auditLogsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AuditLog
     */
    select?: AuditLogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AuditLog
     */
    omit?: AuditLogOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AuditLogInclude<ExtArgs> | null
    where?: AuditLogWhereInput
    orderBy?: AuditLogOrderByWithRelationInput | AuditLogOrderByWithRelationInput[]
    cursor?: AuditLogWhereUniqueInput
    take?: number
    skip?: number
    distinct?: AuditLogScalarFieldEnum | AuditLogScalarFieldEnum[]
  }

  /**
   * Challenge.memberAccesses
   */
  export type Challenge$memberAccessesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MemberChallengeAccess
     */
    select?: MemberChallengeAccessSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MemberChallengeAccess
     */
    omit?: MemberChallengeAccessOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MemberChallengeAccessInclude<ExtArgs> | null
    where?: MemberChallengeAccessWhereInput
    orderBy?: MemberChallengeAccessOrderByWithRelationInput | MemberChallengeAccessOrderByWithRelationInput[]
    take?: number
    skip?: number
    distinct?: MemberChallengeAccessScalarFieldEnum | MemberChallengeAccessScalarFieldEnum[]
  }

  /**
   * Challenge.timelineTemplate
   */
  export type Challenge$timelineTemplateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TimelineTemplate
     */
    select?: TimelineTemplateSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TimelineTemplate
     */
    omit?: TimelineTemplateOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TimelineTemplateInclude<ExtArgs> | null
    where?: TimelineTemplateWhereInput
  }

  /**
   * Challenge without action
   */
  export type ChallengeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Challenge
     */
    select?: ChallengeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Challenge
     */
    omit?: ChallengeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ChallengeInclude<ExtArgs> | null
  }


  /**
   * Model ChallengeType
   */

  export type AggregateChallengeType = {
    _count: ChallengeTypeCountAggregateOutputType | null
    _min: ChallengeTypeMinAggregateOutputType | null
    _max: ChallengeTypeMaxAggregateOutputType | null
  }

  export type ChallengeTypeMinAggregateOutputType = {
    id: string | null
    name: string | null
    description: string | null
    isActive: boolean | null
    isTask: boolean | null
    abbreviation: string | null
    createdAt: Date | null
    createdBy: string | null
    updatedAt: Date | null
    updatedBy: string | null
  }

  export type ChallengeTypeMaxAggregateOutputType = {
    id: string | null
    name: string | null
    description: string | null
    isActive: boolean | null
    isTask: boolean | null
    abbreviation: string | null
    createdAt: Date | null
    createdBy: string | null
    updatedAt: Date | null
    updatedBy: string | null
  }

  export type ChallengeTypeCountAggregateOutputType = {
    id: number
    name: number
    description: number
    isActive: number
    isTask: number
    abbreviation: number
    createdAt: number
    createdBy: number
    updatedAt: number
    updatedBy: number
    _all: number
  }


  export type ChallengeTypeMinAggregateInputType = {
    id?: true
    name?: true
    description?: true
    isActive?: true
    isTask?: true
    abbreviation?: true
    createdAt?: true
    createdBy?: true
    updatedAt?: true
    updatedBy?: true
  }

  export type ChallengeTypeMaxAggregateInputType = {
    id?: true
    name?: true
    description?: true
    isActive?: true
    isTask?: true
    abbreviation?: true
    createdAt?: true
    createdBy?: true
    updatedAt?: true
    updatedBy?: true
  }

  export type ChallengeTypeCountAggregateInputType = {
    id?: true
    name?: true
    description?: true
    isActive?: true
    isTask?: true
    abbreviation?: true
    createdAt?: true
    createdBy?: true
    updatedAt?: true
    updatedBy?: true
    _all?: true
  }

  export type ChallengeTypeAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ChallengeType to aggregate.
     */
    where?: ChallengeTypeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ChallengeTypes to fetch.
     */
    orderBy?: ChallengeTypeOrderByWithRelationInput | ChallengeTypeOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ChallengeTypeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ChallengeTypes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ChallengeTypes.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned ChallengeTypes
    **/
    _count?: true | ChallengeTypeCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ChallengeTypeMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ChallengeTypeMaxAggregateInputType
  }

  export type GetChallengeTypeAggregateType<T extends ChallengeTypeAggregateArgs> = {
        [P in keyof T & keyof AggregateChallengeType]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateChallengeType[P]>
      : GetScalarType<T[P], AggregateChallengeType[P]>
  }




  export type ChallengeTypeGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ChallengeTypeWhereInput
    orderBy?: ChallengeTypeOrderByWithAggregationInput | ChallengeTypeOrderByWithAggregationInput[]
    by: ChallengeTypeScalarFieldEnum[] | ChallengeTypeScalarFieldEnum
    having?: ChallengeTypeScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ChallengeTypeCountAggregateInputType | true
    _min?: ChallengeTypeMinAggregateInputType
    _max?: ChallengeTypeMaxAggregateInputType
  }

  export type ChallengeTypeGroupByOutputType = {
    id: string
    name: string
    description: string | null
    isActive: boolean
    isTask: boolean
    abbreviation: string
    createdAt: Date
    createdBy: string
    updatedAt: Date
    updatedBy: string
    _count: ChallengeTypeCountAggregateOutputType | null
    _min: ChallengeTypeMinAggregateOutputType | null
    _max: ChallengeTypeMaxAggregateOutputType | null
  }

  type GetChallengeTypeGroupByPayload<T extends ChallengeTypeGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ChallengeTypeGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ChallengeTypeGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ChallengeTypeGroupByOutputType[P]>
            : GetScalarType<T[P], ChallengeTypeGroupByOutputType[P]>
        }
      >
    >


  export type ChallengeTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    description?: boolean
    isActive?: boolean
    isTask?: boolean
    abbreviation?: boolean
    createdAt?: boolean
    createdBy?: boolean
    updatedAt?: boolean
    updatedBy?: boolean
    challenges?: boolean | ChallengeType$challengesArgs<ExtArgs>
    timelineTemplates?: boolean | ChallengeType$timelineTemplatesArgs<ExtArgs>
    defaultReviewers?: boolean | ChallengeType$defaultReviewersArgs<ExtArgs>
    _count?: boolean | ChallengeTypeCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["challengeType"]>

  export type ChallengeTypeSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    description?: boolean
    isActive?: boolean
    isTask?: boolean
    abbreviation?: boolean
    createdAt?: boolean
    createdBy?: boolean
    updatedAt?: boolean
    updatedBy?: boolean
  }, ExtArgs["result"]["challengeType"]>

  export type ChallengeTypeSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    description?: boolean
    isActive?: boolean
    isTask?: boolean
    abbreviation?: boolean
    createdAt?: boolean
    createdBy?: boolean
    updatedAt?: boolean
    updatedBy?: boolean
  }, ExtArgs["result"]["challengeType"]>

  export type ChallengeTypeSelectScalar = {
    id?: boolean
    name?: boolean
    description?: boolean
    isActive?: boolean
    isTask?: boolean
    abbreviation?: boolean
    createdAt?: boolean
    createdBy?: boolean
    updatedAt?: boolean
    updatedBy?: boolean
  }

  export type ChallengeTypeOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "name" | "description" | "isActive" | "isTask" | "abbreviation" | "createdAt" | "createdBy" | "updatedAt" | "updatedBy", ExtArgs["result"]["challengeType"]>
  export type ChallengeTypeInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    challenges?: boolean | ChallengeType$challengesArgs<ExtArgs>
    timelineTemplates?: boolean | ChallengeType$timelineTemplatesArgs<ExtArgs>
    defaultReviewers?: boolean | ChallengeType$defaultReviewersArgs<ExtArgs>
    _count?: boolean | ChallengeTypeCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type ChallengeTypeIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}
  export type ChallengeTypeIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}

  export type $ChallengeTypePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "ChallengeType"
    objects: {
      challenges: Prisma.$ChallengePayload<ExtArgs>[]
      timelineTemplates: Prisma.$ChallengeTimelineTemplatePayload<ExtArgs>[]
      defaultReviewers: Prisma.$DefaultChallengeReviewerPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      name: string
      description: string | null
      isActive: boolean
      isTask: boolean
      abbreviation: string
      createdAt: Date
      createdBy: string
      updatedAt: Date
      updatedBy: string
    }, ExtArgs["result"]["challengeType"]>
    composites: {}
  }

  type ChallengeTypeGetPayload<S extends boolean | null | undefined | ChallengeTypeDefaultArgs> = $Result.GetResult<Prisma.$ChallengeTypePayload, S>

  type ChallengeTypeCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<ChallengeTypeFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: ChallengeTypeCountAggregateInputType | true
    }

  export interface ChallengeTypeDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['ChallengeType'], meta: { name: 'ChallengeType' } }
    /**
     * Find zero or one ChallengeType that matches the filter.
     * @param {ChallengeTypeFindUniqueArgs} args - Arguments to find a ChallengeType
     * @example
     * // Get one ChallengeType
     * const challengeType = await prisma.challengeType.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends ChallengeTypeFindUniqueArgs>(args: SelectSubset<T, ChallengeTypeFindUniqueArgs<ExtArgs>>): Prisma__ChallengeTypeClient<$Result.GetResult<Prisma.$ChallengeTypePayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one ChallengeType that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {ChallengeTypeFindUniqueOrThrowArgs} args - Arguments to find a ChallengeType
     * @example
     * // Get one ChallengeType
     * const challengeType = await prisma.challengeType.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends ChallengeTypeFindUniqueOrThrowArgs>(args: SelectSubset<T, ChallengeTypeFindUniqueOrThrowArgs<ExtArgs>>): Prisma__ChallengeTypeClient<$Result.GetResult<Prisma.$ChallengeTypePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first ChallengeType that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ChallengeTypeFindFirstArgs} args - Arguments to find a ChallengeType
     * @example
     * // Get one ChallengeType
     * const challengeType = await prisma.challengeType.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends ChallengeTypeFindFirstArgs>(args?: SelectSubset<T, ChallengeTypeFindFirstArgs<ExtArgs>>): Prisma__ChallengeTypeClient<$Result.GetResult<Prisma.$ChallengeTypePayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first ChallengeType that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ChallengeTypeFindFirstOrThrowArgs} args - Arguments to find a ChallengeType
     * @example
     * // Get one ChallengeType
     * const challengeType = await prisma.challengeType.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends ChallengeTypeFindFirstOrThrowArgs>(args?: SelectSubset<T, ChallengeTypeFindFirstOrThrowArgs<ExtArgs>>): Prisma__ChallengeTypeClient<$Result.GetResult<Prisma.$ChallengeTypePayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more ChallengeTypes that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ChallengeTypeFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all ChallengeTypes
     * const challengeTypes = await prisma.challengeType.findMany()
     * 
     * // Get first 10 ChallengeTypes
     * const challengeTypes = await prisma.challengeType.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const challengeTypeWithIdOnly = await prisma.challengeType.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends ChallengeTypeFindManyArgs>(args?: SelectSubset<T, ChallengeTypeFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ChallengeTypePayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a ChallengeType.
     * @param {ChallengeTypeCreateArgs} args - Arguments to create a ChallengeType.
     * @example
     * // Create one ChallengeType
     * const ChallengeType = await prisma.challengeType.create({
     *   data: {
     *     // ... data to create a ChallengeType
     *   }
     * })
     * 
     */
    create<T extends ChallengeTypeCreateArgs>(args: SelectSubset<T, ChallengeTypeCreateArgs<ExtArgs>>): Prisma__ChallengeTypeClient<$Result.GetResult<Prisma.$ChallengeTypePayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many ChallengeTypes.
     * @param {ChallengeTypeCreateManyArgs} args - Arguments to create many ChallengeTypes.
     * @example
     * // Create many ChallengeTypes
     * const challengeType = await prisma.challengeType.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends ChallengeTypeCreateManyArgs>(args?: SelectSubset<T, ChallengeTypeCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many ChallengeTypes and returns the data saved in the database.
     * @param {ChallengeTypeCreateManyAndReturnArgs} args - Arguments to create many ChallengeTypes.
     * @example
     * // Create many ChallengeTypes
     * const challengeType = await prisma.challengeType.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many ChallengeTypes and only return the `id`
     * const challengeTypeWithIdOnly = await prisma.challengeType.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends ChallengeTypeCreateManyAndReturnArgs>(args?: SelectSubset<T, ChallengeTypeCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ChallengeTypePayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a ChallengeType.
     * @param {ChallengeTypeDeleteArgs} args - Arguments to delete one ChallengeType.
     * @example
     * // Delete one ChallengeType
     * const ChallengeType = await prisma.challengeType.delete({
     *   where: {
     *     // ... filter to delete one ChallengeType
     *   }
     * })
     * 
     */
    delete<T extends ChallengeTypeDeleteArgs>(args: SelectSubset<T, ChallengeTypeDeleteArgs<ExtArgs>>): Prisma__ChallengeTypeClient<$Result.GetResult<Prisma.$ChallengeTypePayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one ChallengeType.
     * @param {ChallengeTypeUpdateArgs} args - Arguments to update one ChallengeType.
     * @example
     * // Update one ChallengeType
     * const challengeType = await prisma.challengeType.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends ChallengeTypeUpdateArgs>(args: SelectSubset<T, ChallengeTypeUpdateArgs<ExtArgs>>): Prisma__ChallengeTypeClient<$Result.GetResult<Prisma.$ChallengeTypePayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more ChallengeTypes.
     * @param {ChallengeTypeDeleteManyArgs} args - Arguments to filter ChallengeTypes to delete.
     * @example
     * // Delete a few ChallengeTypes
     * const { count } = await prisma.challengeType.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends ChallengeTypeDeleteManyArgs>(args?: SelectSubset<T, ChallengeTypeDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more ChallengeTypes.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ChallengeTypeUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many ChallengeTypes
     * const challengeType = await prisma.challengeType.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends ChallengeTypeUpdateManyArgs>(args: SelectSubset<T, ChallengeTypeUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more ChallengeTypes and returns the data updated in the database.
     * @param {ChallengeTypeUpdateManyAndReturnArgs} args - Arguments to update many ChallengeTypes.
     * @example
     * // Update many ChallengeTypes
     * const challengeType = await prisma.challengeType.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more ChallengeTypes and only return the `id`
     * const challengeTypeWithIdOnly = await prisma.challengeType.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends ChallengeTypeUpdateManyAndReturnArgs>(args: SelectSubset<T, ChallengeTypeUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ChallengeTypePayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one ChallengeType.
     * @param {ChallengeTypeUpsertArgs} args - Arguments to update or create a ChallengeType.
     * @example
     * // Update or create a ChallengeType
     * const challengeType = await prisma.challengeType.upsert({
     *   create: {
     *     // ... data to create a ChallengeType
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the ChallengeType we want to update
     *   }
     * })
     */
    upsert<T extends ChallengeTypeUpsertArgs>(args: SelectSubset<T, ChallengeTypeUpsertArgs<ExtArgs>>): Prisma__ChallengeTypeClient<$Result.GetResult<Prisma.$ChallengeTypePayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of ChallengeTypes.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ChallengeTypeCountArgs} args - Arguments to filter ChallengeTypes to count.
     * @example
     * // Count the number of ChallengeTypes
     * const count = await prisma.challengeType.count({
     *   where: {
     *     // ... the filter for the ChallengeTypes we want to count
     *   }
     * })
    **/
    count<T extends ChallengeTypeCountArgs>(
      args?: Subset<T, ChallengeTypeCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ChallengeTypeCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a ChallengeType.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ChallengeTypeAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ChallengeTypeAggregateArgs>(args: Subset<T, ChallengeTypeAggregateArgs>): Prisma.PrismaPromise<GetChallengeTypeAggregateType<T>>

    /**
     * Group by ChallengeType.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ChallengeTypeGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ChallengeTypeGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ChallengeTypeGroupByArgs['orderBy'] }
        : { orderBy?: ChallengeTypeGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ChallengeTypeGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetChallengeTypeGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the ChallengeType model
   */
  readonly fields: ChallengeTypeFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for ChallengeType.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ChallengeTypeClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    challenges<T extends ChallengeType$challengesArgs<ExtArgs> = {}>(args?: Subset<T, ChallengeType$challengesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ChallengePayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    timelineTemplates<T extends ChallengeType$timelineTemplatesArgs<ExtArgs> = {}>(args?: Subset<T, ChallengeType$timelineTemplatesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ChallengeTimelineTemplatePayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    defaultReviewers<T extends ChallengeType$defaultReviewersArgs<ExtArgs> = {}>(args?: Subset<T, ChallengeType$defaultReviewersArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$DefaultChallengeReviewerPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the ChallengeType model
   */
  interface ChallengeTypeFieldRefs {
    readonly id: FieldRef<"ChallengeType", 'String'>
    readonly name: FieldRef<"ChallengeType", 'String'>
    readonly description: FieldRef<"ChallengeType", 'String'>
    readonly isActive: FieldRef<"ChallengeType", 'Boolean'>
    readonly isTask: FieldRef<"ChallengeType", 'Boolean'>
    readonly abbreviation: FieldRef<"ChallengeType", 'String'>
    readonly createdAt: FieldRef<"ChallengeType", 'DateTime'>
    readonly createdBy: FieldRef<"ChallengeType", 'String'>
    readonly updatedAt: FieldRef<"ChallengeType", 'DateTime'>
    readonly updatedBy: FieldRef<"ChallengeType", 'String'>
  }
    

  // Custom InputTypes
  /**
   * ChallengeType findUnique
   */
  export type ChallengeTypeFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ChallengeType
     */
    select?: ChallengeTypeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ChallengeType
     */
    omit?: ChallengeTypeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ChallengeTypeInclude<ExtArgs> | null
    /**
     * Filter, which ChallengeType to fetch.
     */
    where: ChallengeTypeWhereUniqueInput
  }

  /**
   * ChallengeType findUniqueOrThrow
   */
  export type ChallengeTypeFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ChallengeType
     */
    select?: ChallengeTypeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ChallengeType
     */
    omit?: ChallengeTypeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ChallengeTypeInclude<ExtArgs> | null
    /**
     * Filter, which ChallengeType to fetch.
     */
    where: ChallengeTypeWhereUniqueInput
  }

  /**
   * ChallengeType findFirst
   */
  export type ChallengeTypeFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ChallengeType
     */
    select?: ChallengeTypeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ChallengeType
     */
    omit?: ChallengeTypeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ChallengeTypeInclude<ExtArgs> | null
    /**
     * Filter, which ChallengeType to fetch.
     */
    where?: ChallengeTypeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ChallengeTypes to fetch.
     */
    orderBy?: ChallengeTypeOrderByWithRelationInput | ChallengeTypeOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ChallengeTypes.
     */
    cursor?: ChallengeTypeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ChallengeTypes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ChallengeTypes.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ChallengeTypes.
     */
    distinct?: ChallengeTypeScalarFieldEnum | ChallengeTypeScalarFieldEnum[]
  }

  /**
   * ChallengeType findFirstOrThrow
   */
  export type ChallengeTypeFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ChallengeType
     */
    select?: ChallengeTypeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ChallengeType
     */
    omit?: ChallengeTypeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ChallengeTypeInclude<ExtArgs> | null
    /**
     * Filter, which ChallengeType to fetch.
     */
    where?: ChallengeTypeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ChallengeTypes to fetch.
     */
    orderBy?: ChallengeTypeOrderByWithRelationInput | ChallengeTypeOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ChallengeTypes.
     */
    cursor?: ChallengeTypeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ChallengeTypes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ChallengeTypes.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ChallengeTypes.
     */
    distinct?: ChallengeTypeScalarFieldEnum | ChallengeTypeScalarFieldEnum[]
  }

  /**
   * ChallengeType findMany
   */
  export type ChallengeTypeFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ChallengeType
     */
    select?: ChallengeTypeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ChallengeType
     */
    omit?: ChallengeTypeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ChallengeTypeInclude<ExtArgs> | null
    /**
     * Filter, which ChallengeTypes to fetch.
     */
    where?: ChallengeTypeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ChallengeTypes to fetch.
     */
    orderBy?: ChallengeTypeOrderByWithRelationInput | ChallengeTypeOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing ChallengeTypes.
     */
    cursor?: ChallengeTypeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ChallengeTypes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ChallengeTypes.
     */
    skip?: number
    distinct?: ChallengeTypeScalarFieldEnum | ChallengeTypeScalarFieldEnum[]
  }

  /**
   * ChallengeType create
   */
  export type ChallengeTypeCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ChallengeType
     */
    select?: ChallengeTypeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ChallengeType
     */
    omit?: ChallengeTypeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ChallengeTypeInclude<ExtArgs> | null
    /**
     * The data needed to create a ChallengeType.
     */
    data: XOR<ChallengeTypeCreateInput, ChallengeTypeUncheckedCreateInput>
  }

  /**
   * ChallengeType createMany
   */
  export type ChallengeTypeCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many ChallengeTypes.
     */
    data: ChallengeTypeCreateManyInput | ChallengeTypeCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * ChallengeType createManyAndReturn
   */
  export type ChallengeTypeCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ChallengeType
     */
    select?: ChallengeTypeSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the ChallengeType
     */
    omit?: ChallengeTypeOmit<ExtArgs> | null
    /**
     * The data used to create many ChallengeTypes.
     */
    data: ChallengeTypeCreateManyInput | ChallengeTypeCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * ChallengeType update
   */
  export type ChallengeTypeUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ChallengeType
     */
    select?: ChallengeTypeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ChallengeType
     */
    omit?: ChallengeTypeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ChallengeTypeInclude<ExtArgs> | null
    /**
     * The data needed to update a ChallengeType.
     */
    data: XOR<ChallengeTypeUpdateInput, ChallengeTypeUncheckedUpdateInput>
    /**
     * Choose, which ChallengeType to update.
     */
    where: ChallengeTypeWhereUniqueInput
  }

  /**
   * ChallengeType updateMany
   */
  export type ChallengeTypeUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update ChallengeTypes.
     */
    data: XOR<ChallengeTypeUpdateManyMutationInput, ChallengeTypeUncheckedUpdateManyInput>
    /**
     * Filter which ChallengeTypes to update
     */
    where?: ChallengeTypeWhereInput
    /**
     * Limit how many ChallengeTypes to update.
     */
    limit?: number
  }

  /**
   * ChallengeType updateManyAndReturn
   */
  export type ChallengeTypeUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ChallengeType
     */
    select?: ChallengeTypeSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the ChallengeType
     */
    omit?: ChallengeTypeOmit<ExtArgs> | null
    /**
     * The data used to update ChallengeTypes.
     */
    data: XOR<ChallengeTypeUpdateManyMutationInput, ChallengeTypeUncheckedUpdateManyInput>
    /**
     * Filter which ChallengeTypes to update
     */
    where?: ChallengeTypeWhereInput
    /**
     * Limit how many ChallengeTypes to update.
     */
    limit?: number
  }

  /**
   * ChallengeType upsert
   */
  export type ChallengeTypeUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ChallengeType
     */
    select?: ChallengeTypeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ChallengeType
     */
    omit?: ChallengeTypeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ChallengeTypeInclude<ExtArgs> | null
    /**
     * The filter to search for the ChallengeType to update in case it exists.
     */
    where: ChallengeTypeWhereUniqueInput
    /**
     * In case the ChallengeType found by the `where` argument doesn't exist, create a new ChallengeType with this data.
     */
    create: XOR<ChallengeTypeCreateInput, ChallengeTypeUncheckedCreateInput>
    /**
     * In case the ChallengeType was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ChallengeTypeUpdateInput, ChallengeTypeUncheckedUpdateInput>
  }

  /**
   * ChallengeType delete
   */
  export type ChallengeTypeDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ChallengeType
     */
    select?: ChallengeTypeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ChallengeType
     */
    omit?: ChallengeTypeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ChallengeTypeInclude<ExtArgs> | null
    /**
     * Filter which ChallengeType to delete.
     */
    where: ChallengeTypeWhereUniqueInput
  }

  /**
   * ChallengeType deleteMany
   */
  export type ChallengeTypeDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ChallengeTypes to delete
     */
    where?: ChallengeTypeWhereInput
    /**
     * Limit how many ChallengeTypes to delete.
     */
    limit?: number
  }

  /**
   * ChallengeType.challenges
   */
  export type ChallengeType$challengesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Challenge
     */
    select?: ChallengeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Challenge
     */
    omit?: ChallengeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ChallengeInclude<ExtArgs> | null
    where?: ChallengeWhereInput
    orderBy?: ChallengeOrderByWithRelationInput | ChallengeOrderByWithRelationInput[]
    cursor?: ChallengeWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ChallengeScalarFieldEnum | ChallengeScalarFieldEnum[]
  }

  /**
   * ChallengeType.timelineTemplates
   */
  export type ChallengeType$timelineTemplatesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ChallengeTimelineTemplate
     */
    select?: ChallengeTimelineTemplateSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ChallengeTimelineTemplate
     */
    omit?: ChallengeTimelineTemplateOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ChallengeTimelineTemplateInclude<ExtArgs> | null
    where?: ChallengeTimelineTemplateWhereInput
    orderBy?: ChallengeTimelineTemplateOrderByWithRelationInput | ChallengeTimelineTemplateOrderByWithRelationInput[]
    cursor?: ChallengeTimelineTemplateWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ChallengeTimelineTemplateScalarFieldEnum | ChallengeTimelineTemplateScalarFieldEnum[]
  }

  /**
   * ChallengeType.defaultReviewers
   */
  export type ChallengeType$defaultReviewersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DefaultChallengeReviewer
     */
    select?: DefaultChallengeReviewerSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DefaultChallengeReviewer
     */
    omit?: DefaultChallengeReviewerOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DefaultChallengeReviewerInclude<ExtArgs> | null
    where?: DefaultChallengeReviewerWhereInput
    orderBy?: DefaultChallengeReviewerOrderByWithRelationInput | DefaultChallengeReviewerOrderByWithRelationInput[]
    cursor?: DefaultChallengeReviewerWhereUniqueInput
    take?: number
    skip?: number
    distinct?: DefaultChallengeReviewerScalarFieldEnum | DefaultChallengeReviewerScalarFieldEnum[]
  }

  /**
   * ChallengeType without action
   */
  export type ChallengeTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ChallengeType
     */
    select?: ChallengeTypeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ChallengeType
     */
    omit?: ChallengeTypeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ChallengeTypeInclude<ExtArgs> | null
  }


  /**
   * Model ChallengeTrack
   */

  export type AggregateChallengeTrack = {
    _count: ChallengeTrackCountAggregateOutputType | null
    _avg: ChallengeTrackAvgAggregateOutputType | null
    _sum: ChallengeTrackSumAggregateOutputType | null
    _min: ChallengeTrackMinAggregateOutputType | null
    _max: ChallengeTrackMaxAggregateOutputType | null
  }

  export type ChallengeTrackAvgAggregateOutputType = {
    legacyId: number | null
  }

  export type ChallengeTrackSumAggregateOutputType = {
    legacyId: number | null
  }

  export type ChallengeTrackMinAggregateOutputType = {
    id: string | null
    name: string | null
    description: string | null
    isActive: boolean | null
    abbreviation: string | null
    legacyId: number | null
    track: $Enums.ChallengeTrackEnum | null
    createdAt: Date | null
    createdBy: string | null
    updatedAt: Date | null
    updatedBy: string | null
  }

  export type ChallengeTrackMaxAggregateOutputType = {
    id: string | null
    name: string | null
    description: string | null
    isActive: boolean | null
    abbreviation: string | null
    legacyId: number | null
    track: $Enums.ChallengeTrackEnum | null
    createdAt: Date | null
    createdBy: string | null
    updatedAt: Date | null
    updatedBy: string | null
  }

  export type ChallengeTrackCountAggregateOutputType = {
    id: number
    name: number
    description: number
    isActive: number
    abbreviation: number
    legacyId: number
    track: number
    createdAt: number
    createdBy: number
    updatedAt: number
    updatedBy: number
    _all: number
  }


  export type ChallengeTrackAvgAggregateInputType = {
    legacyId?: true
  }

  export type ChallengeTrackSumAggregateInputType = {
    legacyId?: true
  }

  export type ChallengeTrackMinAggregateInputType = {
    id?: true
    name?: true
    description?: true
    isActive?: true
    abbreviation?: true
    legacyId?: true
    track?: true
    createdAt?: true
    createdBy?: true
    updatedAt?: true
    updatedBy?: true
  }

  export type ChallengeTrackMaxAggregateInputType = {
    id?: true
    name?: true
    description?: true
    isActive?: true
    abbreviation?: true
    legacyId?: true
    track?: true
    createdAt?: true
    createdBy?: true
    updatedAt?: true
    updatedBy?: true
  }

  export type ChallengeTrackCountAggregateInputType = {
    id?: true
    name?: true
    description?: true
    isActive?: true
    abbreviation?: true
    legacyId?: true
    track?: true
    createdAt?: true
    createdBy?: true
    updatedAt?: true
    updatedBy?: true
    _all?: true
  }

  export type ChallengeTrackAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ChallengeTrack to aggregate.
     */
    where?: ChallengeTrackWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ChallengeTracks to fetch.
     */
    orderBy?: ChallengeTrackOrderByWithRelationInput | ChallengeTrackOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ChallengeTrackWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ChallengeTracks from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ChallengeTracks.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned ChallengeTracks
    **/
    _count?: true | ChallengeTrackCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: ChallengeTrackAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: ChallengeTrackSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ChallengeTrackMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ChallengeTrackMaxAggregateInputType
  }

  export type GetChallengeTrackAggregateType<T extends ChallengeTrackAggregateArgs> = {
        [P in keyof T & keyof AggregateChallengeTrack]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateChallengeTrack[P]>
      : GetScalarType<T[P], AggregateChallengeTrack[P]>
  }




  export type ChallengeTrackGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ChallengeTrackWhereInput
    orderBy?: ChallengeTrackOrderByWithAggregationInput | ChallengeTrackOrderByWithAggregationInput[]
    by: ChallengeTrackScalarFieldEnum[] | ChallengeTrackScalarFieldEnum
    having?: ChallengeTrackScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ChallengeTrackCountAggregateInputType | true
    _avg?: ChallengeTrackAvgAggregateInputType
    _sum?: ChallengeTrackSumAggregateInputType
    _min?: ChallengeTrackMinAggregateInputType
    _max?: ChallengeTrackMaxAggregateInputType
  }

  export type ChallengeTrackGroupByOutputType = {
    id: string
    name: string
    description: string | null
    isActive: boolean
    abbreviation: string
    legacyId: number | null
    track: $Enums.ChallengeTrackEnum | null
    createdAt: Date
    createdBy: string
    updatedAt: Date
    updatedBy: string
    _count: ChallengeTrackCountAggregateOutputType | null
    _avg: ChallengeTrackAvgAggregateOutputType | null
    _sum: ChallengeTrackSumAggregateOutputType | null
    _min: ChallengeTrackMinAggregateOutputType | null
    _max: ChallengeTrackMaxAggregateOutputType | null
  }

  type GetChallengeTrackGroupByPayload<T extends ChallengeTrackGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ChallengeTrackGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ChallengeTrackGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ChallengeTrackGroupByOutputType[P]>
            : GetScalarType<T[P], ChallengeTrackGroupByOutputType[P]>
        }
      >
    >


  export type ChallengeTrackSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    description?: boolean
    isActive?: boolean
    abbreviation?: boolean
    legacyId?: boolean
    track?: boolean
    createdAt?: boolean
    createdBy?: boolean
    updatedAt?: boolean
    updatedBy?: boolean
    challenges?: boolean | ChallengeTrack$challengesArgs<ExtArgs>
    timelineTemplates?: boolean | ChallengeTrack$timelineTemplatesArgs<ExtArgs>
    defaultReviewers?: boolean | ChallengeTrack$defaultReviewersArgs<ExtArgs>
    _count?: boolean | ChallengeTrackCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["challengeTrack"]>

  export type ChallengeTrackSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    description?: boolean
    isActive?: boolean
    abbreviation?: boolean
    legacyId?: boolean
    track?: boolean
    createdAt?: boolean
    createdBy?: boolean
    updatedAt?: boolean
    updatedBy?: boolean
  }, ExtArgs["result"]["challengeTrack"]>

  export type ChallengeTrackSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    description?: boolean
    isActive?: boolean
    abbreviation?: boolean
    legacyId?: boolean
    track?: boolean
    createdAt?: boolean
    createdBy?: boolean
    updatedAt?: boolean
    updatedBy?: boolean
  }, ExtArgs["result"]["challengeTrack"]>

  export type ChallengeTrackSelectScalar = {
    id?: boolean
    name?: boolean
    description?: boolean
    isActive?: boolean
    abbreviation?: boolean
    legacyId?: boolean
    track?: boolean
    createdAt?: boolean
    createdBy?: boolean
    updatedAt?: boolean
    updatedBy?: boolean
  }

  export type ChallengeTrackOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "name" | "description" | "isActive" | "abbreviation" | "legacyId" | "track" | "createdAt" | "createdBy" | "updatedAt" | "updatedBy", ExtArgs["result"]["challengeTrack"]>
  export type ChallengeTrackInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    challenges?: boolean | ChallengeTrack$challengesArgs<ExtArgs>
    timelineTemplates?: boolean | ChallengeTrack$timelineTemplatesArgs<ExtArgs>
    defaultReviewers?: boolean | ChallengeTrack$defaultReviewersArgs<ExtArgs>
    _count?: boolean | ChallengeTrackCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type ChallengeTrackIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}
  export type ChallengeTrackIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}

  export type $ChallengeTrackPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "ChallengeTrack"
    objects: {
      challenges: Prisma.$ChallengePayload<ExtArgs>[]
      timelineTemplates: Prisma.$ChallengeTimelineTemplatePayload<ExtArgs>[]
      defaultReviewers: Prisma.$DefaultChallengeReviewerPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      name: string
      description: string | null
      isActive: boolean
      abbreviation: string
      legacyId: number | null
      track: $Enums.ChallengeTrackEnum | null
      createdAt: Date
      createdBy: string
      updatedAt: Date
      updatedBy: string
    }, ExtArgs["result"]["challengeTrack"]>
    composites: {}
  }

  type ChallengeTrackGetPayload<S extends boolean | null | undefined | ChallengeTrackDefaultArgs> = $Result.GetResult<Prisma.$ChallengeTrackPayload, S>

  type ChallengeTrackCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<ChallengeTrackFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: ChallengeTrackCountAggregateInputType | true
    }

  export interface ChallengeTrackDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['ChallengeTrack'], meta: { name: 'ChallengeTrack' } }
    /**
     * Find zero or one ChallengeTrack that matches the filter.
     * @param {ChallengeTrackFindUniqueArgs} args - Arguments to find a ChallengeTrack
     * @example
     * // Get one ChallengeTrack
     * const challengeTrack = await prisma.challengeTrack.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends ChallengeTrackFindUniqueArgs>(args: SelectSubset<T, ChallengeTrackFindUniqueArgs<ExtArgs>>): Prisma__ChallengeTrackClient<$Result.GetResult<Prisma.$ChallengeTrackPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one ChallengeTrack that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {ChallengeTrackFindUniqueOrThrowArgs} args - Arguments to find a ChallengeTrack
     * @example
     * // Get one ChallengeTrack
     * const challengeTrack = await prisma.challengeTrack.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends ChallengeTrackFindUniqueOrThrowArgs>(args: SelectSubset<T, ChallengeTrackFindUniqueOrThrowArgs<ExtArgs>>): Prisma__ChallengeTrackClient<$Result.GetResult<Prisma.$ChallengeTrackPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first ChallengeTrack that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ChallengeTrackFindFirstArgs} args - Arguments to find a ChallengeTrack
     * @example
     * // Get one ChallengeTrack
     * const challengeTrack = await prisma.challengeTrack.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends ChallengeTrackFindFirstArgs>(args?: SelectSubset<T, ChallengeTrackFindFirstArgs<ExtArgs>>): Prisma__ChallengeTrackClient<$Result.GetResult<Prisma.$ChallengeTrackPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first ChallengeTrack that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ChallengeTrackFindFirstOrThrowArgs} args - Arguments to find a ChallengeTrack
     * @example
     * // Get one ChallengeTrack
     * const challengeTrack = await prisma.challengeTrack.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends ChallengeTrackFindFirstOrThrowArgs>(args?: SelectSubset<T, ChallengeTrackFindFirstOrThrowArgs<ExtArgs>>): Prisma__ChallengeTrackClient<$Result.GetResult<Prisma.$ChallengeTrackPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more ChallengeTracks that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ChallengeTrackFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all ChallengeTracks
     * const challengeTracks = await prisma.challengeTrack.findMany()
     * 
     * // Get first 10 ChallengeTracks
     * const challengeTracks = await prisma.challengeTrack.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const challengeTrackWithIdOnly = await prisma.challengeTrack.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends ChallengeTrackFindManyArgs>(args?: SelectSubset<T, ChallengeTrackFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ChallengeTrackPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a ChallengeTrack.
     * @param {ChallengeTrackCreateArgs} args - Arguments to create a ChallengeTrack.
     * @example
     * // Create one ChallengeTrack
     * const ChallengeTrack = await prisma.challengeTrack.create({
     *   data: {
     *     // ... data to create a ChallengeTrack
     *   }
     * })
     * 
     */
    create<T extends ChallengeTrackCreateArgs>(args: SelectSubset<T, ChallengeTrackCreateArgs<ExtArgs>>): Prisma__ChallengeTrackClient<$Result.GetResult<Prisma.$ChallengeTrackPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many ChallengeTracks.
     * @param {ChallengeTrackCreateManyArgs} args - Arguments to create many ChallengeTracks.
     * @example
     * // Create many ChallengeTracks
     * const challengeTrack = await prisma.challengeTrack.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends ChallengeTrackCreateManyArgs>(args?: SelectSubset<T, ChallengeTrackCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many ChallengeTracks and returns the data saved in the database.
     * @param {ChallengeTrackCreateManyAndReturnArgs} args - Arguments to create many ChallengeTracks.
     * @example
     * // Create many ChallengeTracks
     * const challengeTrack = await prisma.challengeTrack.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many ChallengeTracks and only return the `id`
     * const challengeTrackWithIdOnly = await prisma.challengeTrack.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends ChallengeTrackCreateManyAndReturnArgs>(args?: SelectSubset<T, ChallengeTrackCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ChallengeTrackPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a ChallengeTrack.
     * @param {ChallengeTrackDeleteArgs} args - Arguments to delete one ChallengeTrack.
     * @example
     * // Delete one ChallengeTrack
     * const ChallengeTrack = await prisma.challengeTrack.delete({
     *   where: {
     *     // ... filter to delete one ChallengeTrack
     *   }
     * })
     * 
     */
    delete<T extends ChallengeTrackDeleteArgs>(args: SelectSubset<T, ChallengeTrackDeleteArgs<ExtArgs>>): Prisma__ChallengeTrackClient<$Result.GetResult<Prisma.$ChallengeTrackPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one ChallengeTrack.
     * @param {ChallengeTrackUpdateArgs} args - Arguments to update one ChallengeTrack.
     * @example
     * // Update one ChallengeTrack
     * const challengeTrack = await prisma.challengeTrack.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends ChallengeTrackUpdateArgs>(args: SelectSubset<T, ChallengeTrackUpdateArgs<ExtArgs>>): Prisma__ChallengeTrackClient<$Result.GetResult<Prisma.$ChallengeTrackPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more ChallengeTracks.
     * @param {ChallengeTrackDeleteManyArgs} args - Arguments to filter ChallengeTracks to delete.
     * @example
     * // Delete a few ChallengeTracks
     * const { count } = await prisma.challengeTrack.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends ChallengeTrackDeleteManyArgs>(args?: SelectSubset<T, ChallengeTrackDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more ChallengeTracks.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ChallengeTrackUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many ChallengeTracks
     * const challengeTrack = await prisma.challengeTrack.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends ChallengeTrackUpdateManyArgs>(args: SelectSubset<T, ChallengeTrackUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more ChallengeTracks and returns the data updated in the database.
     * @param {ChallengeTrackUpdateManyAndReturnArgs} args - Arguments to update many ChallengeTracks.
     * @example
     * // Update many ChallengeTracks
     * const challengeTrack = await prisma.challengeTrack.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more ChallengeTracks and only return the `id`
     * const challengeTrackWithIdOnly = await prisma.challengeTrack.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends ChallengeTrackUpdateManyAndReturnArgs>(args: SelectSubset<T, ChallengeTrackUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ChallengeTrackPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one ChallengeTrack.
     * @param {ChallengeTrackUpsertArgs} args - Arguments to update or create a ChallengeTrack.
     * @example
     * // Update or create a ChallengeTrack
     * const challengeTrack = await prisma.challengeTrack.upsert({
     *   create: {
     *     // ... data to create a ChallengeTrack
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the ChallengeTrack we want to update
     *   }
     * })
     */
    upsert<T extends ChallengeTrackUpsertArgs>(args: SelectSubset<T, ChallengeTrackUpsertArgs<ExtArgs>>): Prisma__ChallengeTrackClient<$Result.GetResult<Prisma.$ChallengeTrackPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of ChallengeTracks.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ChallengeTrackCountArgs} args - Arguments to filter ChallengeTracks to count.
     * @example
     * // Count the number of ChallengeTracks
     * const count = await prisma.challengeTrack.count({
     *   where: {
     *     // ... the filter for the ChallengeTracks we want to count
     *   }
     * })
    **/
    count<T extends ChallengeTrackCountArgs>(
      args?: Subset<T, ChallengeTrackCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ChallengeTrackCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a ChallengeTrack.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ChallengeTrackAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ChallengeTrackAggregateArgs>(args: Subset<T, ChallengeTrackAggregateArgs>): Prisma.PrismaPromise<GetChallengeTrackAggregateType<T>>

    /**
     * Group by ChallengeTrack.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ChallengeTrackGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ChallengeTrackGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ChallengeTrackGroupByArgs['orderBy'] }
        : { orderBy?: ChallengeTrackGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ChallengeTrackGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetChallengeTrackGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the ChallengeTrack model
   */
  readonly fields: ChallengeTrackFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for ChallengeTrack.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ChallengeTrackClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    challenges<T extends ChallengeTrack$challengesArgs<ExtArgs> = {}>(args?: Subset<T, ChallengeTrack$challengesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ChallengePayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    timelineTemplates<T extends ChallengeTrack$timelineTemplatesArgs<ExtArgs> = {}>(args?: Subset<T, ChallengeTrack$timelineTemplatesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ChallengeTimelineTemplatePayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    defaultReviewers<T extends ChallengeTrack$defaultReviewersArgs<ExtArgs> = {}>(args?: Subset<T, ChallengeTrack$defaultReviewersArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$DefaultChallengeReviewerPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the ChallengeTrack model
   */
  interface ChallengeTrackFieldRefs {
    readonly id: FieldRef<"ChallengeTrack", 'String'>
    readonly name: FieldRef<"ChallengeTrack", 'String'>
    readonly description: FieldRef<"ChallengeTrack", 'String'>
    readonly isActive: FieldRef<"ChallengeTrack", 'Boolean'>
    readonly abbreviation: FieldRef<"ChallengeTrack", 'String'>
    readonly legacyId: FieldRef<"ChallengeTrack", 'Int'>
    readonly track: FieldRef<"ChallengeTrack", 'ChallengeTrackEnum'>
    readonly createdAt: FieldRef<"ChallengeTrack", 'DateTime'>
    readonly createdBy: FieldRef<"ChallengeTrack", 'String'>
    readonly updatedAt: FieldRef<"ChallengeTrack", 'DateTime'>
    readonly updatedBy: FieldRef<"ChallengeTrack", 'String'>
  }
    

  // Custom InputTypes
  /**
   * ChallengeTrack findUnique
   */
  export type ChallengeTrackFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ChallengeTrack
     */
    select?: ChallengeTrackSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ChallengeTrack
     */
    omit?: ChallengeTrackOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ChallengeTrackInclude<ExtArgs> | null
    /**
     * Filter, which ChallengeTrack to fetch.
     */
    where: ChallengeTrackWhereUniqueInput
  }

  /**
   * ChallengeTrack findUniqueOrThrow
   */
  export type ChallengeTrackFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ChallengeTrack
     */
    select?: ChallengeTrackSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ChallengeTrack
     */
    omit?: ChallengeTrackOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ChallengeTrackInclude<ExtArgs> | null
    /**
     * Filter, which ChallengeTrack to fetch.
     */
    where: ChallengeTrackWhereUniqueInput
  }

  /**
   * ChallengeTrack findFirst
   */
  export type ChallengeTrackFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ChallengeTrack
     */
    select?: ChallengeTrackSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ChallengeTrack
     */
    omit?: ChallengeTrackOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ChallengeTrackInclude<ExtArgs> | null
    /**
     * Filter, which ChallengeTrack to fetch.
     */
    where?: ChallengeTrackWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ChallengeTracks to fetch.
     */
    orderBy?: ChallengeTrackOrderByWithRelationInput | ChallengeTrackOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ChallengeTracks.
     */
    cursor?: ChallengeTrackWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ChallengeTracks from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ChallengeTracks.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ChallengeTracks.
     */
    distinct?: ChallengeTrackScalarFieldEnum | ChallengeTrackScalarFieldEnum[]
  }

  /**
   * ChallengeTrack findFirstOrThrow
   */
  export type ChallengeTrackFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ChallengeTrack
     */
    select?: ChallengeTrackSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ChallengeTrack
     */
    omit?: ChallengeTrackOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ChallengeTrackInclude<ExtArgs> | null
    /**
     * Filter, which ChallengeTrack to fetch.
     */
    where?: ChallengeTrackWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ChallengeTracks to fetch.
     */
    orderBy?: ChallengeTrackOrderByWithRelationInput | ChallengeTrackOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ChallengeTracks.
     */
    cursor?: ChallengeTrackWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ChallengeTracks from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ChallengeTracks.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ChallengeTracks.
     */
    distinct?: ChallengeTrackScalarFieldEnum | ChallengeTrackScalarFieldEnum[]
  }

  /**
   * ChallengeTrack findMany
   */
  export type ChallengeTrackFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ChallengeTrack
     */
    select?: ChallengeTrackSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ChallengeTrack
     */
    omit?: ChallengeTrackOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ChallengeTrackInclude<ExtArgs> | null
    /**
     * Filter, which ChallengeTracks to fetch.
     */
    where?: ChallengeTrackWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ChallengeTracks to fetch.
     */
    orderBy?: ChallengeTrackOrderByWithRelationInput | ChallengeTrackOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing ChallengeTracks.
     */
    cursor?: ChallengeTrackWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ChallengeTracks from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ChallengeTracks.
     */
    skip?: number
    distinct?: ChallengeTrackScalarFieldEnum | ChallengeTrackScalarFieldEnum[]
  }

  /**
   * ChallengeTrack create
   */
  export type ChallengeTrackCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ChallengeTrack
     */
    select?: ChallengeTrackSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ChallengeTrack
     */
    omit?: ChallengeTrackOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ChallengeTrackInclude<ExtArgs> | null
    /**
     * The data needed to create a ChallengeTrack.
     */
    data: XOR<ChallengeTrackCreateInput, ChallengeTrackUncheckedCreateInput>
  }

  /**
   * ChallengeTrack createMany
   */
  export type ChallengeTrackCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many ChallengeTracks.
     */
    data: ChallengeTrackCreateManyInput | ChallengeTrackCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * ChallengeTrack createManyAndReturn
   */
  export type ChallengeTrackCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ChallengeTrack
     */
    select?: ChallengeTrackSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the ChallengeTrack
     */
    omit?: ChallengeTrackOmit<ExtArgs> | null
    /**
     * The data used to create many ChallengeTracks.
     */
    data: ChallengeTrackCreateManyInput | ChallengeTrackCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * ChallengeTrack update
   */
  export type ChallengeTrackUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ChallengeTrack
     */
    select?: ChallengeTrackSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ChallengeTrack
     */
    omit?: ChallengeTrackOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ChallengeTrackInclude<ExtArgs> | null
    /**
     * The data needed to update a ChallengeTrack.
     */
    data: XOR<ChallengeTrackUpdateInput, ChallengeTrackUncheckedUpdateInput>
    /**
     * Choose, which ChallengeTrack to update.
     */
    where: ChallengeTrackWhereUniqueInput
  }

  /**
   * ChallengeTrack updateMany
   */
  export type ChallengeTrackUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update ChallengeTracks.
     */
    data: XOR<ChallengeTrackUpdateManyMutationInput, ChallengeTrackUncheckedUpdateManyInput>
    /**
     * Filter which ChallengeTracks to update
     */
    where?: ChallengeTrackWhereInput
    /**
     * Limit how many ChallengeTracks to update.
     */
    limit?: number
  }

  /**
   * ChallengeTrack updateManyAndReturn
   */
  export type ChallengeTrackUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ChallengeTrack
     */
    select?: ChallengeTrackSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the ChallengeTrack
     */
    omit?: ChallengeTrackOmit<ExtArgs> | null
    /**
     * The data used to update ChallengeTracks.
     */
    data: XOR<ChallengeTrackUpdateManyMutationInput, ChallengeTrackUncheckedUpdateManyInput>
    /**
     * Filter which ChallengeTracks to update
     */
    where?: ChallengeTrackWhereInput
    /**
     * Limit how many ChallengeTracks to update.
     */
    limit?: number
  }

  /**
   * ChallengeTrack upsert
   */
  export type ChallengeTrackUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ChallengeTrack
     */
    select?: ChallengeTrackSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ChallengeTrack
     */
    omit?: ChallengeTrackOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ChallengeTrackInclude<ExtArgs> | null
    /**
     * The filter to search for the ChallengeTrack to update in case it exists.
     */
    where: ChallengeTrackWhereUniqueInput
    /**
     * In case the ChallengeTrack found by the `where` argument doesn't exist, create a new ChallengeTrack with this data.
     */
    create: XOR<ChallengeTrackCreateInput, ChallengeTrackUncheckedCreateInput>
    /**
     * In case the ChallengeTrack was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ChallengeTrackUpdateInput, ChallengeTrackUncheckedUpdateInput>
  }

  /**
   * ChallengeTrack delete
   */
  export type ChallengeTrackDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ChallengeTrack
     */
    select?: ChallengeTrackSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ChallengeTrack
     */
    omit?: ChallengeTrackOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ChallengeTrackInclude<ExtArgs> | null
    /**
     * Filter which ChallengeTrack to delete.
     */
    where: ChallengeTrackWhereUniqueInput
  }

  /**
   * ChallengeTrack deleteMany
   */
  export type ChallengeTrackDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ChallengeTracks to delete
     */
    where?: ChallengeTrackWhereInput
    /**
     * Limit how many ChallengeTracks to delete.
     */
    limit?: number
  }

  /**
   * ChallengeTrack.challenges
   */
  export type ChallengeTrack$challengesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Challenge
     */
    select?: ChallengeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Challenge
     */
    omit?: ChallengeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ChallengeInclude<ExtArgs> | null
    where?: ChallengeWhereInput
    orderBy?: ChallengeOrderByWithRelationInput | ChallengeOrderByWithRelationInput[]
    cursor?: ChallengeWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ChallengeScalarFieldEnum | ChallengeScalarFieldEnum[]
  }

  /**
   * ChallengeTrack.timelineTemplates
   */
  export type ChallengeTrack$timelineTemplatesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ChallengeTimelineTemplate
     */
    select?: ChallengeTimelineTemplateSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ChallengeTimelineTemplate
     */
    omit?: ChallengeTimelineTemplateOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ChallengeTimelineTemplateInclude<ExtArgs> | null
    where?: ChallengeTimelineTemplateWhereInput
    orderBy?: ChallengeTimelineTemplateOrderByWithRelationInput | ChallengeTimelineTemplateOrderByWithRelationInput[]
    cursor?: ChallengeTimelineTemplateWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ChallengeTimelineTemplateScalarFieldEnum | ChallengeTimelineTemplateScalarFieldEnum[]
  }

  /**
   * ChallengeTrack.defaultReviewers
   */
  export type ChallengeTrack$defaultReviewersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DefaultChallengeReviewer
     */
    select?: DefaultChallengeReviewerSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DefaultChallengeReviewer
     */
    omit?: DefaultChallengeReviewerOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DefaultChallengeReviewerInclude<ExtArgs> | null
    where?: DefaultChallengeReviewerWhereInput
    orderBy?: DefaultChallengeReviewerOrderByWithRelationInput | DefaultChallengeReviewerOrderByWithRelationInput[]
    cursor?: DefaultChallengeReviewerWhereUniqueInput
    take?: number
    skip?: number
    distinct?: DefaultChallengeReviewerScalarFieldEnum | DefaultChallengeReviewerScalarFieldEnum[]
  }

  /**
   * ChallengeTrack without action
   */
  export type ChallengeTrackDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ChallengeTrack
     */
    select?: ChallengeTrackSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ChallengeTrack
     */
    omit?: ChallengeTrackOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ChallengeTrackInclude<ExtArgs> | null
  }


  /**
   * Model ChallengeTimelineTemplate
   */

  export type AggregateChallengeTimelineTemplate = {
    _count: ChallengeTimelineTemplateCountAggregateOutputType | null
    _min: ChallengeTimelineTemplateMinAggregateOutputType | null
    _max: ChallengeTimelineTemplateMaxAggregateOutputType | null
  }

  export type ChallengeTimelineTemplateMinAggregateOutputType = {
    id: string | null
    typeId: string | null
    trackId: string | null
    timelineTemplateId: string | null
    isDefault: boolean | null
    createdAt: Date | null
    createdBy: string | null
    updatedAt: Date | null
    updatedBy: string | null
  }

  export type ChallengeTimelineTemplateMaxAggregateOutputType = {
    id: string | null
    typeId: string | null
    trackId: string | null
    timelineTemplateId: string | null
    isDefault: boolean | null
    createdAt: Date | null
    createdBy: string | null
    updatedAt: Date | null
    updatedBy: string | null
  }

  export type ChallengeTimelineTemplateCountAggregateOutputType = {
    id: number
    typeId: number
    trackId: number
    timelineTemplateId: number
    isDefault: number
    createdAt: number
    createdBy: number
    updatedAt: number
    updatedBy: number
    _all: number
  }


  export type ChallengeTimelineTemplateMinAggregateInputType = {
    id?: true
    typeId?: true
    trackId?: true
    timelineTemplateId?: true
    isDefault?: true
    createdAt?: true
    createdBy?: true
    updatedAt?: true
    updatedBy?: true
  }

  export type ChallengeTimelineTemplateMaxAggregateInputType = {
    id?: true
    typeId?: true
    trackId?: true
    timelineTemplateId?: true
    isDefault?: true
    createdAt?: true
    createdBy?: true
    updatedAt?: true
    updatedBy?: true
  }

  export type ChallengeTimelineTemplateCountAggregateInputType = {
    id?: true
    typeId?: true
    trackId?: true
    timelineTemplateId?: true
    isDefault?: true
    createdAt?: true
    createdBy?: true
    updatedAt?: true
    updatedBy?: true
    _all?: true
  }

  export type ChallengeTimelineTemplateAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ChallengeTimelineTemplate to aggregate.
     */
    where?: ChallengeTimelineTemplateWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ChallengeTimelineTemplates to fetch.
     */
    orderBy?: ChallengeTimelineTemplateOrderByWithRelationInput | ChallengeTimelineTemplateOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ChallengeTimelineTemplateWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ChallengeTimelineTemplates from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ChallengeTimelineTemplates.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned ChallengeTimelineTemplates
    **/
    _count?: true | ChallengeTimelineTemplateCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ChallengeTimelineTemplateMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ChallengeTimelineTemplateMaxAggregateInputType
  }

  export type GetChallengeTimelineTemplateAggregateType<T extends ChallengeTimelineTemplateAggregateArgs> = {
        [P in keyof T & keyof AggregateChallengeTimelineTemplate]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateChallengeTimelineTemplate[P]>
      : GetScalarType<T[P], AggregateChallengeTimelineTemplate[P]>
  }




  export type ChallengeTimelineTemplateGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ChallengeTimelineTemplateWhereInput
    orderBy?: ChallengeTimelineTemplateOrderByWithAggregationInput | ChallengeTimelineTemplateOrderByWithAggregationInput[]
    by: ChallengeTimelineTemplateScalarFieldEnum[] | ChallengeTimelineTemplateScalarFieldEnum
    having?: ChallengeTimelineTemplateScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ChallengeTimelineTemplateCountAggregateInputType | true
    _min?: ChallengeTimelineTemplateMinAggregateInputType
    _max?: ChallengeTimelineTemplateMaxAggregateInputType
  }

  export type ChallengeTimelineTemplateGroupByOutputType = {
    id: string
    typeId: string
    trackId: string
    timelineTemplateId: string
    isDefault: boolean
    createdAt: Date
    createdBy: string
    updatedAt: Date
    updatedBy: string
    _count: ChallengeTimelineTemplateCountAggregateOutputType | null
    _min: ChallengeTimelineTemplateMinAggregateOutputType | null
    _max: ChallengeTimelineTemplateMaxAggregateOutputType | null
  }

  type GetChallengeTimelineTemplateGroupByPayload<T extends ChallengeTimelineTemplateGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ChallengeTimelineTemplateGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ChallengeTimelineTemplateGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ChallengeTimelineTemplateGroupByOutputType[P]>
            : GetScalarType<T[P], ChallengeTimelineTemplateGroupByOutputType[P]>
        }
      >
    >


  export type ChallengeTimelineTemplateSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    typeId?: boolean
    trackId?: boolean
    timelineTemplateId?: boolean
    isDefault?: boolean
    createdAt?: boolean
    createdBy?: boolean
    updatedAt?: boolean
    updatedBy?: boolean
    timelineTemplate?: boolean | TimelineTemplateDefaultArgs<ExtArgs>
    track?: boolean | ChallengeTrackDefaultArgs<ExtArgs>
    type?: boolean | ChallengeTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["challengeTimelineTemplate"]>

  export type ChallengeTimelineTemplateSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    typeId?: boolean
    trackId?: boolean
    timelineTemplateId?: boolean
    isDefault?: boolean
    createdAt?: boolean
    createdBy?: boolean
    updatedAt?: boolean
    updatedBy?: boolean
    timelineTemplate?: boolean | TimelineTemplateDefaultArgs<ExtArgs>
    track?: boolean | ChallengeTrackDefaultArgs<ExtArgs>
    type?: boolean | ChallengeTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["challengeTimelineTemplate"]>

  export type ChallengeTimelineTemplateSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    typeId?: boolean
    trackId?: boolean
    timelineTemplateId?: boolean
    isDefault?: boolean
    createdAt?: boolean
    createdBy?: boolean
    updatedAt?: boolean
    updatedBy?: boolean
    timelineTemplate?: boolean | TimelineTemplateDefaultArgs<ExtArgs>
    track?: boolean | ChallengeTrackDefaultArgs<ExtArgs>
    type?: boolean | ChallengeTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["challengeTimelineTemplate"]>

  export type ChallengeTimelineTemplateSelectScalar = {
    id?: boolean
    typeId?: boolean
    trackId?: boolean
    timelineTemplateId?: boolean
    isDefault?: boolean
    createdAt?: boolean
    createdBy?: boolean
    updatedAt?: boolean
    updatedBy?: boolean
  }

  export type ChallengeTimelineTemplateOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "typeId" | "trackId" | "timelineTemplateId" | "isDefault" | "createdAt" | "createdBy" | "updatedAt" | "updatedBy", ExtArgs["result"]["challengeTimelineTemplate"]>
  export type ChallengeTimelineTemplateInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    timelineTemplate?: boolean | TimelineTemplateDefaultArgs<ExtArgs>
    track?: boolean | ChallengeTrackDefaultArgs<ExtArgs>
    type?: boolean | ChallengeTypeDefaultArgs<ExtArgs>
  }
  export type ChallengeTimelineTemplateIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    timelineTemplate?: boolean | TimelineTemplateDefaultArgs<ExtArgs>
    track?: boolean | ChallengeTrackDefaultArgs<ExtArgs>
    type?: boolean | ChallengeTypeDefaultArgs<ExtArgs>
  }
  export type ChallengeTimelineTemplateIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    timelineTemplate?: boolean | TimelineTemplateDefaultArgs<ExtArgs>
    track?: boolean | ChallengeTrackDefaultArgs<ExtArgs>
    type?: boolean | ChallengeTypeDefaultArgs<ExtArgs>
  }

  export type $ChallengeTimelineTemplatePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "ChallengeTimelineTemplate"
    objects: {
      timelineTemplate: Prisma.$TimelineTemplatePayload<ExtArgs>
      track: Prisma.$ChallengeTrackPayload<ExtArgs>
      type: Prisma.$ChallengeTypePayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      typeId: string
      trackId: string
      timelineTemplateId: string
      isDefault: boolean
      createdAt: Date
      createdBy: string
      updatedAt: Date
      updatedBy: string
    }, ExtArgs["result"]["challengeTimelineTemplate"]>
    composites: {}
  }

  type ChallengeTimelineTemplateGetPayload<S extends boolean | null | undefined | ChallengeTimelineTemplateDefaultArgs> = $Result.GetResult<Prisma.$ChallengeTimelineTemplatePayload, S>

  type ChallengeTimelineTemplateCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<ChallengeTimelineTemplateFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: ChallengeTimelineTemplateCountAggregateInputType | true
    }

  export interface ChallengeTimelineTemplateDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['ChallengeTimelineTemplate'], meta: { name: 'ChallengeTimelineTemplate' } }
    /**
     * Find zero or one ChallengeTimelineTemplate that matches the filter.
     * @param {ChallengeTimelineTemplateFindUniqueArgs} args - Arguments to find a ChallengeTimelineTemplate
     * @example
     * // Get one ChallengeTimelineTemplate
     * const challengeTimelineTemplate = await prisma.challengeTimelineTemplate.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends ChallengeTimelineTemplateFindUniqueArgs>(args: SelectSubset<T, ChallengeTimelineTemplateFindUniqueArgs<ExtArgs>>): Prisma__ChallengeTimelineTemplateClient<$Result.GetResult<Prisma.$ChallengeTimelineTemplatePayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one ChallengeTimelineTemplate that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {ChallengeTimelineTemplateFindUniqueOrThrowArgs} args - Arguments to find a ChallengeTimelineTemplate
     * @example
     * // Get one ChallengeTimelineTemplate
     * const challengeTimelineTemplate = await prisma.challengeTimelineTemplate.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends ChallengeTimelineTemplateFindUniqueOrThrowArgs>(args: SelectSubset<T, ChallengeTimelineTemplateFindUniqueOrThrowArgs<ExtArgs>>): Prisma__ChallengeTimelineTemplateClient<$Result.GetResult<Prisma.$ChallengeTimelineTemplatePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first ChallengeTimelineTemplate that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ChallengeTimelineTemplateFindFirstArgs} args - Arguments to find a ChallengeTimelineTemplate
     * @example
     * // Get one ChallengeTimelineTemplate
     * const challengeTimelineTemplate = await prisma.challengeTimelineTemplate.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends ChallengeTimelineTemplateFindFirstArgs>(args?: SelectSubset<T, ChallengeTimelineTemplateFindFirstArgs<ExtArgs>>): Prisma__ChallengeTimelineTemplateClient<$Result.GetResult<Prisma.$ChallengeTimelineTemplatePayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first ChallengeTimelineTemplate that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ChallengeTimelineTemplateFindFirstOrThrowArgs} args - Arguments to find a ChallengeTimelineTemplate
     * @example
     * // Get one ChallengeTimelineTemplate
     * const challengeTimelineTemplate = await prisma.challengeTimelineTemplate.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends ChallengeTimelineTemplateFindFirstOrThrowArgs>(args?: SelectSubset<T, ChallengeTimelineTemplateFindFirstOrThrowArgs<ExtArgs>>): Prisma__ChallengeTimelineTemplateClient<$Result.GetResult<Prisma.$ChallengeTimelineTemplatePayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more ChallengeTimelineTemplates that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ChallengeTimelineTemplateFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all ChallengeTimelineTemplates
     * const challengeTimelineTemplates = await prisma.challengeTimelineTemplate.findMany()
     * 
     * // Get first 10 ChallengeTimelineTemplates
     * const challengeTimelineTemplates = await prisma.challengeTimelineTemplate.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const challengeTimelineTemplateWithIdOnly = await prisma.challengeTimelineTemplate.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends ChallengeTimelineTemplateFindManyArgs>(args?: SelectSubset<T, ChallengeTimelineTemplateFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ChallengeTimelineTemplatePayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a ChallengeTimelineTemplate.
     * @param {ChallengeTimelineTemplateCreateArgs} args - Arguments to create a ChallengeTimelineTemplate.
     * @example
     * // Create one ChallengeTimelineTemplate
     * const ChallengeTimelineTemplate = await prisma.challengeTimelineTemplate.create({
     *   data: {
     *     // ... data to create a ChallengeTimelineTemplate
     *   }
     * })
     * 
     */
    create<T extends ChallengeTimelineTemplateCreateArgs>(args: SelectSubset<T, ChallengeTimelineTemplateCreateArgs<ExtArgs>>): Prisma__ChallengeTimelineTemplateClient<$Result.GetResult<Prisma.$ChallengeTimelineTemplatePayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many ChallengeTimelineTemplates.
     * @param {ChallengeTimelineTemplateCreateManyArgs} args - Arguments to create many ChallengeTimelineTemplates.
     * @example
     * // Create many ChallengeTimelineTemplates
     * const challengeTimelineTemplate = await prisma.challengeTimelineTemplate.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends ChallengeTimelineTemplateCreateManyArgs>(args?: SelectSubset<T, ChallengeTimelineTemplateCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many ChallengeTimelineTemplates and returns the data saved in the database.
     * @param {ChallengeTimelineTemplateCreateManyAndReturnArgs} args - Arguments to create many ChallengeTimelineTemplates.
     * @example
     * // Create many ChallengeTimelineTemplates
     * const challengeTimelineTemplate = await prisma.challengeTimelineTemplate.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many ChallengeTimelineTemplates and only return the `id`
     * const challengeTimelineTemplateWithIdOnly = await prisma.challengeTimelineTemplate.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends ChallengeTimelineTemplateCreateManyAndReturnArgs>(args?: SelectSubset<T, ChallengeTimelineTemplateCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ChallengeTimelineTemplatePayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a ChallengeTimelineTemplate.
     * @param {ChallengeTimelineTemplateDeleteArgs} args - Arguments to delete one ChallengeTimelineTemplate.
     * @example
     * // Delete one ChallengeTimelineTemplate
     * const ChallengeTimelineTemplate = await prisma.challengeTimelineTemplate.delete({
     *   where: {
     *     // ... filter to delete one ChallengeTimelineTemplate
     *   }
     * })
     * 
     */
    delete<T extends ChallengeTimelineTemplateDeleteArgs>(args: SelectSubset<T, ChallengeTimelineTemplateDeleteArgs<ExtArgs>>): Prisma__ChallengeTimelineTemplateClient<$Result.GetResult<Prisma.$ChallengeTimelineTemplatePayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one ChallengeTimelineTemplate.
     * @param {ChallengeTimelineTemplateUpdateArgs} args - Arguments to update one ChallengeTimelineTemplate.
     * @example
     * // Update one ChallengeTimelineTemplate
     * const challengeTimelineTemplate = await prisma.challengeTimelineTemplate.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends ChallengeTimelineTemplateUpdateArgs>(args: SelectSubset<T, ChallengeTimelineTemplateUpdateArgs<ExtArgs>>): Prisma__ChallengeTimelineTemplateClient<$Result.GetResult<Prisma.$ChallengeTimelineTemplatePayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more ChallengeTimelineTemplates.
     * @param {ChallengeTimelineTemplateDeleteManyArgs} args - Arguments to filter ChallengeTimelineTemplates to delete.
     * @example
     * // Delete a few ChallengeTimelineTemplates
     * const { count } = await prisma.challengeTimelineTemplate.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends ChallengeTimelineTemplateDeleteManyArgs>(args?: SelectSubset<T, ChallengeTimelineTemplateDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more ChallengeTimelineTemplates.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ChallengeTimelineTemplateUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many ChallengeTimelineTemplates
     * const challengeTimelineTemplate = await prisma.challengeTimelineTemplate.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends ChallengeTimelineTemplateUpdateManyArgs>(args: SelectSubset<T, ChallengeTimelineTemplateUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more ChallengeTimelineTemplates and returns the data updated in the database.
     * @param {ChallengeTimelineTemplateUpdateManyAndReturnArgs} args - Arguments to update many ChallengeTimelineTemplates.
     * @example
     * // Update many ChallengeTimelineTemplates
     * const challengeTimelineTemplate = await prisma.challengeTimelineTemplate.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more ChallengeTimelineTemplates and only return the `id`
     * const challengeTimelineTemplateWithIdOnly = await prisma.challengeTimelineTemplate.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends ChallengeTimelineTemplateUpdateManyAndReturnArgs>(args: SelectSubset<T, ChallengeTimelineTemplateUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ChallengeTimelineTemplatePayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one ChallengeTimelineTemplate.
     * @param {ChallengeTimelineTemplateUpsertArgs} args - Arguments to update or create a ChallengeTimelineTemplate.
     * @example
     * // Update or create a ChallengeTimelineTemplate
     * const challengeTimelineTemplate = await prisma.challengeTimelineTemplate.upsert({
     *   create: {
     *     // ... data to create a ChallengeTimelineTemplate
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the ChallengeTimelineTemplate we want to update
     *   }
     * })
     */
    upsert<T extends ChallengeTimelineTemplateUpsertArgs>(args: SelectSubset<T, ChallengeTimelineTemplateUpsertArgs<ExtArgs>>): Prisma__ChallengeTimelineTemplateClient<$Result.GetResult<Prisma.$ChallengeTimelineTemplatePayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of ChallengeTimelineTemplates.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ChallengeTimelineTemplateCountArgs} args - Arguments to filter ChallengeTimelineTemplates to count.
     * @example
     * // Count the number of ChallengeTimelineTemplates
     * const count = await prisma.challengeTimelineTemplate.count({
     *   where: {
     *     // ... the filter for the ChallengeTimelineTemplates we want to count
     *   }
     * })
    **/
    count<T extends ChallengeTimelineTemplateCountArgs>(
      args?: Subset<T, ChallengeTimelineTemplateCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ChallengeTimelineTemplateCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a ChallengeTimelineTemplate.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ChallengeTimelineTemplateAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ChallengeTimelineTemplateAggregateArgs>(args: Subset<T, ChallengeTimelineTemplateAggregateArgs>): Prisma.PrismaPromise<GetChallengeTimelineTemplateAggregateType<T>>

    /**
     * Group by ChallengeTimelineTemplate.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ChallengeTimelineTemplateGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ChallengeTimelineTemplateGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ChallengeTimelineTemplateGroupByArgs['orderBy'] }
        : { orderBy?: ChallengeTimelineTemplateGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ChallengeTimelineTemplateGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetChallengeTimelineTemplateGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the ChallengeTimelineTemplate model
   */
  readonly fields: ChallengeTimelineTemplateFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for ChallengeTimelineTemplate.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ChallengeTimelineTemplateClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    timelineTemplate<T extends TimelineTemplateDefaultArgs<ExtArgs> = {}>(args?: Subset<T, TimelineTemplateDefaultArgs<ExtArgs>>): Prisma__TimelineTemplateClient<$Result.GetResult<Prisma.$TimelineTemplatePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    track<T extends ChallengeTrackDefaultArgs<ExtArgs> = {}>(args?: Subset<T, ChallengeTrackDefaultArgs<ExtArgs>>): Prisma__ChallengeTrackClient<$Result.GetResult<Prisma.$ChallengeTrackPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    type<T extends ChallengeTypeDefaultArgs<ExtArgs> = {}>(args?: Subset<T, ChallengeTypeDefaultArgs<ExtArgs>>): Prisma__ChallengeTypeClient<$Result.GetResult<Prisma.$ChallengeTypePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the ChallengeTimelineTemplate model
   */
  interface ChallengeTimelineTemplateFieldRefs {
    readonly id: FieldRef<"ChallengeTimelineTemplate", 'String'>
    readonly typeId: FieldRef<"ChallengeTimelineTemplate", 'String'>
    readonly trackId: FieldRef<"ChallengeTimelineTemplate", 'String'>
    readonly timelineTemplateId: FieldRef<"ChallengeTimelineTemplate", 'String'>
    readonly isDefault: FieldRef<"ChallengeTimelineTemplate", 'Boolean'>
    readonly createdAt: FieldRef<"ChallengeTimelineTemplate", 'DateTime'>
    readonly createdBy: FieldRef<"ChallengeTimelineTemplate", 'String'>
    readonly updatedAt: FieldRef<"ChallengeTimelineTemplate", 'DateTime'>
    readonly updatedBy: FieldRef<"ChallengeTimelineTemplate", 'String'>
  }
    

  // Custom InputTypes
  /**
   * ChallengeTimelineTemplate findUnique
   */
  export type ChallengeTimelineTemplateFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ChallengeTimelineTemplate
     */
    select?: ChallengeTimelineTemplateSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ChallengeTimelineTemplate
     */
    omit?: ChallengeTimelineTemplateOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ChallengeTimelineTemplateInclude<ExtArgs> | null
    /**
     * Filter, which ChallengeTimelineTemplate to fetch.
     */
    where: ChallengeTimelineTemplateWhereUniqueInput
  }

  /**
   * ChallengeTimelineTemplate findUniqueOrThrow
   */
  export type ChallengeTimelineTemplateFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ChallengeTimelineTemplate
     */
    select?: ChallengeTimelineTemplateSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ChallengeTimelineTemplate
     */
    omit?: ChallengeTimelineTemplateOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ChallengeTimelineTemplateInclude<ExtArgs> | null
    /**
     * Filter, which ChallengeTimelineTemplate to fetch.
     */
    where: ChallengeTimelineTemplateWhereUniqueInput
  }

  /**
   * ChallengeTimelineTemplate findFirst
   */
  export type ChallengeTimelineTemplateFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ChallengeTimelineTemplate
     */
    select?: ChallengeTimelineTemplateSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ChallengeTimelineTemplate
     */
    omit?: ChallengeTimelineTemplateOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ChallengeTimelineTemplateInclude<ExtArgs> | null
    /**
     * Filter, which ChallengeTimelineTemplate to fetch.
     */
    where?: ChallengeTimelineTemplateWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ChallengeTimelineTemplates to fetch.
     */
    orderBy?: ChallengeTimelineTemplateOrderByWithRelationInput | ChallengeTimelineTemplateOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ChallengeTimelineTemplates.
     */
    cursor?: ChallengeTimelineTemplateWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ChallengeTimelineTemplates from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ChallengeTimelineTemplates.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ChallengeTimelineTemplates.
     */
    distinct?: ChallengeTimelineTemplateScalarFieldEnum | ChallengeTimelineTemplateScalarFieldEnum[]
  }

  /**
   * ChallengeTimelineTemplate findFirstOrThrow
   */
  export type ChallengeTimelineTemplateFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ChallengeTimelineTemplate
     */
    select?: ChallengeTimelineTemplateSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ChallengeTimelineTemplate
     */
    omit?: ChallengeTimelineTemplateOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ChallengeTimelineTemplateInclude<ExtArgs> | null
    /**
     * Filter, which ChallengeTimelineTemplate to fetch.
     */
    where?: ChallengeTimelineTemplateWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ChallengeTimelineTemplates to fetch.
     */
    orderBy?: ChallengeTimelineTemplateOrderByWithRelationInput | ChallengeTimelineTemplateOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ChallengeTimelineTemplates.
     */
    cursor?: ChallengeTimelineTemplateWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ChallengeTimelineTemplates from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ChallengeTimelineTemplates.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ChallengeTimelineTemplates.
     */
    distinct?: ChallengeTimelineTemplateScalarFieldEnum | ChallengeTimelineTemplateScalarFieldEnum[]
  }

  /**
   * ChallengeTimelineTemplate findMany
   */
  export type ChallengeTimelineTemplateFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ChallengeTimelineTemplate
     */
    select?: ChallengeTimelineTemplateSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ChallengeTimelineTemplate
     */
    omit?: ChallengeTimelineTemplateOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ChallengeTimelineTemplateInclude<ExtArgs> | null
    /**
     * Filter, which ChallengeTimelineTemplates to fetch.
     */
    where?: ChallengeTimelineTemplateWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ChallengeTimelineTemplates to fetch.
     */
    orderBy?: ChallengeTimelineTemplateOrderByWithRelationInput | ChallengeTimelineTemplateOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing ChallengeTimelineTemplates.
     */
    cursor?: ChallengeTimelineTemplateWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ChallengeTimelineTemplates from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ChallengeTimelineTemplates.
     */
    skip?: number
    distinct?: ChallengeTimelineTemplateScalarFieldEnum | ChallengeTimelineTemplateScalarFieldEnum[]
  }

  /**
   * ChallengeTimelineTemplate create
   */
  export type ChallengeTimelineTemplateCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ChallengeTimelineTemplate
     */
    select?: ChallengeTimelineTemplateSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ChallengeTimelineTemplate
     */
    omit?: ChallengeTimelineTemplateOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ChallengeTimelineTemplateInclude<ExtArgs> | null
    /**
     * The data needed to create a ChallengeTimelineTemplate.
     */
    data: XOR<ChallengeTimelineTemplateCreateInput, ChallengeTimelineTemplateUncheckedCreateInput>
  }

  /**
   * ChallengeTimelineTemplate createMany
   */
  export type ChallengeTimelineTemplateCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many ChallengeTimelineTemplates.
     */
    data: ChallengeTimelineTemplateCreateManyInput | ChallengeTimelineTemplateCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * ChallengeTimelineTemplate createManyAndReturn
   */
  export type ChallengeTimelineTemplateCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ChallengeTimelineTemplate
     */
    select?: ChallengeTimelineTemplateSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the ChallengeTimelineTemplate
     */
    omit?: ChallengeTimelineTemplateOmit<ExtArgs> | null
    /**
     * The data used to create many ChallengeTimelineTemplates.
     */
    data: ChallengeTimelineTemplateCreateManyInput | ChallengeTimelineTemplateCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ChallengeTimelineTemplateIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * ChallengeTimelineTemplate update
   */
  export type ChallengeTimelineTemplateUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ChallengeTimelineTemplate
     */
    select?: ChallengeTimelineTemplateSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ChallengeTimelineTemplate
     */
    omit?: ChallengeTimelineTemplateOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ChallengeTimelineTemplateInclude<ExtArgs> | null
    /**
     * The data needed to update a ChallengeTimelineTemplate.
     */
    data: XOR<ChallengeTimelineTemplateUpdateInput, ChallengeTimelineTemplateUncheckedUpdateInput>
    /**
     * Choose, which ChallengeTimelineTemplate to update.
     */
    where: ChallengeTimelineTemplateWhereUniqueInput
  }

  /**
   * ChallengeTimelineTemplate updateMany
   */
  export type ChallengeTimelineTemplateUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update ChallengeTimelineTemplates.
     */
    data: XOR<ChallengeTimelineTemplateUpdateManyMutationInput, ChallengeTimelineTemplateUncheckedUpdateManyInput>
    /**
     * Filter which ChallengeTimelineTemplates to update
     */
    where?: ChallengeTimelineTemplateWhereInput
    /**
     * Limit how many ChallengeTimelineTemplates to update.
     */
    limit?: number
  }

  /**
   * ChallengeTimelineTemplate updateManyAndReturn
   */
  export type ChallengeTimelineTemplateUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ChallengeTimelineTemplate
     */
    select?: ChallengeTimelineTemplateSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the ChallengeTimelineTemplate
     */
    omit?: ChallengeTimelineTemplateOmit<ExtArgs> | null
    /**
     * The data used to update ChallengeTimelineTemplates.
     */
    data: XOR<ChallengeTimelineTemplateUpdateManyMutationInput, ChallengeTimelineTemplateUncheckedUpdateManyInput>
    /**
     * Filter which ChallengeTimelineTemplates to update
     */
    where?: ChallengeTimelineTemplateWhereInput
    /**
     * Limit how many ChallengeTimelineTemplates to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ChallengeTimelineTemplateIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * ChallengeTimelineTemplate upsert
   */
  export type ChallengeTimelineTemplateUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ChallengeTimelineTemplate
     */
    select?: ChallengeTimelineTemplateSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ChallengeTimelineTemplate
     */
    omit?: ChallengeTimelineTemplateOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ChallengeTimelineTemplateInclude<ExtArgs> | null
    /**
     * The filter to search for the ChallengeTimelineTemplate to update in case it exists.
     */
    where: ChallengeTimelineTemplateWhereUniqueInput
    /**
     * In case the ChallengeTimelineTemplate found by the `where` argument doesn't exist, create a new ChallengeTimelineTemplate with this data.
     */
    create: XOR<ChallengeTimelineTemplateCreateInput, ChallengeTimelineTemplateUncheckedCreateInput>
    /**
     * In case the ChallengeTimelineTemplate was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ChallengeTimelineTemplateUpdateInput, ChallengeTimelineTemplateUncheckedUpdateInput>
  }

  /**
   * ChallengeTimelineTemplate delete
   */
  export type ChallengeTimelineTemplateDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ChallengeTimelineTemplate
     */
    select?: ChallengeTimelineTemplateSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ChallengeTimelineTemplate
     */
    omit?: ChallengeTimelineTemplateOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ChallengeTimelineTemplateInclude<ExtArgs> | null
    /**
     * Filter which ChallengeTimelineTemplate to delete.
     */
    where: ChallengeTimelineTemplateWhereUniqueInput
  }

  /**
   * ChallengeTimelineTemplate deleteMany
   */
  export type ChallengeTimelineTemplateDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ChallengeTimelineTemplates to delete
     */
    where?: ChallengeTimelineTemplateWhereInput
    /**
     * Limit how many ChallengeTimelineTemplates to delete.
     */
    limit?: number
  }

  /**
   * ChallengeTimelineTemplate without action
   */
  export type ChallengeTimelineTemplateDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ChallengeTimelineTemplate
     */
    select?: ChallengeTimelineTemplateSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ChallengeTimelineTemplate
     */
    omit?: ChallengeTimelineTemplateOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ChallengeTimelineTemplateInclude<ExtArgs> | null
  }


  /**
   * Model AuditLog
   */

  export type AggregateAuditLog = {
    _count: AuditLogCountAggregateOutputType | null
    _min: AuditLogMinAggregateOutputType | null
    _max: AuditLogMaxAggregateOutputType | null
  }

  export type AuditLogMinAggregateOutputType = {
    id: string | null
    challengeId: string | null
    fieldName: string | null
    oldValue: string | null
    newValue: string | null
    createdAt: Date | null
    createdBy: string | null
    memberId: string | null
  }

  export type AuditLogMaxAggregateOutputType = {
    id: string | null
    challengeId: string | null
    fieldName: string | null
    oldValue: string | null
    newValue: string | null
    createdAt: Date | null
    createdBy: string | null
    memberId: string | null
  }

  export type AuditLogCountAggregateOutputType = {
    id: number
    challengeId: number
    fieldName: number
    oldValue: number
    newValue: number
    createdAt: number
    createdBy: number
    memberId: number
    _all: number
  }


  export type AuditLogMinAggregateInputType = {
    id?: true
    challengeId?: true
    fieldName?: true
    oldValue?: true
    newValue?: true
    createdAt?: true
    createdBy?: true
    memberId?: true
  }

  export type AuditLogMaxAggregateInputType = {
    id?: true
    challengeId?: true
    fieldName?: true
    oldValue?: true
    newValue?: true
    createdAt?: true
    createdBy?: true
    memberId?: true
  }

  export type AuditLogCountAggregateInputType = {
    id?: true
    challengeId?: true
    fieldName?: true
    oldValue?: true
    newValue?: true
    createdAt?: true
    createdBy?: true
    memberId?: true
    _all?: true
  }

  export type AuditLogAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which AuditLog to aggregate.
     */
    where?: AuditLogWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AuditLogs to fetch.
     */
    orderBy?: AuditLogOrderByWithRelationInput | AuditLogOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: AuditLogWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AuditLogs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AuditLogs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned AuditLogs
    **/
    _count?: true | AuditLogCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: AuditLogMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: AuditLogMaxAggregateInputType
  }

  export type GetAuditLogAggregateType<T extends AuditLogAggregateArgs> = {
        [P in keyof T & keyof AggregateAuditLog]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateAuditLog[P]>
      : GetScalarType<T[P], AggregateAuditLog[P]>
  }




  export type AuditLogGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: AuditLogWhereInput
    orderBy?: AuditLogOrderByWithAggregationInput | AuditLogOrderByWithAggregationInput[]
    by: AuditLogScalarFieldEnum[] | AuditLogScalarFieldEnum
    having?: AuditLogScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: AuditLogCountAggregateInputType | true
    _min?: AuditLogMinAggregateInputType
    _max?: AuditLogMaxAggregateInputType
  }

  export type AuditLogGroupByOutputType = {
    id: string
    challengeId: string | null
    fieldName: string
    oldValue: string | null
    newValue: string | null
    createdAt: Date
    createdBy: string
    memberId: string | null
    _count: AuditLogCountAggregateOutputType | null
    _min: AuditLogMinAggregateOutputType | null
    _max: AuditLogMaxAggregateOutputType | null
  }

  type GetAuditLogGroupByPayload<T extends AuditLogGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<AuditLogGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof AuditLogGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], AuditLogGroupByOutputType[P]>
            : GetScalarType<T[P], AuditLogGroupByOutputType[P]>
        }
      >
    >


  export type AuditLogSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    challengeId?: boolean
    fieldName?: boolean
    oldValue?: boolean
    newValue?: boolean
    createdAt?: boolean
    createdBy?: boolean
    memberId?: boolean
    challenge?: boolean | AuditLog$challengeArgs<ExtArgs>
  }, ExtArgs["result"]["auditLog"]>

  export type AuditLogSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    challengeId?: boolean
    fieldName?: boolean
    oldValue?: boolean
    newValue?: boolean
    createdAt?: boolean
    createdBy?: boolean
    memberId?: boolean
    challenge?: boolean | AuditLog$challengeArgs<ExtArgs>
  }, ExtArgs["result"]["auditLog"]>

  export type AuditLogSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    challengeId?: boolean
    fieldName?: boolean
    oldValue?: boolean
    newValue?: boolean
    createdAt?: boolean
    createdBy?: boolean
    memberId?: boolean
    challenge?: boolean | AuditLog$challengeArgs<ExtArgs>
  }, ExtArgs["result"]["auditLog"]>

  export type AuditLogSelectScalar = {
    id?: boolean
    challengeId?: boolean
    fieldName?: boolean
    oldValue?: boolean
    newValue?: boolean
    createdAt?: boolean
    createdBy?: boolean
    memberId?: boolean
  }

  export type AuditLogOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "challengeId" | "fieldName" | "oldValue" | "newValue" | "createdAt" | "createdBy" | "memberId", ExtArgs["result"]["auditLog"]>
  export type AuditLogInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    challenge?: boolean | AuditLog$challengeArgs<ExtArgs>
  }
  export type AuditLogIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    challenge?: boolean | AuditLog$challengeArgs<ExtArgs>
  }
  export type AuditLogIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    challenge?: boolean | AuditLog$challengeArgs<ExtArgs>
  }

  export type $AuditLogPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "AuditLog"
    objects: {
      challenge: Prisma.$ChallengePayload<ExtArgs> | null
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      challengeId: string | null
      fieldName: string
      oldValue: string | null
      newValue: string | null
      createdAt: Date
      createdBy: string
      memberId: string | null
    }, ExtArgs["result"]["auditLog"]>
    composites: {}
  }

  type AuditLogGetPayload<S extends boolean | null | undefined | AuditLogDefaultArgs> = $Result.GetResult<Prisma.$AuditLogPayload, S>

  type AuditLogCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<AuditLogFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: AuditLogCountAggregateInputType | true
    }

  export interface AuditLogDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['AuditLog'], meta: { name: 'AuditLog' } }
    /**
     * Find zero or one AuditLog that matches the filter.
     * @param {AuditLogFindUniqueArgs} args - Arguments to find a AuditLog
     * @example
     * // Get one AuditLog
     * const auditLog = await prisma.auditLog.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends AuditLogFindUniqueArgs>(args: SelectSubset<T, AuditLogFindUniqueArgs<ExtArgs>>): Prisma__AuditLogClient<$Result.GetResult<Prisma.$AuditLogPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one AuditLog that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {AuditLogFindUniqueOrThrowArgs} args - Arguments to find a AuditLog
     * @example
     * // Get one AuditLog
     * const auditLog = await prisma.auditLog.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends AuditLogFindUniqueOrThrowArgs>(args: SelectSubset<T, AuditLogFindUniqueOrThrowArgs<ExtArgs>>): Prisma__AuditLogClient<$Result.GetResult<Prisma.$AuditLogPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first AuditLog that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AuditLogFindFirstArgs} args - Arguments to find a AuditLog
     * @example
     * // Get one AuditLog
     * const auditLog = await prisma.auditLog.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends AuditLogFindFirstArgs>(args?: SelectSubset<T, AuditLogFindFirstArgs<ExtArgs>>): Prisma__AuditLogClient<$Result.GetResult<Prisma.$AuditLogPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first AuditLog that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AuditLogFindFirstOrThrowArgs} args - Arguments to find a AuditLog
     * @example
     * // Get one AuditLog
     * const auditLog = await prisma.auditLog.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends AuditLogFindFirstOrThrowArgs>(args?: SelectSubset<T, AuditLogFindFirstOrThrowArgs<ExtArgs>>): Prisma__AuditLogClient<$Result.GetResult<Prisma.$AuditLogPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more AuditLogs that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AuditLogFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all AuditLogs
     * const auditLogs = await prisma.auditLog.findMany()
     * 
     * // Get first 10 AuditLogs
     * const auditLogs = await prisma.auditLog.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const auditLogWithIdOnly = await prisma.auditLog.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends AuditLogFindManyArgs>(args?: SelectSubset<T, AuditLogFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AuditLogPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a AuditLog.
     * @param {AuditLogCreateArgs} args - Arguments to create a AuditLog.
     * @example
     * // Create one AuditLog
     * const AuditLog = await prisma.auditLog.create({
     *   data: {
     *     // ... data to create a AuditLog
     *   }
     * })
     * 
     */
    create<T extends AuditLogCreateArgs>(args: SelectSubset<T, AuditLogCreateArgs<ExtArgs>>): Prisma__AuditLogClient<$Result.GetResult<Prisma.$AuditLogPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many AuditLogs.
     * @param {AuditLogCreateManyArgs} args - Arguments to create many AuditLogs.
     * @example
     * // Create many AuditLogs
     * const auditLog = await prisma.auditLog.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends AuditLogCreateManyArgs>(args?: SelectSubset<T, AuditLogCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many AuditLogs and returns the data saved in the database.
     * @param {AuditLogCreateManyAndReturnArgs} args - Arguments to create many AuditLogs.
     * @example
     * // Create many AuditLogs
     * const auditLog = await prisma.auditLog.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many AuditLogs and only return the `id`
     * const auditLogWithIdOnly = await prisma.auditLog.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends AuditLogCreateManyAndReturnArgs>(args?: SelectSubset<T, AuditLogCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AuditLogPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a AuditLog.
     * @param {AuditLogDeleteArgs} args - Arguments to delete one AuditLog.
     * @example
     * // Delete one AuditLog
     * const AuditLog = await prisma.auditLog.delete({
     *   where: {
     *     // ... filter to delete one AuditLog
     *   }
     * })
     * 
     */
    delete<T extends AuditLogDeleteArgs>(args: SelectSubset<T, AuditLogDeleteArgs<ExtArgs>>): Prisma__AuditLogClient<$Result.GetResult<Prisma.$AuditLogPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one AuditLog.
     * @param {AuditLogUpdateArgs} args - Arguments to update one AuditLog.
     * @example
     * // Update one AuditLog
     * const auditLog = await prisma.auditLog.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends AuditLogUpdateArgs>(args: SelectSubset<T, AuditLogUpdateArgs<ExtArgs>>): Prisma__AuditLogClient<$Result.GetResult<Prisma.$AuditLogPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more AuditLogs.
     * @param {AuditLogDeleteManyArgs} args - Arguments to filter AuditLogs to delete.
     * @example
     * // Delete a few AuditLogs
     * const { count } = await prisma.auditLog.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends AuditLogDeleteManyArgs>(args?: SelectSubset<T, AuditLogDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more AuditLogs.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AuditLogUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many AuditLogs
     * const auditLog = await prisma.auditLog.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends AuditLogUpdateManyArgs>(args: SelectSubset<T, AuditLogUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more AuditLogs and returns the data updated in the database.
     * @param {AuditLogUpdateManyAndReturnArgs} args - Arguments to update many AuditLogs.
     * @example
     * // Update many AuditLogs
     * const auditLog = await prisma.auditLog.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more AuditLogs and only return the `id`
     * const auditLogWithIdOnly = await prisma.auditLog.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends AuditLogUpdateManyAndReturnArgs>(args: SelectSubset<T, AuditLogUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AuditLogPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one AuditLog.
     * @param {AuditLogUpsertArgs} args - Arguments to update or create a AuditLog.
     * @example
     * // Update or create a AuditLog
     * const auditLog = await prisma.auditLog.upsert({
     *   create: {
     *     // ... data to create a AuditLog
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the AuditLog we want to update
     *   }
     * })
     */
    upsert<T extends AuditLogUpsertArgs>(args: SelectSubset<T, AuditLogUpsertArgs<ExtArgs>>): Prisma__AuditLogClient<$Result.GetResult<Prisma.$AuditLogPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of AuditLogs.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AuditLogCountArgs} args - Arguments to filter AuditLogs to count.
     * @example
     * // Count the number of AuditLogs
     * const count = await prisma.auditLog.count({
     *   where: {
     *     // ... the filter for the AuditLogs we want to count
     *   }
     * })
    **/
    count<T extends AuditLogCountArgs>(
      args?: Subset<T, AuditLogCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], AuditLogCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a AuditLog.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AuditLogAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends AuditLogAggregateArgs>(args: Subset<T, AuditLogAggregateArgs>): Prisma.PrismaPromise<GetAuditLogAggregateType<T>>

    /**
     * Group by AuditLog.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AuditLogGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends AuditLogGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: AuditLogGroupByArgs['orderBy'] }
        : { orderBy?: AuditLogGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, AuditLogGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetAuditLogGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the AuditLog model
   */
  readonly fields: AuditLogFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for AuditLog.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__AuditLogClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    challenge<T extends AuditLog$challengeArgs<ExtArgs> = {}>(args?: Subset<T, AuditLog$challengeArgs<ExtArgs>>): Prisma__ChallengeClient<$Result.GetResult<Prisma.$ChallengePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the AuditLog model
   */
  interface AuditLogFieldRefs {
    readonly id: FieldRef<"AuditLog", 'String'>
    readonly challengeId: FieldRef<"AuditLog", 'String'>
    readonly fieldName: FieldRef<"AuditLog", 'String'>
    readonly oldValue: FieldRef<"AuditLog", 'String'>
    readonly newValue: FieldRef<"AuditLog", 'String'>
    readonly createdAt: FieldRef<"AuditLog", 'DateTime'>
    readonly createdBy: FieldRef<"AuditLog", 'String'>
    readonly memberId: FieldRef<"AuditLog", 'String'>
  }
    

  // Custom InputTypes
  /**
   * AuditLog findUnique
   */
  export type AuditLogFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AuditLog
     */
    select?: AuditLogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AuditLog
     */
    omit?: AuditLogOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AuditLogInclude<ExtArgs> | null
    /**
     * Filter, which AuditLog to fetch.
     */
    where: AuditLogWhereUniqueInput
  }

  /**
   * AuditLog findUniqueOrThrow
   */
  export type AuditLogFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AuditLog
     */
    select?: AuditLogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AuditLog
     */
    omit?: AuditLogOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AuditLogInclude<ExtArgs> | null
    /**
     * Filter, which AuditLog to fetch.
     */
    where: AuditLogWhereUniqueInput
  }

  /**
   * AuditLog findFirst
   */
  export type AuditLogFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AuditLog
     */
    select?: AuditLogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AuditLog
     */
    omit?: AuditLogOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AuditLogInclude<ExtArgs> | null
    /**
     * Filter, which AuditLog to fetch.
     */
    where?: AuditLogWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AuditLogs to fetch.
     */
    orderBy?: AuditLogOrderByWithRelationInput | AuditLogOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for AuditLogs.
     */
    cursor?: AuditLogWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AuditLogs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AuditLogs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of AuditLogs.
     */
    distinct?: AuditLogScalarFieldEnum | AuditLogScalarFieldEnum[]
  }

  /**
   * AuditLog findFirstOrThrow
   */
  export type AuditLogFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AuditLog
     */
    select?: AuditLogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AuditLog
     */
    omit?: AuditLogOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AuditLogInclude<ExtArgs> | null
    /**
     * Filter, which AuditLog to fetch.
     */
    where?: AuditLogWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AuditLogs to fetch.
     */
    orderBy?: AuditLogOrderByWithRelationInput | AuditLogOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for AuditLogs.
     */
    cursor?: AuditLogWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AuditLogs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AuditLogs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of AuditLogs.
     */
    distinct?: AuditLogScalarFieldEnum | AuditLogScalarFieldEnum[]
  }

  /**
   * AuditLog findMany
   */
  export type AuditLogFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AuditLog
     */
    select?: AuditLogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AuditLog
     */
    omit?: AuditLogOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AuditLogInclude<ExtArgs> | null
    /**
     * Filter, which AuditLogs to fetch.
     */
    where?: AuditLogWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AuditLogs to fetch.
     */
    orderBy?: AuditLogOrderByWithRelationInput | AuditLogOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing AuditLogs.
     */
    cursor?: AuditLogWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AuditLogs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AuditLogs.
     */
    skip?: number
    distinct?: AuditLogScalarFieldEnum | AuditLogScalarFieldEnum[]
  }

  /**
   * AuditLog create
   */
  export type AuditLogCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AuditLog
     */
    select?: AuditLogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AuditLog
     */
    omit?: AuditLogOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AuditLogInclude<ExtArgs> | null
    /**
     * The data needed to create a AuditLog.
     */
    data: XOR<AuditLogCreateInput, AuditLogUncheckedCreateInput>
  }

  /**
   * AuditLog createMany
   */
  export type AuditLogCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many AuditLogs.
     */
    data: AuditLogCreateManyInput | AuditLogCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * AuditLog createManyAndReturn
   */
  export type AuditLogCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AuditLog
     */
    select?: AuditLogSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the AuditLog
     */
    omit?: AuditLogOmit<ExtArgs> | null
    /**
     * The data used to create many AuditLogs.
     */
    data: AuditLogCreateManyInput | AuditLogCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AuditLogIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * AuditLog update
   */
  export type AuditLogUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AuditLog
     */
    select?: AuditLogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AuditLog
     */
    omit?: AuditLogOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AuditLogInclude<ExtArgs> | null
    /**
     * The data needed to update a AuditLog.
     */
    data: XOR<AuditLogUpdateInput, AuditLogUncheckedUpdateInput>
    /**
     * Choose, which AuditLog to update.
     */
    where: AuditLogWhereUniqueInput
  }

  /**
   * AuditLog updateMany
   */
  export type AuditLogUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update AuditLogs.
     */
    data: XOR<AuditLogUpdateManyMutationInput, AuditLogUncheckedUpdateManyInput>
    /**
     * Filter which AuditLogs to update
     */
    where?: AuditLogWhereInput
    /**
     * Limit how many AuditLogs to update.
     */
    limit?: number
  }

  /**
   * AuditLog updateManyAndReturn
   */
  export type AuditLogUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AuditLog
     */
    select?: AuditLogSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the AuditLog
     */
    omit?: AuditLogOmit<ExtArgs> | null
    /**
     * The data used to update AuditLogs.
     */
    data: XOR<AuditLogUpdateManyMutationInput, AuditLogUncheckedUpdateManyInput>
    /**
     * Filter which AuditLogs to update
     */
    where?: AuditLogWhereInput
    /**
     * Limit how many AuditLogs to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AuditLogIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * AuditLog upsert
   */
  export type AuditLogUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AuditLog
     */
    select?: AuditLogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AuditLog
     */
    omit?: AuditLogOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AuditLogInclude<ExtArgs> | null
    /**
     * The filter to search for the AuditLog to update in case it exists.
     */
    where: AuditLogWhereUniqueInput
    /**
     * In case the AuditLog found by the `where` argument doesn't exist, create a new AuditLog with this data.
     */
    create: XOR<AuditLogCreateInput, AuditLogUncheckedCreateInput>
    /**
     * In case the AuditLog was found with the provided `where` argument, update it with this data.
     */
    update: XOR<AuditLogUpdateInput, AuditLogUncheckedUpdateInput>
  }

  /**
   * AuditLog delete
   */
  export type AuditLogDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AuditLog
     */
    select?: AuditLogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AuditLog
     */
    omit?: AuditLogOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AuditLogInclude<ExtArgs> | null
    /**
     * Filter which AuditLog to delete.
     */
    where: AuditLogWhereUniqueInput
  }

  /**
   * AuditLog deleteMany
   */
  export type AuditLogDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which AuditLogs to delete
     */
    where?: AuditLogWhereInput
    /**
     * Limit how many AuditLogs to delete.
     */
    limit?: number
  }

  /**
   * AuditLog.challenge
   */
  export type AuditLog$challengeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Challenge
     */
    select?: ChallengeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Challenge
     */
    omit?: ChallengeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ChallengeInclude<ExtArgs> | null
    where?: ChallengeWhereInput
  }

  /**
   * AuditLog without action
   */
  export type AuditLogDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AuditLog
     */
    select?: AuditLogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AuditLog
     */
    omit?: AuditLogOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AuditLogInclude<ExtArgs> | null
  }


  /**
   * Model Attachment
   */

  export type AggregateAttachment = {
    _count: AttachmentCountAggregateOutputType | null
    _avg: AttachmentAvgAggregateOutputType | null
    _sum: AttachmentSumAggregateOutputType | null
    _min: AttachmentMinAggregateOutputType | null
    _max: AttachmentMaxAggregateOutputType | null
  }

  export type AttachmentAvgAggregateOutputType = {
    fileSize: number | null
  }

  export type AttachmentSumAggregateOutputType = {
    fileSize: number | null
  }

  export type AttachmentMinAggregateOutputType = {
    id: string | null
    challengeId: string | null
    name: string | null
    fileSize: number | null
    url: string | null
    description: string | null
    createdAt: Date | null
    createdBy: string | null
    updatedAt: Date | null
    updatedBy: string | null
  }

  export type AttachmentMaxAggregateOutputType = {
    id: string | null
    challengeId: string | null
    name: string | null
    fileSize: number | null
    url: string | null
    description: string | null
    createdAt: Date | null
    createdBy: string | null
    updatedAt: Date | null
    updatedBy: string | null
  }

  export type AttachmentCountAggregateOutputType = {
    id: number
    challengeId: number
    name: number
    fileSize: number
    url: number
    description: number
    createdAt: number
    createdBy: number
    updatedAt: number
    updatedBy: number
    _all: number
  }


  export type AttachmentAvgAggregateInputType = {
    fileSize?: true
  }

  export type AttachmentSumAggregateInputType = {
    fileSize?: true
  }

  export type AttachmentMinAggregateInputType = {
    id?: true
    challengeId?: true
    name?: true
    fileSize?: true
    url?: true
    description?: true
    createdAt?: true
    createdBy?: true
    updatedAt?: true
    updatedBy?: true
  }

  export type AttachmentMaxAggregateInputType = {
    id?: true
    challengeId?: true
    name?: true
    fileSize?: true
    url?: true
    description?: true
    createdAt?: true
    createdBy?: true
    updatedAt?: true
    updatedBy?: true
  }

  export type AttachmentCountAggregateInputType = {
    id?: true
    challengeId?: true
    name?: true
    fileSize?: true
    url?: true
    description?: true
    createdAt?: true
    createdBy?: true
    updatedAt?: true
    updatedBy?: true
    _all?: true
  }

  export type AttachmentAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Attachment to aggregate.
     */
    where?: AttachmentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Attachments to fetch.
     */
    orderBy?: AttachmentOrderByWithRelationInput | AttachmentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: AttachmentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Attachments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Attachments.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Attachments
    **/
    _count?: true | AttachmentCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: AttachmentAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: AttachmentSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: AttachmentMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: AttachmentMaxAggregateInputType
  }

  export type GetAttachmentAggregateType<T extends AttachmentAggregateArgs> = {
        [P in keyof T & keyof AggregateAttachment]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateAttachment[P]>
      : GetScalarType<T[P], AggregateAttachment[P]>
  }




  export type AttachmentGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: AttachmentWhereInput
    orderBy?: AttachmentOrderByWithAggregationInput | AttachmentOrderByWithAggregationInput[]
    by: AttachmentScalarFieldEnum[] | AttachmentScalarFieldEnum
    having?: AttachmentScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: AttachmentCountAggregateInputType | true
    _avg?: AttachmentAvgAggregateInputType
    _sum?: AttachmentSumAggregateInputType
    _min?: AttachmentMinAggregateInputType
    _max?: AttachmentMaxAggregateInputType
  }

  export type AttachmentGroupByOutputType = {
    id: string
    challengeId: string
    name: string
    fileSize: number
    url: string
    description: string | null
    createdAt: Date
    createdBy: string
    updatedAt: Date
    updatedBy: string
    _count: AttachmentCountAggregateOutputType | null
    _avg: AttachmentAvgAggregateOutputType | null
    _sum: AttachmentSumAggregateOutputType | null
    _min: AttachmentMinAggregateOutputType | null
    _max: AttachmentMaxAggregateOutputType | null
  }

  type GetAttachmentGroupByPayload<T extends AttachmentGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<AttachmentGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof AttachmentGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], AttachmentGroupByOutputType[P]>
            : GetScalarType<T[P], AttachmentGroupByOutputType[P]>
        }
      >
    >


  export type AttachmentSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    challengeId?: boolean
    name?: boolean
    fileSize?: boolean
    url?: boolean
    description?: boolean
    createdAt?: boolean
    createdBy?: boolean
    updatedAt?: boolean
    updatedBy?: boolean
    challenge?: boolean | ChallengeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["attachment"]>

  export type AttachmentSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    challengeId?: boolean
    name?: boolean
    fileSize?: boolean
    url?: boolean
    description?: boolean
    createdAt?: boolean
    createdBy?: boolean
    updatedAt?: boolean
    updatedBy?: boolean
    challenge?: boolean | ChallengeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["attachment"]>

  export type AttachmentSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    challengeId?: boolean
    name?: boolean
    fileSize?: boolean
    url?: boolean
    description?: boolean
    createdAt?: boolean
    createdBy?: boolean
    updatedAt?: boolean
    updatedBy?: boolean
    challenge?: boolean | ChallengeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["attachment"]>

  export type AttachmentSelectScalar = {
    id?: boolean
    challengeId?: boolean
    name?: boolean
    fileSize?: boolean
    url?: boolean
    description?: boolean
    createdAt?: boolean
    createdBy?: boolean
    updatedAt?: boolean
    updatedBy?: boolean
  }

  export type AttachmentOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "challengeId" | "name" | "fileSize" | "url" | "description" | "createdAt" | "createdBy" | "updatedAt" | "updatedBy", ExtArgs["result"]["attachment"]>
  export type AttachmentInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    challenge?: boolean | ChallengeDefaultArgs<ExtArgs>
  }
  export type AttachmentIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    challenge?: boolean | ChallengeDefaultArgs<ExtArgs>
  }
  export type AttachmentIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    challenge?: boolean | ChallengeDefaultArgs<ExtArgs>
  }

  export type $AttachmentPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Attachment"
    objects: {
      challenge: Prisma.$ChallengePayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      challengeId: string
      name: string
      fileSize: number
      url: string
      description: string | null
      createdAt: Date
      createdBy: string
      updatedAt: Date
      updatedBy: string
    }, ExtArgs["result"]["attachment"]>
    composites: {}
  }

  type AttachmentGetPayload<S extends boolean | null | undefined | AttachmentDefaultArgs> = $Result.GetResult<Prisma.$AttachmentPayload, S>

  type AttachmentCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<AttachmentFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: AttachmentCountAggregateInputType | true
    }

  export interface AttachmentDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Attachment'], meta: { name: 'Attachment' } }
    /**
     * Find zero or one Attachment that matches the filter.
     * @param {AttachmentFindUniqueArgs} args - Arguments to find a Attachment
     * @example
     * // Get one Attachment
     * const attachment = await prisma.attachment.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends AttachmentFindUniqueArgs>(args: SelectSubset<T, AttachmentFindUniqueArgs<ExtArgs>>): Prisma__AttachmentClient<$Result.GetResult<Prisma.$AttachmentPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Attachment that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {AttachmentFindUniqueOrThrowArgs} args - Arguments to find a Attachment
     * @example
     * // Get one Attachment
     * const attachment = await prisma.attachment.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends AttachmentFindUniqueOrThrowArgs>(args: SelectSubset<T, AttachmentFindUniqueOrThrowArgs<ExtArgs>>): Prisma__AttachmentClient<$Result.GetResult<Prisma.$AttachmentPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Attachment that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AttachmentFindFirstArgs} args - Arguments to find a Attachment
     * @example
     * // Get one Attachment
     * const attachment = await prisma.attachment.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends AttachmentFindFirstArgs>(args?: SelectSubset<T, AttachmentFindFirstArgs<ExtArgs>>): Prisma__AttachmentClient<$Result.GetResult<Prisma.$AttachmentPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Attachment that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AttachmentFindFirstOrThrowArgs} args - Arguments to find a Attachment
     * @example
     * // Get one Attachment
     * const attachment = await prisma.attachment.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends AttachmentFindFirstOrThrowArgs>(args?: SelectSubset<T, AttachmentFindFirstOrThrowArgs<ExtArgs>>): Prisma__AttachmentClient<$Result.GetResult<Prisma.$AttachmentPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Attachments that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AttachmentFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Attachments
     * const attachments = await prisma.attachment.findMany()
     * 
     * // Get first 10 Attachments
     * const attachments = await prisma.attachment.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const attachmentWithIdOnly = await prisma.attachment.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends AttachmentFindManyArgs>(args?: SelectSubset<T, AttachmentFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AttachmentPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Attachment.
     * @param {AttachmentCreateArgs} args - Arguments to create a Attachment.
     * @example
     * // Create one Attachment
     * const Attachment = await prisma.attachment.create({
     *   data: {
     *     // ... data to create a Attachment
     *   }
     * })
     * 
     */
    create<T extends AttachmentCreateArgs>(args: SelectSubset<T, AttachmentCreateArgs<ExtArgs>>): Prisma__AttachmentClient<$Result.GetResult<Prisma.$AttachmentPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Attachments.
     * @param {AttachmentCreateManyArgs} args - Arguments to create many Attachments.
     * @example
     * // Create many Attachments
     * const attachment = await prisma.attachment.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends AttachmentCreateManyArgs>(args?: SelectSubset<T, AttachmentCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Attachments and returns the data saved in the database.
     * @param {AttachmentCreateManyAndReturnArgs} args - Arguments to create many Attachments.
     * @example
     * // Create many Attachments
     * const attachment = await prisma.attachment.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Attachments and only return the `id`
     * const attachmentWithIdOnly = await prisma.attachment.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends AttachmentCreateManyAndReturnArgs>(args?: SelectSubset<T, AttachmentCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AttachmentPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Attachment.
     * @param {AttachmentDeleteArgs} args - Arguments to delete one Attachment.
     * @example
     * // Delete one Attachment
     * const Attachment = await prisma.attachment.delete({
     *   where: {
     *     // ... filter to delete one Attachment
     *   }
     * })
     * 
     */
    delete<T extends AttachmentDeleteArgs>(args: SelectSubset<T, AttachmentDeleteArgs<ExtArgs>>): Prisma__AttachmentClient<$Result.GetResult<Prisma.$AttachmentPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Attachment.
     * @param {AttachmentUpdateArgs} args - Arguments to update one Attachment.
     * @example
     * // Update one Attachment
     * const attachment = await prisma.attachment.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends AttachmentUpdateArgs>(args: SelectSubset<T, AttachmentUpdateArgs<ExtArgs>>): Prisma__AttachmentClient<$Result.GetResult<Prisma.$AttachmentPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Attachments.
     * @param {AttachmentDeleteManyArgs} args - Arguments to filter Attachments to delete.
     * @example
     * // Delete a few Attachments
     * const { count } = await prisma.attachment.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends AttachmentDeleteManyArgs>(args?: SelectSubset<T, AttachmentDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Attachments.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AttachmentUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Attachments
     * const attachment = await prisma.attachment.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends AttachmentUpdateManyArgs>(args: SelectSubset<T, AttachmentUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Attachments and returns the data updated in the database.
     * @param {AttachmentUpdateManyAndReturnArgs} args - Arguments to update many Attachments.
     * @example
     * // Update many Attachments
     * const attachment = await prisma.attachment.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Attachments and only return the `id`
     * const attachmentWithIdOnly = await prisma.attachment.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends AttachmentUpdateManyAndReturnArgs>(args: SelectSubset<T, AttachmentUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AttachmentPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Attachment.
     * @param {AttachmentUpsertArgs} args - Arguments to update or create a Attachment.
     * @example
     * // Update or create a Attachment
     * const attachment = await prisma.attachment.upsert({
     *   create: {
     *     // ... data to create a Attachment
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Attachment we want to update
     *   }
     * })
     */
    upsert<T extends AttachmentUpsertArgs>(args: SelectSubset<T, AttachmentUpsertArgs<ExtArgs>>): Prisma__AttachmentClient<$Result.GetResult<Prisma.$AttachmentPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Attachments.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AttachmentCountArgs} args - Arguments to filter Attachments to count.
     * @example
     * // Count the number of Attachments
     * const count = await prisma.attachment.count({
     *   where: {
     *     // ... the filter for the Attachments we want to count
     *   }
     * })
    **/
    count<T extends AttachmentCountArgs>(
      args?: Subset<T, AttachmentCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], AttachmentCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Attachment.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AttachmentAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends AttachmentAggregateArgs>(args: Subset<T, AttachmentAggregateArgs>): Prisma.PrismaPromise<GetAttachmentAggregateType<T>>

    /**
     * Group by Attachment.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AttachmentGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends AttachmentGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: AttachmentGroupByArgs['orderBy'] }
        : { orderBy?: AttachmentGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, AttachmentGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetAttachmentGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Attachment model
   */
  readonly fields: AttachmentFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Attachment.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__AttachmentClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    challenge<T extends ChallengeDefaultArgs<ExtArgs> = {}>(args?: Subset<T, ChallengeDefaultArgs<ExtArgs>>): Prisma__ChallengeClient<$Result.GetResult<Prisma.$ChallengePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Attachment model
   */
  interface AttachmentFieldRefs {
    readonly id: FieldRef<"Attachment", 'String'>
    readonly challengeId: FieldRef<"Attachment", 'String'>
    readonly name: FieldRef<"Attachment", 'String'>
    readonly fileSize: FieldRef<"Attachment", 'Int'>
    readonly url: FieldRef<"Attachment", 'String'>
    readonly description: FieldRef<"Attachment", 'String'>
    readonly createdAt: FieldRef<"Attachment", 'DateTime'>
    readonly createdBy: FieldRef<"Attachment", 'String'>
    readonly updatedAt: FieldRef<"Attachment", 'DateTime'>
    readonly updatedBy: FieldRef<"Attachment", 'String'>
  }
    

  // Custom InputTypes
  /**
   * Attachment findUnique
   */
  export type AttachmentFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Attachment
     */
    select?: AttachmentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Attachment
     */
    omit?: AttachmentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AttachmentInclude<ExtArgs> | null
    /**
     * Filter, which Attachment to fetch.
     */
    where: AttachmentWhereUniqueInput
  }

  /**
   * Attachment findUniqueOrThrow
   */
  export type AttachmentFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Attachment
     */
    select?: AttachmentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Attachment
     */
    omit?: AttachmentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AttachmentInclude<ExtArgs> | null
    /**
     * Filter, which Attachment to fetch.
     */
    where: AttachmentWhereUniqueInput
  }

  /**
   * Attachment findFirst
   */
  export type AttachmentFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Attachment
     */
    select?: AttachmentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Attachment
     */
    omit?: AttachmentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AttachmentInclude<ExtArgs> | null
    /**
     * Filter, which Attachment to fetch.
     */
    where?: AttachmentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Attachments to fetch.
     */
    orderBy?: AttachmentOrderByWithRelationInput | AttachmentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Attachments.
     */
    cursor?: AttachmentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Attachments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Attachments.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Attachments.
     */
    distinct?: AttachmentScalarFieldEnum | AttachmentScalarFieldEnum[]
  }

  /**
   * Attachment findFirstOrThrow
   */
  export type AttachmentFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Attachment
     */
    select?: AttachmentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Attachment
     */
    omit?: AttachmentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AttachmentInclude<ExtArgs> | null
    /**
     * Filter, which Attachment to fetch.
     */
    where?: AttachmentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Attachments to fetch.
     */
    orderBy?: AttachmentOrderByWithRelationInput | AttachmentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Attachments.
     */
    cursor?: AttachmentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Attachments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Attachments.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Attachments.
     */
    distinct?: AttachmentScalarFieldEnum | AttachmentScalarFieldEnum[]
  }

  /**
   * Attachment findMany
   */
  export type AttachmentFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Attachment
     */
    select?: AttachmentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Attachment
     */
    omit?: AttachmentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AttachmentInclude<ExtArgs> | null
    /**
     * Filter, which Attachments to fetch.
     */
    where?: AttachmentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Attachments to fetch.
     */
    orderBy?: AttachmentOrderByWithRelationInput | AttachmentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Attachments.
     */
    cursor?: AttachmentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Attachments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Attachments.
     */
    skip?: number
    distinct?: AttachmentScalarFieldEnum | AttachmentScalarFieldEnum[]
  }

  /**
   * Attachment create
   */
  export type AttachmentCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Attachment
     */
    select?: AttachmentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Attachment
     */
    omit?: AttachmentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AttachmentInclude<ExtArgs> | null
    /**
     * The data needed to create a Attachment.
     */
    data: XOR<AttachmentCreateInput, AttachmentUncheckedCreateInput>
  }

  /**
   * Attachment createMany
   */
  export type AttachmentCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Attachments.
     */
    data: AttachmentCreateManyInput | AttachmentCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Attachment createManyAndReturn
   */
  export type AttachmentCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Attachment
     */
    select?: AttachmentSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Attachment
     */
    omit?: AttachmentOmit<ExtArgs> | null
    /**
     * The data used to create many Attachments.
     */
    data: AttachmentCreateManyInput | AttachmentCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AttachmentIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Attachment update
   */
  export type AttachmentUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Attachment
     */
    select?: AttachmentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Attachment
     */
    omit?: AttachmentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AttachmentInclude<ExtArgs> | null
    /**
     * The data needed to update a Attachment.
     */
    data: XOR<AttachmentUpdateInput, AttachmentUncheckedUpdateInput>
    /**
     * Choose, which Attachment to update.
     */
    where: AttachmentWhereUniqueInput
  }

  /**
   * Attachment updateMany
   */
  export type AttachmentUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Attachments.
     */
    data: XOR<AttachmentUpdateManyMutationInput, AttachmentUncheckedUpdateManyInput>
    /**
     * Filter which Attachments to update
     */
    where?: AttachmentWhereInput
    /**
     * Limit how many Attachments to update.
     */
    limit?: number
  }

  /**
   * Attachment updateManyAndReturn
   */
  export type AttachmentUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Attachment
     */
    select?: AttachmentSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Attachment
     */
    omit?: AttachmentOmit<ExtArgs> | null
    /**
     * The data used to update Attachments.
     */
    data: XOR<AttachmentUpdateManyMutationInput, AttachmentUncheckedUpdateManyInput>
    /**
     * Filter which Attachments to update
     */
    where?: AttachmentWhereInput
    /**
     * Limit how many Attachments to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AttachmentIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * Attachment upsert
   */
  export type AttachmentUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Attachment
     */
    select?: AttachmentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Attachment
     */
    omit?: AttachmentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AttachmentInclude<ExtArgs> | null
    /**
     * The filter to search for the Attachment to update in case it exists.
     */
    where: AttachmentWhereUniqueInput
    /**
     * In case the Attachment found by the `where` argument doesn't exist, create a new Attachment with this data.
     */
    create: XOR<AttachmentCreateInput, AttachmentUncheckedCreateInput>
    /**
     * In case the Attachment was found with the provided `where` argument, update it with this data.
     */
    update: XOR<AttachmentUpdateInput, AttachmentUncheckedUpdateInput>
  }

  /**
   * Attachment delete
   */
  export type AttachmentDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Attachment
     */
    select?: AttachmentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Attachment
     */
    omit?: AttachmentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AttachmentInclude<ExtArgs> | null
    /**
     * Filter which Attachment to delete.
     */
    where: AttachmentWhereUniqueInput
  }

  /**
   * Attachment deleteMany
   */
  export type AttachmentDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Attachments to delete
     */
    where?: AttachmentWhereInput
    /**
     * Limit how many Attachments to delete.
     */
    limit?: number
  }

  /**
   * Attachment without action
   */
  export type AttachmentDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Attachment
     */
    select?: AttachmentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Attachment
     */
    omit?: AttachmentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AttachmentInclude<ExtArgs> | null
  }


  /**
   * Model ChallengeMetadata
   */

  export type AggregateChallengeMetadata = {
    _count: ChallengeMetadataCountAggregateOutputType | null
    _min: ChallengeMetadataMinAggregateOutputType | null
    _max: ChallengeMetadataMaxAggregateOutputType | null
  }

  export type ChallengeMetadataMinAggregateOutputType = {
    id: string | null
    challengeId: string | null
    name: string | null
    value: string | null
    createdAt: Date | null
    createdBy: string | null
    updatedAt: Date | null
    updatedBy: string | null
  }

  export type ChallengeMetadataMaxAggregateOutputType = {
    id: string | null
    challengeId: string | null
    name: string | null
    value: string | null
    createdAt: Date | null
    createdBy: string | null
    updatedAt: Date | null
    updatedBy: string | null
  }

  export type ChallengeMetadataCountAggregateOutputType = {
    id: number
    challengeId: number
    name: number
    value: number
    createdAt: number
    createdBy: number
    updatedAt: number
    updatedBy: number
    _all: number
  }


  export type ChallengeMetadataMinAggregateInputType = {
    id?: true
    challengeId?: true
    name?: true
    value?: true
    createdAt?: true
    createdBy?: true
    updatedAt?: true
    updatedBy?: true
  }

  export type ChallengeMetadataMaxAggregateInputType = {
    id?: true
    challengeId?: true
    name?: true
    value?: true
    createdAt?: true
    createdBy?: true
    updatedAt?: true
    updatedBy?: true
  }

  export type ChallengeMetadataCountAggregateInputType = {
    id?: true
    challengeId?: true
    name?: true
    value?: true
    createdAt?: true
    createdBy?: true
    updatedAt?: true
    updatedBy?: true
    _all?: true
  }

  export type ChallengeMetadataAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ChallengeMetadata to aggregate.
     */
    where?: ChallengeMetadataWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ChallengeMetadata to fetch.
     */
    orderBy?: ChallengeMetadataOrderByWithRelationInput | ChallengeMetadataOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ChallengeMetadataWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ChallengeMetadata from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ChallengeMetadata.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned ChallengeMetadata
    **/
    _count?: true | ChallengeMetadataCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ChallengeMetadataMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ChallengeMetadataMaxAggregateInputType
  }

  export type GetChallengeMetadataAggregateType<T extends ChallengeMetadataAggregateArgs> = {
        [P in keyof T & keyof AggregateChallengeMetadata]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateChallengeMetadata[P]>
      : GetScalarType<T[P], AggregateChallengeMetadata[P]>
  }




  export type ChallengeMetadataGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ChallengeMetadataWhereInput
    orderBy?: ChallengeMetadataOrderByWithAggregationInput | ChallengeMetadataOrderByWithAggregationInput[]
    by: ChallengeMetadataScalarFieldEnum[] | ChallengeMetadataScalarFieldEnum
    having?: ChallengeMetadataScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ChallengeMetadataCountAggregateInputType | true
    _min?: ChallengeMetadataMinAggregateInputType
    _max?: ChallengeMetadataMaxAggregateInputType
  }

  export type ChallengeMetadataGroupByOutputType = {
    id: string
    challengeId: string
    name: string
    value: string
    createdAt: Date
    createdBy: string
    updatedAt: Date
    updatedBy: string
    _count: ChallengeMetadataCountAggregateOutputType | null
    _min: ChallengeMetadataMinAggregateOutputType | null
    _max: ChallengeMetadataMaxAggregateOutputType | null
  }

  type GetChallengeMetadataGroupByPayload<T extends ChallengeMetadataGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ChallengeMetadataGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ChallengeMetadataGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ChallengeMetadataGroupByOutputType[P]>
            : GetScalarType<T[P], ChallengeMetadataGroupByOutputType[P]>
        }
      >
    >


  export type ChallengeMetadataSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    challengeId?: boolean
    name?: boolean
    value?: boolean
    createdAt?: boolean
    createdBy?: boolean
    updatedAt?: boolean
    updatedBy?: boolean
    challenge?: boolean | ChallengeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["challengeMetadata"]>

  export type ChallengeMetadataSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    challengeId?: boolean
    name?: boolean
    value?: boolean
    createdAt?: boolean
    createdBy?: boolean
    updatedAt?: boolean
    updatedBy?: boolean
    challenge?: boolean | ChallengeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["challengeMetadata"]>

  export type ChallengeMetadataSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    challengeId?: boolean
    name?: boolean
    value?: boolean
    createdAt?: boolean
    createdBy?: boolean
    updatedAt?: boolean
    updatedBy?: boolean
    challenge?: boolean | ChallengeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["challengeMetadata"]>

  export type ChallengeMetadataSelectScalar = {
    id?: boolean
    challengeId?: boolean
    name?: boolean
    value?: boolean
    createdAt?: boolean
    createdBy?: boolean
    updatedAt?: boolean
    updatedBy?: boolean
  }

  export type ChallengeMetadataOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "challengeId" | "name" | "value" | "createdAt" | "createdBy" | "updatedAt" | "updatedBy", ExtArgs["result"]["challengeMetadata"]>
  export type ChallengeMetadataInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    challenge?: boolean | ChallengeDefaultArgs<ExtArgs>
  }
  export type ChallengeMetadataIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    challenge?: boolean | ChallengeDefaultArgs<ExtArgs>
  }
  export type ChallengeMetadataIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    challenge?: boolean | ChallengeDefaultArgs<ExtArgs>
  }

  export type $ChallengeMetadataPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "ChallengeMetadata"
    objects: {
      challenge: Prisma.$ChallengePayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      challengeId: string
      name: string
      value: string
      createdAt: Date
      createdBy: string
      updatedAt: Date
      updatedBy: string
    }, ExtArgs["result"]["challengeMetadata"]>
    composites: {}
  }

  type ChallengeMetadataGetPayload<S extends boolean | null | undefined | ChallengeMetadataDefaultArgs> = $Result.GetResult<Prisma.$ChallengeMetadataPayload, S>

  type ChallengeMetadataCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<ChallengeMetadataFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: ChallengeMetadataCountAggregateInputType | true
    }

  export interface ChallengeMetadataDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['ChallengeMetadata'], meta: { name: 'ChallengeMetadata' } }
    /**
     * Find zero or one ChallengeMetadata that matches the filter.
     * @param {ChallengeMetadataFindUniqueArgs} args - Arguments to find a ChallengeMetadata
     * @example
     * // Get one ChallengeMetadata
     * const challengeMetadata = await prisma.challengeMetadata.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends ChallengeMetadataFindUniqueArgs>(args: SelectSubset<T, ChallengeMetadataFindUniqueArgs<ExtArgs>>): Prisma__ChallengeMetadataClient<$Result.GetResult<Prisma.$ChallengeMetadataPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one ChallengeMetadata that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {ChallengeMetadataFindUniqueOrThrowArgs} args - Arguments to find a ChallengeMetadata
     * @example
     * // Get one ChallengeMetadata
     * const challengeMetadata = await prisma.challengeMetadata.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends ChallengeMetadataFindUniqueOrThrowArgs>(args: SelectSubset<T, ChallengeMetadataFindUniqueOrThrowArgs<ExtArgs>>): Prisma__ChallengeMetadataClient<$Result.GetResult<Prisma.$ChallengeMetadataPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first ChallengeMetadata that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ChallengeMetadataFindFirstArgs} args - Arguments to find a ChallengeMetadata
     * @example
     * // Get one ChallengeMetadata
     * const challengeMetadata = await prisma.challengeMetadata.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends ChallengeMetadataFindFirstArgs>(args?: SelectSubset<T, ChallengeMetadataFindFirstArgs<ExtArgs>>): Prisma__ChallengeMetadataClient<$Result.GetResult<Prisma.$ChallengeMetadataPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first ChallengeMetadata that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ChallengeMetadataFindFirstOrThrowArgs} args - Arguments to find a ChallengeMetadata
     * @example
     * // Get one ChallengeMetadata
     * const challengeMetadata = await prisma.challengeMetadata.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends ChallengeMetadataFindFirstOrThrowArgs>(args?: SelectSubset<T, ChallengeMetadataFindFirstOrThrowArgs<ExtArgs>>): Prisma__ChallengeMetadataClient<$Result.GetResult<Prisma.$ChallengeMetadataPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more ChallengeMetadata that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ChallengeMetadataFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all ChallengeMetadata
     * const challengeMetadata = await prisma.challengeMetadata.findMany()
     * 
     * // Get first 10 ChallengeMetadata
     * const challengeMetadata = await prisma.challengeMetadata.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const challengeMetadataWithIdOnly = await prisma.challengeMetadata.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends ChallengeMetadataFindManyArgs>(args?: SelectSubset<T, ChallengeMetadataFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ChallengeMetadataPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a ChallengeMetadata.
     * @param {ChallengeMetadataCreateArgs} args - Arguments to create a ChallengeMetadata.
     * @example
     * // Create one ChallengeMetadata
     * const ChallengeMetadata = await prisma.challengeMetadata.create({
     *   data: {
     *     // ... data to create a ChallengeMetadata
     *   }
     * })
     * 
     */
    create<T extends ChallengeMetadataCreateArgs>(args: SelectSubset<T, ChallengeMetadataCreateArgs<ExtArgs>>): Prisma__ChallengeMetadataClient<$Result.GetResult<Prisma.$ChallengeMetadataPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many ChallengeMetadata.
     * @param {ChallengeMetadataCreateManyArgs} args - Arguments to create many ChallengeMetadata.
     * @example
     * // Create many ChallengeMetadata
     * const challengeMetadata = await prisma.challengeMetadata.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends ChallengeMetadataCreateManyArgs>(args?: SelectSubset<T, ChallengeMetadataCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many ChallengeMetadata and returns the data saved in the database.
     * @param {ChallengeMetadataCreateManyAndReturnArgs} args - Arguments to create many ChallengeMetadata.
     * @example
     * // Create many ChallengeMetadata
     * const challengeMetadata = await prisma.challengeMetadata.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many ChallengeMetadata and only return the `id`
     * const challengeMetadataWithIdOnly = await prisma.challengeMetadata.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends ChallengeMetadataCreateManyAndReturnArgs>(args?: SelectSubset<T, ChallengeMetadataCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ChallengeMetadataPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a ChallengeMetadata.
     * @param {ChallengeMetadataDeleteArgs} args - Arguments to delete one ChallengeMetadata.
     * @example
     * // Delete one ChallengeMetadata
     * const ChallengeMetadata = await prisma.challengeMetadata.delete({
     *   where: {
     *     // ... filter to delete one ChallengeMetadata
     *   }
     * })
     * 
     */
    delete<T extends ChallengeMetadataDeleteArgs>(args: SelectSubset<T, ChallengeMetadataDeleteArgs<ExtArgs>>): Prisma__ChallengeMetadataClient<$Result.GetResult<Prisma.$ChallengeMetadataPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one ChallengeMetadata.
     * @param {ChallengeMetadataUpdateArgs} args - Arguments to update one ChallengeMetadata.
     * @example
     * // Update one ChallengeMetadata
     * const challengeMetadata = await prisma.challengeMetadata.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends ChallengeMetadataUpdateArgs>(args: SelectSubset<T, ChallengeMetadataUpdateArgs<ExtArgs>>): Prisma__ChallengeMetadataClient<$Result.GetResult<Prisma.$ChallengeMetadataPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more ChallengeMetadata.
     * @param {ChallengeMetadataDeleteManyArgs} args - Arguments to filter ChallengeMetadata to delete.
     * @example
     * // Delete a few ChallengeMetadata
     * const { count } = await prisma.challengeMetadata.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends ChallengeMetadataDeleteManyArgs>(args?: SelectSubset<T, ChallengeMetadataDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more ChallengeMetadata.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ChallengeMetadataUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many ChallengeMetadata
     * const challengeMetadata = await prisma.challengeMetadata.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends ChallengeMetadataUpdateManyArgs>(args: SelectSubset<T, ChallengeMetadataUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more ChallengeMetadata and returns the data updated in the database.
     * @param {ChallengeMetadataUpdateManyAndReturnArgs} args - Arguments to update many ChallengeMetadata.
     * @example
     * // Update many ChallengeMetadata
     * const challengeMetadata = await prisma.challengeMetadata.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more ChallengeMetadata and only return the `id`
     * const challengeMetadataWithIdOnly = await prisma.challengeMetadata.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends ChallengeMetadataUpdateManyAndReturnArgs>(args: SelectSubset<T, ChallengeMetadataUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ChallengeMetadataPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one ChallengeMetadata.
     * @param {ChallengeMetadataUpsertArgs} args - Arguments to update or create a ChallengeMetadata.
     * @example
     * // Update or create a ChallengeMetadata
     * const challengeMetadata = await prisma.challengeMetadata.upsert({
     *   create: {
     *     // ... data to create a ChallengeMetadata
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the ChallengeMetadata we want to update
     *   }
     * })
     */
    upsert<T extends ChallengeMetadataUpsertArgs>(args: SelectSubset<T, ChallengeMetadataUpsertArgs<ExtArgs>>): Prisma__ChallengeMetadataClient<$Result.GetResult<Prisma.$ChallengeMetadataPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of ChallengeMetadata.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ChallengeMetadataCountArgs} args - Arguments to filter ChallengeMetadata to count.
     * @example
     * // Count the number of ChallengeMetadata
     * const count = await prisma.challengeMetadata.count({
     *   where: {
     *     // ... the filter for the ChallengeMetadata we want to count
     *   }
     * })
    **/
    count<T extends ChallengeMetadataCountArgs>(
      args?: Subset<T, ChallengeMetadataCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ChallengeMetadataCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a ChallengeMetadata.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ChallengeMetadataAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ChallengeMetadataAggregateArgs>(args: Subset<T, ChallengeMetadataAggregateArgs>): Prisma.PrismaPromise<GetChallengeMetadataAggregateType<T>>

    /**
     * Group by ChallengeMetadata.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ChallengeMetadataGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ChallengeMetadataGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ChallengeMetadataGroupByArgs['orderBy'] }
        : { orderBy?: ChallengeMetadataGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ChallengeMetadataGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetChallengeMetadataGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the ChallengeMetadata model
   */
  readonly fields: ChallengeMetadataFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for ChallengeMetadata.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ChallengeMetadataClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    challenge<T extends ChallengeDefaultArgs<ExtArgs> = {}>(args?: Subset<T, ChallengeDefaultArgs<ExtArgs>>): Prisma__ChallengeClient<$Result.GetResult<Prisma.$ChallengePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the ChallengeMetadata model
   */
  interface ChallengeMetadataFieldRefs {
    readonly id: FieldRef<"ChallengeMetadata", 'String'>
    readonly challengeId: FieldRef<"ChallengeMetadata", 'String'>
    readonly name: FieldRef<"ChallengeMetadata", 'String'>
    readonly value: FieldRef<"ChallengeMetadata", 'String'>
    readonly createdAt: FieldRef<"ChallengeMetadata", 'DateTime'>
    readonly createdBy: FieldRef<"ChallengeMetadata", 'String'>
    readonly updatedAt: FieldRef<"ChallengeMetadata", 'DateTime'>
    readonly updatedBy: FieldRef<"ChallengeMetadata", 'String'>
  }
    

  // Custom InputTypes
  /**
   * ChallengeMetadata findUnique
   */
  export type ChallengeMetadataFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ChallengeMetadata
     */
    select?: ChallengeMetadataSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ChallengeMetadata
     */
    omit?: ChallengeMetadataOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ChallengeMetadataInclude<ExtArgs> | null
    /**
     * Filter, which ChallengeMetadata to fetch.
     */
    where: ChallengeMetadataWhereUniqueInput
  }

  /**
   * ChallengeMetadata findUniqueOrThrow
   */
  export type ChallengeMetadataFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ChallengeMetadata
     */
    select?: ChallengeMetadataSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ChallengeMetadata
     */
    omit?: ChallengeMetadataOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ChallengeMetadataInclude<ExtArgs> | null
    /**
     * Filter, which ChallengeMetadata to fetch.
     */
    where: ChallengeMetadataWhereUniqueInput
  }

  /**
   * ChallengeMetadata findFirst
   */
  export type ChallengeMetadataFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ChallengeMetadata
     */
    select?: ChallengeMetadataSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ChallengeMetadata
     */
    omit?: ChallengeMetadataOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ChallengeMetadataInclude<ExtArgs> | null
    /**
     * Filter, which ChallengeMetadata to fetch.
     */
    where?: ChallengeMetadataWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ChallengeMetadata to fetch.
     */
    orderBy?: ChallengeMetadataOrderByWithRelationInput | ChallengeMetadataOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ChallengeMetadata.
     */
    cursor?: ChallengeMetadataWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ChallengeMetadata from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ChallengeMetadata.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ChallengeMetadata.
     */
    distinct?: ChallengeMetadataScalarFieldEnum | ChallengeMetadataScalarFieldEnum[]
  }

  /**
   * ChallengeMetadata findFirstOrThrow
   */
  export type ChallengeMetadataFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ChallengeMetadata
     */
    select?: ChallengeMetadataSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ChallengeMetadata
     */
    omit?: ChallengeMetadataOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ChallengeMetadataInclude<ExtArgs> | null
    /**
     * Filter, which ChallengeMetadata to fetch.
     */
    where?: ChallengeMetadataWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ChallengeMetadata to fetch.
     */
    orderBy?: ChallengeMetadataOrderByWithRelationInput | ChallengeMetadataOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ChallengeMetadata.
     */
    cursor?: ChallengeMetadataWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ChallengeMetadata from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ChallengeMetadata.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ChallengeMetadata.
     */
    distinct?: ChallengeMetadataScalarFieldEnum | ChallengeMetadataScalarFieldEnum[]
  }

  /**
   * ChallengeMetadata findMany
   */
  export type ChallengeMetadataFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ChallengeMetadata
     */
    select?: ChallengeMetadataSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ChallengeMetadata
     */
    omit?: ChallengeMetadataOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ChallengeMetadataInclude<ExtArgs> | null
    /**
     * Filter, which ChallengeMetadata to fetch.
     */
    where?: ChallengeMetadataWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ChallengeMetadata to fetch.
     */
    orderBy?: ChallengeMetadataOrderByWithRelationInput | ChallengeMetadataOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing ChallengeMetadata.
     */
    cursor?: ChallengeMetadataWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ChallengeMetadata from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ChallengeMetadata.
     */
    skip?: number
    distinct?: ChallengeMetadataScalarFieldEnum | ChallengeMetadataScalarFieldEnum[]
  }

  /**
   * ChallengeMetadata create
   */
  export type ChallengeMetadataCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ChallengeMetadata
     */
    select?: ChallengeMetadataSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ChallengeMetadata
     */
    omit?: ChallengeMetadataOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ChallengeMetadataInclude<ExtArgs> | null
    /**
     * The data needed to create a ChallengeMetadata.
     */
    data: XOR<ChallengeMetadataCreateInput, ChallengeMetadataUncheckedCreateInput>
  }

  /**
   * ChallengeMetadata createMany
   */
  export type ChallengeMetadataCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many ChallengeMetadata.
     */
    data: ChallengeMetadataCreateManyInput | ChallengeMetadataCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * ChallengeMetadata createManyAndReturn
   */
  export type ChallengeMetadataCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ChallengeMetadata
     */
    select?: ChallengeMetadataSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the ChallengeMetadata
     */
    omit?: ChallengeMetadataOmit<ExtArgs> | null
    /**
     * The data used to create many ChallengeMetadata.
     */
    data: ChallengeMetadataCreateManyInput | ChallengeMetadataCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ChallengeMetadataIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * ChallengeMetadata update
   */
  export type ChallengeMetadataUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ChallengeMetadata
     */
    select?: ChallengeMetadataSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ChallengeMetadata
     */
    omit?: ChallengeMetadataOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ChallengeMetadataInclude<ExtArgs> | null
    /**
     * The data needed to update a ChallengeMetadata.
     */
    data: XOR<ChallengeMetadataUpdateInput, ChallengeMetadataUncheckedUpdateInput>
    /**
     * Choose, which ChallengeMetadata to update.
     */
    where: ChallengeMetadataWhereUniqueInput
  }

  /**
   * ChallengeMetadata updateMany
   */
  export type ChallengeMetadataUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update ChallengeMetadata.
     */
    data: XOR<ChallengeMetadataUpdateManyMutationInput, ChallengeMetadataUncheckedUpdateManyInput>
    /**
     * Filter which ChallengeMetadata to update
     */
    where?: ChallengeMetadataWhereInput
    /**
     * Limit how many ChallengeMetadata to update.
     */
    limit?: number
  }

  /**
   * ChallengeMetadata updateManyAndReturn
   */
  export type ChallengeMetadataUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ChallengeMetadata
     */
    select?: ChallengeMetadataSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the ChallengeMetadata
     */
    omit?: ChallengeMetadataOmit<ExtArgs> | null
    /**
     * The data used to update ChallengeMetadata.
     */
    data: XOR<ChallengeMetadataUpdateManyMutationInput, ChallengeMetadataUncheckedUpdateManyInput>
    /**
     * Filter which ChallengeMetadata to update
     */
    where?: ChallengeMetadataWhereInput
    /**
     * Limit how many ChallengeMetadata to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ChallengeMetadataIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * ChallengeMetadata upsert
   */
  export type ChallengeMetadataUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ChallengeMetadata
     */
    select?: ChallengeMetadataSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ChallengeMetadata
     */
    omit?: ChallengeMetadataOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ChallengeMetadataInclude<ExtArgs> | null
    /**
     * The filter to search for the ChallengeMetadata to update in case it exists.
     */
    where: ChallengeMetadataWhereUniqueInput
    /**
     * In case the ChallengeMetadata found by the `where` argument doesn't exist, create a new ChallengeMetadata with this data.
     */
    create: XOR<ChallengeMetadataCreateInput, ChallengeMetadataUncheckedCreateInput>
    /**
     * In case the ChallengeMetadata was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ChallengeMetadataUpdateInput, ChallengeMetadataUncheckedUpdateInput>
  }

  /**
   * ChallengeMetadata delete
   */
  export type ChallengeMetadataDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ChallengeMetadata
     */
    select?: ChallengeMetadataSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ChallengeMetadata
     */
    omit?: ChallengeMetadataOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ChallengeMetadataInclude<ExtArgs> | null
    /**
     * Filter which ChallengeMetadata to delete.
     */
    where: ChallengeMetadataWhereUniqueInput
  }

  /**
   * ChallengeMetadata deleteMany
   */
  export type ChallengeMetadataDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ChallengeMetadata to delete
     */
    where?: ChallengeMetadataWhereInput
    /**
     * Limit how many ChallengeMetadata to delete.
     */
    limit?: number
  }

  /**
   * ChallengeMetadata without action
   */
  export type ChallengeMetadataDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ChallengeMetadata
     */
    select?: ChallengeMetadataSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ChallengeMetadata
     */
    omit?: ChallengeMetadataOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ChallengeMetadataInclude<ExtArgs> | null
  }


  /**
   * Model Prize
   */

  export type AggregatePrize = {
    _count: PrizeCountAggregateOutputType | null
    _avg: PrizeAvgAggregateOutputType | null
    _sum: PrizeSumAggregateOutputType | null
    _min: PrizeMinAggregateOutputType | null
    _max: PrizeMaxAggregateOutputType | null
  }

  export type PrizeAvgAggregateOutputType = {
    value: number | null
  }

  export type PrizeSumAggregateOutputType = {
    value: number | null
  }

  export type PrizeMinAggregateOutputType = {
    id: string | null
    description: string | null
    prizeSetId: string | null
    type: string | null
    value: number | null
    createdAt: Date | null
    createdBy: string | null
    updatedAt: Date | null
    updatedBy: string | null
  }

  export type PrizeMaxAggregateOutputType = {
    id: string | null
    description: string | null
    prizeSetId: string | null
    type: string | null
    value: number | null
    createdAt: Date | null
    createdBy: string | null
    updatedAt: Date | null
    updatedBy: string | null
  }

  export type PrizeCountAggregateOutputType = {
    id: number
    description: number
    prizeSetId: number
    type: number
    value: number
    createdAt: number
    createdBy: number
    updatedAt: number
    updatedBy: number
    _all: number
  }


  export type PrizeAvgAggregateInputType = {
    value?: true
  }

  export type PrizeSumAggregateInputType = {
    value?: true
  }

  export type PrizeMinAggregateInputType = {
    id?: true
    description?: true
    prizeSetId?: true
    type?: true
    value?: true
    createdAt?: true
    createdBy?: true
    updatedAt?: true
    updatedBy?: true
  }

  export type PrizeMaxAggregateInputType = {
    id?: true
    description?: true
    prizeSetId?: true
    type?: true
    value?: true
    createdAt?: true
    createdBy?: true
    updatedAt?: true
    updatedBy?: true
  }

  export type PrizeCountAggregateInputType = {
    id?: true
    description?: true
    prizeSetId?: true
    type?: true
    value?: true
    createdAt?: true
    createdBy?: true
    updatedAt?: true
    updatedBy?: true
    _all?: true
  }

  export type PrizeAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Prize to aggregate.
     */
    where?: PrizeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Prizes to fetch.
     */
    orderBy?: PrizeOrderByWithRelationInput | PrizeOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: PrizeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Prizes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Prizes.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Prizes
    **/
    _count?: true | PrizeCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: PrizeAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: PrizeSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: PrizeMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: PrizeMaxAggregateInputType
  }

  export type GetPrizeAggregateType<T extends PrizeAggregateArgs> = {
        [P in keyof T & keyof AggregatePrize]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregatePrize[P]>
      : GetScalarType<T[P], AggregatePrize[P]>
  }




  export type PrizeGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PrizeWhereInput
    orderBy?: PrizeOrderByWithAggregationInput | PrizeOrderByWithAggregationInput[]
    by: PrizeScalarFieldEnum[] | PrizeScalarFieldEnum
    having?: PrizeScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: PrizeCountAggregateInputType | true
    _avg?: PrizeAvgAggregateInputType
    _sum?: PrizeSumAggregateInputType
    _min?: PrizeMinAggregateInputType
    _max?: PrizeMaxAggregateInputType
  }

  export type PrizeGroupByOutputType = {
    id: string
    description: string | null
    prizeSetId: string
    type: string
    value: number
    createdAt: Date
    createdBy: string
    updatedAt: Date
    updatedBy: string
    _count: PrizeCountAggregateOutputType | null
    _avg: PrizeAvgAggregateOutputType | null
    _sum: PrizeSumAggregateOutputType | null
    _min: PrizeMinAggregateOutputType | null
    _max: PrizeMaxAggregateOutputType | null
  }

  type GetPrizeGroupByPayload<T extends PrizeGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<PrizeGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof PrizeGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], PrizeGroupByOutputType[P]>
            : GetScalarType<T[P], PrizeGroupByOutputType[P]>
        }
      >
    >


  export type PrizeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    description?: boolean
    prizeSetId?: boolean
    type?: boolean
    value?: boolean
    createdAt?: boolean
    createdBy?: boolean
    updatedAt?: boolean
    updatedBy?: boolean
    prizeSet?: boolean | ChallengePrizeSetDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["prize"]>

  export type PrizeSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    description?: boolean
    prizeSetId?: boolean
    type?: boolean
    value?: boolean
    createdAt?: boolean
    createdBy?: boolean
    updatedAt?: boolean
    updatedBy?: boolean
    prizeSet?: boolean | ChallengePrizeSetDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["prize"]>

  export type PrizeSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    description?: boolean
    prizeSetId?: boolean
    type?: boolean
    value?: boolean
    createdAt?: boolean
    createdBy?: boolean
    updatedAt?: boolean
    updatedBy?: boolean
    prizeSet?: boolean | ChallengePrizeSetDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["prize"]>

  export type PrizeSelectScalar = {
    id?: boolean
    description?: boolean
    prizeSetId?: boolean
    type?: boolean
    value?: boolean
    createdAt?: boolean
    createdBy?: boolean
    updatedAt?: boolean
    updatedBy?: boolean
  }

  export type PrizeOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "description" | "prizeSetId" | "type" | "value" | "createdAt" | "createdBy" | "updatedAt" | "updatedBy", ExtArgs["result"]["prize"]>
  export type PrizeInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    prizeSet?: boolean | ChallengePrizeSetDefaultArgs<ExtArgs>
  }
  export type PrizeIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    prizeSet?: boolean | ChallengePrizeSetDefaultArgs<ExtArgs>
  }
  export type PrizeIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    prizeSet?: boolean | ChallengePrizeSetDefaultArgs<ExtArgs>
  }

  export type $PrizePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Prize"
    objects: {
      prizeSet: Prisma.$ChallengePrizeSetPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      description: string | null
      prizeSetId: string
      type: string
      value: number
      createdAt: Date
      createdBy: string
      updatedAt: Date
      updatedBy: string
    }, ExtArgs["result"]["prize"]>
    composites: {}
  }

  type PrizeGetPayload<S extends boolean | null | undefined | PrizeDefaultArgs> = $Result.GetResult<Prisma.$PrizePayload, S>

  type PrizeCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<PrizeFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: PrizeCountAggregateInputType | true
    }

  export interface PrizeDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Prize'], meta: { name: 'Prize' } }
    /**
     * Find zero or one Prize that matches the filter.
     * @param {PrizeFindUniqueArgs} args - Arguments to find a Prize
     * @example
     * // Get one Prize
     * const prize = await prisma.prize.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends PrizeFindUniqueArgs>(args: SelectSubset<T, PrizeFindUniqueArgs<ExtArgs>>): Prisma__PrizeClient<$Result.GetResult<Prisma.$PrizePayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Prize that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {PrizeFindUniqueOrThrowArgs} args - Arguments to find a Prize
     * @example
     * // Get one Prize
     * const prize = await prisma.prize.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends PrizeFindUniqueOrThrowArgs>(args: SelectSubset<T, PrizeFindUniqueOrThrowArgs<ExtArgs>>): Prisma__PrizeClient<$Result.GetResult<Prisma.$PrizePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Prize that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PrizeFindFirstArgs} args - Arguments to find a Prize
     * @example
     * // Get one Prize
     * const prize = await prisma.prize.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends PrizeFindFirstArgs>(args?: SelectSubset<T, PrizeFindFirstArgs<ExtArgs>>): Prisma__PrizeClient<$Result.GetResult<Prisma.$PrizePayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Prize that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PrizeFindFirstOrThrowArgs} args - Arguments to find a Prize
     * @example
     * // Get one Prize
     * const prize = await prisma.prize.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends PrizeFindFirstOrThrowArgs>(args?: SelectSubset<T, PrizeFindFirstOrThrowArgs<ExtArgs>>): Prisma__PrizeClient<$Result.GetResult<Prisma.$PrizePayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Prizes that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PrizeFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Prizes
     * const prizes = await prisma.prize.findMany()
     * 
     * // Get first 10 Prizes
     * const prizes = await prisma.prize.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const prizeWithIdOnly = await prisma.prize.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends PrizeFindManyArgs>(args?: SelectSubset<T, PrizeFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PrizePayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Prize.
     * @param {PrizeCreateArgs} args - Arguments to create a Prize.
     * @example
     * // Create one Prize
     * const Prize = await prisma.prize.create({
     *   data: {
     *     // ... data to create a Prize
     *   }
     * })
     * 
     */
    create<T extends PrizeCreateArgs>(args: SelectSubset<T, PrizeCreateArgs<ExtArgs>>): Prisma__PrizeClient<$Result.GetResult<Prisma.$PrizePayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Prizes.
     * @param {PrizeCreateManyArgs} args - Arguments to create many Prizes.
     * @example
     * // Create many Prizes
     * const prize = await prisma.prize.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends PrizeCreateManyArgs>(args?: SelectSubset<T, PrizeCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Prizes and returns the data saved in the database.
     * @param {PrizeCreateManyAndReturnArgs} args - Arguments to create many Prizes.
     * @example
     * // Create many Prizes
     * const prize = await prisma.prize.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Prizes and only return the `id`
     * const prizeWithIdOnly = await prisma.prize.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends PrizeCreateManyAndReturnArgs>(args?: SelectSubset<T, PrizeCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PrizePayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Prize.
     * @param {PrizeDeleteArgs} args - Arguments to delete one Prize.
     * @example
     * // Delete one Prize
     * const Prize = await prisma.prize.delete({
     *   where: {
     *     // ... filter to delete one Prize
     *   }
     * })
     * 
     */
    delete<T extends PrizeDeleteArgs>(args: SelectSubset<T, PrizeDeleteArgs<ExtArgs>>): Prisma__PrizeClient<$Result.GetResult<Prisma.$PrizePayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Prize.
     * @param {PrizeUpdateArgs} args - Arguments to update one Prize.
     * @example
     * // Update one Prize
     * const prize = await prisma.prize.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends PrizeUpdateArgs>(args: SelectSubset<T, PrizeUpdateArgs<ExtArgs>>): Prisma__PrizeClient<$Result.GetResult<Prisma.$PrizePayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Prizes.
     * @param {PrizeDeleteManyArgs} args - Arguments to filter Prizes to delete.
     * @example
     * // Delete a few Prizes
     * const { count } = await prisma.prize.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends PrizeDeleteManyArgs>(args?: SelectSubset<T, PrizeDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Prizes.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PrizeUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Prizes
     * const prize = await prisma.prize.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends PrizeUpdateManyArgs>(args: SelectSubset<T, PrizeUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Prizes and returns the data updated in the database.
     * @param {PrizeUpdateManyAndReturnArgs} args - Arguments to update many Prizes.
     * @example
     * // Update many Prizes
     * const prize = await prisma.prize.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Prizes and only return the `id`
     * const prizeWithIdOnly = await prisma.prize.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends PrizeUpdateManyAndReturnArgs>(args: SelectSubset<T, PrizeUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PrizePayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Prize.
     * @param {PrizeUpsertArgs} args - Arguments to update or create a Prize.
     * @example
     * // Update or create a Prize
     * const prize = await prisma.prize.upsert({
     *   create: {
     *     // ... data to create a Prize
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Prize we want to update
     *   }
     * })
     */
    upsert<T extends PrizeUpsertArgs>(args: SelectSubset<T, PrizeUpsertArgs<ExtArgs>>): Prisma__PrizeClient<$Result.GetResult<Prisma.$PrizePayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Prizes.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PrizeCountArgs} args - Arguments to filter Prizes to count.
     * @example
     * // Count the number of Prizes
     * const count = await prisma.prize.count({
     *   where: {
     *     // ... the filter for the Prizes we want to count
     *   }
     * })
    **/
    count<T extends PrizeCountArgs>(
      args?: Subset<T, PrizeCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], PrizeCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Prize.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PrizeAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends PrizeAggregateArgs>(args: Subset<T, PrizeAggregateArgs>): Prisma.PrismaPromise<GetPrizeAggregateType<T>>

    /**
     * Group by Prize.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PrizeGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends PrizeGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: PrizeGroupByArgs['orderBy'] }
        : { orderBy?: PrizeGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, PrizeGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetPrizeGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Prize model
   */
  readonly fields: PrizeFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Prize.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__PrizeClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    prizeSet<T extends ChallengePrizeSetDefaultArgs<ExtArgs> = {}>(args?: Subset<T, ChallengePrizeSetDefaultArgs<ExtArgs>>): Prisma__ChallengePrizeSetClient<$Result.GetResult<Prisma.$ChallengePrizeSetPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Prize model
   */
  interface PrizeFieldRefs {
    readonly id: FieldRef<"Prize", 'String'>
    readonly description: FieldRef<"Prize", 'String'>
    readonly prizeSetId: FieldRef<"Prize", 'String'>
    readonly type: FieldRef<"Prize", 'String'>
    readonly value: FieldRef<"Prize", 'Float'>
    readonly createdAt: FieldRef<"Prize", 'DateTime'>
    readonly createdBy: FieldRef<"Prize", 'String'>
    readonly updatedAt: FieldRef<"Prize", 'DateTime'>
    readonly updatedBy: FieldRef<"Prize", 'String'>
  }
    

  // Custom InputTypes
  /**
   * Prize findUnique
   */
  export type PrizeFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Prize
     */
    select?: PrizeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Prize
     */
    omit?: PrizeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PrizeInclude<ExtArgs> | null
    /**
     * Filter, which Prize to fetch.
     */
    where: PrizeWhereUniqueInput
  }

  /**
   * Prize findUniqueOrThrow
   */
  export type PrizeFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Prize
     */
    select?: PrizeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Prize
     */
    omit?: PrizeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PrizeInclude<ExtArgs> | null
    /**
     * Filter, which Prize to fetch.
     */
    where: PrizeWhereUniqueInput
  }

  /**
   * Prize findFirst
   */
  export type PrizeFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Prize
     */
    select?: PrizeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Prize
     */
    omit?: PrizeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PrizeInclude<ExtArgs> | null
    /**
     * Filter, which Prize to fetch.
     */
    where?: PrizeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Prizes to fetch.
     */
    orderBy?: PrizeOrderByWithRelationInput | PrizeOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Prizes.
     */
    cursor?: PrizeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Prizes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Prizes.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Prizes.
     */
    distinct?: PrizeScalarFieldEnum | PrizeScalarFieldEnum[]
  }

  /**
   * Prize findFirstOrThrow
   */
  export type PrizeFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Prize
     */
    select?: PrizeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Prize
     */
    omit?: PrizeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PrizeInclude<ExtArgs> | null
    /**
     * Filter, which Prize to fetch.
     */
    where?: PrizeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Prizes to fetch.
     */
    orderBy?: PrizeOrderByWithRelationInput | PrizeOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Prizes.
     */
    cursor?: PrizeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Prizes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Prizes.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Prizes.
     */
    distinct?: PrizeScalarFieldEnum | PrizeScalarFieldEnum[]
  }

  /**
   * Prize findMany
   */
  export type PrizeFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Prize
     */
    select?: PrizeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Prize
     */
    omit?: PrizeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PrizeInclude<ExtArgs> | null
    /**
     * Filter, which Prizes to fetch.
     */
    where?: PrizeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Prizes to fetch.
     */
    orderBy?: PrizeOrderByWithRelationInput | PrizeOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Prizes.
     */
    cursor?: PrizeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Prizes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Prizes.
     */
    skip?: number
    distinct?: PrizeScalarFieldEnum | PrizeScalarFieldEnum[]
  }

  /**
   * Prize create
   */
  export type PrizeCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Prize
     */
    select?: PrizeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Prize
     */
    omit?: PrizeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PrizeInclude<ExtArgs> | null
    /**
     * The data needed to create a Prize.
     */
    data: XOR<PrizeCreateInput, PrizeUncheckedCreateInput>
  }

  /**
   * Prize createMany
   */
  export type PrizeCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Prizes.
     */
    data: PrizeCreateManyInput | PrizeCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Prize createManyAndReturn
   */
  export type PrizeCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Prize
     */
    select?: PrizeSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Prize
     */
    omit?: PrizeOmit<ExtArgs> | null
    /**
     * The data used to create many Prizes.
     */
    data: PrizeCreateManyInput | PrizeCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PrizeIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Prize update
   */
  export type PrizeUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Prize
     */
    select?: PrizeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Prize
     */
    omit?: PrizeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PrizeInclude<ExtArgs> | null
    /**
     * The data needed to update a Prize.
     */
    data: XOR<PrizeUpdateInput, PrizeUncheckedUpdateInput>
    /**
     * Choose, which Prize to update.
     */
    where: PrizeWhereUniqueInput
  }

  /**
   * Prize updateMany
   */
  export type PrizeUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Prizes.
     */
    data: XOR<PrizeUpdateManyMutationInput, PrizeUncheckedUpdateManyInput>
    /**
     * Filter which Prizes to update
     */
    where?: PrizeWhereInput
    /**
     * Limit how many Prizes to update.
     */
    limit?: number
  }

  /**
   * Prize updateManyAndReturn
   */
  export type PrizeUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Prize
     */
    select?: PrizeSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Prize
     */
    omit?: PrizeOmit<ExtArgs> | null
    /**
     * The data used to update Prizes.
     */
    data: XOR<PrizeUpdateManyMutationInput, PrizeUncheckedUpdateManyInput>
    /**
     * Filter which Prizes to update
     */
    where?: PrizeWhereInput
    /**
     * Limit how many Prizes to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PrizeIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * Prize upsert
   */
  export type PrizeUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Prize
     */
    select?: PrizeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Prize
     */
    omit?: PrizeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PrizeInclude<ExtArgs> | null
    /**
     * The filter to search for the Prize to update in case it exists.
     */
    where: PrizeWhereUniqueInput
    /**
     * In case the Prize found by the `where` argument doesn't exist, create a new Prize with this data.
     */
    create: XOR<PrizeCreateInput, PrizeUncheckedCreateInput>
    /**
     * In case the Prize was found with the provided `where` argument, update it with this data.
     */
    update: XOR<PrizeUpdateInput, PrizeUncheckedUpdateInput>
  }

  /**
   * Prize delete
   */
  export type PrizeDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Prize
     */
    select?: PrizeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Prize
     */
    omit?: PrizeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PrizeInclude<ExtArgs> | null
    /**
     * Filter which Prize to delete.
     */
    where: PrizeWhereUniqueInput
  }

  /**
   * Prize deleteMany
   */
  export type PrizeDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Prizes to delete
     */
    where?: PrizeWhereInput
    /**
     * Limit how many Prizes to delete.
     */
    limit?: number
  }

  /**
   * Prize without action
   */
  export type PrizeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Prize
     */
    select?: PrizeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Prize
     */
    omit?: PrizeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PrizeInclude<ExtArgs> | null
  }


  /**
   * Model ChallengeWinner
   */

  export type AggregateChallengeWinner = {
    _count: ChallengeWinnerCountAggregateOutputType | null
    _avg: ChallengeWinnerAvgAggregateOutputType | null
    _sum: ChallengeWinnerSumAggregateOutputType | null
    _min: ChallengeWinnerMinAggregateOutputType | null
    _max: ChallengeWinnerMaxAggregateOutputType | null
  }

  export type ChallengeWinnerAvgAggregateOutputType = {
    userId: number | null
    placement: number | null
  }

  export type ChallengeWinnerSumAggregateOutputType = {
    userId: number | null
    placement: number | null
  }

  export type ChallengeWinnerMinAggregateOutputType = {
    id: string | null
    challengeId: string | null
    userId: number | null
    handle: string | null
    placement: number | null
    type: $Enums.PrizeSetTypeEnum | null
    createdAt: Date | null
    createdBy: string | null
    updatedAt: Date | null
    updatedBy: string | null
  }

  export type ChallengeWinnerMaxAggregateOutputType = {
    id: string | null
    challengeId: string | null
    userId: number | null
    handle: string | null
    placement: number | null
    type: $Enums.PrizeSetTypeEnum | null
    createdAt: Date | null
    createdBy: string | null
    updatedAt: Date | null
    updatedBy: string | null
  }

  export type ChallengeWinnerCountAggregateOutputType = {
    id: number
    challengeId: number
    userId: number
    handle: number
    placement: number
    type: number
    createdAt: number
    createdBy: number
    updatedAt: number
    updatedBy: number
    _all: number
  }


  export type ChallengeWinnerAvgAggregateInputType = {
    userId?: true
    placement?: true
  }

  export type ChallengeWinnerSumAggregateInputType = {
    userId?: true
    placement?: true
  }

  export type ChallengeWinnerMinAggregateInputType = {
    id?: true
    challengeId?: true
    userId?: true
    handle?: true
    placement?: true
    type?: true
    createdAt?: true
    createdBy?: true
    updatedAt?: true
    updatedBy?: true
  }

  export type ChallengeWinnerMaxAggregateInputType = {
    id?: true
    challengeId?: true
    userId?: true
    handle?: true
    placement?: true
    type?: true
    createdAt?: true
    createdBy?: true
    updatedAt?: true
    updatedBy?: true
  }

  export type ChallengeWinnerCountAggregateInputType = {
    id?: true
    challengeId?: true
    userId?: true
    handle?: true
    placement?: true
    type?: true
    createdAt?: true
    createdBy?: true
    updatedAt?: true
    updatedBy?: true
    _all?: true
  }

  export type ChallengeWinnerAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ChallengeWinner to aggregate.
     */
    where?: ChallengeWinnerWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ChallengeWinners to fetch.
     */
    orderBy?: ChallengeWinnerOrderByWithRelationInput | ChallengeWinnerOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ChallengeWinnerWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ChallengeWinners from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ChallengeWinners.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned ChallengeWinners
    **/
    _count?: true | ChallengeWinnerCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: ChallengeWinnerAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: ChallengeWinnerSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ChallengeWinnerMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ChallengeWinnerMaxAggregateInputType
  }

  export type GetChallengeWinnerAggregateType<T extends ChallengeWinnerAggregateArgs> = {
        [P in keyof T & keyof AggregateChallengeWinner]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateChallengeWinner[P]>
      : GetScalarType<T[P], AggregateChallengeWinner[P]>
  }




  export type ChallengeWinnerGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ChallengeWinnerWhereInput
    orderBy?: ChallengeWinnerOrderByWithAggregationInput | ChallengeWinnerOrderByWithAggregationInput[]
    by: ChallengeWinnerScalarFieldEnum[] | ChallengeWinnerScalarFieldEnum
    having?: ChallengeWinnerScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ChallengeWinnerCountAggregateInputType | true
    _avg?: ChallengeWinnerAvgAggregateInputType
    _sum?: ChallengeWinnerSumAggregateInputType
    _min?: ChallengeWinnerMinAggregateInputType
    _max?: ChallengeWinnerMaxAggregateInputType
  }

  export type ChallengeWinnerGroupByOutputType = {
    id: string
    challengeId: string
    userId: number
    handle: string
    placement: number
    type: $Enums.PrizeSetTypeEnum
    createdAt: Date
    createdBy: string
    updatedAt: Date
    updatedBy: string
    _count: ChallengeWinnerCountAggregateOutputType | null
    _avg: ChallengeWinnerAvgAggregateOutputType | null
    _sum: ChallengeWinnerSumAggregateOutputType | null
    _min: ChallengeWinnerMinAggregateOutputType | null
    _max: ChallengeWinnerMaxAggregateOutputType | null
  }

  type GetChallengeWinnerGroupByPayload<T extends ChallengeWinnerGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ChallengeWinnerGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ChallengeWinnerGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ChallengeWinnerGroupByOutputType[P]>
            : GetScalarType<T[P], ChallengeWinnerGroupByOutputType[P]>
        }
      >
    >


  export type ChallengeWinnerSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    challengeId?: boolean
    userId?: boolean
    handle?: boolean
    placement?: boolean
    type?: boolean
    createdAt?: boolean
    createdBy?: boolean
    updatedAt?: boolean
    updatedBy?: boolean
    challenge?: boolean | ChallengeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["challengeWinner"]>

  export type ChallengeWinnerSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    challengeId?: boolean
    userId?: boolean
    handle?: boolean
    placement?: boolean
    type?: boolean
    createdAt?: boolean
    createdBy?: boolean
    updatedAt?: boolean
    updatedBy?: boolean
    challenge?: boolean | ChallengeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["challengeWinner"]>

  export type ChallengeWinnerSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    challengeId?: boolean
    userId?: boolean
    handle?: boolean
    placement?: boolean
    type?: boolean
    createdAt?: boolean
    createdBy?: boolean
    updatedAt?: boolean
    updatedBy?: boolean
    challenge?: boolean | ChallengeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["challengeWinner"]>

  export type ChallengeWinnerSelectScalar = {
    id?: boolean
    challengeId?: boolean
    userId?: boolean
    handle?: boolean
    placement?: boolean
    type?: boolean
    createdAt?: boolean
    createdBy?: boolean
    updatedAt?: boolean
    updatedBy?: boolean
  }

  export type ChallengeWinnerOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "challengeId" | "userId" | "handle" | "placement" | "type" | "createdAt" | "createdBy" | "updatedAt" | "updatedBy", ExtArgs["result"]["challengeWinner"]>
  export type ChallengeWinnerInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    challenge?: boolean | ChallengeDefaultArgs<ExtArgs>
  }
  export type ChallengeWinnerIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    challenge?: boolean | ChallengeDefaultArgs<ExtArgs>
  }
  export type ChallengeWinnerIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    challenge?: boolean | ChallengeDefaultArgs<ExtArgs>
  }

  export type $ChallengeWinnerPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "ChallengeWinner"
    objects: {
      challenge: Prisma.$ChallengePayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      challengeId: string
      userId: number
      handle: string
      placement: number
      type: $Enums.PrizeSetTypeEnum
      createdAt: Date
      createdBy: string
      updatedAt: Date
      updatedBy: string
    }, ExtArgs["result"]["challengeWinner"]>
    composites: {}
  }

  type ChallengeWinnerGetPayload<S extends boolean | null | undefined | ChallengeWinnerDefaultArgs> = $Result.GetResult<Prisma.$ChallengeWinnerPayload, S>

  type ChallengeWinnerCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<ChallengeWinnerFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: ChallengeWinnerCountAggregateInputType | true
    }

  export interface ChallengeWinnerDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['ChallengeWinner'], meta: { name: 'ChallengeWinner' } }
    /**
     * Find zero or one ChallengeWinner that matches the filter.
     * @param {ChallengeWinnerFindUniqueArgs} args - Arguments to find a ChallengeWinner
     * @example
     * // Get one ChallengeWinner
     * const challengeWinner = await prisma.challengeWinner.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends ChallengeWinnerFindUniqueArgs>(args: SelectSubset<T, ChallengeWinnerFindUniqueArgs<ExtArgs>>): Prisma__ChallengeWinnerClient<$Result.GetResult<Prisma.$ChallengeWinnerPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one ChallengeWinner that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {ChallengeWinnerFindUniqueOrThrowArgs} args - Arguments to find a ChallengeWinner
     * @example
     * // Get one ChallengeWinner
     * const challengeWinner = await prisma.challengeWinner.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends ChallengeWinnerFindUniqueOrThrowArgs>(args: SelectSubset<T, ChallengeWinnerFindUniqueOrThrowArgs<ExtArgs>>): Prisma__ChallengeWinnerClient<$Result.GetResult<Prisma.$ChallengeWinnerPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first ChallengeWinner that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ChallengeWinnerFindFirstArgs} args - Arguments to find a ChallengeWinner
     * @example
     * // Get one ChallengeWinner
     * const challengeWinner = await prisma.challengeWinner.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends ChallengeWinnerFindFirstArgs>(args?: SelectSubset<T, ChallengeWinnerFindFirstArgs<ExtArgs>>): Prisma__ChallengeWinnerClient<$Result.GetResult<Prisma.$ChallengeWinnerPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first ChallengeWinner that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ChallengeWinnerFindFirstOrThrowArgs} args - Arguments to find a ChallengeWinner
     * @example
     * // Get one ChallengeWinner
     * const challengeWinner = await prisma.challengeWinner.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends ChallengeWinnerFindFirstOrThrowArgs>(args?: SelectSubset<T, ChallengeWinnerFindFirstOrThrowArgs<ExtArgs>>): Prisma__ChallengeWinnerClient<$Result.GetResult<Prisma.$ChallengeWinnerPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more ChallengeWinners that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ChallengeWinnerFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all ChallengeWinners
     * const challengeWinners = await prisma.challengeWinner.findMany()
     * 
     * // Get first 10 ChallengeWinners
     * const challengeWinners = await prisma.challengeWinner.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const challengeWinnerWithIdOnly = await prisma.challengeWinner.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends ChallengeWinnerFindManyArgs>(args?: SelectSubset<T, ChallengeWinnerFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ChallengeWinnerPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a ChallengeWinner.
     * @param {ChallengeWinnerCreateArgs} args - Arguments to create a ChallengeWinner.
     * @example
     * // Create one ChallengeWinner
     * const ChallengeWinner = await prisma.challengeWinner.create({
     *   data: {
     *     // ... data to create a ChallengeWinner
     *   }
     * })
     * 
     */
    create<T extends ChallengeWinnerCreateArgs>(args: SelectSubset<T, ChallengeWinnerCreateArgs<ExtArgs>>): Prisma__ChallengeWinnerClient<$Result.GetResult<Prisma.$ChallengeWinnerPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many ChallengeWinners.
     * @param {ChallengeWinnerCreateManyArgs} args - Arguments to create many ChallengeWinners.
     * @example
     * // Create many ChallengeWinners
     * const challengeWinner = await prisma.challengeWinner.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends ChallengeWinnerCreateManyArgs>(args?: SelectSubset<T, ChallengeWinnerCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many ChallengeWinners and returns the data saved in the database.
     * @param {ChallengeWinnerCreateManyAndReturnArgs} args - Arguments to create many ChallengeWinners.
     * @example
     * // Create many ChallengeWinners
     * const challengeWinner = await prisma.challengeWinner.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many ChallengeWinners and only return the `id`
     * const challengeWinnerWithIdOnly = await prisma.challengeWinner.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends ChallengeWinnerCreateManyAndReturnArgs>(args?: SelectSubset<T, ChallengeWinnerCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ChallengeWinnerPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a ChallengeWinner.
     * @param {ChallengeWinnerDeleteArgs} args - Arguments to delete one ChallengeWinner.
     * @example
     * // Delete one ChallengeWinner
     * const ChallengeWinner = await prisma.challengeWinner.delete({
     *   where: {
     *     // ... filter to delete one ChallengeWinner
     *   }
     * })
     * 
     */
    delete<T extends ChallengeWinnerDeleteArgs>(args: SelectSubset<T, ChallengeWinnerDeleteArgs<ExtArgs>>): Prisma__ChallengeWinnerClient<$Result.GetResult<Prisma.$ChallengeWinnerPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one ChallengeWinner.
     * @param {ChallengeWinnerUpdateArgs} args - Arguments to update one ChallengeWinner.
     * @example
     * // Update one ChallengeWinner
     * const challengeWinner = await prisma.challengeWinner.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends ChallengeWinnerUpdateArgs>(args: SelectSubset<T, ChallengeWinnerUpdateArgs<ExtArgs>>): Prisma__ChallengeWinnerClient<$Result.GetResult<Prisma.$ChallengeWinnerPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more ChallengeWinners.
     * @param {ChallengeWinnerDeleteManyArgs} args - Arguments to filter ChallengeWinners to delete.
     * @example
     * // Delete a few ChallengeWinners
     * const { count } = await prisma.challengeWinner.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends ChallengeWinnerDeleteManyArgs>(args?: SelectSubset<T, ChallengeWinnerDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more ChallengeWinners.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ChallengeWinnerUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many ChallengeWinners
     * const challengeWinner = await prisma.challengeWinner.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends ChallengeWinnerUpdateManyArgs>(args: SelectSubset<T, ChallengeWinnerUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more ChallengeWinners and returns the data updated in the database.
     * @param {ChallengeWinnerUpdateManyAndReturnArgs} args - Arguments to update many ChallengeWinners.
     * @example
     * // Update many ChallengeWinners
     * const challengeWinner = await prisma.challengeWinner.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more ChallengeWinners and only return the `id`
     * const challengeWinnerWithIdOnly = await prisma.challengeWinner.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends ChallengeWinnerUpdateManyAndReturnArgs>(args: SelectSubset<T, ChallengeWinnerUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ChallengeWinnerPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one ChallengeWinner.
     * @param {ChallengeWinnerUpsertArgs} args - Arguments to update or create a ChallengeWinner.
     * @example
     * // Update or create a ChallengeWinner
     * const challengeWinner = await prisma.challengeWinner.upsert({
     *   create: {
     *     // ... data to create a ChallengeWinner
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the ChallengeWinner we want to update
     *   }
     * })
     */
    upsert<T extends ChallengeWinnerUpsertArgs>(args: SelectSubset<T, ChallengeWinnerUpsertArgs<ExtArgs>>): Prisma__ChallengeWinnerClient<$Result.GetResult<Prisma.$ChallengeWinnerPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of ChallengeWinners.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ChallengeWinnerCountArgs} args - Arguments to filter ChallengeWinners to count.
     * @example
     * // Count the number of ChallengeWinners
     * const count = await prisma.challengeWinner.count({
     *   where: {
     *     // ... the filter for the ChallengeWinners we want to count
     *   }
     * })
    **/
    count<T extends ChallengeWinnerCountArgs>(
      args?: Subset<T, ChallengeWinnerCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ChallengeWinnerCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a ChallengeWinner.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ChallengeWinnerAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ChallengeWinnerAggregateArgs>(args: Subset<T, ChallengeWinnerAggregateArgs>): Prisma.PrismaPromise<GetChallengeWinnerAggregateType<T>>

    /**
     * Group by ChallengeWinner.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ChallengeWinnerGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ChallengeWinnerGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ChallengeWinnerGroupByArgs['orderBy'] }
        : { orderBy?: ChallengeWinnerGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ChallengeWinnerGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetChallengeWinnerGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the ChallengeWinner model
   */
  readonly fields: ChallengeWinnerFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for ChallengeWinner.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ChallengeWinnerClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    challenge<T extends ChallengeDefaultArgs<ExtArgs> = {}>(args?: Subset<T, ChallengeDefaultArgs<ExtArgs>>): Prisma__ChallengeClient<$Result.GetResult<Prisma.$ChallengePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the ChallengeWinner model
   */
  interface ChallengeWinnerFieldRefs {
    readonly id: FieldRef<"ChallengeWinner", 'String'>
    readonly challengeId: FieldRef<"ChallengeWinner", 'String'>
    readonly userId: FieldRef<"ChallengeWinner", 'Int'>
    readonly handle: FieldRef<"ChallengeWinner", 'String'>
    readonly placement: FieldRef<"ChallengeWinner", 'Int'>
    readonly type: FieldRef<"ChallengeWinner", 'PrizeSetTypeEnum'>
    readonly createdAt: FieldRef<"ChallengeWinner", 'DateTime'>
    readonly createdBy: FieldRef<"ChallengeWinner", 'String'>
    readonly updatedAt: FieldRef<"ChallengeWinner", 'DateTime'>
    readonly updatedBy: FieldRef<"ChallengeWinner", 'String'>
  }
    

  // Custom InputTypes
  /**
   * ChallengeWinner findUnique
   */
  export type ChallengeWinnerFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ChallengeWinner
     */
    select?: ChallengeWinnerSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ChallengeWinner
     */
    omit?: ChallengeWinnerOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ChallengeWinnerInclude<ExtArgs> | null
    /**
     * Filter, which ChallengeWinner to fetch.
     */
    where: ChallengeWinnerWhereUniqueInput
  }

  /**
   * ChallengeWinner findUniqueOrThrow
   */
  export type ChallengeWinnerFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ChallengeWinner
     */
    select?: ChallengeWinnerSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ChallengeWinner
     */
    omit?: ChallengeWinnerOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ChallengeWinnerInclude<ExtArgs> | null
    /**
     * Filter, which ChallengeWinner to fetch.
     */
    where: ChallengeWinnerWhereUniqueInput
  }

  /**
   * ChallengeWinner findFirst
   */
  export type ChallengeWinnerFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ChallengeWinner
     */
    select?: ChallengeWinnerSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ChallengeWinner
     */
    omit?: ChallengeWinnerOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ChallengeWinnerInclude<ExtArgs> | null
    /**
     * Filter, which ChallengeWinner to fetch.
     */
    where?: ChallengeWinnerWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ChallengeWinners to fetch.
     */
    orderBy?: ChallengeWinnerOrderByWithRelationInput | ChallengeWinnerOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ChallengeWinners.
     */
    cursor?: ChallengeWinnerWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ChallengeWinners from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ChallengeWinners.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ChallengeWinners.
     */
    distinct?: ChallengeWinnerScalarFieldEnum | ChallengeWinnerScalarFieldEnum[]
  }

  /**
   * ChallengeWinner findFirstOrThrow
   */
  export type ChallengeWinnerFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ChallengeWinner
     */
    select?: ChallengeWinnerSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ChallengeWinner
     */
    omit?: ChallengeWinnerOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ChallengeWinnerInclude<ExtArgs> | null
    /**
     * Filter, which ChallengeWinner to fetch.
     */
    where?: ChallengeWinnerWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ChallengeWinners to fetch.
     */
    orderBy?: ChallengeWinnerOrderByWithRelationInput | ChallengeWinnerOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ChallengeWinners.
     */
    cursor?: ChallengeWinnerWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ChallengeWinners from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ChallengeWinners.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ChallengeWinners.
     */
    distinct?: ChallengeWinnerScalarFieldEnum | ChallengeWinnerScalarFieldEnum[]
  }

  /**
   * ChallengeWinner findMany
   */
  export type ChallengeWinnerFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ChallengeWinner
     */
    select?: ChallengeWinnerSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ChallengeWinner
     */
    omit?: ChallengeWinnerOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ChallengeWinnerInclude<ExtArgs> | null
    /**
     * Filter, which ChallengeWinners to fetch.
     */
    where?: ChallengeWinnerWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ChallengeWinners to fetch.
     */
    orderBy?: ChallengeWinnerOrderByWithRelationInput | ChallengeWinnerOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing ChallengeWinners.
     */
    cursor?: ChallengeWinnerWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ChallengeWinners from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ChallengeWinners.
     */
    skip?: number
    distinct?: ChallengeWinnerScalarFieldEnum | ChallengeWinnerScalarFieldEnum[]
  }

  /**
   * ChallengeWinner create
   */
  export type ChallengeWinnerCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ChallengeWinner
     */
    select?: ChallengeWinnerSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ChallengeWinner
     */
    omit?: ChallengeWinnerOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ChallengeWinnerInclude<ExtArgs> | null
    /**
     * The data needed to create a ChallengeWinner.
     */
    data: XOR<ChallengeWinnerCreateInput, ChallengeWinnerUncheckedCreateInput>
  }

  /**
   * ChallengeWinner createMany
   */
  export type ChallengeWinnerCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many ChallengeWinners.
     */
    data: ChallengeWinnerCreateManyInput | ChallengeWinnerCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * ChallengeWinner createManyAndReturn
   */
  export type ChallengeWinnerCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ChallengeWinner
     */
    select?: ChallengeWinnerSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the ChallengeWinner
     */
    omit?: ChallengeWinnerOmit<ExtArgs> | null
    /**
     * The data used to create many ChallengeWinners.
     */
    data: ChallengeWinnerCreateManyInput | ChallengeWinnerCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ChallengeWinnerIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * ChallengeWinner update
   */
  export type ChallengeWinnerUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ChallengeWinner
     */
    select?: ChallengeWinnerSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ChallengeWinner
     */
    omit?: ChallengeWinnerOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ChallengeWinnerInclude<ExtArgs> | null
    /**
     * The data needed to update a ChallengeWinner.
     */
    data: XOR<ChallengeWinnerUpdateInput, ChallengeWinnerUncheckedUpdateInput>
    /**
     * Choose, which ChallengeWinner to update.
     */
    where: ChallengeWinnerWhereUniqueInput
  }

  /**
   * ChallengeWinner updateMany
   */
  export type ChallengeWinnerUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update ChallengeWinners.
     */
    data: XOR<ChallengeWinnerUpdateManyMutationInput, ChallengeWinnerUncheckedUpdateManyInput>
    /**
     * Filter which ChallengeWinners to update
     */
    where?: ChallengeWinnerWhereInput
    /**
     * Limit how many ChallengeWinners to update.
     */
    limit?: number
  }

  /**
   * ChallengeWinner updateManyAndReturn
   */
  export type ChallengeWinnerUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ChallengeWinner
     */
    select?: ChallengeWinnerSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the ChallengeWinner
     */
    omit?: ChallengeWinnerOmit<ExtArgs> | null
    /**
     * The data used to update ChallengeWinners.
     */
    data: XOR<ChallengeWinnerUpdateManyMutationInput, ChallengeWinnerUncheckedUpdateManyInput>
    /**
     * Filter which ChallengeWinners to update
     */
    where?: ChallengeWinnerWhereInput
    /**
     * Limit how many ChallengeWinners to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ChallengeWinnerIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * ChallengeWinner upsert
   */
  export type ChallengeWinnerUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ChallengeWinner
     */
    select?: ChallengeWinnerSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ChallengeWinner
     */
    omit?: ChallengeWinnerOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ChallengeWinnerInclude<ExtArgs> | null
    /**
     * The filter to search for the ChallengeWinner to update in case it exists.
     */
    where: ChallengeWinnerWhereUniqueInput
    /**
     * In case the ChallengeWinner found by the `where` argument doesn't exist, create a new ChallengeWinner with this data.
     */
    create: XOR<ChallengeWinnerCreateInput, ChallengeWinnerUncheckedCreateInput>
    /**
     * In case the ChallengeWinner was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ChallengeWinnerUpdateInput, ChallengeWinnerUncheckedUpdateInput>
  }

  /**
   * ChallengeWinner delete
   */
  export type ChallengeWinnerDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ChallengeWinner
     */
    select?: ChallengeWinnerSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ChallengeWinner
     */
    omit?: ChallengeWinnerOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ChallengeWinnerInclude<ExtArgs> | null
    /**
     * Filter which ChallengeWinner to delete.
     */
    where: ChallengeWinnerWhereUniqueInput
  }

  /**
   * ChallengeWinner deleteMany
   */
  export type ChallengeWinnerDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ChallengeWinners to delete
     */
    where?: ChallengeWinnerWhereInput
    /**
     * Limit how many ChallengeWinners to delete.
     */
    limit?: number
  }

  /**
   * ChallengeWinner without action
   */
  export type ChallengeWinnerDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ChallengeWinner
     */
    select?: ChallengeWinnerSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ChallengeWinner
     */
    omit?: ChallengeWinnerOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ChallengeWinnerInclude<ExtArgs> | null
  }


  /**
   * Model ChallengeTerm
   */

  export type AggregateChallengeTerm = {
    _count: ChallengeTermCountAggregateOutputType | null
    _min: ChallengeTermMinAggregateOutputType | null
    _max: ChallengeTermMaxAggregateOutputType | null
  }

  export type ChallengeTermMinAggregateOutputType = {
    id: string | null
    challengeId: string | null
    termId: string | null
    roleId: string | null
    createdAt: Date | null
    createdBy: string | null
    updatedAt: Date | null
    updatedBy: string | null
  }

  export type ChallengeTermMaxAggregateOutputType = {
    id: string | null
    challengeId: string | null
    termId: string | null
    roleId: string | null
    createdAt: Date | null
    createdBy: string | null
    updatedAt: Date | null
    updatedBy: string | null
  }

  export type ChallengeTermCountAggregateOutputType = {
    id: number
    challengeId: number
    termId: number
    roleId: number
    createdAt: number
    createdBy: number
    updatedAt: number
    updatedBy: number
    _all: number
  }


  export type ChallengeTermMinAggregateInputType = {
    id?: true
    challengeId?: true
    termId?: true
    roleId?: true
    createdAt?: true
    createdBy?: true
    updatedAt?: true
    updatedBy?: true
  }

  export type ChallengeTermMaxAggregateInputType = {
    id?: true
    challengeId?: true
    termId?: true
    roleId?: true
    createdAt?: true
    createdBy?: true
    updatedAt?: true
    updatedBy?: true
  }

  export type ChallengeTermCountAggregateInputType = {
    id?: true
    challengeId?: true
    termId?: true
    roleId?: true
    createdAt?: true
    createdBy?: true
    updatedAt?: true
    updatedBy?: true
    _all?: true
  }

  export type ChallengeTermAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ChallengeTerm to aggregate.
     */
    where?: ChallengeTermWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ChallengeTerms to fetch.
     */
    orderBy?: ChallengeTermOrderByWithRelationInput | ChallengeTermOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ChallengeTermWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ChallengeTerms from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ChallengeTerms.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned ChallengeTerms
    **/
    _count?: true | ChallengeTermCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ChallengeTermMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ChallengeTermMaxAggregateInputType
  }

  export type GetChallengeTermAggregateType<T extends ChallengeTermAggregateArgs> = {
        [P in keyof T & keyof AggregateChallengeTerm]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateChallengeTerm[P]>
      : GetScalarType<T[P], AggregateChallengeTerm[P]>
  }




  export type ChallengeTermGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ChallengeTermWhereInput
    orderBy?: ChallengeTermOrderByWithAggregationInput | ChallengeTermOrderByWithAggregationInput[]
    by: ChallengeTermScalarFieldEnum[] | ChallengeTermScalarFieldEnum
    having?: ChallengeTermScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ChallengeTermCountAggregateInputType | true
    _min?: ChallengeTermMinAggregateInputType
    _max?: ChallengeTermMaxAggregateInputType
  }

  export type ChallengeTermGroupByOutputType = {
    id: string
    challengeId: string
    termId: string
    roleId: string
    createdAt: Date
    createdBy: string
    updatedAt: Date
    updatedBy: string
    _count: ChallengeTermCountAggregateOutputType | null
    _min: ChallengeTermMinAggregateOutputType | null
    _max: ChallengeTermMaxAggregateOutputType | null
  }

  type GetChallengeTermGroupByPayload<T extends ChallengeTermGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ChallengeTermGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ChallengeTermGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ChallengeTermGroupByOutputType[P]>
            : GetScalarType<T[P], ChallengeTermGroupByOutputType[P]>
        }
      >
    >


  export type ChallengeTermSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    challengeId?: boolean
    termId?: boolean
    roleId?: boolean
    createdAt?: boolean
    createdBy?: boolean
    updatedAt?: boolean
    updatedBy?: boolean
    challenge?: boolean | ChallengeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["challengeTerm"]>

  export type ChallengeTermSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    challengeId?: boolean
    termId?: boolean
    roleId?: boolean
    createdAt?: boolean
    createdBy?: boolean
    updatedAt?: boolean
    updatedBy?: boolean
    challenge?: boolean | ChallengeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["challengeTerm"]>

  export type ChallengeTermSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    challengeId?: boolean
    termId?: boolean
    roleId?: boolean
    createdAt?: boolean
    createdBy?: boolean
    updatedAt?: boolean
    updatedBy?: boolean
    challenge?: boolean | ChallengeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["challengeTerm"]>

  export type ChallengeTermSelectScalar = {
    id?: boolean
    challengeId?: boolean
    termId?: boolean
    roleId?: boolean
    createdAt?: boolean
    createdBy?: boolean
    updatedAt?: boolean
    updatedBy?: boolean
  }

  export type ChallengeTermOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "challengeId" | "termId" | "roleId" | "createdAt" | "createdBy" | "updatedAt" | "updatedBy", ExtArgs["result"]["challengeTerm"]>
  export type ChallengeTermInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    challenge?: boolean | ChallengeDefaultArgs<ExtArgs>
  }
  export type ChallengeTermIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    challenge?: boolean | ChallengeDefaultArgs<ExtArgs>
  }
  export type ChallengeTermIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    challenge?: boolean | ChallengeDefaultArgs<ExtArgs>
  }

  export type $ChallengeTermPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "ChallengeTerm"
    objects: {
      challenge: Prisma.$ChallengePayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      challengeId: string
      termId: string
      roleId: string
      createdAt: Date
      createdBy: string
      updatedAt: Date
      updatedBy: string
    }, ExtArgs["result"]["challengeTerm"]>
    composites: {}
  }

  type ChallengeTermGetPayload<S extends boolean | null | undefined | ChallengeTermDefaultArgs> = $Result.GetResult<Prisma.$ChallengeTermPayload, S>

  type ChallengeTermCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<ChallengeTermFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: ChallengeTermCountAggregateInputType | true
    }

  export interface ChallengeTermDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['ChallengeTerm'], meta: { name: 'ChallengeTerm' } }
    /**
     * Find zero or one ChallengeTerm that matches the filter.
     * @param {ChallengeTermFindUniqueArgs} args - Arguments to find a ChallengeTerm
     * @example
     * // Get one ChallengeTerm
     * const challengeTerm = await prisma.challengeTerm.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends ChallengeTermFindUniqueArgs>(args: SelectSubset<T, ChallengeTermFindUniqueArgs<ExtArgs>>): Prisma__ChallengeTermClient<$Result.GetResult<Prisma.$ChallengeTermPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one ChallengeTerm that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {ChallengeTermFindUniqueOrThrowArgs} args - Arguments to find a ChallengeTerm
     * @example
     * // Get one ChallengeTerm
     * const challengeTerm = await prisma.challengeTerm.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends ChallengeTermFindUniqueOrThrowArgs>(args: SelectSubset<T, ChallengeTermFindUniqueOrThrowArgs<ExtArgs>>): Prisma__ChallengeTermClient<$Result.GetResult<Prisma.$ChallengeTermPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first ChallengeTerm that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ChallengeTermFindFirstArgs} args - Arguments to find a ChallengeTerm
     * @example
     * // Get one ChallengeTerm
     * const challengeTerm = await prisma.challengeTerm.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends ChallengeTermFindFirstArgs>(args?: SelectSubset<T, ChallengeTermFindFirstArgs<ExtArgs>>): Prisma__ChallengeTermClient<$Result.GetResult<Prisma.$ChallengeTermPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first ChallengeTerm that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ChallengeTermFindFirstOrThrowArgs} args - Arguments to find a ChallengeTerm
     * @example
     * // Get one ChallengeTerm
     * const challengeTerm = await prisma.challengeTerm.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends ChallengeTermFindFirstOrThrowArgs>(args?: SelectSubset<T, ChallengeTermFindFirstOrThrowArgs<ExtArgs>>): Prisma__ChallengeTermClient<$Result.GetResult<Prisma.$ChallengeTermPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more ChallengeTerms that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ChallengeTermFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all ChallengeTerms
     * const challengeTerms = await prisma.challengeTerm.findMany()
     * 
     * // Get first 10 ChallengeTerms
     * const challengeTerms = await prisma.challengeTerm.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const challengeTermWithIdOnly = await prisma.challengeTerm.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends ChallengeTermFindManyArgs>(args?: SelectSubset<T, ChallengeTermFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ChallengeTermPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a ChallengeTerm.
     * @param {ChallengeTermCreateArgs} args - Arguments to create a ChallengeTerm.
     * @example
     * // Create one ChallengeTerm
     * const ChallengeTerm = await prisma.challengeTerm.create({
     *   data: {
     *     // ... data to create a ChallengeTerm
     *   }
     * })
     * 
     */
    create<T extends ChallengeTermCreateArgs>(args: SelectSubset<T, ChallengeTermCreateArgs<ExtArgs>>): Prisma__ChallengeTermClient<$Result.GetResult<Prisma.$ChallengeTermPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many ChallengeTerms.
     * @param {ChallengeTermCreateManyArgs} args - Arguments to create many ChallengeTerms.
     * @example
     * // Create many ChallengeTerms
     * const challengeTerm = await prisma.challengeTerm.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends ChallengeTermCreateManyArgs>(args?: SelectSubset<T, ChallengeTermCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many ChallengeTerms and returns the data saved in the database.
     * @param {ChallengeTermCreateManyAndReturnArgs} args - Arguments to create many ChallengeTerms.
     * @example
     * // Create many ChallengeTerms
     * const challengeTerm = await prisma.challengeTerm.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many ChallengeTerms and only return the `id`
     * const challengeTermWithIdOnly = await prisma.challengeTerm.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends ChallengeTermCreateManyAndReturnArgs>(args?: SelectSubset<T, ChallengeTermCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ChallengeTermPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a ChallengeTerm.
     * @param {ChallengeTermDeleteArgs} args - Arguments to delete one ChallengeTerm.
     * @example
     * // Delete one ChallengeTerm
     * const ChallengeTerm = await prisma.challengeTerm.delete({
     *   where: {
     *     // ... filter to delete one ChallengeTerm
     *   }
     * })
     * 
     */
    delete<T extends ChallengeTermDeleteArgs>(args: SelectSubset<T, ChallengeTermDeleteArgs<ExtArgs>>): Prisma__ChallengeTermClient<$Result.GetResult<Prisma.$ChallengeTermPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one ChallengeTerm.
     * @param {ChallengeTermUpdateArgs} args - Arguments to update one ChallengeTerm.
     * @example
     * // Update one ChallengeTerm
     * const challengeTerm = await prisma.challengeTerm.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends ChallengeTermUpdateArgs>(args: SelectSubset<T, ChallengeTermUpdateArgs<ExtArgs>>): Prisma__ChallengeTermClient<$Result.GetResult<Prisma.$ChallengeTermPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more ChallengeTerms.
     * @param {ChallengeTermDeleteManyArgs} args - Arguments to filter ChallengeTerms to delete.
     * @example
     * // Delete a few ChallengeTerms
     * const { count } = await prisma.challengeTerm.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends ChallengeTermDeleteManyArgs>(args?: SelectSubset<T, ChallengeTermDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more ChallengeTerms.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ChallengeTermUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many ChallengeTerms
     * const challengeTerm = await prisma.challengeTerm.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends ChallengeTermUpdateManyArgs>(args: SelectSubset<T, ChallengeTermUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more ChallengeTerms and returns the data updated in the database.
     * @param {ChallengeTermUpdateManyAndReturnArgs} args - Arguments to update many ChallengeTerms.
     * @example
     * // Update many ChallengeTerms
     * const challengeTerm = await prisma.challengeTerm.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more ChallengeTerms and only return the `id`
     * const challengeTermWithIdOnly = await prisma.challengeTerm.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends ChallengeTermUpdateManyAndReturnArgs>(args: SelectSubset<T, ChallengeTermUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ChallengeTermPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one ChallengeTerm.
     * @param {ChallengeTermUpsertArgs} args - Arguments to update or create a ChallengeTerm.
     * @example
     * // Update or create a ChallengeTerm
     * const challengeTerm = await prisma.challengeTerm.upsert({
     *   create: {
     *     // ... data to create a ChallengeTerm
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the ChallengeTerm we want to update
     *   }
     * })
     */
    upsert<T extends ChallengeTermUpsertArgs>(args: SelectSubset<T, ChallengeTermUpsertArgs<ExtArgs>>): Prisma__ChallengeTermClient<$Result.GetResult<Prisma.$ChallengeTermPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of ChallengeTerms.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ChallengeTermCountArgs} args - Arguments to filter ChallengeTerms to count.
     * @example
     * // Count the number of ChallengeTerms
     * const count = await prisma.challengeTerm.count({
     *   where: {
     *     // ... the filter for the ChallengeTerms we want to count
     *   }
     * })
    **/
    count<T extends ChallengeTermCountArgs>(
      args?: Subset<T, ChallengeTermCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ChallengeTermCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a ChallengeTerm.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ChallengeTermAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ChallengeTermAggregateArgs>(args: Subset<T, ChallengeTermAggregateArgs>): Prisma.PrismaPromise<GetChallengeTermAggregateType<T>>

    /**
     * Group by ChallengeTerm.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ChallengeTermGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ChallengeTermGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ChallengeTermGroupByArgs['orderBy'] }
        : { orderBy?: ChallengeTermGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ChallengeTermGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetChallengeTermGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the ChallengeTerm model
   */
  readonly fields: ChallengeTermFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for ChallengeTerm.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ChallengeTermClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    challenge<T extends ChallengeDefaultArgs<ExtArgs> = {}>(args?: Subset<T, ChallengeDefaultArgs<ExtArgs>>): Prisma__ChallengeClient<$Result.GetResult<Prisma.$ChallengePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the ChallengeTerm model
   */
  interface ChallengeTermFieldRefs {
    readonly id: FieldRef<"ChallengeTerm", 'String'>
    readonly challengeId: FieldRef<"ChallengeTerm", 'String'>
    readonly termId: FieldRef<"ChallengeTerm", 'String'>
    readonly roleId: FieldRef<"ChallengeTerm", 'String'>
    readonly createdAt: FieldRef<"ChallengeTerm", 'DateTime'>
    readonly createdBy: FieldRef<"ChallengeTerm", 'String'>
    readonly updatedAt: FieldRef<"ChallengeTerm", 'DateTime'>
    readonly updatedBy: FieldRef<"ChallengeTerm", 'String'>
  }
    

  // Custom InputTypes
  /**
   * ChallengeTerm findUnique
   */
  export type ChallengeTermFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ChallengeTerm
     */
    select?: ChallengeTermSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ChallengeTerm
     */
    omit?: ChallengeTermOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ChallengeTermInclude<ExtArgs> | null
    /**
     * Filter, which ChallengeTerm to fetch.
     */
    where: ChallengeTermWhereUniqueInput
  }

  /**
   * ChallengeTerm findUniqueOrThrow
   */
  export type ChallengeTermFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ChallengeTerm
     */
    select?: ChallengeTermSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ChallengeTerm
     */
    omit?: ChallengeTermOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ChallengeTermInclude<ExtArgs> | null
    /**
     * Filter, which ChallengeTerm to fetch.
     */
    where: ChallengeTermWhereUniqueInput
  }

  /**
   * ChallengeTerm findFirst
   */
  export type ChallengeTermFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ChallengeTerm
     */
    select?: ChallengeTermSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ChallengeTerm
     */
    omit?: ChallengeTermOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ChallengeTermInclude<ExtArgs> | null
    /**
     * Filter, which ChallengeTerm to fetch.
     */
    where?: ChallengeTermWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ChallengeTerms to fetch.
     */
    orderBy?: ChallengeTermOrderByWithRelationInput | ChallengeTermOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ChallengeTerms.
     */
    cursor?: ChallengeTermWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ChallengeTerms from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ChallengeTerms.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ChallengeTerms.
     */
    distinct?: ChallengeTermScalarFieldEnum | ChallengeTermScalarFieldEnum[]
  }

  /**
   * ChallengeTerm findFirstOrThrow
   */
  export type ChallengeTermFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ChallengeTerm
     */
    select?: ChallengeTermSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ChallengeTerm
     */
    omit?: ChallengeTermOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ChallengeTermInclude<ExtArgs> | null
    /**
     * Filter, which ChallengeTerm to fetch.
     */
    where?: ChallengeTermWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ChallengeTerms to fetch.
     */
    orderBy?: ChallengeTermOrderByWithRelationInput | ChallengeTermOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ChallengeTerms.
     */
    cursor?: ChallengeTermWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ChallengeTerms from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ChallengeTerms.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ChallengeTerms.
     */
    distinct?: ChallengeTermScalarFieldEnum | ChallengeTermScalarFieldEnum[]
  }

  /**
   * ChallengeTerm findMany
   */
  export type ChallengeTermFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ChallengeTerm
     */
    select?: ChallengeTermSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ChallengeTerm
     */
    omit?: ChallengeTermOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ChallengeTermInclude<ExtArgs> | null
    /**
     * Filter, which ChallengeTerms to fetch.
     */
    where?: ChallengeTermWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ChallengeTerms to fetch.
     */
    orderBy?: ChallengeTermOrderByWithRelationInput | ChallengeTermOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing ChallengeTerms.
     */
    cursor?: ChallengeTermWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ChallengeTerms from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ChallengeTerms.
     */
    skip?: number
    distinct?: ChallengeTermScalarFieldEnum | ChallengeTermScalarFieldEnum[]
  }

  /**
   * ChallengeTerm create
   */
  export type ChallengeTermCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ChallengeTerm
     */
    select?: ChallengeTermSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ChallengeTerm
     */
    omit?: ChallengeTermOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ChallengeTermInclude<ExtArgs> | null
    /**
     * The data needed to create a ChallengeTerm.
     */
    data: XOR<ChallengeTermCreateInput, ChallengeTermUncheckedCreateInput>
  }

  /**
   * ChallengeTerm createMany
   */
  export type ChallengeTermCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many ChallengeTerms.
     */
    data: ChallengeTermCreateManyInput | ChallengeTermCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * ChallengeTerm createManyAndReturn
   */
  export type ChallengeTermCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ChallengeTerm
     */
    select?: ChallengeTermSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the ChallengeTerm
     */
    omit?: ChallengeTermOmit<ExtArgs> | null
    /**
     * The data used to create many ChallengeTerms.
     */
    data: ChallengeTermCreateManyInput | ChallengeTermCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ChallengeTermIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * ChallengeTerm update
   */
  export type ChallengeTermUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ChallengeTerm
     */
    select?: ChallengeTermSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ChallengeTerm
     */
    omit?: ChallengeTermOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ChallengeTermInclude<ExtArgs> | null
    /**
     * The data needed to update a ChallengeTerm.
     */
    data: XOR<ChallengeTermUpdateInput, ChallengeTermUncheckedUpdateInput>
    /**
     * Choose, which ChallengeTerm to update.
     */
    where: ChallengeTermWhereUniqueInput
  }

  /**
   * ChallengeTerm updateMany
   */
  export type ChallengeTermUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update ChallengeTerms.
     */
    data: XOR<ChallengeTermUpdateManyMutationInput, ChallengeTermUncheckedUpdateManyInput>
    /**
     * Filter which ChallengeTerms to update
     */
    where?: ChallengeTermWhereInput
    /**
     * Limit how many ChallengeTerms to update.
     */
    limit?: number
  }

  /**
   * ChallengeTerm updateManyAndReturn
   */
  export type ChallengeTermUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ChallengeTerm
     */
    select?: ChallengeTermSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the ChallengeTerm
     */
    omit?: ChallengeTermOmit<ExtArgs> | null
    /**
     * The data used to update ChallengeTerms.
     */
    data: XOR<ChallengeTermUpdateManyMutationInput, ChallengeTermUncheckedUpdateManyInput>
    /**
     * Filter which ChallengeTerms to update
     */
    where?: ChallengeTermWhereInput
    /**
     * Limit how many ChallengeTerms to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ChallengeTermIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * ChallengeTerm upsert
   */
  export type ChallengeTermUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ChallengeTerm
     */
    select?: ChallengeTermSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ChallengeTerm
     */
    omit?: ChallengeTermOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ChallengeTermInclude<ExtArgs> | null
    /**
     * The filter to search for the ChallengeTerm to update in case it exists.
     */
    where: ChallengeTermWhereUniqueInput
    /**
     * In case the ChallengeTerm found by the `where` argument doesn't exist, create a new ChallengeTerm with this data.
     */
    create: XOR<ChallengeTermCreateInput, ChallengeTermUncheckedCreateInput>
    /**
     * In case the ChallengeTerm was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ChallengeTermUpdateInput, ChallengeTermUncheckedUpdateInput>
  }

  /**
   * ChallengeTerm delete
   */
  export type ChallengeTermDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ChallengeTerm
     */
    select?: ChallengeTermSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ChallengeTerm
     */
    omit?: ChallengeTermOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ChallengeTermInclude<ExtArgs> | null
    /**
     * Filter which ChallengeTerm to delete.
     */
    where: ChallengeTermWhereUniqueInput
  }

  /**
   * ChallengeTerm deleteMany
   */
  export type ChallengeTermDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ChallengeTerms to delete
     */
    where?: ChallengeTermWhereInput
    /**
     * Limit how many ChallengeTerms to delete.
     */
    limit?: number
  }

  /**
   * ChallengeTerm without action
   */
  export type ChallengeTermDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ChallengeTerm
     */
    select?: ChallengeTermSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ChallengeTerm
     */
    omit?: ChallengeTermOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ChallengeTermInclude<ExtArgs> | null
  }


  /**
   * Model ChallengeSkill
   */

  export type AggregateChallengeSkill = {
    _count: ChallengeSkillCountAggregateOutputType | null
    _min: ChallengeSkillMinAggregateOutputType | null
    _max: ChallengeSkillMaxAggregateOutputType | null
  }

  export type ChallengeSkillMinAggregateOutputType = {
    id: string | null
    challengeId: string | null
    skillId: string | null
    createdAt: Date | null
    createdBy: string | null
    updatedAt: Date | null
    updatedBy: string | null
  }

  export type ChallengeSkillMaxAggregateOutputType = {
    id: string | null
    challengeId: string | null
    skillId: string | null
    createdAt: Date | null
    createdBy: string | null
    updatedAt: Date | null
    updatedBy: string | null
  }

  export type ChallengeSkillCountAggregateOutputType = {
    id: number
    challengeId: number
    skillId: number
    createdAt: number
    createdBy: number
    updatedAt: number
    updatedBy: number
    _all: number
  }


  export type ChallengeSkillMinAggregateInputType = {
    id?: true
    challengeId?: true
    skillId?: true
    createdAt?: true
    createdBy?: true
    updatedAt?: true
    updatedBy?: true
  }

  export type ChallengeSkillMaxAggregateInputType = {
    id?: true
    challengeId?: true
    skillId?: true
    createdAt?: true
    createdBy?: true
    updatedAt?: true
    updatedBy?: true
  }

  export type ChallengeSkillCountAggregateInputType = {
    id?: true
    challengeId?: true
    skillId?: true
    createdAt?: true
    createdBy?: true
    updatedAt?: true
    updatedBy?: true
    _all?: true
  }

  export type ChallengeSkillAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ChallengeSkill to aggregate.
     */
    where?: ChallengeSkillWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ChallengeSkills to fetch.
     */
    orderBy?: ChallengeSkillOrderByWithRelationInput | ChallengeSkillOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ChallengeSkillWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ChallengeSkills from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ChallengeSkills.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned ChallengeSkills
    **/
    _count?: true | ChallengeSkillCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ChallengeSkillMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ChallengeSkillMaxAggregateInputType
  }

  export type GetChallengeSkillAggregateType<T extends ChallengeSkillAggregateArgs> = {
        [P in keyof T & keyof AggregateChallengeSkill]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateChallengeSkill[P]>
      : GetScalarType<T[P], AggregateChallengeSkill[P]>
  }




  export type ChallengeSkillGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ChallengeSkillWhereInput
    orderBy?: ChallengeSkillOrderByWithAggregationInput | ChallengeSkillOrderByWithAggregationInput[]
    by: ChallengeSkillScalarFieldEnum[] | ChallengeSkillScalarFieldEnum
    having?: ChallengeSkillScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ChallengeSkillCountAggregateInputType | true
    _min?: ChallengeSkillMinAggregateInputType
    _max?: ChallengeSkillMaxAggregateInputType
  }

  export type ChallengeSkillGroupByOutputType = {
    id: string
    challengeId: string
    skillId: string
    createdAt: Date
    createdBy: string
    updatedAt: Date
    updatedBy: string
    _count: ChallengeSkillCountAggregateOutputType | null
    _min: ChallengeSkillMinAggregateOutputType | null
    _max: ChallengeSkillMaxAggregateOutputType | null
  }

  type GetChallengeSkillGroupByPayload<T extends ChallengeSkillGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ChallengeSkillGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ChallengeSkillGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ChallengeSkillGroupByOutputType[P]>
            : GetScalarType<T[P], ChallengeSkillGroupByOutputType[P]>
        }
      >
    >


  export type ChallengeSkillSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    challengeId?: boolean
    skillId?: boolean
    createdAt?: boolean
    createdBy?: boolean
    updatedAt?: boolean
    updatedBy?: boolean
    challenge?: boolean | ChallengeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["challengeSkill"]>

  export type ChallengeSkillSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    challengeId?: boolean
    skillId?: boolean
    createdAt?: boolean
    createdBy?: boolean
    updatedAt?: boolean
    updatedBy?: boolean
    challenge?: boolean | ChallengeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["challengeSkill"]>

  export type ChallengeSkillSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    challengeId?: boolean
    skillId?: boolean
    createdAt?: boolean
    createdBy?: boolean
    updatedAt?: boolean
    updatedBy?: boolean
    challenge?: boolean | ChallengeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["challengeSkill"]>

  export type ChallengeSkillSelectScalar = {
    id?: boolean
    challengeId?: boolean
    skillId?: boolean
    createdAt?: boolean
    createdBy?: boolean
    updatedAt?: boolean
    updatedBy?: boolean
  }

  export type ChallengeSkillOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "challengeId" | "skillId" | "createdAt" | "createdBy" | "updatedAt" | "updatedBy", ExtArgs["result"]["challengeSkill"]>
  export type ChallengeSkillInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    challenge?: boolean | ChallengeDefaultArgs<ExtArgs>
  }
  export type ChallengeSkillIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    challenge?: boolean | ChallengeDefaultArgs<ExtArgs>
  }
  export type ChallengeSkillIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    challenge?: boolean | ChallengeDefaultArgs<ExtArgs>
  }

  export type $ChallengeSkillPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "ChallengeSkill"
    objects: {
      challenge: Prisma.$ChallengePayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      challengeId: string
      skillId: string
      createdAt: Date
      createdBy: string
      updatedAt: Date
      updatedBy: string
    }, ExtArgs["result"]["challengeSkill"]>
    composites: {}
  }

  type ChallengeSkillGetPayload<S extends boolean | null | undefined | ChallengeSkillDefaultArgs> = $Result.GetResult<Prisma.$ChallengeSkillPayload, S>

  type ChallengeSkillCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<ChallengeSkillFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: ChallengeSkillCountAggregateInputType | true
    }

  export interface ChallengeSkillDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['ChallengeSkill'], meta: { name: 'ChallengeSkill' } }
    /**
     * Find zero or one ChallengeSkill that matches the filter.
     * @param {ChallengeSkillFindUniqueArgs} args - Arguments to find a ChallengeSkill
     * @example
     * // Get one ChallengeSkill
     * const challengeSkill = await prisma.challengeSkill.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends ChallengeSkillFindUniqueArgs>(args: SelectSubset<T, ChallengeSkillFindUniqueArgs<ExtArgs>>): Prisma__ChallengeSkillClient<$Result.GetResult<Prisma.$ChallengeSkillPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one ChallengeSkill that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {ChallengeSkillFindUniqueOrThrowArgs} args - Arguments to find a ChallengeSkill
     * @example
     * // Get one ChallengeSkill
     * const challengeSkill = await prisma.challengeSkill.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends ChallengeSkillFindUniqueOrThrowArgs>(args: SelectSubset<T, ChallengeSkillFindUniqueOrThrowArgs<ExtArgs>>): Prisma__ChallengeSkillClient<$Result.GetResult<Prisma.$ChallengeSkillPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first ChallengeSkill that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ChallengeSkillFindFirstArgs} args - Arguments to find a ChallengeSkill
     * @example
     * // Get one ChallengeSkill
     * const challengeSkill = await prisma.challengeSkill.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends ChallengeSkillFindFirstArgs>(args?: SelectSubset<T, ChallengeSkillFindFirstArgs<ExtArgs>>): Prisma__ChallengeSkillClient<$Result.GetResult<Prisma.$ChallengeSkillPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first ChallengeSkill that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ChallengeSkillFindFirstOrThrowArgs} args - Arguments to find a ChallengeSkill
     * @example
     * // Get one ChallengeSkill
     * const challengeSkill = await prisma.challengeSkill.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends ChallengeSkillFindFirstOrThrowArgs>(args?: SelectSubset<T, ChallengeSkillFindFirstOrThrowArgs<ExtArgs>>): Prisma__ChallengeSkillClient<$Result.GetResult<Prisma.$ChallengeSkillPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more ChallengeSkills that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ChallengeSkillFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all ChallengeSkills
     * const challengeSkills = await prisma.challengeSkill.findMany()
     * 
     * // Get first 10 ChallengeSkills
     * const challengeSkills = await prisma.challengeSkill.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const challengeSkillWithIdOnly = await prisma.challengeSkill.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends ChallengeSkillFindManyArgs>(args?: SelectSubset<T, ChallengeSkillFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ChallengeSkillPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a ChallengeSkill.
     * @param {ChallengeSkillCreateArgs} args - Arguments to create a ChallengeSkill.
     * @example
     * // Create one ChallengeSkill
     * const ChallengeSkill = await prisma.challengeSkill.create({
     *   data: {
     *     // ... data to create a ChallengeSkill
     *   }
     * })
     * 
     */
    create<T extends ChallengeSkillCreateArgs>(args: SelectSubset<T, ChallengeSkillCreateArgs<ExtArgs>>): Prisma__ChallengeSkillClient<$Result.GetResult<Prisma.$ChallengeSkillPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many ChallengeSkills.
     * @param {ChallengeSkillCreateManyArgs} args - Arguments to create many ChallengeSkills.
     * @example
     * // Create many ChallengeSkills
     * const challengeSkill = await prisma.challengeSkill.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends ChallengeSkillCreateManyArgs>(args?: SelectSubset<T, ChallengeSkillCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many ChallengeSkills and returns the data saved in the database.
     * @param {ChallengeSkillCreateManyAndReturnArgs} args - Arguments to create many ChallengeSkills.
     * @example
     * // Create many ChallengeSkills
     * const challengeSkill = await prisma.challengeSkill.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many ChallengeSkills and only return the `id`
     * const challengeSkillWithIdOnly = await prisma.challengeSkill.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends ChallengeSkillCreateManyAndReturnArgs>(args?: SelectSubset<T, ChallengeSkillCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ChallengeSkillPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a ChallengeSkill.
     * @param {ChallengeSkillDeleteArgs} args - Arguments to delete one ChallengeSkill.
     * @example
     * // Delete one ChallengeSkill
     * const ChallengeSkill = await prisma.challengeSkill.delete({
     *   where: {
     *     // ... filter to delete one ChallengeSkill
     *   }
     * })
     * 
     */
    delete<T extends ChallengeSkillDeleteArgs>(args: SelectSubset<T, ChallengeSkillDeleteArgs<ExtArgs>>): Prisma__ChallengeSkillClient<$Result.GetResult<Prisma.$ChallengeSkillPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one ChallengeSkill.
     * @param {ChallengeSkillUpdateArgs} args - Arguments to update one ChallengeSkill.
     * @example
     * // Update one ChallengeSkill
     * const challengeSkill = await prisma.challengeSkill.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends ChallengeSkillUpdateArgs>(args: SelectSubset<T, ChallengeSkillUpdateArgs<ExtArgs>>): Prisma__ChallengeSkillClient<$Result.GetResult<Prisma.$ChallengeSkillPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more ChallengeSkills.
     * @param {ChallengeSkillDeleteManyArgs} args - Arguments to filter ChallengeSkills to delete.
     * @example
     * // Delete a few ChallengeSkills
     * const { count } = await prisma.challengeSkill.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends ChallengeSkillDeleteManyArgs>(args?: SelectSubset<T, ChallengeSkillDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more ChallengeSkills.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ChallengeSkillUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many ChallengeSkills
     * const challengeSkill = await prisma.challengeSkill.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends ChallengeSkillUpdateManyArgs>(args: SelectSubset<T, ChallengeSkillUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more ChallengeSkills and returns the data updated in the database.
     * @param {ChallengeSkillUpdateManyAndReturnArgs} args - Arguments to update many ChallengeSkills.
     * @example
     * // Update many ChallengeSkills
     * const challengeSkill = await prisma.challengeSkill.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more ChallengeSkills and only return the `id`
     * const challengeSkillWithIdOnly = await prisma.challengeSkill.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends ChallengeSkillUpdateManyAndReturnArgs>(args: SelectSubset<T, ChallengeSkillUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ChallengeSkillPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one ChallengeSkill.
     * @param {ChallengeSkillUpsertArgs} args - Arguments to update or create a ChallengeSkill.
     * @example
     * // Update or create a ChallengeSkill
     * const challengeSkill = await prisma.challengeSkill.upsert({
     *   create: {
     *     // ... data to create a ChallengeSkill
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the ChallengeSkill we want to update
     *   }
     * })
     */
    upsert<T extends ChallengeSkillUpsertArgs>(args: SelectSubset<T, ChallengeSkillUpsertArgs<ExtArgs>>): Prisma__ChallengeSkillClient<$Result.GetResult<Prisma.$ChallengeSkillPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of ChallengeSkills.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ChallengeSkillCountArgs} args - Arguments to filter ChallengeSkills to count.
     * @example
     * // Count the number of ChallengeSkills
     * const count = await prisma.challengeSkill.count({
     *   where: {
     *     // ... the filter for the ChallengeSkills we want to count
     *   }
     * })
    **/
    count<T extends ChallengeSkillCountArgs>(
      args?: Subset<T, ChallengeSkillCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ChallengeSkillCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a ChallengeSkill.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ChallengeSkillAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ChallengeSkillAggregateArgs>(args: Subset<T, ChallengeSkillAggregateArgs>): Prisma.PrismaPromise<GetChallengeSkillAggregateType<T>>

    /**
     * Group by ChallengeSkill.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ChallengeSkillGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ChallengeSkillGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ChallengeSkillGroupByArgs['orderBy'] }
        : { orderBy?: ChallengeSkillGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ChallengeSkillGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetChallengeSkillGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the ChallengeSkill model
   */
  readonly fields: ChallengeSkillFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for ChallengeSkill.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ChallengeSkillClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    challenge<T extends ChallengeDefaultArgs<ExtArgs> = {}>(args?: Subset<T, ChallengeDefaultArgs<ExtArgs>>): Prisma__ChallengeClient<$Result.GetResult<Prisma.$ChallengePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the ChallengeSkill model
   */
  interface ChallengeSkillFieldRefs {
    readonly id: FieldRef<"ChallengeSkill", 'String'>
    readonly challengeId: FieldRef<"ChallengeSkill", 'String'>
    readonly skillId: FieldRef<"ChallengeSkill", 'String'>
    readonly createdAt: FieldRef<"ChallengeSkill", 'DateTime'>
    readonly createdBy: FieldRef<"ChallengeSkill", 'String'>
    readonly updatedAt: FieldRef<"ChallengeSkill", 'DateTime'>
    readonly updatedBy: FieldRef<"ChallengeSkill", 'String'>
  }
    

  // Custom InputTypes
  /**
   * ChallengeSkill findUnique
   */
  export type ChallengeSkillFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ChallengeSkill
     */
    select?: ChallengeSkillSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ChallengeSkill
     */
    omit?: ChallengeSkillOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ChallengeSkillInclude<ExtArgs> | null
    /**
     * Filter, which ChallengeSkill to fetch.
     */
    where: ChallengeSkillWhereUniqueInput
  }

  /**
   * ChallengeSkill findUniqueOrThrow
   */
  export type ChallengeSkillFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ChallengeSkill
     */
    select?: ChallengeSkillSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ChallengeSkill
     */
    omit?: ChallengeSkillOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ChallengeSkillInclude<ExtArgs> | null
    /**
     * Filter, which ChallengeSkill to fetch.
     */
    where: ChallengeSkillWhereUniqueInput
  }

  /**
   * ChallengeSkill findFirst
   */
  export type ChallengeSkillFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ChallengeSkill
     */
    select?: ChallengeSkillSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ChallengeSkill
     */
    omit?: ChallengeSkillOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ChallengeSkillInclude<ExtArgs> | null
    /**
     * Filter, which ChallengeSkill to fetch.
     */
    where?: ChallengeSkillWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ChallengeSkills to fetch.
     */
    orderBy?: ChallengeSkillOrderByWithRelationInput | ChallengeSkillOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ChallengeSkills.
     */
    cursor?: ChallengeSkillWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ChallengeSkills from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ChallengeSkills.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ChallengeSkills.
     */
    distinct?: ChallengeSkillScalarFieldEnum | ChallengeSkillScalarFieldEnum[]
  }

  /**
   * ChallengeSkill findFirstOrThrow
   */
  export type ChallengeSkillFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ChallengeSkill
     */
    select?: ChallengeSkillSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ChallengeSkill
     */
    omit?: ChallengeSkillOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ChallengeSkillInclude<ExtArgs> | null
    /**
     * Filter, which ChallengeSkill to fetch.
     */
    where?: ChallengeSkillWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ChallengeSkills to fetch.
     */
    orderBy?: ChallengeSkillOrderByWithRelationInput | ChallengeSkillOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ChallengeSkills.
     */
    cursor?: ChallengeSkillWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ChallengeSkills from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ChallengeSkills.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ChallengeSkills.
     */
    distinct?: ChallengeSkillScalarFieldEnum | ChallengeSkillScalarFieldEnum[]
  }

  /**
   * ChallengeSkill findMany
   */
  export type ChallengeSkillFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ChallengeSkill
     */
    select?: ChallengeSkillSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ChallengeSkill
     */
    omit?: ChallengeSkillOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ChallengeSkillInclude<ExtArgs> | null
    /**
     * Filter, which ChallengeSkills to fetch.
     */
    where?: ChallengeSkillWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ChallengeSkills to fetch.
     */
    orderBy?: ChallengeSkillOrderByWithRelationInput | ChallengeSkillOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing ChallengeSkills.
     */
    cursor?: ChallengeSkillWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ChallengeSkills from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ChallengeSkills.
     */
    skip?: number
    distinct?: ChallengeSkillScalarFieldEnum | ChallengeSkillScalarFieldEnum[]
  }

  /**
   * ChallengeSkill create
   */
  export type ChallengeSkillCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ChallengeSkill
     */
    select?: ChallengeSkillSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ChallengeSkill
     */
    omit?: ChallengeSkillOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ChallengeSkillInclude<ExtArgs> | null
    /**
     * The data needed to create a ChallengeSkill.
     */
    data: XOR<ChallengeSkillCreateInput, ChallengeSkillUncheckedCreateInput>
  }

  /**
   * ChallengeSkill createMany
   */
  export type ChallengeSkillCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many ChallengeSkills.
     */
    data: ChallengeSkillCreateManyInput | ChallengeSkillCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * ChallengeSkill createManyAndReturn
   */
  export type ChallengeSkillCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ChallengeSkill
     */
    select?: ChallengeSkillSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the ChallengeSkill
     */
    omit?: ChallengeSkillOmit<ExtArgs> | null
    /**
     * The data used to create many ChallengeSkills.
     */
    data: ChallengeSkillCreateManyInput | ChallengeSkillCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ChallengeSkillIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * ChallengeSkill update
   */
  export type ChallengeSkillUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ChallengeSkill
     */
    select?: ChallengeSkillSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ChallengeSkill
     */
    omit?: ChallengeSkillOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ChallengeSkillInclude<ExtArgs> | null
    /**
     * The data needed to update a ChallengeSkill.
     */
    data: XOR<ChallengeSkillUpdateInput, ChallengeSkillUncheckedUpdateInput>
    /**
     * Choose, which ChallengeSkill to update.
     */
    where: ChallengeSkillWhereUniqueInput
  }

  /**
   * ChallengeSkill updateMany
   */
  export type ChallengeSkillUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update ChallengeSkills.
     */
    data: XOR<ChallengeSkillUpdateManyMutationInput, ChallengeSkillUncheckedUpdateManyInput>
    /**
     * Filter which ChallengeSkills to update
     */
    where?: ChallengeSkillWhereInput
    /**
     * Limit how many ChallengeSkills to update.
     */
    limit?: number
  }

  /**
   * ChallengeSkill updateManyAndReturn
   */
  export type ChallengeSkillUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ChallengeSkill
     */
    select?: ChallengeSkillSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the ChallengeSkill
     */
    omit?: ChallengeSkillOmit<ExtArgs> | null
    /**
     * The data used to update ChallengeSkills.
     */
    data: XOR<ChallengeSkillUpdateManyMutationInput, ChallengeSkillUncheckedUpdateManyInput>
    /**
     * Filter which ChallengeSkills to update
     */
    where?: ChallengeSkillWhereInput
    /**
     * Limit how many ChallengeSkills to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ChallengeSkillIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * ChallengeSkill upsert
   */
  export type ChallengeSkillUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ChallengeSkill
     */
    select?: ChallengeSkillSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ChallengeSkill
     */
    omit?: ChallengeSkillOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ChallengeSkillInclude<ExtArgs> | null
    /**
     * The filter to search for the ChallengeSkill to update in case it exists.
     */
    where: ChallengeSkillWhereUniqueInput
    /**
     * In case the ChallengeSkill found by the `where` argument doesn't exist, create a new ChallengeSkill with this data.
     */
    create: XOR<ChallengeSkillCreateInput, ChallengeSkillUncheckedCreateInput>
    /**
     * In case the ChallengeSkill was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ChallengeSkillUpdateInput, ChallengeSkillUncheckedUpdateInput>
  }

  /**
   * ChallengeSkill delete
   */
  export type ChallengeSkillDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ChallengeSkill
     */
    select?: ChallengeSkillSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ChallengeSkill
     */
    omit?: ChallengeSkillOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ChallengeSkillInclude<ExtArgs> | null
    /**
     * Filter which ChallengeSkill to delete.
     */
    where: ChallengeSkillWhereUniqueInput
  }

  /**
   * ChallengeSkill deleteMany
   */
  export type ChallengeSkillDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ChallengeSkills to delete
     */
    where?: ChallengeSkillWhereInput
    /**
     * Limit how many ChallengeSkills to delete.
     */
    limit?: number
  }

  /**
   * ChallengeSkill without action
   */
  export type ChallengeSkillDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ChallengeSkill
     */
    select?: ChallengeSkillSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ChallengeSkill
     */
    omit?: ChallengeSkillOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ChallengeSkillInclude<ExtArgs> | null
  }


  /**
   * Model ChallengeBilling
   */

  export type AggregateChallengeBilling = {
    _count: ChallengeBillingCountAggregateOutputType | null
    _avg: ChallengeBillingAvgAggregateOutputType | null
    _sum: ChallengeBillingSumAggregateOutputType | null
    _min: ChallengeBillingMinAggregateOutputType | null
    _max: ChallengeBillingMaxAggregateOutputType | null
  }

  export type ChallengeBillingAvgAggregateOutputType = {
    markup: number | null
    clientBillingRate: number | null
  }

  export type ChallengeBillingSumAggregateOutputType = {
    markup: number | null
    clientBillingRate: number | null
  }

  export type ChallengeBillingMinAggregateOutputType = {
    id: string | null
    billingAccountId: string | null
    markup: number | null
    clientBillingRate: number | null
    challengeId: string | null
    createdAt: Date | null
    createdBy: string | null
    updatedAt: Date | null
    updatedBy: string | null
  }

  export type ChallengeBillingMaxAggregateOutputType = {
    id: string | null
    billingAccountId: string | null
    markup: number | null
    clientBillingRate: number | null
    challengeId: string | null
    createdAt: Date | null
    createdBy: string | null
    updatedAt: Date | null
    updatedBy: string | null
  }

  export type ChallengeBillingCountAggregateOutputType = {
    id: number
    billingAccountId: number
    markup: number
    clientBillingRate: number
    challengeId: number
    createdAt: number
    createdBy: number
    updatedAt: number
    updatedBy: number
    _all: number
  }


  export type ChallengeBillingAvgAggregateInputType = {
    markup?: true
    clientBillingRate?: true
  }

  export type ChallengeBillingSumAggregateInputType = {
    markup?: true
    clientBillingRate?: true
  }

  export type ChallengeBillingMinAggregateInputType = {
    id?: true
    billingAccountId?: true
    markup?: true
    clientBillingRate?: true
    challengeId?: true
    createdAt?: true
    createdBy?: true
    updatedAt?: true
    updatedBy?: true
  }

  export type ChallengeBillingMaxAggregateInputType = {
    id?: true
    billingAccountId?: true
    markup?: true
    clientBillingRate?: true
    challengeId?: true
    createdAt?: true
    createdBy?: true
    updatedAt?: true
    updatedBy?: true
  }

  export type ChallengeBillingCountAggregateInputType = {
    id?: true
    billingAccountId?: true
    markup?: true
    clientBillingRate?: true
    challengeId?: true
    createdAt?: true
    createdBy?: true
    updatedAt?: true
    updatedBy?: true
    _all?: true
  }

  export type ChallengeBillingAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ChallengeBilling to aggregate.
     */
    where?: ChallengeBillingWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ChallengeBillings to fetch.
     */
    orderBy?: ChallengeBillingOrderByWithRelationInput | ChallengeBillingOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ChallengeBillingWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ChallengeBillings from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ChallengeBillings.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned ChallengeBillings
    **/
    _count?: true | ChallengeBillingCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: ChallengeBillingAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: ChallengeBillingSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ChallengeBillingMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ChallengeBillingMaxAggregateInputType
  }

  export type GetChallengeBillingAggregateType<T extends ChallengeBillingAggregateArgs> = {
        [P in keyof T & keyof AggregateChallengeBilling]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateChallengeBilling[P]>
      : GetScalarType<T[P], AggregateChallengeBilling[P]>
  }




  export type ChallengeBillingGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ChallengeBillingWhereInput
    orderBy?: ChallengeBillingOrderByWithAggregationInput | ChallengeBillingOrderByWithAggregationInput[]
    by: ChallengeBillingScalarFieldEnum[] | ChallengeBillingScalarFieldEnum
    having?: ChallengeBillingScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ChallengeBillingCountAggregateInputType | true
    _avg?: ChallengeBillingAvgAggregateInputType
    _sum?: ChallengeBillingSumAggregateInputType
    _min?: ChallengeBillingMinAggregateInputType
    _max?: ChallengeBillingMaxAggregateInputType
  }

  export type ChallengeBillingGroupByOutputType = {
    id: string
    billingAccountId: string | null
    markup: number | null
    clientBillingRate: number | null
    challengeId: string
    createdAt: Date
    createdBy: string
    updatedAt: Date
    updatedBy: string
    _count: ChallengeBillingCountAggregateOutputType | null
    _avg: ChallengeBillingAvgAggregateOutputType | null
    _sum: ChallengeBillingSumAggregateOutputType | null
    _min: ChallengeBillingMinAggregateOutputType | null
    _max: ChallengeBillingMaxAggregateOutputType | null
  }

  type GetChallengeBillingGroupByPayload<T extends ChallengeBillingGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ChallengeBillingGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ChallengeBillingGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ChallengeBillingGroupByOutputType[P]>
            : GetScalarType<T[P], ChallengeBillingGroupByOutputType[P]>
        }
      >
    >


  export type ChallengeBillingSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    billingAccountId?: boolean
    markup?: boolean
    clientBillingRate?: boolean
    challengeId?: boolean
    createdAt?: boolean
    createdBy?: boolean
    updatedAt?: boolean
    updatedBy?: boolean
    challenge?: boolean | ChallengeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["challengeBilling"]>

  export type ChallengeBillingSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    billingAccountId?: boolean
    markup?: boolean
    clientBillingRate?: boolean
    challengeId?: boolean
    createdAt?: boolean
    createdBy?: boolean
    updatedAt?: boolean
    updatedBy?: boolean
    challenge?: boolean | ChallengeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["challengeBilling"]>

  export type ChallengeBillingSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    billingAccountId?: boolean
    markup?: boolean
    clientBillingRate?: boolean
    challengeId?: boolean
    createdAt?: boolean
    createdBy?: boolean
    updatedAt?: boolean
    updatedBy?: boolean
    challenge?: boolean | ChallengeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["challengeBilling"]>

  export type ChallengeBillingSelectScalar = {
    id?: boolean
    billingAccountId?: boolean
    markup?: boolean
    clientBillingRate?: boolean
    challengeId?: boolean
    createdAt?: boolean
    createdBy?: boolean
    updatedAt?: boolean
    updatedBy?: boolean
  }

  export type ChallengeBillingOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "billingAccountId" | "markup" | "clientBillingRate" | "challengeId" | "createdAt" | "createdBy" | "updatedAt" | "updatedBy", ExtArgs["result"]["challengeBilling"]>
  export type ChallengeBillingInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    challenge?: boolean | ChallengeDefaultArgs<ExtArgs>
  }
  export type ChallengeBillingIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    challenge?: boolean | ChallengeDefaultArgs<ExtArgs>
  }
  export type ChallengeBillingIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    challenge?: boolean | ChallengeDefaultArgs<ExtArgs>
  }

  export type $ChallengeBillingPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "ChallengeBilling"
    objects: {
      challenge: Prisma.$ChallengePayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      billingAccountId: string | null
      markup: number | null
      clientBillingRate: number | null
      challengeId: string
      createdAt: Date
      createdBy: string
      updatedAt: Date
      updatedBy: string
    }, ExtArgs["result"]["challengeBilling"]>
    composites: {}
  }

  type ChallengeBillingGetPayload<S extends boolean | null | undefined | ChallengeBillingDefaultArgs> = $Result.GetResult<Prisma.$ChallengeBillingPayload, S>

  type ChallengeBillingCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<ChallengeBillingFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: ChallengeBillingCountAggregateInputType | true
    }

  export interface ChallengeBillingDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['ChallengeBilling'], meta: { name: 'ChallengeBilling' } }
    /**
     * Find zero or one ChallengeBilling that matches the filter.
     * @param {ChallengeBillingFindUniqueArgs} args - Arguments to find a ChallengeBilling
     * @example
     * // Get one ChallengeBilling
     * const challengeBilling = await prisma.challengeBilling.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends ChallengeBillingFindUniqueArgs>(args: SelectSubset<T, ChallengeBillingFindUniqueArgs<ExtArgs>>): Prisma__ChallengeBillingClient<$Result.GetResult<Prisma.$ChallengeBillingPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one ChallengeBilling that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {ChallengeBillingFindUniqueOrThrowArgs} args - Arguments to find a ChallengeBilling
     * @example
     * // Get one ChallengeBilling
     * const challengeBilling = await prisma.challengeBilling.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends ChallengeBillingFindUniqueOrThrowArgs>(args: SelectSubset<T, ChallengeBillingFindUniqueOrThrowArgs<ExtArgs>>): Prisma__ChallengeBillingClient<$Result.GetResult<Prisma.$ChallengeBillingPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first ChallengeBilling that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ChallengeBillingFindFirstArgs} args - Arguments to find a ChallengeBilling
     * @example
     * // Get one ChallengeBilling
     * const challengeBilling = await prisma.challengeBilling.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends ChallengeBillingFindFirstArgs>(args?: SelectSubset<T, ChallengeBillingFindFirstArgs<ExtArgs>>): Prisma__ChallengeBillingClient<$Result.GetResult<Prisma.$ChallengeBillingPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first ChallengeBilling that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ChallengeBillingFindFirstOrThrowArgs} args - Arguments to find a ChallengeBilling
     * @example
     * // Get one ChallengeBilling
     * const challengeBilling = await prisma.challengeBilling.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends ChallengeBillingFindFirstOrThrowArgs>(args?: SelectSubset<T, ChallengeBillingFindFirstOrThrowArgs<ExtArgs>>): Prisma__ChallengeBillingClient<$Result.GetResult<Prisma.$ChallengeBillingPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more ChallengeBillings that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ChallengeBillingFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all ChallengeBillings
     * const challengeBillings = await prisma.challengeBilling.findMany()
     * 
     * // Get first 10 ChallengeBillings
     * const challengeBillings = await prisma.challengeBilling.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const challengeBillingWithIdOnly = await prisma.challengeBilling.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends ChallengeBillingFindManyArgs>(args?: SelectSubset<T, ChallengeBillingFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ChallengeBillingPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a ChallengeBilling.
     * @param {ChallengeBillingCreateArgs} args - Arguments to create a ChallengeBilling.
     * @example
     * // Create one ChallengeBilling
     * const ChallengeBilling = await prisma.challengeBilling.create({
     *   data: {
     *     // ... data to create a ChallengeBilling
     *   }
     * })
     * 
     */
    create<T extends ChallengeBillingCreateArgs>(args: SelectSubset<T, ChallengeBillingCreateArgs<ExtArgs>>): Prisma__ChallengeBillingClient<$Result.GetResult<Prisma.$ChallengeBillingPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many ChallengeBillings.
     * @param {ChallengeBillingCreateManyArgs} args - Arguments to create many ChallengeBillings.
     * @example
     * // Create many ChallengeBillings
     * const challengeBilling = await prisma.challengeBilling.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends ChallengeBillingCreateManyArgs>(args?: SelectSubset<T, ChallengeBillingCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many ChallengeBillings and returns the data saved in the database.
     * @param {ChallengeBillingCreateManyAndReturnArgs} args - Arguments to create many ChallengeBillings.
     * @example
     * // Create many ChallengeBillings
     * const challengeBilling = await prisma.challengeBilling.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many ChallengeBillings and only return the `id`
     * const challengeBillingWithIdOnly = await prisma.challengeBilling.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends ChallengeBillingCreateManyAndReturnArgs>(args?: SelectSubset<T, ChallengeBillingCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ChallengeBillingPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a ChallengeBilling.
     * @param {ChallengeBillingDeleteArgs} args - Arguments to delete one ChallengeBilling.
     * @example
     * // Delete one ChallengeBilling
     * const ChallengeBilling = await prisma.challengeBilling.delete({
     *   where: {
     *     // ... filter to delete one ChallengeBilling
     *   }
     * })
     * 
     */
    delete<T extends ChallengeBillingDeleteArgs>(args: SelectSubset<T, ChallengeBillingDeleteArgs<ExtArgs>>): Prisma__ChallengeBillingClient<$Result.GetResult<Prisma.$ChallengeBillingPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one ChallengeBilling.
     * @param {ChallengeBillingUpdateArgs} args - Arguments to update one ChallengeBilling.
     * @example
     * // Update one ChallengeBilling
     * const challengeBilling = await prisma.challengeBilling.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends ChallengeBillingUpdateArgs>(args: SelectSubset<T, ChallengeBillingUpdateArgs<ExtArgs>>): Prisma__ChallengeBillingClient<$Result.GetResult<Prisma.$ChallengeBillingPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more ChallengeBillings.
     * @param {ChallengeBillingDeleteManyArgs} args - Arguments to filter ChallengeBillings to delete.
     * @example
     * // Delete a few ChallengeBillings
     * const { count } = await prisma.challengeBilling.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends ChallengeBillingDeleteManyArgs>(args?: SelectSubset<T, ChallengeBillingDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more ChallengeBillings.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ChallengeBillingUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many ChallengeBillings
     * const challengeBilling = await prisma.challengeBilling.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends ChallengeBillingUpdateManyArgs>(args: SelectSubset<T, ChallengeBillingUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more ChallengeBillings and returns the data updated in the database.
     * @param {ChallengeBillingUpdateManyAndReturnArgs} args - Arguments to update many ChallengeBillings.
     * @example
     * // Update many ChallengeBillings
     * const challengeBilling = await prisma.challengeBilling.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more ChallengeBillings and only return the `id`
     * const challengeBillingWithIdOnly = await prisma.challengeBilling.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends ChallengeBillingUpdateManyAndReturnArgs>(args: SelectSubset<T, ChallengeBillingUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ChallengeBillingPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one ChallengeBilling.
     * @param {ChallengeBillingUpsertArgs} args - Arguments to update or create a ChallengeBilling.
     * @example
     * // Update or create a ChallengeBilling
     * const challengeBilling = await prisma.challengeBilling.upsert({
     *   create: {
     *     // ... data to create a ChallengeBilling
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the ChallengeBilling we want to update
     *   }
     * })
     */
    upsert<T extends ChallengeBillingUpsertArgs>(args: SelectSubset<T, ChallengeBillingUpsertArgs<ExtArgs>>): Prisma__ChallengeBillingClient<$Result.GetResult<Prisma.$ChallengeBillingPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of ChallengeBillings.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ChallengeBillingCountArgs} args - Arguments to filter ChallengeBillings to count.
     * @example
     * // Count the number of ChallengeBillings
     * const count = await prisma.challengeBilling.count({
     *   where: {
     *     // ... the filter for the ChallengeBillings we want to count
     *   }
     * })
    **/
    count<T extends ChallengeBillingCountArgs>(
      args?: Subset<T, ChallengeBillingCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ChallengeBillingCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a ChallengeBilling.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ChallengeBillingAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ChallengeBillingAggregateArgs>(args: Subset<T, ChallengeBillingAggregateArgs>): Prisma.PrismaPromise<GetChallengeBillingAggregateType<T>>

    /**
     * Group by ChallengeBilling.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ChallengeBillingGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ChallengeBillingGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ChallengeBillingGroupByArgs['orderBy'] }
        : { orderBy?: ChallengeBillingGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ChallengeBillingGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetChallengeBillingGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the ChallengeBilling model
   */
  readonly fields: ChallengeBillingFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for ChallengeBilling.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ChallengeBillingClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    challenge<T extends ChallengeDefaultArgs<ExtArgs> = {}>(args?: Subset<T, ChallengeDefaultArgs<ExtArgs>>): Prisma__ChallengeClient<$Result.GetResult<Prisma.$ChallengePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the ChallengeBilling model
   */
  interface ChallengeBillingFieldRefs {
    readonly id: FieldRef<"ChallengeBilling", 'String'>
    readonly billingAccountId: FieldRef<"ChallengeBilling", 'String'>
    readonly markup: FieldRef<"ChallengeBilling", 'Float'>
    readonly clientBillingRate: FieldRef<"ChallengeBilling", 'Float'>
    readonly challengeId: FieldRef<"ChallengeBilling", 'String'>
    readonly createdAt: FieldRef<"ChallengeBilling", 'DateTime'>
    readonly createdBy: FieldRef<"ChallengeBilling", 'String'>
    readonly updatedAt: FieldRef<"ChallengeBilling", 'DateTime'>
    readonly updatedBy: FieldRef<"ChallengeBilling", 'String'>
  }
    

  // Custom InputTypes
  /**
   * ChallengeBilling findUnique
   */
  export type ChallengeBillingFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ChallengeBilling
     */
    select?: ChallengeBillingSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ChallengeBilling
     */
    omit?: ChallengeBillingOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ChallengeBillingInclude<ExtArgs> | null
    /**
     * Filter, which ChallengeBilling to fetch.
     */
    where: ChallengeBillingWhereUniqueInput
  }

  /**
   * ChallengeBilling findUniqueOrThrow
   */
  export type ChallengeBillingFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ChallengeBilling
     */
    select?: ChallengeBillingSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ChallengeBilling
     */
    omit?: ChallengeBillingOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ChallengeBillingInclude<ExtArgs> | null
    /**
     * Filter, which ChallengeBilling to fetch.
     */
    where: ChallengeBillingWhereUniqueInput
  }

  /**
   * ChallengeBilling findFirst
   */
  export type ChallengeBillingFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ChallengeBilling
     */
    select?: ChallengeBillingSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ChallengeBilling
     */
    omit?: ChallengeBillingOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ChallengeBillingInclude<ExtArgs> | null
    /**
     * Filter, which ChallengeBilling to fetch.
     */
    where?: ChallengeBillingWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ChallengeBillings to fetch.
     */
    orderBy?: ChallengeBillingOrderByWithRelationInput | ChallengeBillingOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ChallengeBillings.
     */
    cursor?: ChallengeBillingWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ChallengeBillings from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ChallengeBillings.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ChallengeBillings.
     */
    distinct?: ChallengeBillingScalarFieldEnum | ChallengeBillingScalarFieldEnum[]
  }

  /**
   * ChallengeBilling findFirstOrThrow
   */
  export type ChallengeBillingFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ChallengeBilling
     */
    select?: ChallengeBillingSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ChallengeBilling
     */
    omit?: ChallengeBillingOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ChallengeBillingInclude<ExtArgs> | null
    /**
     * Filter, which ChallengeBilling to fetch.
     */
    where?: ChallengeBillingWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ChallengeBillings to fetch.
     */
    orderBy?: ChallengeBillingOrderByWithRelationInput | ChallengeBillingOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ChallengeBillings.
     */
    cursor?: ChallengeBillingWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ChallengeBillings from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ChallengeBillings.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ChallengeBillings.
     */
    distinct?: ChallengeBillingScalarFieldEnum | ChallengeBillingScalarFieldEnum[]
  }

  /**
   * ChallengeBilling findMany
   */
  export type ChallengeBillingFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ChallengeBilling
     */
    select?: ChallengeBillingSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ChallengeBilling
     */
    omit?: ChallengeBillingOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ChallengeBillingInclude<ExtArgs> | null
    /**
     * Filter, which ChallengeBillings to fetch.
     */
    where?: ChallengeBillingWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ChallengeBillings to fetch.
     */
    orderBy?: ChallengeBillingOrderByWithRelationInput | ChallengeBillingOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing ChallengeBillings.
     */
    cursor?: ChallengeBillingWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ChallengeBillings from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ChallengeBillings.
     */
    skip?: number
    distinct?: ChallengeBillingScalarFieldEnum | ChallengeBillingScalarFieldEnum[]
  }

  /**
   * ChallengeBilling create
   */
  export type ChallengeBillingCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ChallengeBilling
     */
    select?: ChallengeBillingSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ChallengeBilling
     */
    omit?: ChallengeBillingOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ChallengeBillingInclude<ExtArgs> | null
    /**
     * The data needed to create a ChallengeBilling.
     */
    data: XOR<ChallengeBillingCreateInput, ChallengeBillingUncheckedCreateInput>
  }

  /**
   * ChallengeBilling createMany
   */
  export type ChallengeBillingCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many ChallengeBillings.
     */
    data: ChallengeBillingCreateManyInput | ChallengeBillingCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * ChallengeBilling createManyAndReturn
   */
  export type ChallengeBillingCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ChallengeBilling
     */
    select?: ChallengeBillingSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the ChallengeBilling
     */
    omit?: ChallengeBillingOmit<ExtArgs> | null
    /**
     * The data used to create many ChallengeBillings.
     */
    data: ChallengeBillingCreateManyInput | ChallengeBillingCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ChallengeBillingIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * ChallengeBilling update
   */
  export type ChallengeBillingUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ChallengeBilling
     */
    select?: ChallengeBillingSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ChallengeBilling
     */
    omit?: ChallengeBillingOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ChallengeBillingInclude<ExtArgs> | null
    /**
     * The data needed to update a ChallengeBilling.
     */
    data: XOR<ChallengeBillingUpdateInput, ChallengeBillingUncheckedUpdateInput>
    /**
     * Choose, which ChallengeBilling to update.
     */
    where: ChallengeBillingWhereUniqueInput
  }

  /**
   * ChallengeBilling updateMany
   */
  export type ChallengeBillingUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update ChallengeBillings.
     */
    data: XOR<ChallengeBillingUpdateManyMutationInput, ChallengeBillingUncheckedUpdateManyInput>
    /**
     * Filter which ChallengeBillings to update
     */
    where?: ChallengeBillingWhereInput
    /**
     * Limit how many ChallengeBillings to update.
     */
    limit?: number
  }

  /**
   * ChallengeBilling updateManyAndReturn
   */
  export type ChallengeBillingUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ChallengeBilling
     */
    select?: ChallengeBillingSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the ChallengeBilling
     */
    omit?: ChallengeBillingOmit<ExtArgs> | null
    /**
     * The data used to update ChallengeBillings.
     */
    data: XOR<ChallengeBillingUpdateManyMutationInput, ChallengeBillingUncheckedUpdateManyInput>
    /**
     * Filter which ChallengeBillings to update
     */
    where?: ChallengeBillingWhereInput
    /**
     * Limit how many ChallengeBillings to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ChallengeBillingIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * ChallengeBilling upsert
   */
  export type ChallengeBillingUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ChallengeBilling
     */
    select?: ChallengeBillingSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ChallengeBilling
     */
    omit?: ChallengeBillingOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ChallengeBillingInclude<ExtArgs> | null
    /**
     * The filter to search for the ChallengeBilling to update in case it exists.
     */
    where: ChallengeBillingWhereUniqueInput
    /**
     * In case the ChallengeBilling found by the `where` argument doesn't exist, create a new ChallengeBilling with this data.
     */
    create: XOR<ChallengeBillingCreateInput, ChallengeBillingUncheckedCreateInput>
    /**
     * In case the ChallengeBilling was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ChallengeBillingUpdateInput, ChallengeBillingUncheckedUpdateInput>
  }

  /**
   * ChallengeBilling delete
   */
  export type ChallengeBillingDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ChallengeBilling
     */
    select?: ChallengeBillingSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ChallengeBilling
     */
    omit?: ChallengeBillingOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ChallengeBillingInclude<ExtArgs> | null
    /**
     * Filter which ChallengeBilling to delete.
     */
    where: ChallengeBillingWhereUniqueInput
  }

  /**
   * ChallengeBilling deleteMany
   */
  export type ChallengeBillingDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ChallengeBillings to delete
     */
    where?: ChallengeBillingWhereInput
    /**
     * Limit how many ChallengeBillings to delete.
     */
    limit?: number
  }

  /**
   * ChallengeBilling without action
   */
  export type ChallengeBillingDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ChallengeBilling
     */
    select?: ChallengeBillingSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ChallengeBilling
     */
    omit?: ChallengeBillingOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ChallengeBillingInclude<ExtArgs> | null
  }


  /**
   * Model ChallengeLegacy
   */

  export type AggregateChallengeLegacy = {
    _count: ChallengeLegacyCountAggregateOutputType | null
    _avg: ChallengeLegacyAvgAggregateOutputType | null
    _sum: ChallengeLegacySumAggregateOutputType | null
    _min: ChallengeLegacyMinAggregateOutputType | null
    _max: ChallengeLegacyMaxAggregateOutputType | null
  }

  export type ChallengeLegacyAvgAggregateOutputType = {
    forumId: number | null
    directProjectId: number | null
    screeningScorecardId: number | null
    reviewScorecardId: number | null
    legacySystemId: number | null
  }

  export type ChallengeLegacySumAggregateOutputType = {
    forumId: number | null
    directProjectId: number | null
    screeningScorecardId: number | null
    reviewScorecardId: number | null
    legacySystemId: number | null
  }

  export type ChallengeLegacyMinAggregateOutputType = {
    id: string | null
    reviewType: $Enums.ReviewTypeEnum | null
    confidentialityType: string | null
    forumId: number | null
    directProjectId: number | null
    screeningScorecardId: number | null
    reviewScorecardId: number | null
    isTask: boolean | null
    useSchedulingAPI: boolean | null
    pureV5Task: boolean | null
    pureV5: boolean | null
    selfService: boolean | null
    selfServiceCopilot: string | null
    track: string | null
    subTrack: string | null
    legacySystemId: number | null
    challengeId: string | null
    createdAt: Date | null
    createdBy: string | null
    updatedAt: Date | null
    updatedBy: string | null
  }

  export type ChallengeLegacyMaxAggregateOutputType = {
    id: string | null
    reviewType: $Enums.ReviewTypeEnum | null
    confidentialityType: string | null
    forumId: number | null
    directProjectId: number | null
    screeningScorecardId: number | null
    reviewScorecardId: number | null
    isTask: boolean | null
    useSchedulingAPI: boolean | null
    pureV5Task: boolean | null
    pureV5: boolean | null
    selfService: boolean | null
    selfServiceCopilot: string | null
    track: string | null
    subTrack: string | null
    legacySystemId: number | null
    challengeId: string | null
    createdAt: Date | null
    createdBy: string | null
    updatedAt: Date | null
    updatedBy: string | null
  }

  export type ChallengeLegacyCountAggregateOutputType = {
    id: number
    reviewType: number
    confidentialityType: number
    forumId: number
    directProjectId: number
    screeningScorecardId: number
    reviewScorecardId: number
    isTask: number
    useSchedulingAPI: number
    pureV5Task: number
    pureV5: number
    selfService: number
    selfServiceCopilot: number
    track: number
    subTrack: number
    legacySystemId: number
    challengeId: number
    createdAt: number
    createdBy: number
    updatedAt: number
    updatedBy: number
    _all: number
  }


  export type ChallengeLegacyAvgAggregateInputType = {
    forumId?: true
    directProjectId?: true
    screeningScorecardId?: true
    reviewScorecardId?: true
    legacySystemId?: true
  }

  export type ChallengeLegacySumAggregateInputType = {
    forumId?: true
    directProjectId?: true
    screeningScorecardId?: true
    reviewScorecardId?: true
    legacySystemId?: true
  }

  export type ChallengeLegacyMinAggregateInputType = {
    id?: true
    reviewType?: true
    confidentialityType?: true
    forumId?: true
    directProjectId?: true
    screeningScorecardId?: true
    reviewScorecardId?: true
    isTask?: true
    useSchedulingAPI?: true
    pureV5Task?: true
    pureV5?: true
    selfService?: true
    selfServiceCopilot?: true
    track?: true
    subTrack?: true
    legacySystemId?: true
    challengeId?: true
    createdAt?: true
    createdBy?: true
    updatedAt?: true
    updatedBy?: true
  }

  export type ChallengeLegacyMaxAggregateInputType = {
    id?: true
    reviewType?: true
    confidentialityType?: true
    forumId?: true
    directProjectId?: true
    screeningScorecardId?: true
    reviewScorecardId?: true
    isTask?: true
    useSchedulingAPI?: true
    pureV5Task?: true
    pureV5?: true
    selfService?: true
    selfServiceCopilot?: true
    track?: true
    subTrack?: true
    legacySystemId?: true
    challengeId?: true
    createdAt?: true
    createdBy?: true
    updatedAt?: true
    updatedBy?: true
  }

  export type ChallengeLegacyCountAggregateInputType = {
    id?: true
    reviewType?: true
    confidentialityType?: true
    forumId?: true
    directProjectId?: true
    screeningScorecardId?: true
    reviewScorecardId?: true
    isTask?: true
    useSchedulingAPI?: true
    pureV5Task?: true
    pureV5?: true
    selfService?: true
    selfServiceCopilot?: true
    track?: true
    subTrack?: true
    legacySystemId?: true
    challengeId?: true
    createdAt?: true
    createdBy?: true
    updatedAt?: true
    updatedBy?: true
    _all?: true
  }

  export type ChallengeLegacyAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ChallengeLegacy to aggregate.
     */
    where?: ChallengeLegacyWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ChallengeLegacies to fetch.
     */
    orderBy?: ChallengeLegacyOrderByWithRelationInput | ChallengeLegacyOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ChallengeLegacyWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ChallengeLegacies from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ChallengeLegacies.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned ChallengeLegacies
    **/
    _count?: true | ChallengeLegacyCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: ChallengeLegacyAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: ChallengeLegacySumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ChallengeLegacyMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ChallengeLegacyMaxAggregateInputType
  }

  export type GetChallengeLegacyAggregateType<T extends ChallengeLegacyAggregateArgs> = {
        [P in keyof T & keyof AggregateChallengeLegacy]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateChallengeLegacy[P]>
      : GetScalarType<T[P], AggregateChallengeLegacy[P]>
  }




  export type ChallengeLegacyGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ChallengeLegacyWhereInput
    orderBy?: ChallengeLegacyOrderByWithAggregationInput | ChallengeLegacyOrderByWithAggregationInput[]
    by: ChallengeLegacyScalarFieldEnum[] | ChallengeLegacyScalarFieldEnum
    having?: ChallengeLegacyScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ChallengeLegacyCountAggregateInputType | true
    _avg?: ChallengeLegacyAvgAggregateInputType
    _sum?: ChallengeLegacySumAggregateInputType
    _min?: ChallengeLegacyMinAggregateInputType
    _max?: ChallengeLegacyMaxAggregateInputType
  }

  export type ChallengeLegacyGroupByOutputType = {
    id: string
    reviewType: $Enums.ReviewTypeEnum
    confidentialityType: string
    forumId: number | null
    directProjectId: number | null
    screeningScorecardId: number | null
    reviewScorecardId: number | null
    isTask: boolean
    useSchedulingAPI: boolean
    pureV5Task: boolean
    pureV5: boolean
    selfService: boolean
    selfServiceCopilot: string | null
    track: string | null
    subTrack: string | null
    legacySystemId: number | null
    challengeId: string
    createdAt: Date
    createdBy: string
    updatedAt: Date
    updatedBy: string
    _count: ChallengeLegacyCountAggregateOutputType | null
    _avg: ChallengeLegacyAvgAggregateOutputType | null
    _sum: ChallengeLegacySumAggregateOutputType | null
    _min: ChallengeLegacyMinAggregateOutputType | null
    _max: ChallengeLegacyMaxAggregateOutputType | null
  }

  type GetChallengeLegacyGroupByPayload<T extends ChallengeLegacyGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ChallengeLegacyGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ChallengeLegacyGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ChallengeLegacyGroupByOutputType[P]>
            : GetScalarType<T[P], ChallengeLegacyGroupByOutputType[P]>
        }
      >
    >


  export type ChallengeLegacySelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    reviewType?: boolean
    confidentialityType?: boolean
    forumId?: boolean
    directProjectId?: boolean
    screeningScorecardId?: boolean
    reviewScorecardId?: boolean
    isTask?: boolean
    useSchedulingAPI?: boolean
    pureV5Task?: boolean
    pureV5?: boolean
    selfService?: boolean
    selfServiceCopilot?: boolean
    track?: boolean
    subTrack?: boolean
    legacySystemId?: boolean
    challengeId?: boolean
    createdAt?: boolean
    createdBy?: boolean
    updatedAt?: boolean
    updatedBy?: boolean
    challenge?: boolean | ChallengeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["challengeLegacy"]>

  export type ChallengeLegacySelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    reviewType?: boolean
    confidentialityType?: boolean
    forumId?: boolean
    directProjectId?: boolean
    screeningScorecardId?: boolean
    reviewScorecardId?: boolean
    isTask?: boolean
    useSchedulingAPI?: boolean
    pureV5Task?: boolean
    pureV5?: boolean
    selfService?: boolean
    selfServiceCopilot?: boolean
    track?: boolean
    subTrack?: boolean
    legacySystemId?: boolean
    challengeId?: boolean
    createdAt?: boolean
    createdBy?: boolean
    updatedAt?: boolean
    updatedBy?: boolean
    challenge?: boolean | ChallengeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["challengeLegacy"]>

  export type ChallengeLegacySelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    reviewType?: boolean
    confidentialityType?: boolean
    forumId?: boolean
    directProjectId?: boolean
    screeningScorecardId?: boolean
    reviewScorecardId?: boolean
    isTask?: boolean
    useSchedulingAPI?: boolean
    pureV5Task?: boolean
    pureV5?: boolean
    selfService?: boolean
    selfServiceCopilot?: boolean
    track?: boolean
    subTrack?: boolean
    legacySystemId?: boolean
    challengeId?: boolean
    createdAt?: boolean
    createdBy?: boolean
    updatedAt?: boolean
    updatedBy?: boolean
    challenge?: boolean | ChallengeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["challengeLegacy"]>

  export type ChallengeLegacySelectScalar = {
    id?: boolean
    reviewType?: boolean
    confidentialityType?: boolean
    forumId?: boolean
    directProjectId?: boolean
    screeningScorecardId?: boolean
    reviewScorecardId?: boolean
    isTask?: boolean
    useSchedulingAPI?: boolean
    pureV5Task?: boolean
    pureV5?: boolean
    selfService?: boolean
    selfServiceCopilot?: boolean
    track?: boolean
    subTrack?: boolean
    legacySystemId?: boolean
    challengeId?: boolean
    createdAt?: boolean
    createdBy?: boolean
    updatedAt?: boolean
    updatedBy?: boolean
  }

  export type ChallengeLegacyOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "reviewType" | "confidentialityType" | "forumId" | "directProjectId" | "screeningScorecardId" | "reviewScorecardId" | "isTask" | "useSchedulingAPI" | "pureV5Task" | "pureV5" | "selfService" | "selfServiceCopilot" | "track" | "subTrack" | "legacySystemId" | "challengeId" | "createdAt" | "createdBy" | "updatedAt" | "updatedBy", ExtArgs["result"]["challengeLegacy"]>
  export type ChallengeLegacyInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    challenge?: boolean | ChallengeDefaultArgs<ExtArgs>
  }
  export type ChallengeLegacyIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    challenge?: boolean | ChallengeDefaultArgs<ExtArgs>
  }
  export type ChallengeLegacyIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    challenge?: boolean | ChallengeDefaultArgs<ExtArgs>
  }

  export type $ChallengeLegacyPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "ChallengeLegacy"
    objects: {
      challenge: Prisma.$ChallengePayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      reviewType: $Enums.ReviewTypeEnum
      confidentialityType: string
      forumId: number | null
      directProjectId: number | null
      screeningScorecardId: number | null
      reviewScorecardId: number | null
      isTask: boolean
      useSchedulingAPI: boolean
      pureV5Task: boolean
      pureV5: boolean
      selfService: boolean
      selfServiceCopilot: string | null
      track: string | null
      subTrack: string | null
      legacySystemId: number | null
      challengeId: string
      createdAt: Date
      createdBy: string
      updatedAt: Date
      updatedBy: string
    }, ExtArgs["result"]["challengeLegacy"]>
    composites: {}
  }

  type ChallengeLegacyGetPayload<S extends boolean | null | undefined | ChallengeLegacyDefaultArgs> = $Result.GetResult<Prisma.$ChallengeLegacyPayload, S>

  type ChallengeLegacyCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<ChallengeLegacyFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: ChallengeLegacyCountAggregateInputType | true
    }

  export interface ChallengeLegacyDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['ChallengeLegacy'], meta: { name: 'ChallengeLegacy' } }
    /**
     * Find zero or one ChallengeLegacy that matches the filter.
     * @param {ChallengeLegacyFindUniqueArgs} args - Arguments to find a ChallengeLegacy
     * @example
     * // Get one ChallengeLegacy
     * const challengeLegacy = await prisma.challengeLegacy.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends ChallengeLegacyFindUniqueArgs>(args: SelectSubset<T, ChallengeLegacyFindUniqueArgs<ExtArgs>>): Prisma__ChallengeLegacyClient<$Result.GetResult<Prisma.$ChallengeLegacyPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one ChallengeLegacy that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {ChallengeLegacyFindUniqueOrThrowArgs} args - Arguments to find a ChallengeLegacy
     * @example
     * // Get one ChallengeLegacy
     * const challengeLegacy = await prisma.challengeLegacy.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends ChallengeLegacyFindUniqueOrThrowArgs>(args: SelectSubset<T, ChallengeLegacyFindUniqueOrThrowArgs<ExtArgs>>): Prisma__ChallengeLegacyClient<$Result.GetResult<Prisma.$ChallengeLegacyPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first ChallengeLegacy that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ChallengeLegacyFindFirstArgs} args - Arguments to find a ChallengeLegacy
     * @example
     * // Get one ChallengeLegacy
     * const challengeLegacy = await prisma.challengeLegacy.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends ChallengeLegacyFindFirstArgs>(args?: SelectSubset<T, ChallengeLegacyFindFirstArgs<ExtArgs>>): Prisma__ChallengeLegacyClient<$Result.GetResult<Prisma.$ChallengeLegacyPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first ChallengeLegacy that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ChallengeLegacyFindFirstOrThrowArgs} args - Arguments to find a ChallengeLegacy
     * @example
     * // Get one ChallengeLegacy
     * const challengeLegacy = await prisma.challengeLegacy.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends ChallengeLegacyFindFirstOrThrowArgs>(args?: SelectSubset<T, ChallengeLegacyFindFirstOrThrowArgs<ExtArgs>>): Prisma__ChallengeLegacyClient<$Result.GetResult<Prisma.$ChallengeLegacyPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more ChallengeLegacies that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ChallengeLegacyFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all ChallengeLegacies
     * const challengeLegacies = await prisma.challengeLegacy.findMany()
     * 
     * // Get first 10 ChallengeLegacies
     * const challengeLegacies = await prisma.challengeLegacy.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const challengeLegacyWithIdOnly = await prisma.challengeLegacy.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends ChallengeLegacyFindManyArgs>(args?: SelectSubset<T, ChallengeLegacyFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ChallengeLegacyPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a ChallengeLegacy.
     * @param {ChallengeLegacyCreateArgs} args - Arguments to create a ChallengeLegacy.
     * @example
     * // Create one ChallengeLegacy
     * const ChallengeLegacy = await prisma.challengeLegacy.create({
     *   data: {
     *     // ... data to create a ChallengeLegacy
     *   }
     * })
     * 
     */
    create<T extends ChallengeLegacyCreateArgs>(args: SelectSubset<T, ChallengeLegacyCreateArgs<ExtArgs>>): Prisma__ChallengeLegacyClient<$Result.GetResult<Prisma.$ChallengeLegacyPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many ChallengeLegacies.
     * @param {ChallengeLegacyCreateManyArgs} args - Arguments to create many ChallengeLegacies.
     * @example
     * // Create many ChallengeLegacies
     * const challengeLegacy = await prisma.challengeLegacy.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends ChallengeLegacyCreateManyArgs>(args?: SelectSubset<T, ChallengeLegacyCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many ChallengeLegacies and returns the data saved in the database.
     * @param {ChallengeLegacyCreateManyAndReturnArgs} args - Arguments to create many ChallengeLegacies.
     * @example
     * // Create many ChallengeLegacies
     * const challengeLegacy = await prisma.challengeLegacy.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many ChallengeLegacies and only return the `id`
     * const challengeLegacyWithIdOnly = await prisma.challengeLegacy.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends ChallengeLegacyCreateManyAndReturnArgs>(args?: SelectSubset<T, ChallengeLegacyCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ChallengeLegacyPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a ChallengeLegacy.
     * @param {ChallengeLegacyDeleteArgs} args - Arguments to delete one ChallengeLegacy.
     * @example
     * // Delete one ChallengeLegacy
     * const ChallengeLegacy = await prisma.challengeLegacy.delete({
     *   where: {
     *     // ... filter to delete one ChallengeLegacy
     *   }
     * })
     * 
     */
    delete<T extends ChallengeLegacyDeleteArgs>(args: SelectSubset<T, ChallengeLegacyDeleteArgs<ExtArgs>>): Prisma__ChallengeLegacyClient<$Result.GetResult<Prisma.$ChallengeLegacyPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one ChallengeLegacy.
     * @param {ChallengeLegacyUpdateArgs} args - Arguments to update one ChallengeLegacy.
     * @example
     * // Update one ChallengeLegacy
     * const challengeLegacy = await prisma.challengeLegacy.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends ChallengeLegacyUpdateArgs>(args: SelectSubset<T, ChallengeLegacyUpdateArgs<ExtArgs>>): Prisma__ChallengeLegacyClient<$Result.GetResult<Prisma.$ChallengeLegacyPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more ChallengeLegacies.
     * @param {ChallengeLegacyDeleteManyArgs} args - Arguments to filter ChallengeLegacies to delete.
     * @example
     * // Delete a few ChallengeLegacies
     * const { count } = await prisma.challengeLegacy.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends ChallengeLegacyDeleteManyArgs>(args?: SelectSubset<T, ChallengeLegacyDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more ChallengeLegacies.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ChallengeLegacyUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many ChallengeLegacies
     * const challengeLegacy = await prisma.challengeLegacy.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends ChallengeLegacyUpdateManyArgs>(args: SelectSubset<T, ChallengeLegacyUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more ChallengeLegacies and returns the data updated in the database.
     * @param {ChallengeLegacyUpdateManyAndReturnArgs} args - Arguments to update many ChallengeLegacies.
     * @example
     * // Update many ChallengeLegacies
     * const challengeLegacy = await prisma.challengeLegacy.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more ChallengeLegacies and only return the `id`
     * const challengeLegacyWithIdOnly = await prisma.challengeLegacy.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends ChallengeLegacyUpdateManyAndReturnArgs>(args: SelectSubset<T, ChallengeLegacyUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ChallengeLegacyPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one ChallengeLegacy.
     * @param {ChallengeLegacyUpsertArgs} args - Arguments to update or create a ChallengeLegacy.
     * @example
     * // Update or create a ChallengeLegacy
     * const challengeLegacy = await prisma.challengeLegacy.upsert({
     *   create: {
     *     // ... data to create a ChallengeLegacy
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the ChallengeLegacy we want to update
     *   }
     * })
     */
    upsert<T extends ChallengeLegacyUpsertArgs>(args: SelectSubset<T, ChallengeLegacyUpsertArgs<ExtArgs>>): Prisma__ChallengeLegacyClient<$Result.GetResult<Prisma.$ChallengeLegacyPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of ChallengeLegacies.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ChallengeLegacyCountArgs} args - Arguments to filter ChallengeLegacies to count.
     * @example
     * // Count the number of ChallengeLegacies
     * const count = await prisma.challengeLegacy.count({
     *   where: {
     *     // ... the filter for the ChallengeLegacies we want to count
     *   }
     * })
    **/
    count<T extends ChallengeLegacyCountArgs>(
      args?: Subset<T, ChallengeLegacyCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ChallengeLegacyCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a ChallengeLegacy.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ChallengeLegacyAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ChallengeLegacyAggregateArgs>(args: Subset<T, ChallengeLegacyAggregateArgs>): Prisma.PrismaPromise<GetChallengeLegacyAggregateType<T>>

    /**
     * Group by ChallengeLegacy.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ChallengeLegacyGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ChallengeLegacyGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ChallengeLegacyGroupByArgs['orderBy'] }
        : { orderBy?: ChallengeLegacyGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ChallengeLegacyGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetChallengeLegacyGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the ChallengeLegacy model
   */
  readonly fields: ChallengeLegacyFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for ChallengeLegacy.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ChallengeLegacyClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    challenge<T extends ChallengeDefaultArgs<ExtArgs> = {}>(args?: Subset<T, ChallengeDefaultArgs<ExtArgs>>): Prisma__ChallengeClient<$Result.GetResult<Prisma.$ChallengePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the ChallengeLegacy model
   */
  interface ChallengeLegacyFieldRefs {
    readonly id: FieldRef<"ChallengeLegacy", 'String'>
    readonly reviewType: FieldRef<"ChallengeLegacy", 'ReviewTypeEnum'>
    readonly confidentialityType: FieldRef<"ChallengeLegacy", 'String'>
    readonly forumId: FieldRef<"ChallengeLegacy", 'Int'>
    readonly directProjectId: FieldRef<"ChallengeLegacy", 'Int'>
    readonly screeningScorecardId: FieldRef<"ChallengeLegacy", 'Int'>
    readonly reviewScorecardId: FieldRef<"ChallengeLegacy", 'Int'>
    readonly isTask: FieldRef<"ChallengeLegacy", 'Boolean'>
    readonly useSchedulingAPI: FieldRef<"ChallengeLegacy", 'Boolean'>
    readonly pureV5Task: FieldRef<"ChallengeLegacy", 'Boolean'>
    readonly pureV5: FieldRef<"ChallengeLegacy", 'Boolean'>
    readonly selfService: FieldRef<"ChallengeLegacy", 'Boolean'>
    readonly selfServiceCopilot: FieldRef<"ChallengeLegacy", 'String'>
    readonly track: FieldRef<"ChallengeLegacy", 'String'>
    readonly subTrack: FieldRef<"ChallengeLegacy", 'String'>
    readonly legacySystemId: FieldRef<"ChallengeLegacy", 'Int'>
    readonly challengeId: FieldRef<"ChallengeLegacy", 'String'>
    readonly createdAt: FieldRef<"ChallengeLegacy", 'DateTime'>
    readonly createdBy: FieldRef<"ChallengeLegacy", 'String'>
    readonly updatedAt: FieldRef<"ChallengeLegacy", 'DateTime'>
    readonly updatedBy: FieldRef<"ChallengeLegacy", 'String'>
  }
    

  // Custom InputTypes
  /**
   * ChallengeLegacy findUnique
   */
  export type ChallengeLegacyFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ChallengeLegacy
     */
    select?: ChallengeLegacySelect<ExtArgs> | null
    /**
     * Omit specific fields from the ChallengeLegacy
     */
    omit?: ChallengeLegacyOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ChallengeLegacyInclude<ExtArgs> | null
    /**
     * Filter, which ChallengeLegacy to fetch.
     */
    where: ChallengeLegacyWhereUniqueInput
  }

  /**
   * ChallengeLegacy findUniqueOrThrow
   */
  export type ChallengeLegacyFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ChallengeLegacy
     */
    select?: ChallengeLegacySelect<ExtArgs> | null
    /**
     * Omit specific fields from the ChallengeLegacy
     */
    omit?: ChallengeLegacyOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ChallengeLegacyInclude<ExtArgs> | null
    /**
     * Filter, which ChallengeLegacy to fetch.
     */
    where: ChallengeLegacyWhereUniqueInput
  }

  /**
   * ChallengeLegacy findFirst
   */
  export type ChallengeLegacyFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ChallengeLegacy
     */
    select?: ChallengeLegacySelect<ExtArgs> | null
    /**
     * Omit specific fields from the ChallengeLegacy
     */
    omit?: ChallengeLegacyOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ChallengeLegacyInclude<ExtArgs> | null
    /**
     * Filter, which ChallengeLegacy to fetch.
     */
    where?: ChallengeLegacyWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ChallengeLegacies to fetch.
     */
    orderBy?: ChallengeLegacyOrderByWithRelationInput | ChallengeLegacyOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ChallengeLegacies.
     */
    cursor?: ChallengeLegacyWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ChallengeLegacies from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ChallengeLegacies.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ChallengeLegacies.
     */
    distinct?: ChallengeLegacyScalarFieldEnum | ChallengeLegacyScalarFieldEnum[]
  }

  /**
   * ChallengeLegacy findFirstOrThrow
   */
  export type ChallengeLegacyFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ChallengeLegacy
     */
    select?: ChallengeLegacySelect<ExtArgs> | null
    /**
     * Omit specific fields from the ChallengeLegacy
     */
    omit?: ChallengeLegacyOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ChallengeLegacyInclude<ExtArgs> | null
    /**
     * Filter, which ChallengeLegacy to fetch.
     */
    where?: ChallengeLegacyWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ChallengeLegacies to fetch.
     */
    orderBy?: ChallengeLegacyOrderByWithRelationInput | ChallengeLegacyOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ChallengeLegacies.
     */
    cursor?: ChallengeLegacyWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ChallengeLegacies from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ChallengeLegacies.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ChallengeLegacies.
     */
    distinct?: ChallengeLegacyScalarFieldEnum | ChallengeLegacyScalarFieldEnum[]
  }

  /**
   * ChallengeLegacy findMany
   */
  export type ChallengeLegacyFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ChallengeLegacy
     */
    select?: ChallengeLegacySelect<ExtArgs> | null
    /**
     * Omit specific fields from the ChallengeLegacy
     */
    omit?: ChallengeLegacyOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ChallengeLegacyInclude<ExtArgs> | null
    /**
     * Filter, which ChallengeLegacies to fetch.
     */
    where?: ChallengeLegacyWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ChallengeLegacies to fetch.
     */
    orderBy?: ChallengeLegacyOrderByWithRelationInput | ChallengeLegacyOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing ChallengeLegacies.
     */
    cursor?: ChallengeLegacyWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ChallengeLegacies from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ChallengeLegacies.
     */
    skip?: number
    distinct?: ChallengeLegacyScalarFieldEnum | ChallengeLegacyScalarFieldEnum[]
  }

  /**
   * ChallengeLegacy create
   */
  export type ChallengeLegacyCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ChallengeLegacy
     */
    select?: ChallengeLegacySelect<ExtArgs> | null
    /**
     * Omit specific fields from the ChallengeLegacy
     */
    omit?: ChallengeLegacyOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ChallengeLegacyInclude<ExtArgs> | null
    /**
     * The data needed to create a ChallengeLegacy.
     */
    data: XOR<ChallengeLegacyCreateInput, ChallengeLegacyUncheckedCreateInput>
  }

  /**
   * ChallengeLegacy createMany
   */
  export type ChallengeLegacyCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many ChallengeLegacies.
     */
    data: ChallengeLegacyCreateManyInput | ChallengeLegacyCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * ChallengeLegacy createManyAndReturn
   */
  export type ChallengeLegacyCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ChallengeLegacy
     */
    select?: ChallengeLegacySelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the ChallengeLegacy
     */
    omit?: ChallengeLegacyOmit<ExtArgs> | null
    /**
     * The data used to create many ChallengeLegacies.
     */
    data: ChallengeLegacyCreateManyInput | ChallengeLegacyCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ChallengeLegacyIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * ChallengeLegacy update
   */
  export type ChallengeLegacyUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ChallengeLegacy
     */
    select?: ChallengeLegacySelect<ExtArgs> | null
    /**
     * Omit specific fields from the ChallengeLegacy
     */
    omit?: ChallengeLegacyOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ChallengeLegacyInclude<ExtArgs> | null
    /**
     * The data needed to update a ChallengeLegacy.
     */
    data: XOR<ChallengeLegacyUpdateInput, ChallengeLegacyUncheckedUpdateInput>
    /**
     * Choose, which ChallengeLegacy to update.
     */
    where: ChallengeLegacyWhereUniqueInput
  }

  /**
   * ChallengeLegacy updateMany
   */
  export type ChallengeLegacyUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update ChallengeLegacies.
     */
    data: XOR<ChallengeLegacyUpdateManyMutationInput, ChallengeLegacyUncheckedUpdateManyInput>
    /**
     * Filter which ChallengeLegacies to update
     */
    where?: ChallengeLegacyWhereInput
    /**
     * Limit how many ChallengeLegacies to update.
     */
    limit?: number
  }

  /**
   * ChallengeLegacy updateManyAndReturn
   */
  export type ChallengeLegacyUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ChallengeLegacy
     */
    select?: ChallengeLegacySelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the ChallengeLegacy
     */
    omit?: ChallengeLegacyOmit<ExtArgs> | null
    /**
     * The data used to update ChallengeLegacies.
     */
    data: XOR<ChallengeLegacyUpdateManyMutationInput, ChallengeLegacyUncheckedUpdateManyInput>
    /**
     * Filter which ChallengeLegacies to update
     */
    where?: ChallengeLegacyWhereInput
    /**
     * Limit how many ChallengeLegacies to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ChallengeLegacyIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * ChallengeLegacy upsert
   */
  export type ChallengeLegacyUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ChallengeLegacy
     */
    select?: ChallengeLegacySelect<ExtArgs> | null
    /**
     * Omit specific fields from the ChallengeLegacy
     */
    omit?: ChallengeLegacyOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ChallengeLegacyInclude<ExtArgs> | null
    /**
     * The filter to search for the ChallengeLegacy to update in case it exists.
     */
    where: ChallengeLegacyWhereUniqueInput
    /**
     * In case the ChallengeLegacy found by the `where` argument doesn't exist, create a new ChallengeLegacy with this data.
     */
    create: XOR<ChallengeLegacyCreateInput, ChallengeLegacyUncheckedCreateInput>
    /**
     * In case the ChallengeLegacy was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ChallengeLegacyUpdateInput, ChallengeLegacyUncheckedUpdateInput>
  }

  /**
   * ChallengeLegacy delete
   */
  export type ChallengeLegacyDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ChallengeLegacy
     */
    select?: ChallengeLegacySelect<ExtArgs> | null
    /**
     * Omit specific fields from the ChallengeLegacy
     */
    omit?: ChallengeLegacyOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ChallengeLegacyInclude<ExtArgs> | null
    /**
     * Filter which ChallengeLegacy to delete.
     */
    where: ChallengeLegacyWhereUniqueInput
  }

  /**
   * ChallengeLegacy deleteMany
   */
  export type ChallengeLegacyDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ChallengeLegacies to delete
     */
    where?: ChallengeLegacyWhereInput
    /**
     * Limit how many ChallengeLegacies to delete.
     */
    limit?: number
  }

  /**
   * ChallengeLegacy without action
   */
  export type ChallengeLegacyDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ChallengeLegacy
     */
    select?: ChallengeLegacySelect<ExtArgs> | null
    /**
     * Omit specific fields from the ChallengeLegacy
     */
    omit?: ChallengeLegacyOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ChallengeLegacyInclude<ExtArgs> | null
  }


  /**
   * Model ChallengeEvent
   */

  export type AggregateChallengeEvent = {
    _count: ChallengeEventCountAggregateOutputType | null
    _avg: ChallengeEventAvgAggregateOutputType | null
    _sum: ChallengeEventSumAggregateOutputType | null
    _min: ChallengeEventMinAggregateOutputType | null
    _max: ChallengeEventMaxAggregateOutputType | null
  }

  export type ChallengeEventAvgAggregateOutputType = {
    eventId: number | null
  }

  export type ChallengeEventSumAggregateOutputType = {
    eventId: number | null
  }

  export type ChallengeEventMinAggregateOutputType = {
    id: string | null
    challengeId: string | null
    eventId: number | null
    name: string | null
    key: string | null
    createdAt: Date | null
    createdBy: string | null
    updatedAt: Date | null
    updatedBy: string | null
  }

  export type ChallengeEventMaxAggregateOutputType = {
    id: string | null
    challengeId: string | null
    eventId: number | null
    name: string | null
    key: string | null
    createdAt: Date | null
    createdBy: string | null
    updatedAt: Date | null
    updatedBy: string | null
  }

  export type ChallengeEventCountAggregateOutputType = {
    id: number
    challengeId: number
    eventId: number
    name: number
    key: number
    createdAt: number
    createdBy: number
    updatedAt: number
    updatedBy: number
    _all: number
  }


  export type ChallengeEventAvgAggregateInputType = {
    eventId?: true
  }

  export type ChallengeEventSumAggregateInputType = {
    eventId?: true
  }

  export type ChallengeEventMinAggregateInputType = {
    id?: true
    challengeId?: true
    eventId?: true
    name?: true
    key?: true
    createdAt?: true
    createdBy?: true
    updatedAt?: true
    updatedBy?: true
  }

  export type ChallengeEventMaxAggregateInputType = {
    id?: true
    challengeId?: true
    eventId?: true
    name?: true
    key?: true
    createdAt?: true
    createdBy?: true
    updatedAt?: true
    updatedBy?: true
  }

  export type ChallengeEventCountAggregateInputType = {
    id?: true
    challengeId?: true
    eventId?: true
    name?: true
    key?: true
    createdAt?: true
    createdBy?: true
    updatedAt?: true
    updatedBy?: true
    _all?: true
  }

  export type ChallengeEventAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ChallengeEvent to aggregate.
     */
    where?: ChallengeEventWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ChallengeEvents to fetch.
     */
    orderBy?: ChallengeEventOrderByWithRelationInput | ChallengeEventOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ChallengeEventWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ChallengeEvents from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ChallengeEvents.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned ChallengeEvents
    **/
    _count?: true | ChallengeEventCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: ChallengeEventAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: ChallengeEventSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ChallengeEventMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ChallengeEventMaxAggregateInputType
  }

  export type GetChallengeEventAggregateType<T extends ChallengeEventAggregateArgs> = {
        [P in keyof T & keyof AggregateChallengeEvent]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateChallengeEvent[P]>
      : GetScalarType<T[P], AggregateChallengeEvent[P]>
  }




  export type ChallengeEventGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ChallengeEventWhereInput
    orderBy?: ChallengeEventOrderByWithAggregationInput | ChallengeEventOrderByWithAggregationInput[]
    by: ChallengeEventScalarFieldEnum[] | ChallengeEventScalarFieldEnum
    having?: ChallengeEventScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ChallengeEventCountAggregateInputType | true
    _avg?: ChallengeEventAvgAggregateInputType
    _sum?: ChallengeEventSumAggregateInputType
    _min?: ChallengeEventMinAggregateInputType
    _max?: ChallengeEventMaxAggregateInputType
  }

  export type ChallengeEventGroupByOutputType = {
    id: string
    challengeId: string
    eventId: number
    name: string | null
    key: string | null
    createdAt: Date
    createdBy: string
    updatedAt: Date
    updatedBy: string
    _count: ChallengeEventCountAggregateOutputType | null
    _avg: ChallengeEventAvgAggregateOutputType | null
    _sum: ChallengeEventSumAggregateOutputType | null
    _min: ChallengeEventMinAggregateOutputType | null
    _max: ChallengeEventMaxAggregateOutputType | null
  }

  type GetChallengeEventGroupByPayload<T extends ChallengeEventGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ChallengeEventGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ChallengeEventGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ChallengeEventGroupByOutputType[P]>
            : GetScalarType<T[P], ChallengeEventGroupByOutputType[P]>
        }
      >
    >


  export type ChallengeEventSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    challengeId?: boolean
    eventId?: boolean
    name?: boolean
    key?: boolean
    createdAt?: boolean
    createdBy?: boolean
    updatedAt?: boolean
    updatedBy?: boolean
    challenge?: boolean | ChallengeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["challengeEvent"]>

  export type ChallengeEventSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    challengeId?: boolean
    eventId?: boolean
    name?: boolean
    key?: boolean
    createdAt?: boolean
    createdBy?: boolean
    updatedAt?: boolean
    updatedBy?: boolean
    challenge?: boolean | ChallengeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["challengeEvent"]>

  export type ChallengeEventSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    challengeId?: boolean
    eventId?: boolean
    name?: boolean
    key?: boolean
    createdAt?: boolean
    createdBy?: boolean
    updatedAt?: boolean
    updatedBy?: boolean
    challenge?: boolean | ChallengeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["challengeEvent"]>

  export type ChallengeEventSelectScalar = {
    id?: boolean
    challengeId?: boolean
    eventId?: boolean
    name?: boolean
    key?: boolean
    createdAt?: boolean
    createdBy?: boolean
    updatedAt?: boolean
    updatedBy?: boolean
  }

  export type ChallengeEventOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "challengeId" | "eventId" | "name" | "key" | "createdAt" | "createdBy" | "updatedAt" | "updatedBy", ExtArgs["result"]["challengeEvent"]>
  export type ChallengeEventInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    challenge?: boolean | ChallengeDefaultArgs<ExtArgs>
  }
  export type ChallengeEventIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    challenge?: boolean | ChallengeDefaultArgs<ExtArgs>
  }
  export type ChallengeEventIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    challenge?: boolean | ChallengeDefaultArgs<ExtArgs>
  }

  export type $ChallengeEventPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "ChallengeEvent"
    objects: {
      challenge: Prisma.$ChallengePayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      challengeId: string
      eventId: number
      name: string | null
      key: string | null
      createdAt: Date
      createdBy: string
      updatedAt: Date
      updatedBy: string
    }, ExtArgs["result"]["challengeEvent"]>
    composites: {}
  }

  type ChallengeEventGetPayload<S extends boolean | null | undefined | ChallengeEventDefaultArgs> = $Result.GetResult<Prisma.$ChallengeEventPayload, S>

  type ChallengeEventCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<ChallengeEventFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: ChallengeEventCountAggregateInputType | true
    }

  export interface ChallengeEventDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['ChallengeEvent'], meta: { name: 'ChallengeEvent' } }
    /**
     * Find zero or one ChallengeEvent that matches the filter.
     * @param {ChallengeEventFindUniqueArgs} args - Arguments to find a ChallengeEvent
     * @example
     * // Get one ChallengeEvent
     * const challengeEvent = await prisma.challengeEvent.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends ChallengeEventFindUniqueArgs>(args: SelectSubset<T, ChallengeEventFindUniqueArgs<ExtArgs>>): Prisma__ChallengeEventClient<$Result.GetResult<Prisma.$ChallengeEventPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one ChallengeEvent that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {ChallengeEventFindUniqueOrThrowArgs} args - Arguments to find a ChallengeEvent
     * @example
     * // Get one ChallengeEvent
     * const challengeEvent = await prisma.challengeEvent.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends ChallengeEventFindUniqueOrThrowArgs>(args: SelectSubset<T, ChallengeEventFindUniqueOrThrowArgs<ExtArgs>>): Prisma__ChallengeEventClient<$Result.GetResult<Prisma.$ChallengeEventPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first ChallengeEvent that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ChallengeEventFindFirstArgs} args - Arguments to find a ChallengeEvent
     * @example
     * // Get one ChallengeEvent
     * const challengeEvent = await prisma.challengeEvent.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends ChallengeEventFindFirstArgs>(args?: SelectSubset<T, ChallengeEventFindFirstArgs<ExtArgs>>): Prisma__ChallengeEventClient<$Result.GetResult<Prisma.$ChallengeEventPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first ChallengeEvent that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ChallengeEventFindFirstOrThrowArgs} args - Arguments to find a ChallengeEvent
     * @example
     * // Get one ChallengeEvent
     * const challengeEvent = await prisma.challengeEvent.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends ChallengeEventFindFirstOrThrowArgs>(args?: SelectSubset<T, ChallengeEventFindFirstOrThrowArgs<ExtArgs>>): Prisma__ChallengeEventClient<$Result.GetResult<Prisma.$ChallengeEventPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more ChallengeEvents that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ChallengeEventFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all ChallengeEvents
     * const challengeEvents = await prisma.challengeEvent.findMany()
     * 
     * // Get first 10 ChallengeEvents
     * const challengeEvents = await prisma.challengeEvent.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const challengeEventWithIdOnly = await prisma.challengeEvent.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends ChallengeEventFindManyArgs>(args?: SelectSubset<T, ChallengeEventFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ChallengeEventPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a ChallengeEvent.
     * @param {ChallengeEventCreateArgs} args - Arguments to create a ChallengeEvent.
     * @example
     * // Create one ChallengeEvent
     * const ChallengeEvent = await prisma.challengeEvent.create({
     *   data: {
     *     // ... data to create a ChallengeEvent
     *   }
     * })
     * 
     */
    create<T extends ChallengeEventCreateArgs>(args: SelectSubset<T, ChallengeEventCreateArgs<ExtArgs>>): Prisma__ChallengeEventClient<$Result.GetResult<Prisma.$ChallengeEventPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many ChallengeEvents.
     * @param {ChallengeEventCreateManyArgs} args - Arguments to create many ChallengeEvents.
     * @example
     * // Create many ChallengeEvents
     * const challengeEvent = await prisma.challengeEvent.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends ChallengeEventCreateManyArgs>(args?: SelectSubset<T, ChallengeEventCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many ChallengeEvents and returns the data saved in the database.
     * @param {ChallengeEventCreateManyAndReturnArgs} args - Arguments to create many ChallengeEvents.
     * @example
     * // Create many ChallengeEvents
     * const challengeEvent = await prisma.challengeEvent.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many ChallengeEvents and only return the `id`
     * const challengeEventWithIdOnly = await prisma.challengeEvent.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends ChallengeEventCreateManyAndReturnArgs>(args?: SelectSubset<T, ChallengeEventCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ChallengeEventPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a ChallengeEvent.
     * @param {ChallengeEventDeleteArgs} args - Arguments to delete one ChallengeEvent.
     * @example
     * // Delete one ChallengeEvent
     * const ChallengeEvent = await prisma.challengeEvent.delete({
     *   where: {
     *     // ... filter to delete one ChallengeEvent
     *   }
     * })
     * 
     */
    delete<T extends ChallengeEventDeleteArgs>(args: SelectSubset<T, ChallengeEventDeleteArgs<ExtArgs>>): Prisma__ChallengeEventClient<$Result.GetResult<Prisma.$ChallengeEventPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one ChallengeEvent.
     * @param {ChallengeEventUpdateArgs} args - Arguments to update one ChallengeEvent.
     * @example
     * // Update one ChallengeEvent
     * const challengeEvent = await prisma.challengeEvent.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends ChallengeEventUpdateArgs>(args: SelectSubset<T, ChallengeEventUpdateArgs<ExtArgs>>): Prisma__ChallengeEventClient<$Result.GetResult<Prisma.$ChallengeEventPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more ChallengeEvents.
     * @param {ChallengeEventDeleteManyArgs} args - Arguments to filter ChallengeEvents to delete.
     * @example
     * // Delete a few ChallengeEvents
     * const { count } = await prisma.challengeEvent.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends ChallengeEventDeleteManyArgs>(args?: SelectSubset<T, ChallengeEventDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more ChallengeEvents.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ChallengeEventUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many ChallengeEvents
     * const challengeEvent = await prisma.challengeEvent.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends ChallengeEventUpdateManyArgs>(args: SelectSubset<T, ChallengeEventUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more ChallengeEvents and returns the data updated in the database.
     * @param {ChallengeEventUpdateManyAndReturnArgs} args - Arguments to update many ChallengeEvents.
     * @example
     * // Update many ChallengeEvents
     * const challengeEvent = await prisma.challengeEvent.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more ChallengeEvents and only return the `id`
     * const challengeEventWithIdOnly = await prisma.challengeEvent.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends ChallengeEventUpdateManyAndReturnArgs>(args: SelectSubset<T, ChallengeEventUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ChallengeEventPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one ChallengeEvent.
     * @param {ChallengeEventUpsertArgs} args - Arguments to update or create a ChallengeEvent.
     * @example
     * // Update or create a ChallengeEvent
     * const challengeEvent = await prisma.challengeEvent.upsert({
     *   create: {
     *     // ... data to create a ChallengeEvent
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the ChallengeEvent we want to update
     *   }
     * })
     */
    upsert<T extends ChallengeEventUpsertArgs>(args: SelectSubset<T, ChallengeEventUpsertArgs<ExtArgs>>): Prisma__ChallengeEventClient<$Result.GetResult<Prisma.$ChallengeEventPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of ChallengeEvents.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ChallengeEventCountArgs} args - Arguments to filter ChallengeEvents to count.
     * @example
     * // Count the number of ChallengeEvents
     * const count = await prisma.challengeEvent.count({
     *   where: {
     *     // ... the filter for the ChallengeEvents we want to count
     *   }
     * })
    **/
    count<T extends ChallengeEventCountArgs>(
      args?: Subset<T, ChallengeEventCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ChallengeEventCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a ChallengeEvent.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ChallengeEventAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ChallengeEventAggregateArgs>(args: Subset<T, ChallengeEventAggregateArgs>): Prisma.PrismaPromise<GetChallengeEventAggregateType<T>>

    /**
     * Group by ChallengeEvent.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ChallengeEventGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ChallengeEventGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ChallengeEventGroupByArgs['orderBy'] }
        : { orderBy?: ChallengeEventGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ChallengeEventGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetChallengeEventGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the ChallengeEvent model
   */
  readonly fields: ChallengeEventFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for ChallengeEvent.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ChallengeEventClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    challenge<T extends ChallengeDefaultArgs<ExtArgs> = {}>(args?: Subset<T, ChallengeDefaultArgs<ExtArgs>>): Prisma__ChallengeClient<$Result.GetResult<Prisma.$ChallengePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the ChallengeEvent model
   */
  interface ChallengeEventFieldRefs {
    readonly id: FieldRef<"ChallengeEvent", 'String'>
    readonly challengeId: FieldRef<"ChallengeEvent", 'String'>
    readonly eventId: FieldRef<"ChallengeEvent", 'Int'>
    readonly name: FieldRef<"ChallengeEvent", 'String'>
    readonly key: FieldRef<"ChallengeEvent", 'String'>
    readonly createdAt: FieldRef<"ChallengeEvent", 'DateTime'>
    readonly createdBy: FieldRef<"ChallengeEvent", 'String'>
    readonly updatedAt: FieldRef<"ChallengeEvent", 'DateTime'>
    readonly updatedBy: FieldRef<"ChallengeEvent", 'String'>
  }
    

  // Custom InputTypes
  /**
   * ChallengeEvent findUnique
   */
  export type ChallengeEventFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ChallengeEvent
     */
    select?: ChallengeEventSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ChallengeEvent
     */
    omit?: ChallengeEventOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ChallengeEventInclude<ExtArgs> | null
    /**
     * Filter, which ChallengeEvent to fetch.
     */
    where: ChallengeEventWhereUniqueInput
  }

  /**
   * ChallengeEvent findUniqueOrThrow
   */
  export type ChallengeEventFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ChallengeEvent
     */
    select?: ChallengeEventSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ChallengeEvent
     */
    omit?: ChallengeEventOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ChallengeEventInclude<ExtArgs> | null
    /**
     * Filter, which ChallengeEvent to fetch.
     */
    where: ChallengeEventWhereUniqueInput
  }

  /**
   * ChallengeEvent findFirst
   */
  export type ChallengeEventFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ChallengeEvent
     */
    select?: ChallengeEventSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ChallengeEvent
     */
    omit?: ChallengeEventOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ChallengeEventInclude<ExtArgs> | null
    /**
     * Filter, which ChallengeEvent to fetch.
     */
    where?: ChallengeEventWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ChallengeEvents to fetch.
     */
    orderBy?: ChallengeEventOrderByWithRelationInput | ChallengeEventOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ChallengeEvents.
     */
    cursor?: ChallengeEventWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ChallengeEvents from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ChallengeEvents.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ChallengeEvents.
     */
    distinct?: ChallengeEventScalarFieldEnum | ChallengeEventScalarFieldEnum[]
  }

  /**
   * ChallengeEvent findFirstOrThrow
   */
  export type ChallengeEventFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ChallengeEvent
     */
    select?: ChallengeEventSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ChallengeEvent
     */
    omit?: ChallengeEventOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ChallengeEventInclude<ExtArgs> | null
    /**
     * Filter, which ChallengeEvent to fetch.
     */
    where?: ChallengeEventWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ChallengeEvents to fetch.
     */
    orderBy?: ChallengeEventOrderByWithRelationInput | ChallengeEventOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ChallengeEvents.
     */
    cursor?: ChallengeEventWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ChallengeEvents from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ChallengeEvents.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ChallengeEvents.
     */
    distinct?: ChallengeEventScalarFieldEnum | ChallengeEventScalarFieldEnum[]
  }

  /**
   * ChallengeEvent findMany
   */
  export type ChallengeEventFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ChallengeEvent
     */
    select?: ChallengeEventSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ChallengeEvent
     */
    omit?: ChallengeEventOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ChallengeEventInclude<ExtArgs> | null
    /**
     * Filter, which ChallengeEvents to fetch.
     */
    where?: ChallengeEventWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ChallengeEvents to fetch.
     */
    orderBy?: ChallengeEventOrderByWithRelationInput | ChallengeEventOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing ChallengeEvents.
     */
    cursor?: ChallengeEventWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ChallengeEvents from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ChallengeEvents.
     */
    skip?: number
    distinct?: ChallengeEventScalarFieldEnum | ChallengeEventScalarFieldEnum[]
  }

  /**
   * ChallengeEvent create
   */
  export type ChallengeEventCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ChallengeEvent
     */
    select?: ChallengeEventSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ChallengeEvent
     */
    omit?: ChallengeEventOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ChallengeEventInclude<ExtArgs> | null
    /**
     * The data needed to create a ChallengeEvent.
     */
    data: XOR<ChallengeEventCreateInput, ChallengeEventUncheckedCreateInput>
  }

  /**
   * ChallengeEvent createMany
   */
  export type ChallengeEventCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many ChallengeEvents.
     */
    data: ChallengeEventCreateManyInput | ChallengeEventCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * ChallengeEvent createManyAndReturn
   */
  export type ChallengeEventCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ChallengeEvent
     */
    select?: ChallengeEventSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the ChallengeEvent
     */
    omit?: ChallengeEventOmit<ExtArgs> | null
    /**
     * The data used to create many ChallengeEvents.
     */
    data: ChallengeEventCreateManyInput | ChallengeEventCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ChallengeEventIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * ChallengeEvent update
   */
  export type ChallengeEventUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ChallengeEvent
     */
    select?: ChallengeEventSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ChallengeEvent
     */
    omit?: ChallengeEventOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ChallengeEventInclude<ExtArgs> | null
    /**
     * The data needed to update a ChallengeEvent.
     */
    data: XOR<ChallengeEventUpdateInput, ChallengeEventUncheckedUpdateInput>
    /**
     * Choose, which ChallengeEvent to update.
     */
    where: ChallengeEventWhereUniqueInput
  }

  /**
   * ChallengeEvent updateMany
   */
  export type ChallengeEventUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update ChallengeEvents.
     */
    data: XOR<ChallengeEventUpdateManyMutationInput, ChallengeEventUncheckedUpdateManyInput>
    /**
     * Filter which ChallengeEvents to update
     */
    where?: ChallengeEventWhereInput
    /**
     * Limit how many ChallengeEvents to update.
     */
    limit?: number
  }

  /**
   * ChallengeEvent updateManyAndReturn
   */
  export type ChallengeEventUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ChallengeEvent
     */
    select?: ChallengeEventSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the ChallengeEvent
     */
    omit?: ChallengeEventOmit<ExtArgs> | null
    /**
     * The data used to update ChallengeEvents.
     */
    data: XOR<ChallengeEventUpdateManyMutationInput, ChallengeEventUncheckedUpdateManyInput>
    /**
     * Filter which ChallengeEvents to update
     */
    where?: ChallengeEventWhereInput
    /**
     * Limit how many ChallengeEvents to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ChallengeEventIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * ChallengeEvent upsert
   */
  export type ChallengeEventUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ChallengeEvent
     */
    select?: ChallengeEventSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ChallengeEvent
     */
    omit?: ChallengeEventOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ChallengeEventInclude<ExtArgs> | null
    /**
     * The filter to search for the ChallengeEvent to update in case it exists.
     */
    where: ChallengeEventWhereUniqueInput
    /**
     * In case the ChallengeEvent found by the `where` argument doesn't exist, create a new ChallengeEvent with this data.
     */
    create: XOR<ChallengeEventCreateInput, ChallengeEventUncheckedCreateInput>
    /**
     * In case the ChallengeEvent was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ChallengeEventUpdateInput, ChallengeEventUncheckedUpdateInput>
  }

  /**
   * ChallengeEvent delete
   */
  export type ChallengeEventDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ChallengeEvent
     */
    select?: ChallengeEventSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ChallengeEvent
     */
    omit?: ChallengeEventOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ChallengeEventInclude<ExtArgs> | null
    /**
     * Filter which ChallengeEvent to delete.
     */
    where: ChallengeEventWhereUniqueInput
  }

  /**
   * ChallengeEvent deleteMany
   */
  export type ChallengeEventDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ChallengeEvents to delete
     */
    where?: ChallengeEventWhereInput
    /**
     * Limit how many ChallengeEvents to delete.
     */
    limit?: number
  }

  /**
   * ChallengeEvent without action
   */
  export type ChallengeEventDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ChallengeEvent
     */
    select?: ChallengeEventSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ChallengeEvent
     */
    omit?: ChallengeEventOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ChallengeEventInclude<ExtArgs> | null
  }


  /**
   * Model ChallengeDiscussion
   */

  export type AggregateChallengeDiscussion = {
    _count: ChallengeDiscussionCountAggregateOutputType | null
    _min: ChallengeDiscussionMinAggregateOutputType | null
    _max: ChallengeDiscussionMaxAggregateOutputType | null
  }

  export type ChallengeDiscussionMinAggregateOutputType = {
    id: string | null
    challengeId: string | null
    discussionId: string | null
    name: string | null
    type: $Enums.DiscussionTypeEnum | null
    provider: string | null
    url: string | null
    createdAt: Date | null
    createdBy: string | null
    updatedAt: Date | null
    updatedBy: string | null
  }

  export type ChallengeDiscussionMaxAggregateOutputType = {
    id: string | null
    challengeId: string | null
    discussionId: string | null
    name: string | null
    type: $Enums.DiscussionTypeEnum | null
    provider: string | null
    url: string | null
    createdAt: Date | null
    createdBy: string | null
    updatedAt: Date | null
    updatedBy: string | null
  }

  export type ChallengeDiscussionCountAggregateOutputType = {
    id: number
    challengeId: number
    discussionId: number
    name: number
    type: number
    provider: number
    url: number
    createdAt: number
    createdBy: number
    updatedAt: number
    updatedBy: number
    _all: number
  }


  export type ChallengeDiscussionMinAggregateInputType = {
    id?: true
    challengeId?: true
    discussionId?: true
    name?: true
    type?: true
    provider?: true
    url?: true
    createdAt?: true
    createdBy?: true
    updatedAt?: true
    updatedBy?: true
  }

  export type ChallengeDiscussionMaxAggregateInputType = {
    id?: true
    challengeId?: true
    discussionId?: true
    name?: true
    type?: true
    provider?: true
    url?: true
    createdAt?: true
    createdBy?: true
    updatedAt?: true
    updatedBy?: true
  }

  export type ChallengeDiscussionCountAggregateInputType = {
    id?: true
    challengeId?: true
    discussionId?: true
    name?: true
    type?: true
    provider?: true
    url?: true
    createdAt?: true
    createdBy?: true
    updatedAt?: true
    updatedBy?: true
    _all?: true
  }

  export type ChallengeDiscussionAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ChallengeDiscussion to aggregate.
     */
    where?: ChallengeDiscussionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ChallengeDiscussions to fetch.
     */
    orderBy?: ChallengeDiscussionOrderByWithRelationInput | ChallengeDiscussionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ChallengeDiscussionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ChallengeDiscussions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ChallengeDiscussions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned ChallengeDiscussions
    **/
    _count?: true | ChallengeDiscussionCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ChallengeDiscussionMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ChallengeDiscussionMaxAggregateInputType
  }

  export type GetChallengeDiscussionAggregateType<T extends ChallengeDiscussionAggregateArgs> = {
        [P in keyof T & keyof AggregateChallengeDiscussion]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateChallengeDiscussion[P]>
      : GetScalarType<T[P], AggregateChallengeDiscussion[P]>
  }




  export type ChallengeDiscussionGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ChallengeDiscussionWhereInput
    orderBy?: ChallengeDiscussionOrderByWithAggregationInput | ChallengeDiscussionOrderByWithAggregationInput[]
    by: ChallengeDiscussionScalarFieldEnum[] | ChallengeDiscussionScalarFieldEnum
    having?: ChallengeDiscussionScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ChallengeDiscussionCountAggregateInputType | true
    _min?: ChallengeDiscussionMinAggregateInputType
    _max?: ChallengeDiscussionMaxAggregateInputType
  }

  export type ChallengeDiscussionGroupByOutputType = {
    id: string
    challengeId: string
    discussionId: string | null
    name: string
    type: $Enums.DiscussionTypeEnum
    provider: string
    url: string | null
    createdAt: Date
    createdBy: string
    updatedAt: Date
    updatedBy: string
    _count: ChallengeDiscussionCountAggregateOutputType | null
    _min: ChallengeDiscussionMinAggregateOutputType | null
    _max: ChallengeDiscussionMaxAggregateOutputType | null
  }

  type GetChallengeDiscussionGroupByPayload<T extends ChallengeDiscussionGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ChallengeDiscussionGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ChallengeDiscussionGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ChallengeDiscussionGroupByOutputType[P]>
            : GetScalarType<T[P], ChallengeDiscussionGroupByOutputType[P]>
        }
      >
    >


  export type ChallengeDiscussionSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    challengeId?: boolean
    discussionId?: boolean
    name?: boolean
    type?: boolean
    provider?: boolean
    url?: boolean
    createdAt?: boolean
    createdBy?: boolean
    updatedAt?: boolean
    updatedBy?: boolean
    challenge?: boolean | ChallengeDefaultArgs<ExtArgs>
    options?: boolean | ChallengeDiscussion$optionsArgs<ExtArgs>
    _count?: boolean | ChallengeDiscussionCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["challengeDiscussion"]>

  export type ChallengeDiscussionSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    challengeId?: boolean
    discussionId?: boolean
    name?: boolean
    type?: boolean
    provider?: boolean
    url?: boolean
    createdAt?: boolean
    createdBy?: boolean
    updatedAt?: boolean
    updatedBy?: boolean
    challenge?: boolean | ChallengeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["challengeDiscussion"]>

  export type ChallengeDiscussionSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    challengeId?: boolean
    discussionId?: boolean
    name?: boolean
    type?: boolean
    provider?: boolean
    url?: boolean
    createdAt?: boolean
    createdBy?: boolean
    updatedAt?: boolean
    updatedBy?: boolean
    challenge?: boolean | ChallengeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["challengeDiscussion"]>

  export type ChallengeDiscussionSelectScalar = {
    id?: boolean
    challengeId?: boolean
    discussionId?: boolean
    name?: boolean
    type?: boolean
    provider?: boolean
    url?: boolean
    createdAt?: boolean
    createdBy?: boolean
    updatedAt?: boolean
    updatedBy?: boolean
  }

  export type ChallengeDiscussionOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "challengeId" | "discussionId" | "name" | "type" | "provider" | "url" | "createdAt" | "createdBy" | "updatedAt" | "updatedBy", ExtArgs["result"]["challengeDiscussion"]>
  export type ChallengeDiscussionInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    challenge?: boolean | ChallengeDefaultArgs<ExtArgs>
    options?: boolean | ChallengeDiscussion$optionsArgs<ExtArgs>
    _count?: boolean | ChallengeDiscussionCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type ChallengeDiscussionIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    challenge?: boolean | ChallengeDefaultArgs<ExtArgs>
  }
  export type ChallengeDiscussionIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    challenge?: boolean | ChallengeDefaultArgs<ExtArgs>
  }

  export type $ChallengeDiscussionPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "ChallengeDiscussion"
    objects: {
      challenge: Prisma.$ChallengePayload<ExtArgs>
      options: Prisma.$ChallengeDiscussionOptionPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      challengeId: string
      discussionId: string | null
      name: string
      type: $Enums.DiscussionTypeEnum
      provider: string
      url: string | null
      createdAt: Date
      createdBy: string
      updatedAt: Date
      updatedBy: string
    }, ExtArgs["result"]["challengeDiscussion"]>
    composites: {}
  }

  type ChallengeDiscussionGetPayload<S extends boolean | null | undefined | ChallengeDiscussionDefaultArgs> = $Result.GetResult<Prisma.$ChallengeDiscussionPayload, S>

  type ChallengeDiscussionCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<ChallengeDiscussionFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: ChallengeDiscussionCountAggregateInputType | true
    }

  export interface ChallengeDiscussionDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['ChallengeDiscussion'], meta: { name: 'ChallengeDiscussion' } }
    /**
     * Find zero or one ChallengeDiscussion that matches the filter.
     * @param {ChallengeDiscussionFindUniqueArgs} args - Arguments to find a ChallengeDiscussion
     * @example
     * // Get one ChallengeDiscussion
     * const challengeDiscussion = await prisma.challengeDiscussion.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends ChallengeDiscussionFindUniqueArgs>(args: SelectSubset<T, ChallengeDiscussionFindUniqueArgs<ExtArgs>>): Prisma__ChallengeDiscussionClient<$Result.GetResult<Prisma.$ChallengeDiscussionPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one ChallengeDiscussion that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {ChallengeDiscussionFindUniqueOrThrowArgs} args - Arguments to find a ChallengeDiscussion
     * @example
     * // Get one ChallengeDiscussion
     * const challengeDiscussion = await prisma.challengeDiscussion.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends ChallengeDiscussionFindUniqueOrThrowArgs>(args: SelectSubset<T, ChallengeDiscussionFindUniqueOrThrowArgs<ExtArgs>>): Prisma__ChallengeDiscussionClient<$Result.GetResult<Prisma.$ChallengeDiscussionPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first ChallengeDiscussion that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ChallengeDiscussionFindFirstArgs} args - Arguments to find a ChallengeDiscussion
     * @example
     * // Get one ChallengeDiscussion
     * const challengeDiscussion = await prisma.challengeDiscussion.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends ChallengeDiscussionFindFirstArgs>(args?: SelectSubset<T, ChallengeDiscussionFindFirstArgs<ExtArgs>>): Prisma__ChallengeDiscussionClient<$Result.GetResult<Prisma.$ChallengeDiscussionPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first ChallengeDiscussion that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ChallengeDiscussionFindFirstOrThrowArgs} args - Arguments to find a ChallengeDiscussion
     * @example
     * // Get one ChallengeDiscussion
     * const challengeDiscussion = await prisma.challengeDiscussion.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends ChallengeDiscussionFindFirstOrThrowArgs>(args?: SelectSubset<T, ChallengeDiscussionFindFirstOrThrowArgs<ExtArgs>>): Prisma__ChallengeDiscussionClient<$Result.GetResult<Prisma.$ChallengeDiscussionPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more ChallengeDiscussions that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ChallengeDiscussionFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all ChallengeDiscussions
     * const challengeDiscussions = await prisma.challengeDiscussion.findMany()
     * 
     * // Get first 10 ChallengeDiscussions
     * const challengeDiscussions = await prisma.challengeDiscussion.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const challengeDiscussionWithIdOnly = await prisma.challengeDiscussion.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends ChallengeDiscussionFindManyArgs>(args?: SelectSubset<T, ChallengeDiscussionFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ChallengeDiscussionPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a ChallengeDiscussion.
     * @param {ChallengeDiscussionCreateArgs} args - Arguments to create a ChallengeDiscussion.
     * @example
     * // Create one ChallengeDiscussion
     * const ChallengeDiscussion = await prisma.challengeDiscussion.create({
     *   data: {
     *     // ... data to create a ChallengeDiscussion
     *   }
     * })
     * 
     */
    create<T extends ChallengeDiscussionCreateArgs>(args: SelectSubset<T, ChallengeDiscussionCreateArgs<ExtArgs>>): Prisma__ChallengeDiscussionClient<$Result.GetResult<Prisma.$ChallengeDiscussionPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many ChallengeDiscussions.
     * @param {ChallengeDiscussionCreateManyArgs} args - Arguments to create many ChallengeDiscussions.
     * @example
     * // Create many ChallengeDiscussions
     * const challengeDiscussion = await prisma.challengeDiscussion.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends ChallengeDiscussionCreateManyArgs>(args?: SelectSubset<T, ChallengeDiscussionCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many ChallengeDiscussions and returns the data saved in the database.
     * @param {ChallengeDiscussionCreateManyAndReturnArgs} args - Arguments to create many ChallengeDiscussions.
     * @example
     * // Create many ChallengeDiscussions
     * const challengeDiscussion = await prisma.challengeDiscussion.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many ChallengeDiscussions and only return the `id`
     * const challengeDiscussionWithIdOnly = await prisma.challengeDiscussion.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends ChallengeDiscussionCreateManyAndReturnArgs>(args?: SelectSubset<T, ChallengeDiscussionCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ChallengeDiscussionPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a ChallengeDiscussion.
     * @param {ChallengeDiscussionDeleteArgs} args - Arguments to delete one ChallengeDiscussion.
     * @example
     * // Delete one ChallengeDiscussion
     * const ChallengeDiscussion = await prisma.challengeDiscussion.delete({
     *   where: {
     *     // ... filter to delete one ChallengeDiscussion
     *   }
     * })
     * 
     */
    delete<T extends ChallengeDiscussionDeleteArgs>(args: SelectSubset<T, ChallengeDiscussionDeleteArgs<ExtArgs>>): Prisma__ChallengeDiscussionClient<$Result.GetResult<Prisma.$ChallengeDiscussionPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one ChallengeDiscussion.
     * @param {ChallengeDiscussionUpdateArgs} args - Arguments to update one ChallengeDiscussion.
     * @example
     * // Update one ChallengeDiscussion
     * const challengeDiscussion = await prisma.challengeDiscussion.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends ChallengeDiscussionUpdateArgs>(args: SelectSubset<T, ChallengeDiscussionUpdateArgs<ExtArgs>>): Prisma__ChallengeDiscussionClient<$Result.GetResult<Prisma.$ChallengeDiscussionPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more ChallengeDiscussions.
     * @param {ChallengeDiscussionDeleteManyArgs} args - Arguments to filter ChallengeDiscussions to delete.
     * @example
     * // Delete a few ChallengeDiscussions
     * const { count } = await prisma.challengeDiscussion.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends ChallengeDiscussionDeleteManyArgs>(args?: SelectSubset<T, ChallengeDiscussionDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more ChallengeDiscussions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ChallengeDiscussionUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many ChallengeDiscussions
     * const challengeDiscussion = await prisma.challengeDiscussion.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends ChallengeDiscussionUpdateManyArgs>(args: SelectSubset<T, ChallengeDiscussionUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more ChallengeDiscussions and returns the data updated in the database.
     * @param {ChallengeDiscussionUpdateManyAndReturnArgs} args - Arguments to update many ChallengeDiscussions.
     * @example
     * // Update many ChallengeDiscussions
     * const challengeDiscussion = await prisma.challengeDiscussion.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more ChallengeDiscussions and only return the `id`
     * const challengeDiscussionWithIdOnly = await prisma.challengeDiscussion.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends ChallengeDiscussionUpdateManyAndReturnArgs>(args: SelectSubset<T, ChallengeDiscussionUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ChallengeDiscussionPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one ChallengeDiscussion.
     * @param {ChallengeDiscussionUpsertArgs} args - Arguments to update or create a ChallengeDiscussion.
     * @example
     * // Update or create a ChallengeDiscussion
     * const challengeDiscussion = await prisma.challengeDiscussion.upsert({
     *   create: {
     *     // ... data to create a ChallengeDiscussion
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the ChallengeDiscussion we want to update
     *   }
     * })
     */
    upsert<T extends ChallengeDiscussionUpsertArgs>(args: SelectSubset<T, ChallengeDiscussionUpsertArgs<ExtArgs>>): Prisma__ChallengeDiscussionClient<$Result.GetResult<Prisma.$ChallengeDiscussionPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of ChallengeDiscussions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ChallengeDiscussionCountArgs} args - Arguments to filter ChallengeDiscussions to count.
     * @example
     * // Count the number of ChallengeDiscussions
     * const count = await prisma.challengeDiscussion.count({
     *   where: {
     *     // ... the filter for the ChallengeDiscussions we want to count
     *   }
     * })
    **/
    count<T extends ChallengeDiscussionCountArgs>(
      args?: Subset<T, ChallengeDiscussionCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ChallengeDiscussionCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a ChallengeDiscussion.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ChallengeDiscussionAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ChallengeDiscussionAggregateArgs>(args: Subset<T, ChallengeDiscussionAggregateArgs>): Prisma.PrismaPromise<GetChallengeDiscussionAggregateType<T>>

    /**
     * Group by ChallengeDiscussion.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ChallengeDiscussionGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ChallengeDiscussionGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ChallengeDiscussionGroupByArgs['orderBy'] }
        : { orderBy?: ChallengeDiscussionGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ChallengeDiscussionGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetChallengeDiscussionGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the ChallengeDiscussion model
   */
  readonly fields: ChallengeDiscussionFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for ChallengeDiscussion.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ChallengeDiscussionClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    challenge<T extends ChallengeDefaultArgs<ExtArgs> = {}>(args?: Subset<T, ChallengeDefaultArgs<ExtArgs>>): Prisma__ChallengeClient<$Result.GetResult<Prisma.$ChallengePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    options<T extends ChallengeDiscussion$optionsArgs<ExtArgs> = {}>(args?: Subset<T, ChallengeDiscussion$optionsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ChallengeDiscussionOptionPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the ChallengeDiscussion model
   */
  interface ChallengeDiscussionFieldRefs {
    readonly id: FieldRef<"ChallengeDiscussion", 'String'>
    readonly challengeId: FieldRef<"ChallengeDiscussion", 'String'>
    readonly discussionId: FieldRef<"ChallengeDiscussion", 'String'>
    readonly name: FieldRef<"ChallengeDiscussion", 'String'>
    readonly type: FieldRef<"ChallengeDiscussion", 'DiscussionTypeEnum'>
    readonly provider: FieldRef<"ChallengeDiscussion", 'String'>
    readonly url: FieldRef<"ChallengeDiscussion", 'String'>
    readonly createdAt: FieldRef<"ChallengeDiscussion", 'DateTime'>
    readonly createdBy: FieldRef<"ChallengeDiscussion", 'String'>
    readonly updatedAt: FieldRef<"ChallengeDiscussion", 'DateTime'>
    readonly updatedBy: FieldRef<"ChallengeDiscussion", 'String'>
  }
    

  // Custom InputTypes
  /**
   * ChallengeDiscussion findUnique
   */
  export type ChallengeDiscussionFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ChallengeDiscussion
     */
    select?: ChallengeDiscussionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ChallengeDiscussion
     */
    omit?: ChallengeDiscussionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ChallengeDiscussionInclude<ExtArgs> | null
    /**
     * Filter, which ChallengeDiscussion to fetch.
     */
    where: ChallengeDiscussionWhereUniqueInput
  }

  /**
   * ChallengeDiscussion findUniqueOrThrow
   */
  export type ChallengeDiscussionFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ChallengeDiscussion
     */
    select?: ChallengeDiscussionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ChallengeDiscussion
     */
    omit?: ChallengeDiscussionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ChallengeDiscussionInclude<ExtArgs> | null
    /**
     * Filter, which ChallengeDiscussion to fetch.
     */
    where: ChallengeDiscussionWhereUniqueInput
  }

  /**
   * ChallengeDiscussion findFirst
   */
  export type ChallengeDiscussionFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ChallengeDiscussion
     */
    select?: ChallengeDiscussionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ChallengeDiscussion
     */
    omit?: ChallengeDiscussionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ChallengeDiscussionInclude<ExtArgs> | null
    /**
     * Filter, which ChallengeDiscussion to fetch.
     */
    where?: ChallengeDiscussionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ChallengeDiscussions to fetch.
     */
    orderBy?: ChallengeDiscussionOrderByWithRelationInput | ChallengeDiscussionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ChallengeDiscussions.
     */
    cursor?: ChallengeDiscussionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ChallengeDiscussions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ChallengeDiscussions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ChallengeDiscussions.
     */
    distinct?: ChallengeDiscussionScalarFieldEnum | ChallengeDiscussionScalarFieldEnum[]
  }

  /**
   * ChallengeDiscussion findFirstOrThrow
   */
  export type ChallengeDiscussionFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ChallengeDiscussion
     */
    select?: ChallengeDiscussionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ChallengeDiscussion
     */
    omit?: ChallengeDiscussionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ChallengeDiscussionInclude<ExtArgs> | null
    /**
     * Filter, which ChallengeDiscussion to fetch.
     */
    where?: ChallengeDiscussionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ChallengeDiscussions to fetch.
     */
    orderBy?: ChallengeDiscussionOrderByWithRelationInput | ChallengeDiscussionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ChallengeDiscussions.
     */
    cursor?: ChallengeDiscussionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ChallengeDiscussions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ChallengeDiscussions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ChallengeDiscussions.
     */
    distinct?: ChallengeDiscussionScalarFieldEnum | ChallengeDiscussionScalarFieldEnum[]
  }

  /**
   * ChallengeDiscussion findMany
   */
  export type ChallengeDiscussionFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ChallengeDiscussion
     */
    select?: ChallengeDiscussionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ChallengeDiscussion
     */
    omit?: ChallengeDiscussionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ChallengeDiscussionInclude<ExtArgs> | null
    /**
     * Filter, which ChallengeDiscussions to fetch.
     */
    where?: ChallengeDiscussionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ChallengeDiscussions to fetch.
     */
    orderBy?: ChallengeDiscussionOrderByWithRelationInput | ChallengeDiscussionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing ChallengeDiscussions.
     */
    cursor?: ChallengeDiscussionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ChallengeDiscussions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ChallengeDiscussions.
     */
    skip?: number
    distinct?: ChallengeDiscussionScalarFieldEnum | ChallengeDiscussionScalarFieldEnum[]
  }

  /**
   * ChallengeDiscussion create
   */
  export type ChallengeDiscussionCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ChallengeDiscussion
     */
    select?: ChallengeDiscussionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ChallengeDiscussion
     */
    omit?: ChallengeDiscussionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ChallengeDiscussionInclude<ExtArgs> | null
    /**
     * The data needed to create a ChallengeDiscussion.
     */
    data: XOR<ChallengeDiscussionCreateInput, ChallengeDiscussionUncheckedCreateInput>
  }

  /**
   * ChallengeDiscussion createMany
   */
  export type ChallengeDiscussionCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many ChallengeDiscussions.
     */
    data: ChallengeDiscussionCreateManyInput | ChallengeDiscussionCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * ChallengeDiscussion createManyAndReturn
   */
  export type ChallengeDiscussionCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ChallengeDiscussion
     */
    select?: ChallengeDiscussionSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the ChallengeDiscussion
     */
    omit?: ChallengeDiscussionOmit<ExtArgs> | null
    /**
     * The data used to create many ChallengeDiscussions.
     */
    data: ChallengeDiscussionCreateManyInput | ChallengeDiscussionCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ChallengeDiscussionIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * ChallengeDiscussion update
   */
  export type ChallengeDiscussionUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ChallengeDiscussion
     */
    select?: ChallengeDiscussionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ChallengeDiscussion
     */
    omit?: ChallengeDiscussionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ChallengeDiscussionInclude<ExtArgs> | null
    /**
     * The data needed to update a ChallengeDiscussion.
     */
    data: XOR<ChallengeDiscussionUpdateInput, ChallengeDiscussionUncheckedUpdateInput>
    /**
     * Choose, which ChallengeDiscussion to update.
     */
    where: ChallengeDiscussionWhereUniqueInput
  }

  /**
   * ChallengeDiscussion updateMany
   */
  export type ChallengeDiscussionUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update ChallengeDiscussions.
     */
    data: XOR<ChallengeDiscussionUpdateManyMutationInput, ChallengeDiscussionUncheckedUpdateManyInput>
    /**
     * Filter which ChallengeDiscussions to update
     */
    where?: ChallengeDiscussionWhereInput
    /**
     * Limit how many ChallengeDiscussions to update.
     */
    limit?: number
  }

  /**
   * ChallengeDiscussion updateManyAndReturn
   */
  export type ChallengeDiscussionUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ChallengeDiscussion
     */
    select?: ChallengeDiscussionSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the ChallengeDiscussion
     */
    omit?: ChallengeDiscussionOmit<ExtArgs> | null
    /**
     * The data used to update ChallengeDiscussions.
     */
    data: XOR<ChallengeDiscussionUpdateManyMutationInput, ChallengeDiscussionUncheckedUpdateManyInput>
    /**
     * Filter which ChallengeDiscussions to update
     */
    where?: ChallengeDiscussionWhereInput
    /**
     * Limit how many ChallengeDiscussions to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ChallengeDiscussionIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * ChallengeDiscussion upsert
   */
  export type ChallengeDiscussionUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ChallengeDiscussion
     */
    select?: ChallengeDiscussionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ChallengeDiscussion
     */
    omit?: ChallengeDiscussionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ChallengeDiscussionInclude<ExtArgs> | null
    /**
     * The filter to search for the ChallengeDiscussion to update in case it exists.
     */
    where: ChallengeDiscussionWhereUniqueInput
    /**
     * In case the ChallengeDiscussion found by the `where` argument doesn't exist, create a new ChallengeDiscussion with this data.
     */
    create: XOR<ChallengeDiscussionCreateInput, ChallengeDiscussionUncheckedCreateInput>
    /**
     * In case the ChallengeDiscussion was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ChallengeDiscussionUpdateInput, ChallengeDiscussionUncheckedUpdateInput>
  }

  /**
   * ChallengeDiscussion delete
   */
  export type ChallengeDiscussionDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ChallengeDiscussion
     */
    select?: ChallengeDiscussionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ChallengeDiscussion
     */
    omit?: ChallengeDiscussionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ChallengeDiscussionInclude<ExtArgs> | null
    /**
     * Filter which ChallengeDiscussion to delete.
     */
    where: ChallengeDiscussionWhereUniqueInput
  }

  /**
   * ChallengeDiscussion deleteMany
   */
  export type ChallengeDiscussionDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ChallengeDiscussions to delete
     */
    where?: ChallengeDiscussionWhereInput
    /**
     * Limit how many ChallengeDiscussions to delete.
     */
    limit?: number
  }

  /**
   * ChallengeDiscussion.options
   */
  export type ChallengeDiscussion$optionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ChallengeDiscussionOption
     */
    select?: ChallengeDiscussionOptionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ChallengeDiscussionOption
     */
    omit?: ChallengeDiscussionOptionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ChallengeDiscussionOptionInclude<ExtArgs> | null
    where?: ChallengeDiscussionOptionWhereInput
    orderBy?: ChallengeDiscussionOptionOrderByWithRelationInput | ChallengeDiscussionOptionOrderByWithRelationInput[]
    cursor?: ChallengeDiscussionOptionWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ChallengeDiscussionOptionScalarFieldEnum | ChallengeDiscussionOptionScalarFieldEnum[]
  }

  /**
   * ChallengeDiscussion without action
   */
  export type ChallengeDiscussionDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ChallengeDiscussion
     */
    select?: ChallengeDiscussionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ChallengeDiscussion
     */
    omit?: ChallengeDiscussionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ChallengeDiscussionInclude<ExtArgs> | null
  }


  /**
   * Model ChallengeDiscussionOption
   */

  export type AggregateChallengeDiscussionOption = {
    _count: ChallengeDiscussionOptionCountAggregateOutputType | null
    _min: ChallengeDiscussionOptionMinAggregateOutputType | null
    _max: ChallengeDiscussionOptionMaxAggregateOutputType | null
  }

  export type ChallengeDiscussionOptionMinAggregateOutputType = {
    id: string | null
    discussionId: string | null
    optionKey: string | null
    optionValue: string | null
    createdAt: Date | null
    createdBy: string | null
    updatedAt: Date | null
    updatedBy: string | null
  }

  export type ChallengeDiscussionOptionMaxAggregateOutputType = {
    id: string | null
    discussionId: string | null
    optionKey: string | null
    optionValue: string | null
    createdAt: Date | null
    createdBy: string | null
    updatedAt: Date | null
    updatedBy: string | null
  }

  export type ChallengeDiscussionOptionCountAggregateOutputType = {
    id: number
    discussionId: number
    optionKey: number
    optionValue: number
    createdAt: number
    createdBy: number
    updatedAt: number
    updatedBy: number
    _all: number
  }


  export type ChallengeDiscussionOptionMinAggregateInputType = {
    id?: true
    discussionId?: true
    optionKey?: true
    optionValue?: true
    createdAt?: true
    createdBy?: true
    updatedAt?: true
    updatedBy?: true
  }

  export type ChallengeDiscussionOptionMaxAggregateInputType = {
    id?: true
    discussionId?: true
    optionKey?: true
    optionValue?: true
    createdAt?: true
    createdBy?: true
    updatedAt?: true
    updatedBy?: true
  }

  export type ChallengeDiscussionOptionCountAggregateInputType = {
    id?: true
    discussionId?: true
    optionKey?: true
    optionValue?: true
    createdAt?: true
    createdBy?: true
    updatedAt?: true
    updatedBy?: true
    _all?: true
  }

  export type ChallengeDiscussionOptionAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ChallengeDiscussionOption to aggregate.
     */
    where?: ChallengeDiscussionOptionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ChallengeDiscussionOptions to fetch.
     */
    orderBy?: ChallengeDiscussionOptionOrderByWithRelationInput | ChallengeDiscussionOptionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ChallengeDiscussionOptionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ChallengeDiscussionOptions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ChallengeDiscussionOptions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned ChallengeDiscussionOptions
    **/
    _count?: true | ChallengeDiscussionOptionCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ChallengeDiscussionOptionMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ChallengeDiscussionOptionMaxAggregateInputType
  }

  export type GetChallengeDiscussionOptionAggregateType<T extends ChallengeDiscussionOptionAggregateArgs> = {
        [P in keyof T & keyof AggregateChallengeDiscussionOption]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateChallengeDiscussionOption[P]>
      : GetScalarType<T[P], AggregateChallengeDiscussionOption[P]>
  }




  export type ChallengeDiscussionOptionGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ChallengeDiscussionOptionWhereInput
    orderBy?: ChallengeDiscussionOptionOrderByWithAggregationInput | ChallengeDiscussionOptionOrderByWithAggregationInput[]
    by: ChallengeDiscussionOptionScalarFieldEnum[] | ChallengeDiscussionOptionScalarFieldEnum
    having?: ChallengeDiscussionOptionScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ChallengeDiscussionOptionCountAggregateInputType | true
    _min?: ChallengeDiscussionOptionMinAggregateInputType
    _max?: ChallengeDiscussionOptionMaxAggregateInputType
  }

  export type ChallengeDiscussionOptionGroupByOutputType = {
    id: string
    discussionId: string
    optionKey: string
    optionValue: string
    createdAt: Date
    createdBy: string
    updatedAt: Date
    updatedBy: string
    _count: ChallengeDiscussionOptionCountAggregateOutputType | null
    _min: ChallengeDiscussionOptionMinAggregateOutputType | null
    _max: ChallengeDiscussionOptionMaxAggregateOutputType | null
  }

  type GetChallengeDiscussionOptionGroupByPayload<T extends ChallengeDiscussionOptionGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ChallengeDiscussionOptionGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ChallengeDiscussionOptionGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ChallengeDiscussionOptionGroupByOutputType[P]>
            : GetScalarType<T[P], ChallengeDiscussionOptionGroupByOutputType[P]>
        }
      >
    >


  export type ChallengeDiscussionOptionSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    discussionId?: boolean
    optionKey?: boolean
    optionValue?: boolean
    createdAt?: boolean
    createdBy?: boolean
    updatedAt?: boolean
    updatedBy?: boolean
    discussion?: boolean | ChallengeDiscussionDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["challengeDiscussionOption"]>

  export type ChallengeDiscussionOptionSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    discussionId?: boolean
    optionKey?: boolean
    optionValue?: boolean
    createdAt?: boolean
    createdBy?: boolean
    updatedAt?: boolean
    updatedBy?: boolean
    discussion?: boolean | ChallengeDiscussionDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["challengeDiscussionOption"]>

  export type ChallengeDiscussionOptionSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    discussionId?: boolean
    optionKey?: boolean
    optionValue?: boolean
    createdAt?: boolean
    createdBy?: boolean
    updatedAt?: boolean
    updatedBy?: boolean
    discussion?: boolean | ChallengeDiscussionDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["challengeDiscussionOption"]>

  export type ChallengeDiscussionOptionSelectScalar = {
    id?: boolean
    discussionId?: boolean
    optionKey?: boolean
    optionValue?: boolean
    createdAt?: boolean
    createdBy?: boolean
    updatedAt?: boolean
    updatedBy?: boolean
  }

  export type ChallengeDiscussionOptionOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "discussionId" | "optionKey" | "optionValue" | "createdAt" | "createdBy" | "updatedAt" | "updatedBy", ExtArgs["result"]["challengeDiscussionOption"]>
  export type ChallengeDiscussionOptionInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    discussion?: boolean | ChallengeDiscussionDefaultArgs<ExtArgs>
  }
  export type ChallengeDiscussionOptionIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    discussion?: boolean | ChallengeDiscussionDefaultArgs<ExtArgs>
  }
  export type ChallengeDiscussionOptionIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    discussion?: boolean | ChallengeDiscussionDefaultArgs<ExtArgs>
  }

  export type $ChallengeDiscussionOptionPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "ChallengeDiscussionOption"
    objects: {
      discussion: Prisma.$ChallengeDiscussionPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      discussionId: string
      optionKey: string
      optionValue: string
      createdAt: Date
      createdBy: string
      updatedAt: Date
      updatedBy: string
    }, ExtArgs["result"]["challengeDiscussionOption"]>
    composites: {}
  }

  type ChallengeDiscussionOptionGetPayload<S extends boolean | null | undefined | ChallengeDiscussionOptionDefaultArgs> = $Result.GetResult<Prisma.$ChallengeDiscussionOptionPayload, S>

  type ChallengeDiscussionOptionCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<ChallengeDiscussionOptionFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: ChallengeDiscussionOptionCountAggregateInputType | true
    }

  export interface ChallengeDiscussionOptionDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['ChallengeDiscussionOption'], meta: { name: 'ChallengeDiscussionOption' } }
    /**
     * Find zero or one ChallengeDiscussionOption that matches the filter.
     * @param {ChallengeDiscussionOptionFindUniqueArgs} args - Arguments to find a ChallengeDiscussionOption
     * @example
     * // Get one ChallengeDiscussionOption
     * const challengeDiscussionOption = await prisma.challengeDiscussionOption.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends ChallengeDiscussionOptionFindUniqueArgs>(args: SelectSubset<T, ChallengeDiscussionOptionFindUniqueArgs<ExtArgs>>): Prisma__ChallengeDiscussionOptionClient<$Result.GetResult<Prisma.$ChallengeDiscussionOptionPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one ChallengeDiscussionOption that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {ChallengeDiscussionOptionFindUniqueOrThrowArgs} args - Arguments to find a ChallengeDiscussionOption
     * @example
     * // Get one ChallengeDiscussionOption
     * const challengeDiscussionOption = await prisma.challengeDiscussionOption.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends ChallengeDiscussionOptionFindUniqueOrThrowArgs>(args: SelectSubset<T, ChallengeDiscussionOptionFindUniqueOrThrowArgs<ExtArgs>>): Prisma__ChallengeDiscussionOptionClient<$Result.GetResult<Prisma.$ChallengeDiscussionOptionPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first ChallengeDiscussionOption that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ChallengeDiscussionOptionFindFirstArgs} args - Arguments to find a ChallengeDiscussionOption
     * @example
     * // Get one ChallengeDiscussionOption
     * const challengeDiscussionOption = await prisma.challengeDiscussionOption.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends ChallengeDiscussionOptionFindFirstArgs>(args?: SelectSubset<T, ChallengeDiscussionOptionFindFirstArgs<ExtArgs>>): Prisma__ChallengeDiscussionOptionClient<$Result.GetResult<Prisma.$ChallengeDiscussionOptionPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first ChallengeDiscussionOption that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ChallengeDiscussionOptionFindFirstOrThrowArgs} args - Arguments to find a ChallengeDiscussionOption
     * @example
     * // Get one ChallengeDiscussionOption
     * const challengeDiscussionOption = await prisma.challengeDiscussionOption.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends ChallengeDiscussionOptionFindFirstOrThrowArgs>(args?: SelectSubset<T, ChallengeDiscussionOptionFindFirstOrThrowArgs<ExtArgs>>): Prisma__ChallengeDiscussionOptionClient<$Result.GetResult<Prisma.$ChallengeDiscussionOptionPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more ChallengeDiscussionOptions that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ChallengeDiscussionOptionFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all ChallengeDiscussionOptions
     * const challengeDiscussionOptions = await prisma.challengeDiscussionOption.findMany()
     * 
     * // Get first 10 ChallengeDiscussionOptions
     * const challengeDiscussionOptions = await prisma.challengeDiscussionOption.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const challengeDiscussionOptionWithIdOnly = await prisma.challengeDiscussionOption.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends ChallengeDiscussionOptionFindManyArgs>(args?: SelectSubset<T, ChallengeDiscussionOptionFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ChallengeDiscussionOptionPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a ChallengeDiscussionOption.
     * @param {ChallengeDiscussionOptionCreateArgs} args - Arguments to create a ChallengeDiscussionOption.
     * @example
     * // Create one ChallengeDiscussionOption
     * const ChallengeDiscussionOption = await prisma.challengeDiscussionOption.create({
     *   data: {
     *     // ... data to create a ChallengeDiscussionOption
     *   }
     * })
     * 
     */
    create<T extends ChallengeDiscussionOptionCreateArgs>(args: SelectSubset<T, ChallengeDiscussionOptionCreateArgs<ExtArgs>>): Prisma__ChallengeDiscussionOptionClient<$Result.GetResult<Prisma.$ChallengeDiscussionOptionPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many ChallengeDiscussionOptions.
     * @param {ChallengeDiscussionOptionCreateManyArgs} args - Arguments to create many ChallengeDiscussionOptions.
     * @example
     * // Create many ChallengeDiscussionOptions
     * const challengeDiscussionOption = await prisma.challengeDiscussionOption.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends ChallengeDiscussionOptionCreateManyArgs>(args?: SelectSubset<T, ChallengeDiscussionOptionCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many ChallengeDiscussionOptions and returns the data saved in the database.
     * @param {ChallengeDiscussionOptionCreateManyAndReturnArgs} args - Arguments to create many ChallengeDiscussionOptions.
     * @example
     * // Create many ChallengeDiscussionOptions
     * const challengeDiscussionOption = await prisma.challengeDiscussionOption.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many ChallengeDiscussionOptions and only return the `id`
     * const challengeDiscussionOptionWithIdOnly = await prisma.challengeDiscussionOption.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends ChallengeDiscussionOptionCreateManyAndReturnArgs>(args?: SelectSubset<T, ChallengeDiscussionOptionCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ChallengeDiscussionOptionPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a ChallengeDiscussionOption.
     * @param {ChallengeDiscussionOptionDeleteArgs} args - Arguments to delete one ChallengeDiscussionOption.
     * @example
     * // Delete one ChallengeDiscussionOption
     * const ChallengeDiscussionOption = await prisma.challengeDiscussionOption.delete({
     *   where: {
     *     // ... filter to delete one ChallengeDiscussionOption
     *   }
     * })
     * 
     */
    delete<T extends ChallengeDiscussionOptionDeleteArgs>(args: SelectSubset<T, ChallengeDiscussionOptionDeleteArgs<ExtArgs>>): Prisma__ChallengeDiscussionOptionClient<$Result.GetResult<Prisma.$ChallengeDiscussionOptionPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one ChallengeDiscussionOption.
     * @param {ChallengeDiscussionOptionUpdateArgs} args - Arguments to update one ChallengeDiscussionOption.
     * @example
     * // Update one ChallengeDiscussionOption
     * const challengeDiscussionOption = await prisma.challengeDiscussionOption.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends ChallengeDiscussionOptionUpdateArgs>(args: SelectSubset<T, ChallengeDiscussionOptionUpdateArgs<ExtArgs>>): Prisma__ChallengeDiscussionOptionClient<$Result.GetResult<Prisma.$ChallengeDiscussionOptionPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more ChallengeDiscussionOptions.
     * @param {ChallengeDiscussionOptionDeleteManyArgs} args - Arguments to filter ChallengeDiscussionOptions to delete.
     * @example
     * // Delete a few ChallengeDiscussionOptions
     * const { count } = await prisma.challengeDiscussionOption.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends ChallengeDiscussionOptionDeleteManyArgs>(args?: SelectSubset<T, ChallengeDiscussionOptionDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more ChallengeDiscussionOptions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ChallengeDiscussionOptionUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many ChallengeDiscussionOptions
     * const challengeDiscussionOption = await prisma.challengeDiscussionOption.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends ChallengeDiscussionOptionUpdateManyArgs>(args: SelectSubset<T, ChallengeDiscussionOptionUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more ChallengeDiscussionOptions and returns the data updated in the database.
     * @param {ChallengeDiscussionOptionUpdateManyAndReturnArgs} args - Arguments to update many ChallengeDiscussionOptions.
     * @example
     * // Update many ChallengeDiscussionOptions
     * const challengeDiscussionOption = await prisma.challengeDiscussionOption.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more ChallengeDiscussionOptions and only return the `id`
     * const challengeDiscussionOptionWithIdOnly = await prisma.challengeDiscussionOption.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends ChallengeDiscussionOptionUpdateManyAndReturnArgs>(args: SelectSubset<T, ChallengeDiscussionOptionUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ChallengeDiscussionOptionPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one ChallengeDiscussionOption.
     * @param {ChallengeDiscussionOptionUpsertArgs} args - Arguments to update or create a ChallengeDiscussionOption.
     * @example
     * // Update or create a ChallengeDiscussionOption
     * const challengeDiscussionOption = await prisma.challengeDiscussionOption.upsert({
     *   create: {
     *     // ... data to create a ChallengeDiscussionOption
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the ChallengeDiscussionOption we want to update
     *   }
     * })
     */
    upsert<T extends ChallengeDiscussionOptionUpsertArgs>(args: SelectSubset<T, ChallengeDiscussionOptionUpsertArgs<ExtArgs>>): Prisma__ChallengeDiscussionOptionClient<$Result.GetResult<Prisma.$ChallengeDiscussionOptionPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of ChallengeDiscussionOptions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ChallengeDiscussionOptionCountArgs} args - Arguments to filter ChallengeDiscussionOptions to count.
     * @example
     * // Count the number of ChallengeDiscussionOptions
     * const count = await prisma.challengeDiscussionOption.count({
     *   where: {
     *     // ... the filter for the ChallengeDiscussionOptions we want to count
     *   }
     * })
    **/
    count<T extends ChallengeDiscussionOptionCountArgs>(
      args?: Subset<T, ChallengeDiscussionOptionCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ChallengeDiscussionOptionCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a ChallengeDiscussionOption.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ChallengeDiscussionOptionAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ChallengeDiscussionOptionAggregateArgs>(args: Subset<T, ChallengeDiscussionOptionAggregateArgs>): Prisma.PrismaPromise<GetChallengeDiscussionOptionAggregateType<T>>

    /**
     * Group by ChallengeDiscussionOption.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ChallengeDiscussionOptionGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ChallengeDiscussionOptionGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ChallengeDiscussionOptionGroupByArgs['orderBy'] }
        : { orderBy?: ChallengeDiscussionOptionGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ChallengeDiscussionOptionGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetChallengeDiscussionOptionGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the ChallengeDiscussionOption model
   */
  readonly fields: ChallengeDiscussionOptionFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for ChallengeDiscussionOption.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ChallengeDiscussionOptionClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    discussion<T extends ChallengeDiscussionDefaultArgs<ExtArgs> = {}>(args?: Subset<T, ChallengeDiscussionDefaultArgs<ExtArgs>>): Prisma__ChallengeDiscussionClient<$Result.GetResult<Prisma.$ChallengeDiscussionPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the ChallengeDiscussionOption model
   */
  interface ChallengeDiscussionOptionFieldRefs {
    readonly id: FieldRef<"ChallengeDiscussionOption", 'String'>
    readonly discussionId: FieldRef<"ChallengeDiscussionOption", 'String'>
    readonly optionKey: FieldRef<"ChallengeDiscussionOption", 'String'>
    readonly optionValue: FieldRef<"ChallengeDiscussionOption", 'String'>
    readonly createdAt: FieldRef<"ChallengeDiscussionOption", 'DateTime'>
    readonly createdBy: FieldRef<"ChallengeDiscussionOption", 'String'>
    readonly updatedAt: FieldRef<"ChallengeDiscussionOption", 'DateTime'>
    readonly updatedBy: FieldRef<"ChallengeDiscussionOption", 'String'>
  }
    

  // Custom InputTypes
  /**
   * ChallengeDiscussionOption findUnique
   */
  export type ChallengeDiscussionOptionFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ChallengeDiscussionOption
     */
    select?: ChallengeDiscussionOptionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ChallengeDiscussionOption
     */
    omit?: ChallengeDiscussionOptionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ChallengeDiscussionOptionInclude<ExtArgs> | null
    /**
     * Filter, which ChallengeDiscussionOption to fetch.
     */
    where: ChallengeDiscussionOptionWhereUniqueInput
  }

  /**
   * ChallengeDiscussionOption findUniqueOrThrow
   */
  export type ChallengeDiscussionOptionFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ChallengeDiscussionOption
     */
    select?: ChallengeDiscussionOptionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ChallengeDiscussionOption
     */
    omit?: ChallengeDiscussionOptionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ChallengeDiscussionOptionInclude<ExtArgs> | null
    /**
     * Filter, which ChallengeDiscussionOption to fetch.
     */
    where: ChallengeDiscussionOptionWhereUniqueInput
  }

  /**
   * ChallengeDiscussionOption findFirst
   */
  export type ChallengeDiscussionOptionFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ChallengeDiscussionOption
     */
    select?: ChallengeDiscussionOptionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ChallengeDiscussionOption
     */
    omit?: ChallengeDiscussionOptionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ChallengeDiscussionOptionInclude<ExtArgs> | null
    /**
     * Filter, which ChallengeDiscussionOption to fetch.
     */
    where?: ChallengeDiscussionOptionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ChallengeDiscussionOptions to fetch.
     */
    orderBy?: ChallengeDiscussionOptionOrderByWithRelationInput | ChallengeDiscussionOptionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ChallengeDiscussionOptions.
     */
    cursor?: ChallengeDiscussionOptionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ChallengeDiscussionOptions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ChallengeDiscussionOptions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ChallengeDiscussionOptions.
     */
    distinct?: ChallengeDiscussionOptionScalarFieldEnum | ChallengeDiscussionOptionScalarFieldEnum[]
  }

  /**
   * ChallengeDiscussionOption findFirstOrThrow
   */
  export type ChallengeDiscussionOptionFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ChallengeDiscussionOption
     */
    select?: ChallengeDiscussionOptionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ChallengeDiscussionOption
     */
    omit?: ChallengeDiscussionOptionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ChallengeDiscussionOptionInclude<ExtArgs> | null
    /**
     * Filter, which ChallengeDiscussionOption to fetch.
     */
    where?: ChallengeDiscussionOptionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ChallengeDiscussionOptions to fetch.
     */
    orderBy?: ChallengeDiscussionOptionOrderByWithRelationInput | ChallengeDiscussionOptionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ChallengeDiscussionOptions.
     */
    cursor?: ChallengeDiscussionOptionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ChallengeDiscussionOptions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ChallengeDiscussionOptions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ChallengeDiscussionOptions.
     */
    distinct?: ChallengeDiscussionOptionScalarFieldEnum | ChallengeDiscussionOptionScalarFieldEnum[]
  }

  /**
   * ChallengeDiscussionOption findMany
   */
  export type ChallengeDiscussionOptionFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ChallengeDiscussionOption
     */
    select?: ChallengeDiscussionOptionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ChallengeDiscussionOption
     */
    omit?: ChallengeDiscussionOptionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ChallengeDiscussionOptionInclude<ExtArgs> | null
    /**
     * Filter, which ChallengeDiscussionOptions to fetch.
     */
    where?: ChallengeDiscussionOptionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ChallengeDiscussionOptions to fetch.
     */
    orderBy?: ChallengeDiscussionOptionOrderByWithRelationInput | ChallengeDiscussionOptionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing ChallengeDiscussionOptions.
     */
    cursor?: ChallengeDiscussionOptionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ChallengeDiscussionOptions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ChallengeDiscussionOptions.
     */
    skip?: number
    distinct?: ChallengeDiscussionOptionScalarFieldEnum | ChallengeDiscussionOptionScalarFieldEnum[]
  }

  /**
   * ChallengeDiscussionOption create
   */
  export type ChallengeDiscussionOptionCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ChallengeDiscussionOption
     */
    select?: ChallengeDiscussionOptionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ChallengeDiscussionOption
     */
    omit?: ChallengeDiscussionOptionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ChallengeDiscussionOptionInclude<ExtArgs> | null
    /**
     * The data needed to create a ChallengeDiscussionOption.
     */
    data: XOR<ChallengeDiscussionOptionCreateInput, ChallengeDiscussionOptionUncheckedCreateInput>
  }

  /**
   * ChallengeDiscussionOption createMany
   */
  export type ChallengeDiscussionOptionCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many ChallengeDiscussionOptions.
     */
    data: ChallengeDiscussionOptionCreateManyInput | ChallengeDiscussionOptionCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * ChallengeDiscussionOption createManyAndReturn
   */
  export type ChallengeDiscussionOptionCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ChallengeDiscussionOption
     */
    select?: ChallengeDiscussionOptionSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the ChallengeDiscussionOption
     */
    omit?: ChallengeDiscussionOptionOmit<ExtArgs> | null
    /**
     * The data used to create many ChallengeDiscussionOptions.
     */
    data: ChallengeDiscussionOptionCreateManyInput | ChallengeDiscussionOptionCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ChallengeDiscussionOptionIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * ChallengeDiscussionOption update
   */
  export type ChallengeDiscussionOptionUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ChallengeDiscussionOption
     */
    select?: ChallengeDiscussionOptionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ChallengeDiscussionOption
     */
    omit?: ChallengeDiscussionOptionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ChallengeDiscussionOptionInclude<ExtArgs> | null
    /**
     * The data needed to update a ChallengeDiscussionOption.
     */
    data: XOR<ChallengeDiscussionOptionUpdateInput, ChallengeDiscussionOptionUncheckedUpdateInput>
    /**
     * Choose, which ChallengeDiscussionOption to update.
     */
    where: ChallengeDiscussionOptionWhereUniqueInput
  }

  /**
   * ChallengeDiscussionOption updateMany
   */
  export type ChallengeDiscussionOptionUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update ChallengeDiscussionOptions.
     */
    data: XOR<ChallengeDiscussionOptionUpdateManyMutationInput, ChallengeDiscussionOptionUncheckedUpdateManyInput>
    /**
     * Filter which ChallengeDiscussionOptions to update
     */
    where?: ChallengeDiscussionOptionWhereInput
    /**
     * Limit how many ChallengeDiscussionOptions to update.
     */
    limit?: number
  }

  /**
   * ChallengeDiscussionOption updateManyAndReturn
   */
  export type ChallengeDiscussionOptionUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ChallengeDiscussionOption
     */
    select?: ChallengeDiscussionOptionSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the ChallengeDiscussionOption
     */
    omit?: ChallengeDiscussionOptionOmit<ExtArgs> | null
    /**
     * The data used to update ChallengeDiscussionOptions.
     */
    data: XOR<ChallengeDiscussionOptionUpdateManyMutationInput, ChallengeDiscussionOptionUncheckedUpdateManyInput>
    /**
     * Filter which ChallengeDiscussionOptions to update
     */
    where?: ChallengeDiscussionOptionWhereInput
    /**
     * Limit how many ChallengeDiscussionOptions to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ChallengeDiscussionOptionIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * ChallengeDiscussionOption upsert
   */
  export type ChallengeDiscussionOptionUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ChallengeDiscussionOption
     */
    select?: ChallengeDiscussionOptionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ChallengeDiscussionOption
     */
    omit?: ChallengeDiscussionOptionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ChallengeDiscussionOptionInclude<ExtArgs> | null
    /**
     * The filter to search for the ChallengeDiscussionOption to update in case it exists.
     */
    where: ChallengeDiscussionOptionWhereUniqueInput
    /**
     * In case the ChallengeDiscussionOption found by the `where` argument doesn't exist, create a new ChallengeDiscussionOption with this data.
     */
    create: XOR<ChallengeDiscussionOptionCreateInput, ChallengeDiscussionOptionUncheckedCreateInput>
    /**
     * In case the ChallengeDiscussionOption was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ChallengeDiscussionOptionUpdateInput, ChallengeDiscussionOptionUncheckedUpdateInput>
  }

  /**
   * ChallengeDiscussionOption delete
   */
  export type ChallengeDiscussionOptionDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ChallengeDiscussionOption
     */
    select?: ChallengeDiscussionOptionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ChallengeDiscussionOption
     */
    omit?: ChallengeDiscussionOptionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ChallengeDiscussionOptionInclude<ExtArgs> | null
    /**
     * Filter which ChallengeDiscussionOption to delete.
     */
    where: ChallengeDiscussionOptionWhereUniqueInput
  }

  /**
   * ChallengeDiscussionOption deleteMany
   */
  export type ChallengeDiscussionOptionDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ChallengeDiscussionOptions to delete
     */
    where?: ChallengeDiscussionOptionWhereInput
    /**
     * Limit how many ChallengeDiscussionOptions to delete.
     */
    limit?: number
  }

  /**
   * ChallengeDiscussionOption without action
   */
  export type ChallengeDiscussionOptionDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ChallengeDiscussionOption
     */
    select?: ChallengeDiscussionOptionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ChallengeDiscussionOption
     */
    omit?: ChallengeDiscussionOptionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ChallengeDiscussionOptionInclude<ExtArgs> | null
  }


  /**
   * Model ChallengeConstraint
   */

  export type AggregateChallengeConstraint = {
    _count: ChallengeConstraintCountAggregateOutputType | null
    _min: ChallengeConstraintMinAggregateOutputType | null
    _max: ChallengeConstraintMaxAggregateOutputType | null
  }

  export type ChallengeConstraintMinAggregateOutputType = {
    id: string | null
    challengeId: string | null
    createdAt: Date | null
    createdBy: string | null
    updatedAt: Date | null
    updatedBy: string | null
  }

  export type ChallengeConstraintMaxAggregateOutputType = {
    id: string | null
    challengeId: string | null
    createdAt: Date | null
    createdBy: string | null
    updatedAt: Date | null
    updatedBy: string | null
  }

  export type ChallengeConstraintCountAggregateOutputType = {
    id: number
    challengeId: number
    allowedRegistrants: number
    createdAt: number
    createdBy: number
    updatedAt: number
    updatedBy: number
    _all: number
  }


  export type ChallengeConstraintMinAggregateInputType = {
    id?: true
    challengeId?: true
    createdAt?: true
    createdBy?: true
    updatedAt?: true
    updatedBy?: true
  }

  export type ChallengeConstraintMaxAggregateInputType = {
    id?: true
    challengeId?: true
    createdAt?: true
    createdBy?: true
    updatedAt?: true
    updatedBy?: true
  }

  export type ChallengeConstraintCountAggregateInputType = {
    id?: true
    challengeId?: true
    allowedRegistrants?: true
    createdAt?: true
    createdBy?: true
    updatedAt?: true
    updatedBy?: true
    _all?: true
  }

  export type ChallengeConstraintAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ChallengeConstraint to aggregate.
     */
    where?: ChallengeConstraintWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ChallengeConstraints to fetch.
     */
    orderBy?: ChallengeConstraintOrderByWithRelationInput | ChallengeConstraintOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ChallengeConstraintWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ChallengeConstraints from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ChallengeConstraints.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned ChallengeConstraints
    **/
    _count?: true | ChallengeConstraintCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ChallengeConstraintMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ChallengeConstraintMaxAggregateInputType
  }

  export type GetChallengeConstraintAggregateType<T extends ChallengeConstraintAggregateArgs> = {
        [P in keyof T & keyof AggregateChallengeConstraint]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateChallengeConstraint[P]>
      : GetScalarType<T[P], AggregateChallengeConstraint[P]>
  }




  export type ChallengeConstraintGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ChallengeConstraintWhereInput
    orderBy?: ChallengeConstraintOrderByWithAggregationInput | ChallengeConstraintOrderByWithAggregationInput[]
    by: ChallengeConstraintScalarFieldEnum[] | ChallengeConstraintScalarFieldEnum
    having?: ChallengeConstraintScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ChallengeConstraintCountAggregateInputType | true
    _min?: ChallengeConstraintMinAggregateInputType
    _max?: ChallengeConstraintMaxAggregateInputType
  }

  export type ChallengeConstraintGroupByOutputType = {
    id: string
    challengeId: string
    allowedRegistrants: string[]
    createdAt: Date
    createdBy: string
    updatedAt: Date
    updatedBy: string
    _count: ChallengeConstraintCountAggregateOutputType | null
    _min: ChallengeConstraintMinAggregateOutputType | null
    _max: ChallengeConstraintMaxAggregateOutputType | null
  }

  type GetChallengeConstraintGroupByPayload<T extends ChallengeConstraintGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ChallengeConstraintGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ChallengeConstraintGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ChallengeConstraintGroupByOutputType[P]>
            : GetScalarType<T[P], ChallengeConstraintGroupByOutputType[P]>
        }
      >
    >


  export type ChallengeConstraintSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    challengeId?: boolean
    allowedRegistrants?: boolean
    createdAt?: boolean
    createdBy?: boolean
    updatedAt?: boolean
    updatedBy?: boolean
    challenge?: boolean | ChallengeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["challengeConstraint"]>

  export type ChallengeConstraintSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    challengeId?: boolean
    allowedRegistrants?: boolean
    createdAt?: boolean
    createdBy?: boolean
    updatedAt?: boolean
    updatedBy?: boolean
    challenge?: boolean | ChallengeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["challengeConstraint"]>

  export type ChallengeConstraintSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    challengeId?: boolean
    allowedRegistrants?: boolean
    createdAt?: boolean
    createdBy?: boolean
    updatedAt?: boolean
    updatedBy?: boolean
    challenge?: boolean | ChallengeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["challengeConstraint"]>

  export type ChallengeConstraintSelectScalar = {
    id?: boolean
    challengeId?: boolean
    allowedRegistrants?: boolean
    createdAt?: boolean
    createdBy?: boolean
    updatedAt?: boolean
    updatedBy?: boolean
  }

  export type ChallengeConstraintOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "challengeId" | "allowedRegistrants" | "createdAt" | "createdBy" | "updatedAt" | "updatedBy", ExtArgs["result"]["challengeConstraint"]>
  export type ChallengeConstraintInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    challenge?: boolean | ChallengeDefaultArgs<ExtArgs>
  }
  export type ChallengeConstraintIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    challenge?: boolean | ChallengeDefaultArgs<ExtArgs>
  }
  export type ChallengeConstraintIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    challenge?: boolean | ChallengeDefaultArgs<ExtArgs>
  }

  export type $ChallengeConstraintPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "ChallengeConstraint"
    objects: {
      challenge: Prisma.$ChallengePayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      challengeId: string
      allowedRegistrants: string[]
      createdAt: Date
      createdBy: string
      updatedAt: Date
      updatedBy: string
    }, ExtArgs["result"]["challengeConstraint"]>
    composites: {}
  }

  type ChallengeConstraintGetPayload<S extends boolean | null | undefined | ChallengeConstraintDefaultArgs> = $Result.GetResult<Prisma.$ChallengeConstraintPayload, S>

  type ChallengeConstraintCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<ChallengeConstraintFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: ChallengeConstraintCountAggregateInputType | true
    }

  export interface ChallengeConstraintDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['ChallengeConstraint'], meta: { name: 'ChallengeConstraint' } }
    /**
     * Find zero or one ChallengeConstraint that matches the filter.
     * @param {ChallengeConstraintFindUniqueArgs} args - Arguments to find a ChallengeConstraint
     * @example
     * // Get one ChallengeConstraint
     * const challengeConstraint = await prisma.challengeConstraint.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends ChallengeConstraintFindUniqueArgs>(args: SelectSubset<T, ChallengeConstraintFindUniqueArgs<ExtArgs>>): Prisma__ChallengeConstraintClient<$Result.GetResult<Prisma.$ChallengeConstraintPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one ChallengeConstraint that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {ChallengeConstraintFindUniqueOrThrowArgs} args - Arguments to find a ChallengeConstraint
     * @example
     * // Get one ChallengeConstraint
     * const challengeConstraint = await prisma.challengeConstraint.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends ChallengeConstraintFindUniqueOrThrowArgs>(args: SelectSubset<T, ChallengeConstraintFindUniqueOrThrowArgs<ExtArgs>>): Prisma__ChallengeConstraintClient<$Result.GetResult<Prisma.$ChallengeConstraintPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first ChallengeConstraint that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ChallengeConstraintFindFirstArgs} args - Arguments to find a ChallengeConstraint
     * @example
     * // Get one ChallengeConstraint
     * const challengeConstraint = await prisma.challengeConstraint.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends ChallengeConstraintFindFirstArgs>(args?: SelectSubset<T, ChallengeConstraintFindFirstArgs<ExtArgs>>): Prisma__ChallengeConstraintClient<$Result.GetResult<Prisma.$ChallengeConstraintPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first ChallengeConstraint that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ChallengeConstraintFindFirstOrThrowArgs} args - Arguments to find a ChallengeConstraint
     * @example
     * // Get one ChallengeConstraint
     * const challengeConstraint = await prisma.challengeConstraint.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends ChallengeConstraintFindFirstOrThrowArgs>(args?: SelectSubset<T, ChallengeConstraintFindFirstOrThrowArgs<ExtArgs>>): Prisma__ChallengeConstraintClient<$Result.GetResult<Prisma.$ChallengeConstraintPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more ChallengeConstraints that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ChallengeConstraintFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all ChallengeConstraints
     * const challengeConstraints = await prisma.challengeConstraint.findMany()
     * 
     * // Get first 10 ChallengeConstraints
     * const challengeConstraints = await prisma.challengeConstraint.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const challengeConstraintWithIdOnly = await prisma.challengeConstraint.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends ChallengeConstraintFindManyArgs>(args?: SelectSubset<T, ChallengeConstraintFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ChallengeConstraintPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a ChallengeConstraint.
     * @param {ChallengeConstraintCreateArgs} args - Arguments to create a ChallengeConstraint.
     * @example
     * // Create one ChallengeConstraint
     * const ChallengeConstraint = await prisma.challengeConstraint.create({
     *   data: {
     *     // ... data to create a ChallengeConstraint
     *   }
     * })
     * 
     */
    create<T extends ChallengeConstraintCreateArgs>(args: SelectSubset<T, ChallengeConstraintCreateArgs<ExtArgs>>): Prisma__ChallengeConstraintClient<$Result.GetResult<Prisma.$ChallengeConstraintPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many ChallengeConstraints.
     * @param {ChallengeConstraintCreateManyArgs} args - Arguments to create many ChallengeConstraints.
     * @example
     * // Create many ChallengeConstraints
     * const challengeConstraint = await prisma.challengeConstraint.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends ChallengeConstraintCreateManyArgs>(args?: SelectSubset<T, ChallengeConstraintCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many ChallengeConstraints and returns the data saved in the database.
     * @param {ChallengeConstraintCreateManyAndReturnArgs} args - Arguments to create many ChallengeConstraints.
     * @example
     * // Create many ChallengeConstraints
     * const challengeConstraint = await prisma.challengeConstraint.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many ChallengeConstraints and only return the `id`
     * const challengeConstraintWithIdOnly = await prisma.challengeConstraint.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends ChallengeConstraintCreateManyAndReturnArgs>(args?: SelectSubset<T, ChallengeConstraintCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ChallengeConstraintPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a ChallengeConstraint.
     * @param {ChallengeConstraintDeleteArgs} args - Arguments to delete one ChallengeConstraint.
     * @example
     * // Delete one ChallengeConstraint
     * const ChallengeConstraint = await prisma.challengeConstraint.delete({
     *   where: {
     *     // ... filter to delete one ChallengeConstraint
     *   }
     * })
     * 
     */
    delete<T extends ChallengeConstraintDeleteArgs>(args: SelectSubset<T, ChallengeConstraintDeleteArgs<ExtArgs>>): Prisma__ChallengeConstraintClient<$Result.GetResult<Prisma.$ChallengeConstraintPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one ChallengeConstraint.
     * @param {ChallengeConstraintUpdateArgs} args - Arguments to update one ChallengeConstraint.
     * @example
     * // Update one ChallengeConstraint
     * const challengeConstraint = await prisma.challengeConstraint.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends ChallengeConstraintUpdateArgs>(args: SelectSubset<T, ChallengeConstraintUpdateArgs<ExtArgs>>): Prisma__ChallengeConstraintClient<$Result.GetResult<Prisma.$ChallengeConstraintPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more ChallengeConstraints.
     * @param {ChallengeConstraintDeleteManyArgs} args - Arguments to filter ChallengeConstraints to delete.
     * @example
     * // Delete a few ChallengeConstraints
     * const { count } = await prisma.challengeConstraint.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends ChallengeConstraintDeleteManyArgs>(args?: SelectSubset<T, ChallengeConstraintDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more ChallengeConstraints.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ChallengeConstraintUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many ChallengeConstraints
     * const challengeConstraint = await prisma.challengeConstraint.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends ChallengeConstraintUpdateManyArgs>(args: SelectSubset<T, ChallengeConstraintUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more ChallengeConstraints and returns the data updated in the database.
     * @param {ChallengeConstraintUpdateManyAndReturnArgs} args - Arguments to update many ChallengeConstraints.
     * @example
     * // Update many ChallengeConstraints
     * const challengeConstraint = await prisma.challengeConstraint.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more ChallengeConstraints and only return the `id`
     * const challengeConstraintWithIdOnly = await prisma.challengeConstraint.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends ChallengeConstraintUpdateManyAndReturnArgs>(args: SelectSubset<T, ChallengeConstraintUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ChallengeConstraintPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one ChallengeConstraint.
     * @param {ChallengeConstraintUpsertArgs} args - Arguments to update or create a ChallengeConstraint.
     * @example
     * // Update or create a ChallengeConstraint
     * const challengeConstraint = await prisma.challengeConstraint.upsert({
     *   create: {
     *     // ... data to create a ChallengeConstraint
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the ChallengeConstraint we want to update
     *   }
     * })
     */
    upsert<T extends ChallengeConstraintUpsertArgs>(args: SelectSubset<T, ChallengeConstraintUpsertArgs<ExtArgs>>): Prisma__ChallengeConstraintClient<$Result.GetResult<Prisma.$ChallengeConstraintPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of ChallengeConstraints.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ChallengeConstraintCountArgs} args - Arguments to filter ChallengeConstraints to count.
     * @example
     * // Count the number of ChallengeConstraints
     * const count = await prisma.challengeConstraint.count({
     *   where: {
     *     // ... the filter for the ChallengeConstraints we want to count
     *   }
     * })
    **/
    count<T extends ChallengeConstraintCountArgs>(
      args?: Subset<T, ChallengeConstraintCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ChallengeConstraintCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a ChallengeConstraint.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ChallengeConstraintAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ChallengeConstraintAggregateArgs>(args: Subset<T, ChallengeConstraintAggregateArgs>): Prisma.PrismaPromise<GetChallengeConstraintAggregateType<T>>

    /**
     * Group by ChallengeConstraint.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ChallengeConstraintGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ChallengeConstraintGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ChallengeConstraintGroupByArgs['orderBy'] }
        : { orderBy?: ChallengeConstraintGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ChallengeConstraintGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetChallengeConstraintGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the ChallengeConstraint model
   */
  readonly fields: ChallengeConstraintFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for ChallengeConstraint.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ChallengeConstraintClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    challenge<T extends ChallengeDefaultArgs<ExtArgs> = {}>(args?: Subset<T, ChallengeDefaultArgs<ExtArgs>>): Prisma__ChallengeClient<$Result.GetResult<Prisma.$ChallengePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the ChallengeConstraint model
   */
  interface ChallengeConstraintFieldRefs {
    readonly id: FieldRef<"ChallengeConstraint", 'String'>
    readonly challengeId: FieldRef<"ChallengeConstraint", 'String'>
    readonly allowedRegistrants: FieldRef<"ChallengeConstraint", 'String[]'>
    readonly createdAt: FieldRef<"ChallengeConstraint", 'DateTime'>
    readonly createdBy: FieldRef<"ChallengeConstraint", 'String'>
    readonly updatedAt: FieldRef<"ChallengeConstraint", 'DateTime'>
    readonly updatedBy: FieldRef<"ChallengeConstraint", 'String'>
  }
    

  // Custom InputTypes
  /**
   * ChallengeConstraint findUnique
   */
  export type ChallengeConstraintFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ChallengeConstraint
     */
    select?: ChallengeConstraintSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ChallengeConstraint
     */
    omit?: ChallengeConstraintOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ChallengeConstraintInclude<ExtArgs> | null
    /**
     * Filter, which ChallengeConstraint to fetch.
     */
    where: ChallengeConstraintWhereUniqueInput
  }

  /**
   * ChallengeConstraint findUniqueOrThrow
   */
  export type ChallengeConstraintFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ChallengeConstraint
     */
    select?: ChallengeConstraintSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ChallengeConstraint
     */
    omit?: ChallengeConstraintOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ChallengeConstraintInclude<ExtArgs> | null
    /**
     * Filter, which ChallengeConstraint to fetch.
     */
    where: ChallengeConstraintWhereUniqueInput
  }

  /**
   * ChallengeConstraint findFirst
   */
  export type ChallengeConstraintFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ChallengeConstraint
     */
    select?: ChallengeConstraintSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ChallengeConstraint
     */
    omit?: ChallengeConstraintOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ChallengeConstraintInclude<ExtArgs> | null
    /**
     * Filter, which ChallengeConstraint to fetch.
     */
    where?: ChallengeConstraintWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ChallengeConstraints to fetch.
     */
    orderBy?: ChallengeConstraintOrderByWithRelationInput | ChallengeConstraintOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ChallengeConstraints.
     */
    cursor?: ChallengeConstraintWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ChallengeConstraints from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ChallengeConstraints.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ChallengeConstraints.
     */
    distinct?: ChallengeConstraintScalarFieldEnum | ChallengeConstraintScalarFieldEnum[]
  }

  /**
   * ChallengeConstraint findFirstOrThrow
   */
  export type ChallengeConstraintFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ChallengeConstraint
     */
    select?: ChallengeConstraintSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ChallengeConstraint
     */
    omit?: ChallengeConstraintOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ChallengeConstraintInclude<ExtArgs> | null
    /**
     * Filter, which ChallengeConstraint to fetch.
     */
    where?: ChallengeConstraintWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ChallengeConstraints to fetch.
     */
    orderBy?: ChallengeConstraintOrderByWithRelationInput | ChallengeConstraintOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ChallengeConstraints.
     */
    cursor?: ChallengeConstraintWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ChallengeConstraints from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ChallengeConstraints.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ChallengeConstraints.
     */
    distinct?: ChallengeConstraintScalarFieldEnum | ChallengeConstraintScalarFieldEnum[]
  }

  /**
   * ChallengeConstraint findMany
   */
  export type ChallengeConstraintFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ChallengeConstraint
     */
    select?: ChallengeConstraintSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ChallengeConstraint
     */
    omit?: ChallengeConstraintOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ChallengeConstraintInclude<ExtArgs> | null
    /**
     * Filter, which ChallengeConstraints to fetch.
     */
    where?: ChallengeConstraintWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ChallengeConstraints to fetch.
     */
    orderBy?: ChallengeConstraintOrderByWithRelationInput | ChallengeConstraintOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing ChallengeConstraints.
     */
    cursor?: ChallengeConstraintWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ChallengeConstraints from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ChallengeConstraints.
     */
    skip?: number
    distinct?: ChallengeConstraintScalarFieldEnum | ChallengeConstraintScalarFieldEnum[]
  }

  /**
   * ChallengeConstraint create
   */
  export type ChallengeConstraintCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ChallengeConstraint
     */
    select?: ChallengeConstraintSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ChallengeConstraint
     */
    omit?: ChallengeConstraintOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ChallengeConstraintInclude<ExtArgs> | null
    /**
     * The data needed to create a ChallengeConstraint.
     */
    data: XOR<ChallengeConstraintCreateInput, ChallengeConstraintUncheckedCreateInput>
  }

  /**
   * ChallengeConstraint createMany
   */
  export type ChallengeConstraintCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many ChallengeConstraints.
     */
    data: ChallengeConstraintCreateManyInput | ChallengeConstraintCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * ChallengeConstraint createManyAndReturn
   */
  export type ChallengeConstraintCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ChallengeConstraint
     */
    select?: ChallengeConstraintSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the ChallengeConstraint
     */
    omit?: ChallengeConstraintOmit<ExtArgs> | null
    /**
     * The data used to create many ChallengeConstraints.
     */
    data: ChallengeConstraintCreateManyInput | ChallengeConstraintCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ChallengeConstraintIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * ChallengeConstraint update
   */
  export type ChallengeConstraintUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ChallengeConstraint
     */
    select?: ChallengeConstraintSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ChallengeConstraint
     */
    omit?: ChallengeConstraintOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ChallengeConstraintInclude<ExtArgs> | null
    /**
     * The data needed to update a ChallengeConstraint.
     */
    data: XOR<ChallengeConstraintUpdateInput, ChallengeConstraintUncheckedUpdateInput>
    /**
     * Choose, which ChallengeConstraint to update.
     */
    where: ChallengeConstraintWhereUniqueInput
  }

  /**
   * ChallengeConstraint updateMany
   */
  export type ChallengeConstraintUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update ChallengeConstraints.
     */
    data: XOR<ChallengeConstraintUpdateManyMutationInput, ChallengeConstraintUncheckedUpdateManyInput>
    /**
     * Filter which ChallengeConstraints to update
     */
    where?: ChallengeConstraintWhereInput
    /**
     * Limit how many ChallengeConstraints to update.
     */
    limit?: number
  }

  /**
   * ChallengeConstraint updateManyAndReturn
   */
  export type ChallengeConstraintUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ChallengeConstraint
     */
    select?: ChallengeConstraintSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the ChallengeConstraint
     */
    omit?: ChallengeConstraintOmit<ExtArgs> | null
    /**
     * The data used to update ChallengeConstraints.
     */
    data: XOR<ChallengeConstraintUpdateManyMutationInput, ChallengeConstraintUncheckedUpdateManyInput>
    /**
     * Filter which ChallengeConstraints to update
     */
    where?: ChallengeConstraintWhereInput
    /**
     * Limit how many ChallengeConstraints to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ChallengeConstraintIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * ChallengeConstraint upsert
   */
  export type ChallengeConstraintUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ChallengeConstraint
     */
    select?: ChallengeConstraintSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ChallengeConstraint
     */
    omit?: ChallengeConstraintOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ChallengeConstraintInclude<ExtArgs> | null
    /**
     * The filter to search for the ChallengeConstraint to update in case it exists.
     */
    where: ChallengeConstraintWhereUniqueInput
    /**
     * In case the ChallengeConstraint found by the `where` argument doesn't exist, create a new ChallengeConstraint with this data.
     */
    create: XOR<ChallengeConstraintCreateInput, ChallengeConstraintUncheckedCreateInput>
    /**
     * In case the ChallengeConstraint was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ChallengeConstraintUpdateInput, ChallengeConstraintUncheckedUpdateInput>
  }

  /**
   * ChallengeConstraint delete
   */
  export type ChallengeConstraintDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ChallengeConstraint
     */
    select?: ChallengeConstraintSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ChallengeConstraint
     */
    omit?: ChallengeConstraintOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ChallengeConstraintInclude<ExtArgs> | null
    /**
     * Filter which ChallengeConstraint to delete.
     */
    where: ChallengeConstraintWhereUniqueInput
  }

  /**
   * ChallengeConstraint deleteMany
   */
  export type ChallengeConstraintDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ChallengeConstraints to delete
     */
    where?: ChallengeConstraintWhereInput
    /**
     * Limit how many ChallengeConstraints to delete.
     */
    limit?: number
  }

  /**
   * ChallengeConstraint without action
   */
  export type ChallengeConstraintDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ChallengeConstraint
     */
    select?: ChallengeConstraintSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ChallengeConstraint
     */
    omit?: ChallengeConstraintOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ChallengeConstraintInclude<ExtArgs> | null
  }


  /**
   * Model Phase
   */

  export type AggregatePhase = {
    _count: PhaseCountAggregateOutputType | null
    _avg: PhaseAvgAggregateOutputType | null
    _sum: PhaseSumAggregateOutputType | null
    _min: PhaseMinAggregateOutputType | null
    _max: PhaseMaxAggregateOutputType | null
  }

  export type PhaseAvgAggregateOutputType = {
    duration: number | null
  }

  export type PhaseSumAggregateOutputType = {
    duration: number | null
  }

  export type PhaseMinAggregateOutputType = {
    id: string | null
    name: string | null
    description: string | null
    isOpen: boolean | null
    duration: number | null
    createdAt: Date | null
    createdBy: string | null
    updatedAt: Date | null
    updatedBy: string | null
  }

  export type PhaseMaxAggregateOutputType = {
    id: string | null
    name: string | null
    description: string | null
    isOpen: boolean | null
    duration: number | null
    createdAt: Date | null
    createdBy: string | null
    updatedAt: Date | null
    updatedBy: string | null
  }

  export type PhaseCountAggregateOutputType = {
    id: number
    name: number
    description: number
    isOpen: number
    duration: number
    createdAt: number
    createdBy: number
    updatedAt: number
    updatedBy: number
    _all: number
  }


  export type PhaseAvgAggregateInputType = {
    duration?: true
  }

  export type PhaseSumAggregateInputType = {
    duration?: true
  }

  export type PhaseMinAggregateInputType = {
    id?: true
    name?: true
    description?: true
    isOpen?: true
    duration?: true
    createdAt?: true
    createdBy?: true
    updatedAt?: true
    updatedBy?: true
  }

  export type PhaseMaxAggregateInputType = {
    id?: true
    name?: true
    description?: true
    isOpen?: true
    duration?: true
    createdAt?: true
    createdBy?: true
    updatedAt?: true
    updatedBy?: true
  }

  export type PhaseCountAggregateInputType = {
    id?: true
    name?: true
    description?: true
    isOpen?: true
    duration?: true
    createdAt?: true
    createdBy?: true
    updatedAt?: true
    updatedBy?: true
    _all?: true
  }

  export type PhaseAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Phase to aggregate.
     */
    where?: PhaseWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Phases to fetch.
     */
    orderBy?: PhaseOrderByWithRelationInput | PhaseOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: PhaseWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Phases from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Phases.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Phases
    **/
    _count?: true | PhaseCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: PhaseAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: PhaseSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: PhaseMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: PhaseMaxAggregateInputType
  }

  export type GetPhaseAggregateType<T extends PhaseAggregateArgs> = {
        [P in keyof T & keyof AggregatePhase]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregatePhase[P]>
      : GetScalarType<T[P], AggregatePhase[P]>
  }




  export type PhaseGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PhaseWhereInput
    orderBy?: PhaseOrderByWithAggregationInput | PhaseOrderByWithAggregationInput[]
    by: PhaseScalarFieldEnum[] | PhaseScalarFieldEnum
    having?: PhaseScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: PhaseCountAggregateInputType | true
    _avg?: PhaseAvgAggregateInputType
    _sum?: PhaseSumAggregateInputType
    _min?: PhaseMinAggregateInputType
    _max?: PhaseMaxAggregateInputType
  }

  export type PhaseGroupByOutputType = {
    id: string
    name: string
    description: string | null
    isOpen: boolean
    duration: number
    createdAt: Date
    createdBy: string
    updatedAt: Date
    updatedBy: string
    _count: PhaseCountAggregateOutputType | null
    _avg: PhaseAvgAggregateOutputType | null
    _sum: PhaseSumAggregateOutputType | null
    _min: PhaseMinAggregateOutputType | null
    _max: PhaseMaxAggregateOutputType | null
  }

  type GetPhaseGroupByPayload<T extends PhaseGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<PhaseGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof PhaseGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], PhaseGroupByOutputType[P]>
            : GetScalarType<T[P], PhaseGroupByOutputType[P]>
        }
      >
    >


  export type PhaseSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    description?: boolean
    isOpen?: boolean
    duration?: boolean
    createdAt?: boolean
    createdBy?: boolean
    updatedAt?: boolean
    updatedBy?: boolean
    challengePhases?: boolean | Phase$challengePhasesArgs<ExtArgs>
    ChallengeReviewer?: boolean | Phase$ChallengeReviewerArgs<ExtArgs>
    DefaultChallengeReviewer?: boolean | Phase$DefaultChallengeReviewerArgs<ExtArgs>
    _count?: boolean | PhaseCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["phase"]>

  export type PhaseSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    description?: boolean
    isOpen?: boolean
    duration?: boolean
    createdAt?: boolean
    createdBy?: boolean
    updatedAt?: boolean
    updatedBy?: boolean
  }, ExtArgs["result"]["phase"]>

  export type PhaseSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    description?: boolean
    isOpen?: boolean
    duration?: boolean
    createdAt?: boolean
    createdBy?: boolean
    updatedAt?: boolean
    updatedBy?: boolean
  }, ExtArgs["result"]["phase"]>

  export type PhaseSelectScalar = {
    id?: boolean
    name?: boolean
    description?: boolean
    isOpen?: boolean
    duration?: boolean
    createdAt?: boolean
    createdBy?: boolean
    updatedAt?: boolean
    updatedBy?: boolean
  }

  export type PhaseOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "name" | "description" | "isOpen" | "duration" | "createdAt" | "createdBy" | "updatedAt" | "updatedBy", ExtArgs["result"]["phase"]>
  export type PhaseInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    challengePhases?: boolean | Phase$challengePhasesArgs<ExtArgs>
    ChallengeReviewer?: boolean | Phase$ChallengeReviewerArgs<ExtArgs>
    DefaultChallengeReviewer?: boolean | Phase$DefaultChallengeReviewerArgs<ExtArgs>
    _count?: boolean | PhaseCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type PhaseIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}
  export type PhaseIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}

  export type $PhasePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Phase"
    objects: {
      challengePhases: Prisma.$ChallengePhasePayload<ExtArgs>[]
      ChallengeReviewer: Prisma.$ChallengeReviewerPayload<ExtArgs>[]
      DefaultChallengeReviewer: Prisma.$DefaultChallengeReviewerPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      name: string
      description: string | null
      isOpen: boolean
      duration: number
      createdAt: Date
      createdBy: string
      updatedAt: Date
      updatedBy: string
    }, ExtArgs["result"]["phase"]>
    composites: {}
  }

  type PhaseGetPayload<S extends boolean | null | undefined | PhaseDefaultArgs> = $Result.GetResult<Prisma.$PhasePayload, S>

  type PhaseCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<PhaseFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: PhaseCountAggregateInputType | true
    }

  export interface PhaseDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Phase'], meta: { name: 'Phase' } }
    /**
     * Find zero or one Phase that matches the filter.
     * @param {PhaseFindUniqueArgs} args - Arguments to find a Phase
     * @example
     * // Get one Phase
     * const phase = await prisma.phase.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends PhaseFindUniqueArgs>(args: SelectSubset<T, PhaseFindUniqueArgs<ExtArgs>>): Prisma__PhaseClient<$Result.GetResult<Prisma.$PhasePayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Phase that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {PhaseFindUniqueOrThrowArgs} args - Arguments to find a Phase
     * @example
     * // Get one Phase
     * const phase = await prisma.phase.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends PhaseFindUniqueOrThrowArgs>(args: SelectSubset<T, PhaseFindUniqueOrThrowArgs<ExtArgs>>): Prisma__PhaseClient<$Result.GetResult<Prisma.$PhasePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Phase that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PhaseFindFirstArgs} args - Arguments to find a Phase
     * @example
     * // Get one Phase
     * const phase = await prisma.phase.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends PhaseFindFirstArgs>(args?: SelectSubset<T, PhaseFindFirstArgs<ExtArgs>>): Prisma__PhaseClient<$Result.GetResult<Prisma.$PhasePayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Phase that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PhaseFindFirstOrThrowArgs} args - Arguments to find a Phase
     * @example
     * // Get one Phase
     * const phase = await prisma.phase.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends PhaseFindFirstOrThrowArgs>(args?: SelectSubset<T, PhaseFindFirstOrThrowArgs<ExtArgs>>): Prisma__PhaseClient<$Result.GetResult<Prisma.$PhasePayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Phases that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PhaseFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Phases
     * const phases = await prisma.phase.findMany()
     * 
     * // Get first 10 Phases
     * const phases = await prisma.phase.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const phaseWithIdOnly = await prisma.phase.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends PhaseFindManyArgs>(args?: SelectSubset<T, PhaseFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PhasePayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Phase.
     * @param {PhaseCreateArgs} args - Arguments to create a Phase.
     * @example
     * // Create one Phase
     * const Phase = await prisma.phase.create({
     *   data: {
     *     // ... data to create a Phase
     *   }
     * })
     * 
     */
    create<T extends PhaseCreateArgs>(args: SelectSubset<T, PhaseCreateArgs<ExtArgs>>): Prisma__PhaseClient<$Result.GetResult<Prisma.$PhasePayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Phases.
     * @param {PhaseCreateManyArgs} args - Arguments to create many Phases.
     * @example
     * // Create many Phases
     * const phase = await prisma.phase.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends PhaseCreateManyArgs>(args?: SelectSubset<T, PhaseCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Phases and returns the data saved in the database.
     * @param {PhaseCreateManyAndReturnArgs} args - Arguments to create many Phases.
     * @example
     * // Create many Phases
     * const phase = await prisma.phase.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Phases and only return the `id`
     * const phaseWithIdOnly = await prisma.phase.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends PhaseCreateManyAndReturnArgs>(args?: SelectSubset<T, PhaseCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PhasePayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Phase.
     * @param {PhaseDeleteArgs} args - Arguments to delete one Phase.
     * @example
     * // Delete one Phase
     * const Phase = await prisma.phase.delete({
     *   where: {
     *     // ... filter to delete one Phase
     *   }
     * })
     * 
     */
    delete<T extends PhaseDeleteArgs>(args: SelectSubset<T, PhaseDeleteArgs<ExtArgs>>): Prisma__PhaseClient<$Result.GetResult<Prisma.$PhasePayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Phase.
     * @param {PhaseUpdateArgs} args - Arguments to update one Phase.
     * @example
     * // Update one Phase
     * const phase = await prisma.phase.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends PhaseUpdateArgs>(args: SelectSubset<T, PhaseUpdateArgs<ExtArgs>>): Prisma__PhaseClient<$Result.GetResult<Prisma.$PhasePayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Phases.
     * @param {PhaseDeleteManyArgs} args - Arguments to filter Phases to delete.
     * @example
     * // Delete a few Phases
     * const { count } = await prisma.phase.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends PhaseDeleteManyArgs>(args?: SelectSubset<T, PhaseDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Phases.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PhaseUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Phases
     * const phase = await prisma.phase.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends PhaseUpdateManyArgs>(args: SelectSubset<T, PhaseUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Phases and returns the data updated in the database.
     * @param {PhaseUpdateManyAndReturnArgs} args - Arguments to update many Phases.
     * @example
     * // Update many Phases
     * const phase = await prisma.phase.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Phases and only return the `id`
     * const phaseWithIdOnly = await prisma.phase.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends PhaseUpdateManyAndReturnArgs>(args: SelectSubset<T, PhaseUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PhasePayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Phase.
     * @param {PhaseUpsertArgs} args - Arguments to update or create a Phase.
     * @example
     * // Update or create a Phase
     * const phase = await prisma.phase.upsert({
     *   create: {
     *     // ... data to create a Phase
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Phase we want to update
     *   }
     * })
     */
    upsert<T extends PhaseUpsertArgs>(args: SelectSubset<T, PhaseUpsertArgs<ExtArgs>>): Prisma__PhaseClient<$Result.GetResult<Prisma.$PhasePayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Phases.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PhaseCountArgs} args - Arguments to filter Phases to count.
     * @example
     * // Count the number of Phases
     * const count = await prisma.phase.count({
     *   where: {
     *     // ... the filter for the Phases we want to count
     *   }
     * })
    **/
    count<T extends PhaseCountArgs>(
      args?: Subset<T, PhaseCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], PhaseCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Phase.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PhaseAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends PhaseAggregateArgs>(args: Subset<T, PhaseAggregateArgs>): Prisma.PrismaPromise<GetPhaseAggregateType<T>>

    /**
     * Group by Phase.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PhaseGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends PhaseGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: PhaseGroupByArgs['orderBy'] }
        : { orderBy?: PhaseGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, PhaseGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetPhaseGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Phase model
   */
  readonly fields: PhaseFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Phase.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__PhaseClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    challengePhases<T extends Phase$challengePhasesArgs<ExtArgs> = {}>(args?: Subset<T, Phase$challengePhasesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ChallengePhasePayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    ChallengeReviewer<T extends Phase$ChallengeReviewerArgs<ExtArgs> = {}>(args?: Subset<T, Phase$ChallengeReviewerArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ChallengeReviewerPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    DefaultChallengeReviewer<T extends Phase$DefaultChallengeReviewerArgs<ExtArgs> = {}>(args?: Subset<T, Phase$DefaultChallengeReviewerArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$DefaultChallengeReviewerPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Phase model
   */
  interface PhaseFieldRefs {
    readonly id: FieldRef<"Phase", 'String'>
    readonly name: FieldRef<"Phase", 'String'>
    readonly description: FieldRef<"Phase", 'String'>
    readonly isOpen: FieldRef<"Phase", 'Boolean'>
    readonly duration: FieldRef<"Phase", 'Int'>
    readonly createdAt: FieldRef<"Phase", 'DateTime'>
    readonly createdBy: FieldRef<"Phase", 'String'>
    readonly updatedAt: FieldRef<"Phase", 'DateTime'>
    readonly updatedBy: FieldRef<"Phase", 'String'>
  }
    

  // Custom InputTypes
  /**
   * Phase findUnique
   */
  export type PhaseFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Phase
     */
    select?: PhaseSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Phase
     */
    omit?: PhaseOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PhaseInclude<ExtArgs> | null
    /**
     * Filter, which Phase to fetch.
     */
    where: PhaseWhereUniqueInput
  }

  /**
   * Phase findUniqueOrThrow
   */
  export type PhaseFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Phase
     */
    select?: PhaseSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Phase
     */
    omit?: PhaseOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PhaseInclude<ExtArgs> | null
    /**
     * Filter, which Phase to fetch.
     */
    where: PhaseWhereUniqueInput
  }

  /**
   * Phase findFirst
   */
  export type PhaseFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Phase
     */
    select?: PhaseSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Phase
     */
    omit?: PhaseOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PhaseInclude<ExtArgs> | null
    /**
     * Filter, which Phase to fetch.
     */
    where?: PhaseWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Phases to fetch.
     */
    orderBy?: PhaseOrderByWithRelationInput | PhaseOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Phases.
     */
    cursor?: PhaseWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Phases from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Phases.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Phases.
     */
    distinct?: PhaseScalarFieldEnum | PhaseScalarFieldEnum[]
  }

  /**
   * Phase findFirstOrThrow
   */
  export type PhaseFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Phase
     */
    select?: PhaseSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Phase
     */
    omit?: PhaseOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PhaseInclude<ExtArgs> | null
    /**
     * Filter, which Phase to fetch.
     */
    where?: PhaseWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Phases to fetch.
     */
    orderBy?: PhaseOrderByWithRelationInput | PhaseOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Phases.
     */
    cursor?: PhaseWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Phases from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Phases.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Phases.
     */
    distinct?: PhaseScalarFieldEnum | PhaseScalarFieldEnum[]
  }

  /**
   * Phase findMany
   */
  export type PhaseFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Phase
     */
    select?: PhaseSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Phase
     */
    omit?: PhaseOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PhaseInclude<ExtArgs> | null
    /**
     * Filter, which Phases to fetch.
     */
    where?: PhaseWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Phases to fetch.
     */
    orderBy?: PhaseOrderByWithRelationInput | PhaseOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Phases.
     */
    cursor?: PhaseWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Phases from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Phases.
     */
    skip?: number
    distinct?: PhaseScalarFieldEnum | PhaseScalarFieldEnum[]
  }

  /**
   * Phase create
   */
  export type PhaseCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Phase
     */
    select?: PhaseSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Phase
     */
    omit?: PhaseOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PhaseInclude<ExtArgs> | null
    /**
     * The data needed to create a Phase.
     */
    data: XOR<PhaseCreateInput, PhaseUncheckedCreateInput>
  }

  /**
   * Phase createMany
   */
  export type PhaseCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Phases.
     */
    data: PhaseCreateManyInput | PhaseCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Phase createManyAndReturn
   */
  export type PhaseCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Phase
     */
    select?: PhaseSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Phase
     */
    omit?: PhaseOmit<ExtArgs> | null
    /**
     * The data used to create many Phases.
     */
    data: PhaseCreateManyInput | PhaseCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Phase update
   */
  export type PhaseUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Phase
     */
    select?: PhaseSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Phase
     */
    omit?: PhaseOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PhaseInclude<ExtArgs> | null
    /**
     * The data needed to update a Phase.
     */
    data: XOR<PhaseUpdateInput, PhaseUncheckedUpdateInput>
    /**
     * Choose, which Phase to update.
     */
    where: PhaseWhereUniqueInput
  }

  /**
   * Phase updateMany
   */
  export type PhaseUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Phases.
     */
    data: XOR<PhaseUpdateManyMutationInput, PhaseUncheckedUpdateManyInput>
    /**
     * Filter which Phases to update
     */
    where?: PhaseWhereInput
    /**
     * Limit how many Phases to update.
     */
    limit?: number
  }

  /**
   * Phase updateManyAndReturn
   */
  export type PhaseUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Phase
     */
    select?: PhaseSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Phase
     */
    omit?: PhaseOmit<ExtArgs> | null
    /**
     * The data used to update Phases.
     */
    data: XOR<PhaseUpdateManyMutationInput, PhaseUncheckedUpdateManyInput>
    /**
     * Filter which Phases to update
     */
    where?: PhaseWhereInput
    /**
     * Limit how many Phases to update.
     */
    limit?: number
  }

  /**
   * Phase upsert
   */
  export type PhaseUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Phase
     */
    select?: PhaseSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Phase
     */
    omit?: PhaseOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PhaseInclude<ExtArgs> | null
    /**
     * The filter to search for the Phase to update in case it exists.
     */
    where: PhaseWhereUniqueInput
    /**
     * In case the Phase found by the `where` argument doesn't exist, create a new Phase with this data.
     */
    create: XOR<PhaseCreateInput, PhaseUncheckedCreateInput>
    /**
     * In case the Phase was found with the provided `where` argument, update it with this data.
     */
    update: XOR<PhaseUpdateInput, PhaseUncheckedUpdateInput>
  }

  /**
   * Phase delete
   */
  export type PhaseDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Phase
     */
    select?: PhaseSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Phase
     */
    omit?: PhaseOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PhaseInclude<ExtArgs> | null
    /**
     * Filter which Phase to delete.
     */
    where: PhaseWhereUniqueInput
  }

  /**
   * Phase deleteMany
   */
  export type PhaseDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Phases to delete
     */
    where?: PhaseWhereInput
    /**
     * Limit how many Phases to delete.
     */
    limit?: number
  }

  /**
   * Phase.challengePhases
   */
  export type Phase$challengePhasesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ChallengePhase
     */
    select?: ChallengePhaseSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ChallengePhase
     */
    omit?: ChallengePhaseOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ChallengePhaseInclude<ExtArgs> | null
    where?: ChallengePhaseWhereInput
    orderBy?: ChallengePhaseOrderByWithRelationInput | ChallengePhaseOrderByWithRelationInput[]
    cursor?: ChallengePhaseWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ChallengePhaseScalarFieldEnum | ChallengePhaseScalarFieldEnum[]
  }

  /**
   * Phase.ChallengeReviewer
   */
  export type Phase$ChallengeReviewerArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ChallengeReviewer
     */
    select?: ChallengeReviewerSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ChallengeReviewer
     */
    omit?: ChallengeReviewerOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ChallengeReviewerInclude<ExtArgs> | null
    where?: ChallengeReviewerWhereInput
    orderBy?: ChallengeReviewerOrderByWithRelationInput | ChallengeReviewerOrderByWithRelationInput[]
    cursor?: ChallengeReviewerWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ChallengeReviewerScalarFieldEnum | ChallengeReviewerScalarFieldEnum[]
  }

  /**
   * Phase.DefaultChallengeReviewer
   */
  export type Phase$DefaultChallengeReviewerArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DefaultChallengeReviewer
     */
    select?: DefaultChallengeReviewerSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DefaultChallengeReviewer
     */
    omit?: DefaultChallengeReviewerOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DefaultChallengeReviewerInclude<ExtArgs> | null
    where?: DefaultChallengeReviewerWhereInput
    orderBy?: DefaultChallengeReviewerOrderByWithRelationInput | DefaultChallengeReviewerOrderByWithRelationInput[]
    cursor?: DefaultChallengeReviewerWhereUniqueInput
    take?: number
    skip?: number
    distinct?: DefaultChallengeReviewerScalarFieldEnum | DefaultChallengeReviewerScalarFieldEnum[]
  }

  /**
   * Phase without action
   */
  export type PhaseDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Phase
     */
    select?: PhaseSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Phase
     */
    omit?: PhaseOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PhaseInclude<ExtArgs> | null
  }


  /**
   * Model ChallengePhase
   */

  export type AggregateChallengePhase = {
    _count: ChallengePhaseCountAggregateOutputType | null
    _avg: ChallengePhaseAvgAggregateOutputType | null
    _sum: ChallengePhaseSumAggregateOutputType | null
    _min: ChallengePhaseMinAggregateOutputType | null
    _max: ChallengePhaseMaxAggregateOutputType | null
  }

  export type ChallengePhaseAvgAggregateOutputType = {
    duration: number | null
  }

  export type ChallengePhaseSumAggregateOutputType = {
    duration: number | null
  }

  export type ChallengePhaseMinAggregateOutputType = {
    id: string | null
    challengeId: string | null
    phaseId: string | null
    name: string | null
    description: string | null
    isOpen: boolean | null
    predecessor: string | null
    duration: number | null
    scheduledStartDate: Date | null
    scheduledEndDate: Date | null
    actualStartDate: Date | null
    actualEndDate: Date | null
    createdAt: Date | null
    createdBy: string | null
    updatedAt: Date | null
    updatedBy: string | null
  }

  export type ChallengePhaseMaxAggregateOutputType = {
    id: string | null
    challengeId: string | null
    phaseId: string | null
    name: string | null
    description: string | null
    isOpen: boolean | null
    predecessor: string | null
    duration: number | null
    scheduledStartDate: Date | null
    scheduledEndDate: Date | null
    actualStartDate: Date | null
    actualEndDate: Date | null
    createdAt: Date | null
    createdBy: string | null
    updatedAt: Date | null
    updatedBy: string | null
  }

  export type ChallengePhaseCountAggregateOutputType = {
    id: number
    challengeId: number
    phaseId: number
    name: number
    description: number
    isOpen: number
    predecessor: number
    duration: number
    scheduledStartDate: number
    scheduledEndDate: number
    actualStartDate: number
    actualEndDate: number
    createdAt: number
    createdBy: number
    updatedAt: number
    updatedBy: number
    _all: number
  }


  export type ChallengePhaseAvgAggregateInputType = {
    duration?: true
  }

  export type ChallengePhaseSumAggregateInputType = {
    duration?: true
  }

  export type ChallengePhaseMinAggregateInputType = {
    id?: true
    challengeId?: true
    phaseId?: true
    name?: true
    description?: true
    isOpen?: true
    predecessor?: true
    duration?: true
    scheduledStartDate?: true
    scheduledEndDate?: true
    actualStartDate?: true
    actualEndDate?: true
    createdAt?: true
    createdBy?: true
    updatedAt?: true
    updatedBy?: true
  }

  export type ChallengePhaseMaxAggregateInputType = {
    id?: true
    challengeId?: true
    phaseId?: true
    name?: true
    description?: true
    isOpen?: true
    predecessor?: true
    duration?: true
    scheduledStartDate?: true
    scheduledEndDate?: true
    actualStartDate?: true
    actualEndDate?: true
    createdAt?: true
    createdBy?: true
    updatedAt?: true
    updatedBy?: true
  }

  export type ChallengePhaseCountAggregateInputType = {
    id?: true
    challengeId?: true
    phaseId?: true
    name?: true
    description?: true
    isOpen?: true
    predecessor?: true
    duration?: true
    scheduledStartDate?: true
    scheduledEndDate?: true
    actualStartDate?: true
    actualEndDate?: true
    createdAt?: true
    createdBy?: true
    updatedAt?: true
    updatedBy?: true
    _all?: true
  }

  export type ChallengePhaseAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ChallengePhase to aggregate.
     */
    where?: ChallengePhaseWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ChallengePhases to fetch.
     */
    orderBy?: ChallengePhaseOrderByWithRelationInput | ChallengePhaseOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ChallengePhaseWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ChallengePhases from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ChallengePhases.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned ChallengePhases
    **/
    _count?: true | ChallengePhaseCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: ChallengePhaseAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: ChallengePhaseSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ChallengePhaseMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ChallengePhaseMaxAggregateInputType
  }

  export type GetChallengePhaseAggregateType<T extends ChallengePhaseAggregateArgs> = {
        [P in keyof T & keyof AggregateChallengePhase]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateChallengePhase[P]>
      : GetScalarType<T[P], AggregateChallengePhase[P]>
  }




  export type ChallengePhaseGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ChallengePhaseWhereInput
    orderBy?: ChallengePhaseOrderByWithAggregationInput | ChallengePhaseOrderByWithAggregationInput[]
    by: ChallengePhaseScalarFieldEnum[] | ChallengePhaseScalarFieldEnum
    having?: ChallengePhaseScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ChallengePhaseCountAggregateInputType | true
    _avg?: ChallengePhaseAvgAggregateInputType
    _sum?: ChallengePhaseSumAggregateInputType
    _min?: ChallengePhaseMinAggregateInputType
    _max?: ChallengePhaseMaxAggregateInputType
  }

  export type ChallengePhaseGroupByOutputType = {
    id: string
    challengeId: string
    phaseId: string
    name: string
    description: string | null
    isOpen: boolean | null
    predecessor: string | null
    duration: number | null
    scheduledStartDate: Date | null
    scheduledEndDate: Date | null
    actualStartDate: Date | null
    actualEndDate: Date | null
    createdAt: Date
    createdBy: string
    updatedAt: Date
    updatedBy: string
    _count: ChallengePhaseCountAggregateOutputType | null
    _avg: ChallengePhaseAvgAggregateOutputType | null
    _sum: ChallengePhaseSumAggregateOutputType | null
    _min: ChallengePhaseMinAggregateOutputType | null
    _max: ChallengePhaseMaxAggregateOutputType | null
  }

  type GetChallengePhaseGroupByPayload<T extends ChallengePhaseGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ChallengePhaseGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ChallengePhaseGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ChallengePhaseGroupByOutputType[P]>
            : GetScalarType<T[P], ChallengePhaseGroupByOutputType[P]>
        }
      >
    >


  export type ChallengePhaseSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    challengeId?: boolean
    phaseId?: boolean
    name?: boolean
    description?: boolean
    isOpen?: boolean
    predecessor?: boolean
    duration?: boolean
    scheduledStartDate?: boolean
    scheduledEndDate?: boolean
    actualStartDate?: boolean
    actualEndDate?: boolean
    createdAt?: boolean
    createdBy?: boolean
    updatedAt?: boolean
    updatedBy?: boolean
    constraints?: boolean | ChallengePhase$constraintsArgs<ExtArgs>
    challenge?: boolean | ChallengeDefaultArgs<ExtArgs>
    phase?: boolean | PhaseDefaultArgs<ExtArgs>
    _count?: boolean | ChallengePhaseCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["challengePhase"]>

  export type ChallengePhaseSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    challengeId?: boolean
    phaseId?: boolean
    name?: boolean
    description?: boolean
    isOpen?: boolean
    predecessor?: boolean
    duration?: boolean
    scheduledStartDate?: boolean
    scheduledEndDate?: boolean
    actualStartDate?: boolean
    actualEndDate?: boolean
    createdAt?: boolean
    createdBy?: boolean
    updatedAt?: boolean
    updatedBy?: boolean
    challenge?: boolean | ChallengeDefaultArgs<ExtArgs>
    phase?: boolean | PhaseDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["challengePhase"]>

  export type ChallengePhaseSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    challengeId?: boolean
    phaseId?: boolean
    name?: boolean
    description?: boolean
    isOpen?: boolean
    predecessor?: boolean
    duration?: boolean
    scheduledStartDate?: boolean
    scheduledEndDate?: boolean
    actualStartDate?: boolean
    actualEndDate?: boolean
    createdAt?: boolean
    createdBy?: boolean
    updatedAt?: boolean
    updatedBy?: boolean
    challenge?: boolean | ChallengeDefaultArgs<ExtArgs>
    phase?: boolean | PhaseDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["challengePhase"]>

  export type ChallengePhaseSelectScalar = {
    id?: boolean
    challengeId?: boolean
    phaseId?: boolean
    name?: boolean
    description?: boolean
    isOpen?: boolean
    predecessor?: boolean
    duration?: boolean
    scheduledStartDate?: boolean
    scheduledEndDate?: boolean
    actualStartDate?: boolean
    actualEndDate?: boolean
    createdAt?: boolean
    createdBy?: boolean
    updatedAt?: boolean
    updatedBy?: boolean
  }

  export type ChallengePhaseOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "challengeId" | "phaseId" | "name" | "description" | "isOpen" | "predecessor" | "duration" | "scheduledStartDate" | "scheduledEndDate" | "actualStartDate" | "actualEndDate" | "createdAt" | "createdBy" | "updatedAt" | "updatedBy", ExtArgs["result"]["challengePhase"]>
  export type ChallengePhaseInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    constraints?: boolean | ChallengePhase$constraintsArgs<ExtArgs>
    challenge?: boolean | ChallengeDefaultArgs<ExtArgs>
    phase?: boolean | PhaseDefaultArgs<ExtArgs>
    _count?: boolean | ChallengePhaseCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type ChallengePhaseIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    challenge?: boolean | ChallengeDefaultArgs<ExtArgs>
    phase?: boolean | PhaseDefaultArgs<ExtArgs>
  }
  export type ChallengePhaseIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    challenge?: boolean | ChallengeDefaultArgs<ExtArgs>
    phase?: boolean | PhaseDefaultArgs<ExtArgs>
  }

  export type $ChallengePhasePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "ChallengePhase"
    objects: {
      constraints: Prisma.$ChallengePhaseConstraintPayload<ExtArgs>[]
      challenge: Prisma.$ChallengePayload<ExtArgs>
      phase: Prisma.$PhasePayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      challengeId: string
      phaseId: string
      name: string
      description: string | null
      isOpen: boolean | null
      predecessor: string | null
      duration: number | null
      scheduledStartDate: Date | null
      scheduledEndDate: Date | null
      actualStartDate: Date | null
      actualEndDate: Date | null
      createdAt: Date
      createdBy: string
      updatedAt: Date
      updatedBy: string
    }, ExtArgs["result"]["challengePhase"]>
    composites: {}
  }

  type ChallengePhaseGetPayload<S extends boolean | null | undefined | ChallengePhaseDefaultArgs> = $Result.GetResult<Prisma.$ChallengePhasePayload, S>

  type ChallengePhaseCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<ChallengePhaseFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: ChallengePhaseCountAggregateInputType | true
    }

  export interface ChallengePhaseDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['ChallengePhase'], meta: { name: 'ChallengePhase' } }
    /**
     * Find zero or one ChallengePhase that matches the filter.
     * @param {ChallengePhaseFindUniqueArgs} args - Arguments to find a ChallengePhase
     * @example
     * // Get one ChallengePhase
     * const challengePhase = await prisma.challengePhase.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends ChallengePhaseFindUniqueArgs>(args: SelectSubset<T, ChallengePhaseFindUniqueArgs<ExtArgs>>): Prisma__ChallengePhaseClient<$Result.GetResult<Prisma.$ChallengePhasePayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one ChallengePhase that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {ChallengePhaseFindUniqueOrThrowArgs} args - Arguments to find a ChallengePhase
     * @example
     * // Get one ChallengePhase
     * const challengePhase = await prisma.challengePhase.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends ChallengePhaseFindUniqueOrThrowArgs>(args: SelectSubset<T, ChallengePhaseFindUniqueOrThrowArgs<ExtArgs>>): Prisma__ChallengePhaseClient<$Result.GetResult<Prisma.$ChallengePhasePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first ChallengePhase that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ChallengePhaseFindFirstArgs} args - Arguments to find a ChallengePhase
     * @example
     * // Get one ChallengePhase
     * const challengePhase = await prisma.challengePhase.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends ChallengePhaseFindFirstArgs>(args?: SelectSubset<T, ChallengePhaseFindFirstArgs<ExtArgs>>): Prisma__ChallengePhaseClient<$Result.GetResult<Prisma.$ChallengePhasePayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first ChallengePhase that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ChallengePhaseFindFirstOrThrowArgs} args - Arguments to find a ChallengePhase
     * @example
     * // Get one ChallengePhase
     * const challengePhase = await prisma.challengePhase.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends ChallengePhaseFindFirstOrThrowArgs>(args?: SelectSubset<T, ChallengePhaseFindFirstOrThrowArgs<ExtArgs>>): Prisma__ChallengePhaseClient<$Result.GetResult<Prisma.$ChallengePhasePayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more ChallengePhases that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ChallengePhaseFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all ChallengePhases
     * const challengePhases = await prisma.challengePhase.findMany()
     * 
     * // Get first 10 ChallengePhases
     * const challengePhases = await prisma.challengePhase.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const challengePhaseWithIdOnly = await prisma.challengePhase.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends ChallengePhaseFindManyArgs>(args?: SelectSubset<T, ChallengePhaseFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ChallengePhasePayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a ChallengePhase.
     * @param {ChallengePhaseCreateArgs} args - Arguments to create a ChallengePhase.
     * @example
     * // Create one ChallengePhase
     * const ChallengePhase = await prisma.challengePhase.create({
     *   data: {
     *     // ... data to create a ChallengePhase
     *   }
     * })
     * 
     */
    create<T extends ChallengePhaseCreateArgs>(args: SelectSubset<T, ChallengePhaseCreateArgs<ExtArgs>>): Prisma__ChallengePhaseClient<$Result.GetResult<Prisma.$ChallengePhasePayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many ChallengePhases.
     * @param {ChallengePhaseCreateManyArgs} args - Arguments to create many ChallengePhases.
     * @example
     * // Create many ChallengePhases
     * const challengePhase = await prisma.challengePhase.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends ChallengePhaseCreateManyArgs>(args?: SelectSubset<T, ChallengePhaseCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many ChallengePhases and returns the data saved in the database.
     * @param {ChallengePhaseCreateManyAndReturnArgs} args - Arguments to create many ChallengePhases.
     * @example
     * // Create many ChallengePhases
     * const challengePhase = await prisma.challengePhase.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many ChallengePhases and only return the `id`
     * const challengePhaseWithIdOnly = await prisma.challengePhase.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends ChallengePhaseCreateManyAndReturnArgs>(args?: SelectSubset<T, ChallengePhaseCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ChallengePhasePayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a ChallengePhase.
     * @param {ChallengePhaseDeleteArgs} args - Arguments to delete one ChallengePhase.
     * @example
     * // Delete one ChallengePhase
     * const ChallengePhase = await prisma.challengePhase.delete({
     *   where: {
     *     // ... filter to delete one ChallengePhase
     *   }
     * })
     * 
     */
    delete<T extends ChallengePhaseDeleteArgs>(args: SelectSubset<T, ChallengePhaseDeleteArgs<ExtArgs>>): Prisma__ChallengePhaseClient<$Result.GetResult<Prisma.$ChallengePhasePayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one ChallengePhase.
     * @param {ChallengePhaseUpdateArgs} args - Arguments to update one ChallengePhase.
     * @example
     * // Update one ChallengePhase
     * const challengePhase = await prisma.challengePhase.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends ChallengePhaseUpdateArgs>(args: SelectSubset<T, ChallengePhaseUpdateArgs<ExtArgs>>): Prisma__ChallengePhaseClient<$Result.GetResult<Prisma.$ChallengePhasePayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more ChallengePhases.
     * @param {ChallengePhaseDeleteManyArgs} args - Arguments to filter ChallengePhases to delete.
     * @example
     * // Delete a few ChallengePhases
     * const { count } = await prisma.challengePhase.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends ChallengePhaseDeleteManyArgs>(args?: SelectSubset<T, ChallengePhaseDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more ChallengePhases.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ChallengePhaseUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many ChallengePhases
     * const challengePhase = await prisma.challengePhase.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends ChallengePhaseUpdateManyArgs>(args: SelectSubset<T, ChallengePhaseUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more ChallengePhases and returns the data updated in the database.
     * @param {ChallengePhaseUpdateManyAndReturnArgs} args - Arguments to update many ChallengePhases.
     * @example
     * // Update many ChallengePhases
     * const challengePhase = await prisma.challengePhase.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more ChallengePhases and only return the `id`
     * const challengePhaseWithIdOnly = await prisma.challengePhase.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends ChallengePhaseUpdateManyAndReturnArgs>(args: SelectSubset<T, ChallengePhaseUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ChallengePhasePayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one ChallengePhase.
     * @param {ChallengePhaseUpsertArgs} args - Arguments to update or create a ChallengePhase.
     * @example
     * // Update or create a ChallengePhase
     * const challengePhase = await prisma.challengePhase.upsert({
     *   create: {
     *     // ... data to create a ChallengePhase
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the ChallengePhase we want to update
     *   }
     * })
     */
    upsert<T extends ChallengePhaseUpsertArgs>(args: SelectSubset<T, ChallengePhaseUpsertArgs<ExtArgs>>): Prisma__ChallengePhaseClient<$Result.GetResult<Prisma.$ChallengePhasePayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of ChallengePhases.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ChallengePhaseCountArgs} args - Arguments to filter ChallengePhases to count.
     * @example
     * // Count the number of ChallengePhases
     * const count = await prisma.challengePhase.count({
     *   where: {
     *     // ... the filter for the ChallengePhases we want to count
     *   }
     * })
    **/
    count<T extends ChallengePhaseCountArgs>(
      args?: Subset<T, ChallengePhaseCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ChallengePhaseCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a ChallengePhase.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ChallengePhaseAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ChallengePhaseAggregateArgs>(args: Subset<T, ChallengePhaseAggregateArgs>): Prisma.PrismaPromise<GetChallengePhaseAggregateType<T>>

    /**
     * Group by ChallengePhase.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ChallengePhaseGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ChallengePhaseGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ChallengePhaseGroupByArgs['orderBy'] }
        : { orderBy?: ChallengePhaseGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ChallengePhaseGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetChallengePhaseGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the ChallengePhase model
   */
  readonly fields: ChallengePhaseFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for ChallengePhase.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ChallengePhaseClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    constraints<T extends ChallengePhase$constraintsArgs<ExtArgs> = {}>(args?: Subset<T, ChallengePhase$constraintsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ChallengePhaseConstraintPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    challenge<T extends ChallengeDefaultArgs<ExtArgs> = {}>(args?: Subset<T, ChallengeDefaultArgs<ExtArgs>>): Prisma__ChallengeClient<$Result.GetResult<Prisma.$ChallengePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    phase<T extends PhaseDefaultArgs<ExtArgs> = {}>(args?: Subset<T, PhaseDefaultArgs<ExtArgs>>): Prisma__PhaseClient<$Result.GetResult<Prisma.$PhasePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the ChallengePhase model
   */
  interface ChallengePhaseFieldRefs {
    readonly id: FieldRef<"ChallengePhase", 'String'>
    readonly challengeId: FieldRef<"ChallengePhase", 'String'>
    readonly phaseId: FieldRef<"ChallengePhase", 'String'>
    readonly name: FieldRef<"ChallengePhase", 'String'>
    readonly description: FieldRef<"ChallengePhase", 'String'>
    readonly isOpen: FieldRef<"ChallengePhase", 'Boolean'>
    readonly predecessor: FieldRef<"ChallengePhase", 'String'>
    readonly duration: FieldRef<"ChallengePhase", 'Int'>
    readonly scheduledStartDate: FieldRef<"ChallengePhase", 'DateTime'>
    readonly scheduledEndDate: FieldRef<"ChallengePhase", 'DateTime'>
    readonly actualStartDate: FieldRef<"ChallengePhase", 'DateTime'>
    readonly actualEndDate: FieldRef<"ChallengePhase", 'DateTime'>
    readonly createdAt: FieldRef<"ChallengePhase", 'DateTime'>
    readonly createdBy: FieldRef<"ChallengePhase", 'String'>
    readonly updatedAt: FieldRef<"ChallengePhase", 'DateTime'>
    readonly updatedBy: FieldRef<"ChallengePhase", 'String'>
  }
    

  // Custom InputTypes
  /**
   * ChallengePhase findUnique
   */
  export type ChallengePhaseFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ChallengePhase
     */
    select?: ChallengePhaseSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ChallengePhase
     */
    omit?: ChallengePhaseOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ChallengePhaseInclude<ExtArgs> | null
    /**
     * Filter, which ChallengePhase to fetch.
     */
    where: ChallengePhaseWhereUniqueInput
  }

  /**
   * ChallengePhase findUniqueOrThrow
   */
  export type ChallengePhaseFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ChallengePhase
     */
    select?: ChallengePhaseSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ChallengePhase
     */
    omit?: ChallengePhaseOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ChallengePhaseInclude<ExtArgs> | null
    /**
     * Filter, which ChallengePhase to fetch.
     */
    where: ChallengePhaseWhereUniqueInput
  }

  /**
   * ChallengePhase findFirst
   */
  export type ChallengePhaseFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ChallengePhase
     */
    select?: ChallengePhaseSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ChallengePhase
     */
    omit?: ChallengePhaseOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ChallengePhaseInclude<ExtArgs> | null
    /**
     * Filter, which ChallengePhase to fetch.
     */
    where?: ChallengePhaseWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ChallengePhases to fetch.
     */
    orderBy?: ChallengePhaseOrderByWithRelationInput | ChallengePhaseOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ChallengePhases.
     */
    cursor?: ChallengePhaseWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ChallengePhases from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ChallengePhases.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ChallengePhases.
     */
    distinct?: ChallengePhaseScalarFieldEnum | ChallengePhaseScalarFieldEnum[]
  }

  /**
   * ChallengePhase findFirstOrThrow
   */
  export type ChallengePhaseFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ChallengePhase
     */
    select?: ChallengePhaseSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ChallengePhase
     */
    omit?: ChallengePhaseOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ChallengePhaseInclude<ExtArgs> | null
    /**
     * Filter, which ChallengePhase to fetch.
     */
    where?: ChallengePhaseWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ChallengePhases to fetch.
     */
    orderBy?: ChallengePhaseOrderByWithRelationInput | ChallengePhaseOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ChallengePhases.
     */
    cursor?: ChallengePhaseWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ChallengePhases from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ChallengePhases.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ChallengePhases.
     */
    distinct?: ChallengePhaseScalarFieldEnum | ChallengePhaseScalarFieldEnum[]
  }

  /**
   * ChallengePhase findMany
   */
  export type ChallengePhaseFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ChallengePhase
     */
    select?: ChallengePhaseSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ChallengePhase
     */
    omit?: ChallengePhaseOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ChallengePhaseInclude<ExtArgs> | null
    /**
     * Filter, which ChallengePhases to fetch.
     */
    where?: ChallengePhaseWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ChallengePhases to fetch.
     */
    orderBy?: ChallengePhaseOrderByWithRelationInput | ChallengePhaseOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing ChallengePhases.
     */
    cursor?: ChallengePhaseWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ChallengePhases from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ChallengePhases.
     */
    skip?: number
    distinct?: ChallengePhaseScalarFieldEnum | ChallengePhaseScalarFieldEnum[]
  }

  /**
   * ChallengePhase create
   */
  export type ChallengePhaseCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ChallengePhase
     */
    select?: ChallengePhaseSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ChallengePhase
     */
    omit?: ChallengePhaseOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ChallengePhaseInclude<ExtArgs> | null
    /**
     * The data needed to create a ChallengePhase.
     */
    data: XOR<ChallengePhaseCreateInput, ChallengePhaseUncheckedCreateInput>
  }

  /**
   * ChallengePhase createMany
   */
  export type ChallengePhaseCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many ChallengePhases.
     */
    data: ChallengePhaseCreateManyInput | ChallengePhaseCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * ChallengePhase createManyAndReturn
   */
  export type ChallengePhaseCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ChallengePhase
     */
    select?: ChallengePhaseSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the ChallengePhase
     */
    omit?: ChallengePhaseOmit<ExtArgs> | null
    /**
     * The data used to create many ChallengePhases.
     */
    data: ChallengePhaseCreateManyInput | ChallengePhaseCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ChallengePhaseIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * ChallengePhase update
   */
  export type ChallengePhaseUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ChallengePhase
     */
    select?: ChallengePhaseSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ChallengePhase
     */
    omit?: ChallengePhaseOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ChallengePhaseInclude<ExtArgs> | null
    /**
     * The data needed to update a ChallengePhase.
     */
    data: XOR<ChallengePhaseUpdateInput, ChallengePhaseUncheckedUpdateInput>
    /**
     * Choose, which ChallengePhase to update.
     */
    where: ChallengePhaseWhereUniqueInput
  }

  /**
   * ChallengePhase updateMany
   */
  export type ChallengePhaseUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update ChallengePhases.
     */
    data: XOR<ChallengePhaseUpdateManyMutationInput, ChallengePhaseUncheckedUpdateManyInput>
    /**
     * Filter which ChallengePhases to update
     */
    where?: ChallengePhaseWhereInput
    /**
     * Limit how many ChallengePhases to update.
     */
    limit?: number
  }

  /**
   * ChallengePhase updateManyAndReturn
   */
  export type ChallengePhaseUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ChallengePhase
     */
    select?: ChallengePhaseSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the ChallengePhase
     */
    omit?: ChallengePhaseOmit<ExtArgs> | null
    /**
     * The data used to update ChallengePhases.
     */
    data: XOR<ChallengePhaseUpdateManyMutationInput, ChallengePhaseUncheckedUpdateManyInput>
    /**
     * Filter which ChallengePhases to update
     */
    where?: ChallengePhaseWhereInput
    /**
     * Limit how many ChallengePhases to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ChallengePhaseIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * ChallengePhase upsert
   */
  export type ChallengePhaseUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ChallengePhase
     */
    select?: ChallengePhaseSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ChallengePhase
     */
    omit?: ChallengePhaseOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ChallengePhaseInclude<ExtArgs> | null
    /**
     * The filter to search for the ChallengePhase to update in case it exists.
     */
    where: ChallengePhaseWhereUniqueInput
    /**
     * In case the ChallengePhase found by the `where` argument doesn't exist, create a new ChallengePhase with this data.
     */
    create: XOR<ChallengePhaseCreateInput, ChallengePhaseUncheckedCreateInput>
    /**
     * In case the ChallengePhase was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ChallengePhaseUpdateInput, ChallengePhaseUncheckedUpdateInput>
  }

  /**
   * ChallengePhase delete
   */
  export type ChallengePhaseDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ChallengePhase
     */
    select?: ChallengePhaseSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ChallengePhase
     */
    omit?: ChallengePhaseOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ChallengePhaseInclude<ExtArgs> | null
    /**
     * Filter which ChallengePhase to delete.
     */
    where: ChallengePhaseWhereUniqueInput
  }

  /**
   * ChallengePhase deleteMany
   */
  export type ChallengePhaseDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ChallengePhases to delete
     */
    where?: ChallengePhaseWhereInput
    /**
     * Limit how many ChallengePhases to delete.
     */
    limit?: number
  }

  /**
   * ChallengePhase.constraints
   */
  export type ChallengePhase$constraintsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ChallengePhaseConstraint
     */
    select?: ChallengePhaseConstraintSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ChallengePhaseConstraint
     */
    omit?: ChallengePhaseConstraintOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ChallengePhaseConstraintInclude<ExtArgs> | null
    where?: ChallengePhaseConstraintWhereInput
    orderBy?: ChallengePhaseConstraintOrderByWithRelationInput | ChallengePhaseConstraintOrderByWithRelationInput[]
    cursor?: ChallengePhaseConstraintWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ChallengePhaseConstraintScalarFieldEnum | ChallengePhaseConstraintScalarFieldEnum[]
  }

  /**
   * ChallengePhase without action
   */
  export type ChallengePhaseDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ChallengePhase
     */
    select?: ChallengePhaseSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ChallengePhase
     */
    omit?: ChallengePhaseOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ChallengePhaseInclude<ExtArgs> | null
  }


  /**
   * Model ChallengePhaseConstraint
   */

  export type AggregateChallengePhaseConstraint = {
    _count: ChallengePhaseConstraintCountAggregateOutputType | null
    _avg: ChallengePhaseConstraintAvgAggregateOutputType | null
    _sum: ChallengePhaseConstraintSumAggregateOutputType | null
    _min: ChallengePhaseConstraintMinAggregateOutputType | null
    _max: ChallengePhaseConstraintMaxAggregateOutputType | null
  }

  export type ChallengePhaseConstraintAvgAggregateOutputType = {
    value: number | null
  }

  export type ChallengePhaseConstraintSumAggregateOutputType = {
    value: number | null
  }

  export type ChallengePhaseConstraintMinAggregateOutputType = {
    id: string | null
    challengePhaseId: string | null
    name: string | null
    value: number | null
    createdAt: Date | null
    createdBy: string | null
    updatedAt: Date | null
    updatedBy: string | null
  }

  export type ChallengePhaseConstraintMaxAggregateOutputType = {
    id: string | null
    challengePhaseId: string | null
    name: string | null
    value: number | null
    createdAt: Date | null
    createdBy: string | null
    updatedAt: Date | null
    updatedBy: string | null
  }

  export type ChallengePhaseConstraintCountAggregateOutputType = {
    id: number
    challengePhaseId: number
    name: number
    value: number
    createdAt: number
    createdBy: number
    updatedAt: number
    updatedBy: number
    _all: number
  }


  export type ChallengePhaseConstraintAvgAggregateInputType = {
    value?: true
  }

  export type ChallengePhaseConstraintSumAggregateInputType = {
    value?: true
  }

  export type ChallengePhaseConstraintMinAggregateInputType = {
    id?: true
    challengePhaseId?: true
    name?: true
    value?: true
    createdAt?: true
    createdBy?: true
    updatedAt?: true
    updatedBy?: true
  }

  export type ChallengePhaseConstraintMaxAggregateInputType = {
    id?: true
    challengePhaseId?: true
    name?: true
    value?: true
    createdAt?: true
    createdBy?: true
    updatedAt?: true
    updatedBy?: true
  }

  export type ChallengePhaseConstraintCountAggregateInputType = {
    id?: true
    challengePhaseId?: true
    name?: true
    value?: true
    createdAt?: true
    createdBy?: true
    updatedAt?: true
    updatedBy?: true
    _all?: true
  }

  export type ChallengePhaseConstraintAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ChallengePhaseConstraint to aggregate.
     */
    where?: ChallengePhaseConstraintWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ChallengePhaseConstraints to fetch.
     */
    orderBy?: ChallengePhaseConstraintOrderByWithRelationInput | ChallengePhaseConstraintOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ChallengePhaseConstraintWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ChallengePhaseConstraints from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ChallengePhaseConstraints.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned ChallengePhaseConstraints
    **/
    _count?: true | ChallengePhaseConstraintCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: ChallengePhaseConstraintAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: ChallengePhaseConstraintSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ChallengePhaseConstraintMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ChallengePhaseConstraintMaxAggregateInputType
  }

  export type GetChallengePhaseConstraintAggregateType<T extends ChallengePhaseConstraintAggregateArgs> = {
        [P in keyof T & keyof AggregateChallengePhaseConstraint]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateChallengePhaseConstraint[P]>
      : GetScalarType<T[P], AggregateChallengePhaseConstraint[P]>
  }




  export type ChallengePhaseConstraintGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ChallengePhaseConstraintWhereInput
    orderBy?: ChallengePhaseConstraintOrderByWithAggregationInput | ChallengePhaseConstraintOrderByWithAggregationInput[]
    by: ChallengePhaseConstraintScalarFieldEnum[] | ChallengePhaseConstraintScalarFieldEnum
    having?: ChallengePhaseConstraintScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ChallengePhaseConstraintCountAggregateInputType | true
    _avg?: ChallengePhaseConstraintAvgAggregateInputType
    _sum?: ChallengePhaseConstraintSumAggregateInputType
    _min?: ChallengePhaseConstraintMinAggregateInputType
    _max?: ChallengePhaseConstraintMaxAggregateInputType
  }

  export type ChallengePhaseConstraintGroupByOutputType = {
    id: string
    challengePhaseId: string
    name: string
    value: number
    createdAt: Date
    createdBy: string
    updatedAt: Date
    updatedBy: string
    _count: ChallengePhaseConstraintCountAggregateOutputType | null
    _avg: ChallengePhaseConstraintAvgAggregateOutputType | null
    _sum: ChallengePhaseConstraintSumAggregateOutputType | null
    _min: ChallengePhaseConstraintMinAggregateOutputType | null
    _max: ChallengePhaseConstraintMaxAggregateOutputType | null
  }

  type GetChallengePhaseConstraintGroupByPayload<T extends ChallengePhaseConstraintGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ChallengePhaseConstraintGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ChallengePhaseConstraintGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ChallengePhaseConstraintGroupByOutputType[P]>
            : GetScalarType<T[P], ChallengePhaseConstraintGroupByOutputType[P]>
        }
      >
    >


  export type ChallengePhaseConstraintSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    challengePhaseId?: boolean
    name?: boolean
    value?: boolean
    createdAt?: boolean
    createdBy?: boolean
    updatedAt?: boolean
    updatedBy?: boolean
    challengePhase?: boolean | ChallengePhaseDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["challengePhaseConstraint"]>

  export type ChallengePhaseConstraintSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    challengePhaseId?: boolean
    name?: boolean
    value?: boolean
    createdAt?: boolean
    createdBy?: boolean
    updatedAt?: boolean
    updatedBy?: boolean
    challengePhase?: boolean | ChallengePhaseDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["challengePhaseConstraint"]>

  export type ChallengePhaseConstraintSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    challengePhaseId?: boolean
    name?: boolean
    value?: boolean
    createdAt?: boolean
    createdBy?: boolean
    updatedAt?: boolean
    updatedBy?: boolean
    challengePhase?: boolean | ChallengePhaseDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["challengePhaseConstraint"]>

  export type ChallengePhaseConstraintSelectScalar = {
    id?: boolean
    challengePhaseId?: boolean
    name?: boolean
    value?: boolean
    createdAt?: boolean
    createdBy?: boolean
    updatedAt?: boolean
    updatedBy?: boolean
  }

  export type ChallengePhaseConstraintOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "challengePhaseId" | "name" | "value" | "createdAt" | "createdBy" | "updatedAt" | "updatedBy", ExtArgs["result"]["challengePhaseConstraint"]>
  export type ChallengePhaseConstraintInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    challengePhase?: boolean | ChallengePhaseDefaultArgs<ExtArgs>
  }
  export type ChallengePhaseConstraintIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    challengePhase?: boolean | ChallengePhaseDefaultArgs<ExtArgs>
  }
  export type ChallengePhaseConstraintIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    challengePhase?: boolean | ChallengePhaseDefaultArgs<ExtArgs>
  }

  export type $ChallengePhaseConstraintPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "ChallengePhaseConstraint"
    objects: {
      challengePhase: Prisma.$ChallengePhasePayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      challengePhaseId: string
      name: string
      value: number
      createdAt: Date
      createdBy: string
      updatedAt: Date
      updatedBy: string
    }, ExtArgs["result"]["challengePhaseConstraint"]>
    composites: {}
  }

  type ChallengePhaseConstraintGetPayload<S extends boolean | null | undefined | ChallengePhaseConstraintDefaultArgs> = $Result.GetResult<Prisma.$ChallengePhaseConstraintPayload, S>

  type ChallengePhaseConstraintCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<ChallengePhaseConstraintFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: ChallengePhaseConstraintCountAggregateInputType | true
    }

  export interface ChallengePhaseConstraintDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['ChallengePhaseConstraint'], meta: { name: 'ChallengePhaseConstraint' } }
    /**
     * Find zero or one ChallengePhaseConstraint that matches the filter.
     * @param {ChallengePhaseConstraintFindUniqueArgs} args - Arguments to find a ChallengePhaseConstraint
     * @example
     * // Get one ChallengePhaseConstraint
     * const challengePhaseConstraint = await prisma.challengePhaseConstraint.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends ChallengePhaseConstraintFindUniqueArgs>(args: SelectSubset<T, ChallengePhaseConstraintFindUniqueArgs<ExtArgs>>): Prisma__ChallengePhaseConstraintClient<$Result.GetResult<Prisma.$ChallengePhaseConstraintPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one ChallengePhaseConstraint that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {ChallengePhaseConstraintFindUniqueOrThrowArgs} args - Arguments to find a ChallengePhaseConstraint
     * @example
     * // Get one ChallengePhaseConstraint
     * const challengePhaseConstraint = await prisma.challengePhaseConstraint.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends ChallengePhaseConstraintFindUniqueOrThrowArgs>(args: SelectSubset<T, ChallengePhaseConstraintFindUniqueOrThrowArgs<ExtArgs>>): Prisma__ChallengePhaseConstraintClient<$Result.GetResult<Prisma.$ChallengePhaseConstraintPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first ChallengePhaseConstraint that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ChallengePhaseConstraintFindFirstArgs} args - Arguments to find a ChallengePhaseConstraint
     * @example
     * // Get one ChallengePhaseConstraint
     * const challengePhaseConstraint = await prisma.challengePhaseConstraint.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends ChallengePhaseConstraintFindFirstArgs>(args?: SelectSubset<T, ChallengePhaseConstraintFindFirstArgs<ExtArgs>>): Prisma__ChallengePhaseConstraintClient<$Result.GetResult<Prisma.$ChallengePhaseConstraintPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first ChallengePhaseConstraint that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ChallengePhaseConstraintFindFirstOrThrowArgs} args - Arguments to find a ChallengePhaseConstraint
     * @example
     * // Get one ChallengePhaseConstraint
     * const challengePhaseConstraint = await prisma.challengePhaseConstraint.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends ChallengePhaseConstraintFindFirstOrThrowArgs>(args?: SelectSubset<T, ChallengePhaseConstraintFindFirstOrThrowArgs<ExtArgs>>): Prisma__ChallengePhaseConstraintClient<$Result.GetResult<Prisma.$ChallengePhaseConstraintPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more ChallengePhaseConstraints that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ChallengePhaseConstraintFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all ChallengePhaseConstraints
     * const challengePhaseConstraints = await prisma.challengePhaseConstraint.findMany()
     * 
     * // Get first 10 ChallengePhaseConstraints
     * const challengePhaseConstraints = await prisma.challengePhaseConstraint.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const challengePhaseConstraintWithIdOnly = await prisma.challengePhaseConstraint.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends ChallengePhaseConstraintFindManyArgs>(args?: SelectSubset<T, ChallengePhaseConstraintFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ChallengePhaseConstraintPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a ChallengePhaseConstraint.
     * @param {ChallengePhaseConstraintCreateArgs} args - Arguments to create a ChallengePhaseConstraint.
     * @example
     * // Create one ChallengePhaseConstraint
     * const ChallengePhaseConstraint = await prisma.challengePhaseConstraint.create({
     *   data: {
     *     // ... data to create a ChallengePhaseConstraint
     *   }
     * })
     * 
     */
    create<T extends ChallengePhaseConstraintCreateArgs>(args: SelectSubset<T, ChallengePhaseConstraintCreateArgs<ExtArgs>>): Prisma__ChallengePhaseConstraintClient<$Result.GetResult<Prisma.$ChallengePhaseConstraintPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many ChallengePhaseConstraints.
     * @param {ChallengePhaseConstraintCreateManyArgs} args - Arguments to create many ChallengePhaseConstraints.
     * @example
     * // Create many ChallengePhaseConstraints
     * const challengePhaseConstraint = await prisma.challengePhaseConstraint.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends ChallengePhaseConstraintCreateManyArgs>(args?: SelectSubset<T, ChallengePhaseConstraintCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many ChallengePhaseConstraints and returns the data saved in the database.
     * @param {ChallengePhaseConstraintCreateManyAndReturnArgs} args - Arguments to create many ChallengePhaseConstraints.
     * @example
     * // Create many ChallengePhaseConstraints
     * const challengePhaseConstraint = await prisma.challengePhaseConstraint.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many ChallengePhaseConstraints and only return the `id`
     * const challengePhaseConstraintWithIdOnly = await prisma.challengePhaseConstraint.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends ChallengePhaseConstraintCreateManyAndReturnArgs>(args?: SelectSubset<T, ChallengePhaseConstraintCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ChallengePhaseConstraintPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a ChallengePhaseConstraint.
     * @param {ChallengePhaseConstraintDeleteArgs} args - Arguments to delete one ChallengePhaseConstraint.
     * @example
     * // Delete one ChallengePhaseConstraint
     * const ChallengePhaseConstraint = await prisma.challengePhaseConstraint.delete({
     *   where: {
     *     // ... filter to delete one ChallengePhaseConstraint
     *   }
     * })
     * 
     */
    delete<T extends ChallengePhaseConstraintDeleteArgs>(args: SelectSubset<T, ChallengePhaseConstraintDeleteArgs<ExtArgs>>): Prisma__ChallengePhaseConstraintClient<$Result.GetResult<Prisma.$ChallengePhaseConstraintPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one ChallengePhaseConstraint.
     * @param {ChallengePhaseConstraintUpdateArgs} args - Arguments to update one ChallengePhaseConstraint.
     * @example
     * // Update one ChallengePhaseConstraint
     * const challengePhaseConstraint = await prisma.challengePhaseConstraint.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends ChallengePhaseConstraintUpdateArgs>(args: SelectSubset<T, ChallengePhaseConstraintUpdateArgs<ExtArgs>>): Prisma__ChallengePhaseConstraintClient<$Result.GetResult<Prisma.$ChallengePhaseConstraintPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more ChallengePhaseConstraints.
     * @param {ChallengePhaseConstraintDeleteManyArgs} args - Arguments to filter ChallengePhaseConstraints to delete.
     * @example
     * // Delete a few ChallengePhaseConstraints
     * const { count } = await prisma.challengePhaseConstraint.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends ChallengePhaseConstraintDeleteManyArgs>(args?: SelectSubset<T, ChallengePhaseConstraintDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more ChallengePhaseConstraints.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ChallengePhaseConstraintUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many ChallengePhaseConstraints
     * const challengePhaseConstraint = await prisma.challengePhaseConstraint.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends ChallengePhaseConstraintUpdateManyArgs>(args: SelectSubset<T, ChallengePhaseConstraintUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more ChallengePhaseConstraints and returns the data updated in the database.
     * @param {ChallengePhaseConstraintUpdateManyAndReturnArgs} args - Arguments to update many ChallengePhaseConstraints.
     * @example
     * // Update many ChallengePhaseConstraints
     * const challengePhaseConstraint = await prisma.challengePhaseConstraint.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more ChallengePhaseConstraints and only return the `id`
     * const challengePhaseConstraintWithIdOnly = await prisma.challengePhaseConstraint.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends ChallengePhaseConstraintUpdateManyAndReturnArgs>(args: SelectSubset<T, ChallengePhaseConstraintUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ChallengePhaseConstraintPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one ChallengePhaseConstraint.
     * @param {ChallengePhaseConstraintUpsertArgs} args - Arguments to update or create a ChallengePhaseConstraint.
     * @example
     * // Update or create a ChallengePhaseConstraint
     * const challengePhaseConstraint = await prisma.challengePhaseConstraint.upsert({
     *   create: {
     *     // ... data to create a ChallengePhaseConstraint
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the ChallengePhaseConstraint we want to update
     *   }
     * })
     */
    upsert<T extends ChallengePhaseConstraintUpsertArgs>(args: SelectSubset<T, ChallengePhaseConstraintUpsertArgs<ExtArgs>>): Prisma__ChallengePhaseConstraintClient<$Result.GetResult<Prisma.$ChallengePhaseConstraintPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of ChallengePhaseConstraints.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ChallengePhaseConstraintCountArgs} args - Arguments to filter ChallengePhaseConstraints to count.
     * @example
     * // Count the number of ChallengePhaseConstraints
     * const count = await prisma.challengePhaseConstraint.count({
     *   where: {
     *     // ... the filter for the ChallengePhaseConstraints we want to count
     *   }
     * })
    **/
    count<T extends ChallengePhaseConstraintCountArgs>(
      args?: Subset<T, ChallengePhaseConstraintCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ChallengePhaseConstraintCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a ChallengePhaseConstraint.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ChallengePhaseConstraintAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ChallengePhaseConstraintAggregateArgs>(args: Subset<T, ChallengePhaseConstraintAggregateArgs>): Prisma.PrismaPromise<GetChallengePhaseConstraintAggregateType<T>>

    /**
     * Group by ChallengePhaseConstraint.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ChallengePhaseConstraintGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ChallengePhaseConstraintGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ChallengePhaseConstraintGroupByArgs['orderBy'] }
        : { orderBy?: ChallengePhaseConstraintGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ChallengePhaseConstraintGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetChallengePhaseConstraintGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the ChallengePhaseConstraint model
   */
  readonly fields: ChallengePhaseConstraintFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for ChallengePhaseConstraint.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ChallengePhaseConstraintClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    challengePhase<T extends ChallengePhaseDefaultArgs<ExtArgs> = {}>(args?: Subset<T, ChallengePhaseDefaultArgs<ExtArgs>>): Prisma__ChallengePhaseClient<$Result.GetResult<Prisma.$ChallengePhasePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the ChallengePhaseConstraint model
   */
  interface ChallengePhaseConstraintFieldRefs {
    readonly id: FieldRef<"ChallengePhaseConstraint", 'String'>
    readonly challengePhaseId: FieldRef<"ChallengePhaseConstraint", 'String'>
    readonly name: FieldRef<"ChallengePhaseConstraint", 'String'>
    readonly value: FieldRef<"ChallengePhaseConstraint", 'Int'>
    readonly createdAt: FieldRef<"ChallengePhaseConstraint", 'DateTime'>
    readonly createdBy: FieldRef<"ChallengePhaseConstraint", 'String'>
    readonly updatedAt: FieldRef<"ChallengePhaseConstraint", 'DateTime'>
    readonly updatedBy: FieldRef<"ChallengePhaseConstraint", 'String'>
  }
    

  // Custom InputTypes
  /**
   * ChallengePhaseConstraint findUnique
   */
  export type ChallengePhaseConstraintFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ChallengePhaseConstraint
     */
    select?: ChallengePhaseConstraintSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ChallengePhaseConstraint
     */
    omit?: ChallengePhaseConstraintOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ChallengePhaseConstraintInclude<ExtArgs> | null
    /**
     * Filter, which ChallengePhaseConstraint to fetch.
     */
    where: ChallengePhaseConstraintWhereUniqueInput
  }

  /**
   * ChallengePhaseConstraint findUniqueOrThrow
   */
  export type ChallengePhaseConstraintFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ChallengePhaseConstraint
     */
    select?: ChallengePhaseConstraintSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ChallengePhaseConstraint
     */
    omit?: ChallengePhaseConstraintOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ChallengePhaseConstraintInclude<ExtArgs> | null
    /**
     * Filter, which ChallengePhaseConstraint to fetch.
     */
    where: ChallengePhaseConstraintWhereUniqueInput
  }

  /**
   * ChallengePhaseConstraint findFirst
   */
  export type ChallengePhaseConstraintFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ChallengePhaseConstraint
     */
    select?: ChallengePhaseConstraintSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ChallengePhaseConstraint
     */
    omit?: ChallengePhaseConstraintOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ChallengePhaseConstraintInclude<ExtArgs> | null
    /**
     * Filter, which ChallengePhaseConstraint to fetch.
     */
    where?: ChallengePhaseConstraintWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ChallengePhaseConstraints to fetch.
     */
    orderBy?: ChallengePhaseConstraintOrderByWithRelationInput | ChallengePhaseConstraintOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ChallengePhaseConstraints.
     */
    cursor?: ChallengePhaseConstraintWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ChallengePhaseConstraints from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ChallengePhaseConstraints.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ChallengePhaseConstraints.
     */
    distinct?: ChallengePhaseConstraintScalarFieldEnum | ChallengePhaseConstraintScalarFieldEnum[]
  }

  /**
   * ChallengePhaseConstraint findFirstOrThrow
   */
  export type ChallengePhaseConstraintFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ChallengePhaseConstraint
     */
    select?: ChallengePhaseConstraintSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ChallengePhaseConstraint
     */
    omit?: ChallengePhaseConstraintOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ChallengePhaseConstraintInclude<ExtArgs> | null
    /**
     * Filter, which ChallengePhaseConstraint to fetch.
     */
    where?: ChallengePhaseConstraintWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ChallengePhaseConstraints to fetch.
     */
    orderBy?: ChallengePhaseConstraintOrderByWithRelationInput | ChallengePhaseConstraintOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ChallengePhaseConstraints.
     */
    cursor?: ChallengePhaseConstraintWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ChallengePhaseConstraints from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ChallengePhaseConstraints.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ChallengePhaseConstraints.
     */
    distinct?: ChallengePhaseConstraintScalarFieldEnum | ChallengePhaseConstraintScalarFieldEnum[]
  }

  /**
   * ChallengePhaseConstraint findMany
   */
  export type ChallengePhaseConstraintFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ChallengePhaseConstraint
     */
    select?: ChallengePhaseConstraintSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ChallengePhaseConstraint
     */
    omit?: ChallengePhaseConstraintOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ChallengePhaseConstraintInclude<ExtArgs> | null
    /**
     * Filter, which ChallengePhaseConstraints to fetch.
     */
    where?: ChallengePhaseConstraintWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ChallengePhaseConstraints to fetch.
     */
    orderBy?: ChallengePhaseConstraintOrderByWithRelationInput | ChallengePhaseConstraintOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing ChallengePhaseConstraints.
     */
    cursor?: ChallengePhaseConstraintWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ChallengePhaseConstraints from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ChallengePhaseConstraints.
     */
    skip?: number
    distinct?: ChallengePhaseConstraintScalarFieldEnum | ChallengePhaseConstraintScalarFieldEnum[]
  }

  /**
   * ChallengePhaseConstraint create
   */
  export type ChallengePhaseConstraintCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ChallengePhaseConstraint
     */
    select?: ChallengePhaseConstraintSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ChallengePhaseConstraint
     */
    omit?: ChallengePhaseConstraintOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ChallengePhaseConstraintInclude<ExtArgs> | null
    /**
     * The data needed to create a ChallengePhaseConstraint.
     */
    data: XOR<ChallengePhaseConstraintCreateInput, ChallengePhaseConstraintUncheckedCreateInput>
  }

  /**
   * ChallengePhaseConstraint createMany
   */
  export type ChallengePhaseConstraintCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many ChallengePhaseConstraints.
     */
    data: ChallengePhaseConstraintCreateManyInput | ChallengePhaseConstraintCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * ChallengePhaseConstraint createManyAndReturn
   */
  export type ChallengePhaseConstraintCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ChallengePhaseConstraint
     */
    select?: ChallengePhaseConstraintSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the ChallengePhaseConstraint
     */
    omit?: ChallengePhaseConstraintOmit<ExtArgs> | null
    /**
     * The data used to create many ChallengePhaseConstraints.
     */
    data: ChallengePhaseConstraintCreateManyInput | ChallengePhaseConstraintCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ChallengePhaseConstraintIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * ChallengePhaseConstraint update
   */
  export type ChallengePhaseConstraintUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ChallengePhaseConstraint
     */
    select?: ChallengePhaseConstraintSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ChallengePhaseConstraint
     */
    omit?: ChallengePhaseConstraintOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ChallengePhaseConstraintInclude<ExtArgs> | null
    /**
     * The data needed to update a ChallengePhaseConstraint.
     */
    data: XOR<ChallengePhaseConstraintUpdateInput, ChallengePhaseConstraintUncheckedUpdateInput>
    /**
     * Choose, which ChallengePhaseConstraint to update.
     */
    where: ChallengePhaseConstraintWhereUniqueInput
  }

  /**
   * ChallengePhaseConstraint updateMany
   */
  export type ChallengePhaseConstraintUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update ChallengePhaseConstraints.
     */
    data: XOR<ChallengePhaseConstraintUpdateManyMutationInput, ChallengePhaseConstraintUncheckedUpdateManyInput>
    /**
     * Filter which ChallengePhaseConstraints to update
     */
    where?: ChallengePhaseConstraintWhereInput
    /**
     * Limit how many ChallengePhaseConstraints to update.
     */
    limit?: number
  }

  /**
   * ChallengePhaseConstraint updateManyAndReturn
   */
  export type ChallengePhaseConstraintUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ChallengePhaseConstraint
     */
    select?: ChallengePhaseConstraintSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the ChallengePhaseConstraint
     */
    omit?: ChallengePhaseConstraintOmit<ExtArgs> | null
    /**
     * The data used to update ChallengePhaseConstraints.
     */
    data: XOR<ChallengePhaseConstraintUpdateManyMutationInput, ChallengePhaseConstraintUncheckedUpdateManyInput>
    /**
     * Filter which ChallengePhaseConstraints to update
     */
    where?: ChallengePhaseConstraintWhereInput
    /**
     * Limit how many ChallengePhaseConstraints to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ChallengePhaseConstraintIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * ChallengePhaseConstraint upsert
   */
  export type ChallengePhaseConstraintUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ChallengePhaseConstraint
     */
    select?: ChallengePhaseConstraintSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ChallengePhaseConstraint
     */
    omit?: ChallengePhaseConstraintOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ChallengePhaseConstraintInclude<ExtArgs> | null
    /**
     * The filter to search for the ChallengePhaseConstraint to update in case it exists.
     */
    where: ChallengePhaseConstraintWhereUniqueInput
    /**
     * In case the ChallengePhaseConstraint found by the `where` argument doesn't exist, create a new ChallengePhaseConstraint with this data.
     */
    create: XOR<ChallengePhaseConstraintCreateInput, ChallengePhaseConstraintUncheckedCreateInput>
    /**
     * In case the ChallengePhaseConstraint was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ChallengePhaseConstraintUpdateInput, ChallengePhaseConstraintUncheckedUpdateInput>
  }

  /**
   * ChallengePhaseConstraint delete
   */
  export type ChallengePhaseConstraintDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ChallengePhaseConstraint
     */
    select?: ChallengePhaseConstraintSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ChallengePhaseConstraint
     */
    omit?: ChallengePhaseConstraintOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ChallengePhaseConstraintInclude<ExtArgs> | null
    /**
     * Filter which ChallengePhaseConstraint to delete.
     */
    where: ChallengePhaseConstraintWhereUniqueInput
  }

  /**
   * ChallengePhaseConstraint deleteMany
   */
  export type ChallengePhaseConstraintDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ChallengePhaseConstraints to delete
     */
    where?: ChallengePhaseConstraintWhereInput
    /**
     * Limit how many ChallengePhaseConstraints to delete.
     */
    limit?: number
  }

  /**
   * ChallengePhaseConstraint without action
   */
  export type ChallengePhaseConstraintDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ChallengePhaseConstraint
     */
    select?: ChallengePhaseConstraintSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ChallengePhaseConstraint
     */
    omit?: ChallengePhaseConstraintOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ChallengePhaseConstraintInclude<ExtArgs> | null
  }


  /**
   * Model ChallengePrizeSet
   */

  export type AggregateChallengePrizeSet = {
    _count: ChallengePrizeSetCountAggregateOutputType | null
    _min: ChallengePrizeSetMinAggregateOutputType | null
    _max: ChallengePrizeSetMaxAggregateOutputType | null
  }

  export type ChallengePrizeSetMinAggregateOutputType = {
    id: string | null
    challengeId: string | null
    type: $Enums.PrizeSetTypeEnum | null
    description: string | null
    createdAt: Date | null
    createdBy: string | null
    updatedAt: Date | null
    updatedBy: string | null
  }

  export type ChallengePrizeSetMaxAggregateOutputType = {
    id: string | null
    challengeId: string | null
    type: $Enums.PrizeSetTypeEnum | null
    description: string | null
    createdAt: Date | null
    createdBy: string | null
    updatedAt: Date | null
    updatedBy: string | null
  }

  export type ChallengePrizeSetCountAggregateOutputType = {
    id: number
    challengeId: number
    type: number
    description: number
    createdAt: number
    createdBy: number
    updatedAt: number
    updatedBy: number
    _all: number
  }


  export type ChallengePrizeSetMinAggregateInputType = {
    id?: true
    challengeId?: true
    type?: true
    description?: true
    createdAt?: true
    createdBy?: true
    updatedAt?: true
    updatedBy?: true
  }

  export type ChallengePrizeSetMaxAggregateInputType = {
    id?: true
    challengeId?: true
    type?: true
    description?: true
    createdAt?: true
    createdBy?: true
    updatedAt?: true
    updatedBy?: true
  }

  export type ChallengePrizeSetCountAggregateInputType = {
    id?: true
    challengeId?: true
    type?: true
    description?: true
    createdAt?: true
    createdBy?: true
    updatedAt?: true
    updatedBy?: true
    _all?: true
  }

  export type ChallengePrizeSetAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ChallengePrizeSet to aggregate.
     */
    where?: ChallengePrizeSetWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ChallengePrizeSets to fetch.
     */
    orderBy?: ChallengePrizeSetOrderByWithRelationInput | ChallengePrizeSetOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ChallengePrizeSetWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ChallengePrizeSets from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ChallengePrizeSets.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned ChallengePrizeSets
    **/
    _count?: true | ChallengePrizeSetCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ChallengePrizeSetMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ChallengePrizeSetMaxAggregateInputType
  }

  export type GetChallengePrizeSetAggregateType<T extends ChallengePrizeSetAggregateArgs> = {
        [P in keyof T & keyof AggregateChallengePrizeSet]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateChallengePrizeSet[P]>
      : GetScalarType<T[P], AggregateChallengePrizeSet[P]>
  }




  export type ChallengePrizeSetGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ChallengePrizeSetWhereInput
    orderBy?: ChallengePrizeSetOrderByWithAggregationInput | ChallengePrizeSetOrderByWithAggregationInput[]
    by: ChallengePrizeSetScalarFieldEnum[] | ChallengePrizeSetScalarFieldEnum
    having?: ChallengePrizeSetScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ChallengePrizeSetCountAggregateInputType | true
    _min?: ChallengePrizeSetMinAggregateInputType
    _max?: ChallengePrizeSetMaxAggregateInputType
  }

  export type ChallengePrizeSetGroupByOutputType = {
    id: string
    challengeId: string
    type: $Enums.PrizeSetTypeEnum
    description: string | null
    createdAt: Date
    createdBy: string
    updatedAt: Date
    updatedBy: string
    _count: ChallengePrizeSetCountAggregateOutputType | null
    _min: ChallengePrizeSetMinAggregateOutputType | null
    _max: ChallengePrizeSetMaxAggregateOutputType | null
  }

  type GetChallengePrizeSetGroupByPayload<T extends ChallengePrizeSetGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ChallengePrizeSetGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ChallengePrizeSetGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ChallengePrizeSetGroupByOutputType[P]>
            : GetScalarType<T[P], ChallengePrizeSetGroupByOutputType[P]>
        }
      >
    >


  export type ChallengePrizeSetSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    challengeId?: boolean
    type?: boolean
    description?: boolean
    createdAt?: boolean
    createdBy?: boolean
    updatedAt?: boolean
    updatedBy?: boolean
    prizes?: boolean | ChallengePrizeSet$prizesArgs<ExtArgs>
    challenge?: boolean | ChallengeDefaultArgs<ExtArgs>
    _count?: boolean | ChallengePrizeSetCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["challengePrizeSet"]>

  export type ChallengePrizeSetSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    challengeId?: boolean
    type?: boolean
    description?: boolean
    createdAt?: boolean
    createdBy?: boolean
    updatedAt?: boolean
    updatedBy?: boolean
    challenge?: boolean | ChallengeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["challengePrizeSet"]>

  export type ChallengePrizeSetSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    challengeId?: boolean
    type?: boolean
    description?: boolean
    createdAt?: boolean
    createdBy?: boolean
    updatedAt?: boolean
    updatedBy?: boolean
    challenge?: boolean | ChallengeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["challengePrizeSet"]>

  export type ChallengePrizeSetSelectScalar = {
    id?: boolean
    challengeId?: boolean
    type?: boolean
    description?: boolean
    createdAt?: boolean
    createdBy?: boolean
    updatedAt?: boolean
    updatedBy?: boolean
  }

  export type ChallengePrizeSetOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "challengeId" | "type" | "description" | "createdAt" | "createdBy" | "updatedAt" | "updatedBy", ExtArgs["result"]["challengePrizeSet"]>
  export type ChallengePrizeSetInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    prizes?: boolean | ChallengePrizeSet$prizesArgs<ExtArgs>
    challenge?: boolean | ChallengeDefaultArgs<ExtArgs>
    _count?: boolean | ChallengePrizeSetCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type ChallengePrizeSetIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    challenge?: boolean | ChallengeDefaultArgs<ExtArgs>
  }
  export type ChallengePrizeSetIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    challenge?: boolean | ChallengeDefaultArgs<ExtArgs>
  }

  export type $ChallengePrizeSetPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "ChallengePrizeSet"
    objects: {
      prizes: Prisma.$PrizePayload<ExtArgs>[]
      challenge: Prisma.$ChallengePayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      challengeId: string
      type: $Enums.PrizeSetTypeEnum
      description: string | null
      createdAt: Date
      createdBy: string
      updatedAt: Date
      updatedBy: string
    }, ExtArgs["result"]["challengePrizeSet"]>
    composites: {}
  }

  type ChallengePrizeSetGetPayload<S extends boolean | null | undefined | ChallengePrizeSetDefaultArgs> = $Result.GetResult<Prisma.$ChallengePrizeSetPayload, S>

  type ChallengePrizeSetCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<ChallengePrizeSetFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: ChallengePrizeSetCountAggregateInputType | true
    }

  export interface ChallengePrizeSetDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['ChallengePrizeSet'], meta: { name: 'ChallengePrizeSet' } }
    /**
     * Find zero or one ChallengePrizeSet that matches the filter.
     * @param {ChallengePrizeSetFindUniqueArgs} args - Arguments to find a ChallengePrizeSet
     * @example
     * // Get one ChallengePrizeSet
     * const challengePrizeSet = await prisma.challengePrizeSet.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends ChallengePrizeSetFindUniqueArgs>(args: SelectSubset<T, ChallengePrizeSetFindUniqueArgs<ExtArgs>>): Prisma__ChallengePrizeSetClient<$Result.GetResult<Prisma.$ChallengePrizeSetPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one ChallengePrizeSet that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {ChallengePrizeSetFindUniqueOrThrowArgs} args - Arguments to find a ChallengePrizeSet
     * @example
     * // Get one ChallengePrizeSet
     * const challengePrizeSet = await prisma.challengePrizeSet.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends ChallengePrizeSetFindUniqueOrThrowArgs>(args: SelectSubset<T, ChallengePrizeSetFindUniqueOrThrowArgs<ExtArgs>>): Prisma__ChallengePrizeSetClient<$Result.GetResult<Prisma.$ChallengePrizeSetPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first ChallengePrizeSet that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ChallengePrizeSetFindFirstArgs} args - Arguments to find a ChallengePrizeSet
     * @example
     * // Get one ChallengePrizeSet
     * const challengePrizeSet = await prisma.challengePrizeSet.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends ChallengePrizeSetFindFirstArgs>(args?: SelectSubset<T, ChallengePrizeSetFindFirstArgs<ExtArgs>>): Prisma__ChallengePrizeSetClient<$Result.GetResult<Prisma.$ChallengePrizeSetPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first ChallengePrizeSet that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ChallengePrizeSetFindFirstOrThrowArgs} args - Arguments to find a ChallengePrizeSet
     * @example
     * // Get one ChallengePrizeSet
     * const challengePrizeSet = await prisma.challengePrizeSet.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends ChallengePrizeSetFindFirstOrThrowArgs>(args?: SelectSubset<T, ChallengePrizeSetFindFirstOrThrowArgs<ExtArgs>>): Prisma__ChallengePrizeSetClient<$Result.GetResult<Prisma.$ChallengePrizeSetPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more ChallengePrizeSets that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ChallengePrizeSetFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all ChallengePrizeSets
     * const challengePrizeSets = await prisma.challengePrizeSet.findMany()
     * 
     * // Get first 10 ChallengePrizeSets
     * const challengePrizeSets = await prisma.challengePrizeSet.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const challengePrizeSetWithIdOnly = await prisma.challengePrizeSet.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends ChallengePrizeSetFindManyArgs>(args?: SelectSubset<T, ChallengePrizeSetFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ChallengePrizeSetPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a ChallengePrizeSet.
     * @param {ChallengePrizeSetCreateArgs} args - Arguments to create a ChallengePrizeSet.
     * @example
     * // Create one ChallengePrizeSet
     * const ChallengePrizeSet = await prisma.challengePrizeSet.create({
     *   data: {
     *     // ... data to create a ChallengePrizeSet
     *   }
     * })
     * 
     */
    create<T extends ChallengePrizeSetCreateArgs>(args: SelectSubset<T, ChallengePrizeSetCreateArgs<ExtArgs>>): Prisma__ChallengePrizeSetClient<$Result.GetResult<Prisma.$ChallengePrizeSetPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many ChallengePrizeSets.
     * @param {ChallengePrizeSetCreateManyArgs} args - Arguments to create many ChallengePrizeSets.
     * @example
     * // Create many ChallengePrizeSets
     * const challengePrizeSet = await prisma.challengePrizeSet.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends ChallengePrizeSetCreateManyArgs>(args?: SelectSubset<T, ChallengePrizeSetCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many ChallengePrizeSets and returns the data saved in the database.
     * @param {ChallengePrizeSetCreateManyAndReturnArgs} args - Arguments to create many ChallengePrizeSets.
     * @example
     * // Create many ChallengePrizeSets
     * const challengePrizeSet = await prisma.challengePrizeSet.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many ChallengePrizeSets and only return the `id`
     * const challengePrizeSetWithIdOnly = await prisma.challengePrizeSet.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends ChallengePrizeSetCreateManyAndReturnArgs>(args?: SelectSubset<T, ChallengePrizeSetCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ChallengePrizeSetPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a ChallengePrizeSet.
     * @param {ChallengePrizeSetDeleteArgs} args - Arguments to delete one ChallengePrizeSet.
     * @example
     * // Delete one ChallengePrizeSet
     * const ChallengePrizeSet = await prisma.challengePrizeSet.delete({
     *   where: {
     *     // ... filter to delete one ChallengePrizeSet
     *   }
     * })
     * 
     */
    delete<T extends ChallengePrizeSetDeleteArgs>(args: SelectSubset<T, ChallengePrizeSetDeleteArgs<ExtArgs>>): Prisma__ChallengePrizeSetClient<$Result.GetResult<Prisma.$ChallengePrizeSetPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one ChallengePrizeSet.
     * @param {ChallengePrizeSetUpdateArgs} args - Arguments to update one ChallengePrizeSet.
     * @example
     * // Update one ChallengePrizeSet
     * const challengePrizeSet = await prisma.challengePrizeSet.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends ChallengePrizeSetUpdateArgs>(args: SelectSubset<T, ChallengePrizeSetUpdateArgs<ExtArgs>>): Prisma__ChallengePrizeSetClient<$Result.GetResult<Prisma.$ChallengePrizeSetPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more ChallengePrizeSets.
     * @param {ChallengePrizeSetDeleteManyArgs} args - Arguments to filter ChallengePrizeSets to delete.
     * @example
     * // Delete a few ChallengePrizeSets
     * const { count } = await prisma.challengePrizeSet.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends ChallengePrizeSetDeleteManyArgs>(args?: SelectSubset<T, ChallengePrizeSetDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more ChallengePrizeSets.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ChallengePrizeSetUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many ChallengePrizeSets
     * const challengePrizeSet = await prisma.challengePrizeSet.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends ChallengePrizeSetUpdateManyArgs>(args: SelectSubset<T, ChallengePrizeSetUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more ChallengePrizeSets and returns the data updated in the database.
     * @param {ChallengePrizeSetUpdateManyAndReturnArgs} args - Arguments to update many ChallengePrizeSets.
     * @example
     * // Update many ChallengePrizeSets
     * const challengePrizeSet = await prisma.challengePrizeSet.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more ChallengePrizeSets and only return the `id`
     * const challengePrizeSetWithIdOnly = await prisma.challengePrizeSet.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends ChallengePrizeSetUpdateManyAndReturnArgs>(args: SelectSubset<T, ChallengePrizeSetUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ChallengePrizeSetPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one ChallengePrizeSet.
     * @param {ChallengePrizeSetUpsertArgs} args - Arguments to update or create a ChallengePrizeSet.
     * @example
     * // Update or create a ChallengePrizeSet
     * const challengePrizeSet = await prisma.challengePrizeSet.upsert({
     *   create: {
     *     // ... data to create a ChallengePrizeSet
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the ChallengePrizeSet we want to update
     *   }
     * })
     */
    upsert<T extends ChallengePrizeSetUpsertArgs>(args: SelectSubset<T, ChallengePrizeSetUpsertArgs<ExtArgs>>): Prisma__ChallengePrizeSetClient<$Result.GetResult<Prisma.$ChallengePrizeSetPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of ChallengePrizeSets.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ChallengePrizeSetCountArgs} args - Arguments to filter ChallengePrizeSets to count.
     * @example
     * // Count the number of ChallengePrizeSets
     * const count = await prisma.challengePrizeSet.count({
     *   where: {
     *     // ... the filter for the ChallengePrizeSets we want to count
     *   }
     * })
    **/
    count<T extends ChallengePrizeSetCountArgs>(
      args?: Subset<T, ChallengePrizeSetCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ChallengePrizeSetCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a ChallengePrizeSet.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ChallengePrizeSetAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ChallengePrizeSetAggregateArgs>(args: Subset<T, ChallengePrizeSetAggregateArgs>): Prisma.PrismaPromise<GetChallengePrizeSetAggregateType<T>>

    /**
     * Group by ChallengePrizeSet.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ChallengePrizeSetGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ChallengePrizeSetGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ChallengePrizeSetGroupByArgs['orderBy'] }
        : { orderBy?: ChallengePrizeSetGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ChallengePrizeSetGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetChallengePrizeSetGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the ChallengePrizeSet model
   */
  readonly fields: ChallengePrizeSetFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for ChallengePrizeSet.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ChallengePrizeSetClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    prizes<T extends ChallengePrizeSet$prizesArgs<ExtArgs> = {}>(args?: Subset<T, ChallengePrizeSet$prizesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PrizePayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    challenge<T extends ChallengeDefaultArgs<ExtArgs> = {}>(args?: Subset<T, ChallengeDefaultArgs<ExtArgs>>): Prisma__ChallengeClient<$Result.GetResult<Prisma.$ChallengePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the ChallengePrizeSet model
   */
  interface ChallengePrizeSetFieldRefs {
    readonly id: FieldRef<"ChallengePrizeSet", 'String'>
    readonly challengeId: FieldRef<"ChallengePrizeSet", 'String'>
    readonly type: FieldRef<"ChallengePrizeSet", 'PrizeSetTypeEnum'>
    readonly description: FieldRef<"ChallengePrizeSet", 'String'>
    readonly createdAt: FieldRef<"ChallengePrizeSet", 'DateTime'>
    readonly createdBy: FieldRef<"ChallengePrizeSet", 'String'>
    readonly updatedAt: FieldRef<"ChallengePrizeSet", 'DateTime'>
    readonly updatedBy: FieldRef<"ChallengePrizeSet", 'String'>
  }
    

  // Custom InputTypes
  /**
   * ChallengePrizeSet findUnique
   */
  export type ChallengePrizeSetFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ChallengePrizeSet
     */
    select?: ChallengePrizeSetSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ChallengePrizeSet
     */
    omit?: ChallengePrizeSetOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ChallengePrizeSetInclude<ExtArgs> | null
    /**
     * Filter, which ChallengePrizeSet to fetch.
     */
    where: ChallengePrizeSetWhereUniqueInput
  }

  /**
   * ChallengePrizeSet findUniqueOrThrow
   */
  export type ChallengePrizeSetFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ChallengePrizeSet
     */
    select?: ChallengePrizeSetSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ChallengePrizeSet
     */
    omit?: ChallengePrizeSetOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ChallengePrizeSetInclude<ExtArgs> | null
    /**
     * Filter, which ChallengePrizeSet to fetch.
     */
    where: ChallengePrizeSetWhereUniqueInput
  }

  /**
   * ChallengePrizeSet findFirst
   */
  export type ChallengePrizeSetFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ChallengePrizeSet
     */
    select?: ChallengePrizeSetSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ChallengePrizeSet
     */
    omit?: ChallengePrizeSetOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ChallengePrizeSetInclude<ExtArgs> | null
    /**
     * Filter, which ChallengePrizeSet to fetch.
     */
    where?: ChallengePrizeSetWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ChallengePrizeSets to fetch.
     */
    orderBy?: ChallengePrizeSetOrderByWithRelationInput | ChallengePrizeSetOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ChallengePrizeSets.
     */
    cursor?: ChallengePrizeSetWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ChallengePrizeSets from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ChallengePrizeSets.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ChallengePrizeSets.
     */
    distinct?: ChallengePrizeSetScalarFieldEnum | ChallengePrizeSetScalarFieldEnum[]
  }

  /**
   * ChallengePrizeSet findFirstOrThrow
   */
  export type ChallengePrizeSetFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ChallengePrizeSet
     */
    select?: ChallengePrizeSetSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ChallengePrizeSet
     */
    omit?: ChallengePrizeSetOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ChallengePrizeSetInclude<ExtArgs> | null
    /**
     * Filter, which ChallengePrizeSet to fetch.
     */
    where?: ChallengePrizeSetWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ChallengePrizeSets to fetch.
     */
    orderBy?: ChallengePrizeSetOrderByWithRelationInput | ChallengePrizeSetOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ChallengePrizeSets.
     */
    cursor?: ChallengePrizeSetWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ChallengePrizeSets from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ChallengePrizeSets.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ChallengePrizeSets.
     */
    distinct?: ChallengePrizeSetScalarFieldEnum | ChallengePrizeSetScalarFieldEnum[]
  }

  /**
   * ChallengePrizeSet findMany
   */
  export type ChallengePrizeSetFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ChallengePrizeSet
     */
    select?: ChallengePrizeSetSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ChallengePrizeSet
     */
    omit?: ChallengePrizeSetOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ChallengePrizeSetInclude<ExtArgs> | null
    /**
     * Filter, which ChallengePrizeSets to fetch.
     */
    where?: ChallengePrizeSetWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ChallengePrizeSets to fetch.
     */
    orderBy?: ChallengePrizeSetOrderByWithRelationInput | ChallengePrizeSetOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing ChallengePrizeSets.
     */
    cursor?: ChallengePrizeSetWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ChallengePrizeSets from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ChallengePrizeSets.
     */
    skip?: number
    distinct?: ChallengePrizeSetScalarFieldEnum | ChallengePrizeSetScalarFieldEnum[]
  }

  /**
   * ChallengePrizeSet create
   */
  export type ChallengePrizeSetCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ChallengePrizeSet
     */
    select?: ChallengePrizeSetSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ChallengePrizeSet
     */
    omit?: ChallengePrizeSetOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ChallengePrizeSetInclude<ExtArgs> | null
    /**
     * The data needed to create a ChallengePrizeSet.
     */
    data: XOR<ChallengePrizeSetCreateInput, ChallengePrizeSetUncheckedCreateInput>
  }

  /**
   * ChallengePrizeSet createMany
   */
  export type ChallengePrizeSetCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many ChallengePrizeSets.
     */
    data: ChallengePrizeSetCreateManyInput | ChallengePrizeSetCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * ChallengePrizeSet createManyAndReturn
   */
  export type ChallengePrizeSetCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ChallengePrizeSet
     */
    select?: ChallengePrizeSetSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the ChallengePrizeSet
     */
    omit?: ChallengePrizeSetOmit<ExtArgs> | null
    /**
     * The data used to create many ChallengePrizeSets.
     */
    data: ChallengePrizeSetCreateManyInput | ChallengePrizeSetCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ChallengePrizeSetIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * ChallengePrizeSet update
   */
  export type ChallengePrizeSetUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ChallengePrizeSet
     */
    select?: ChallengePrizeSetSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ChallengePrizeSet
     */
    omit?: ChallengePrizeSetOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ChallengePrizeSetInclude<ExtArgs> | null
    /**
     * The data needed to update a ChallengePrizeSet.
     */
    data: XOR<ChallengePrizeSetUpdateInput, ChallengePrizeSetUncheckedUpdateInput>
    /**
     * Choose, which ChallengePrizeSet to update.
     */
    where: ChallengePrizeSetWhereUniqueInput
  }

  /**
   * ChallengePrizeSet updateMany
   */
  export type ChallengePrizeSetUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update ChallengePrizeSets.
     */
    data: XOR<ChallengePrizeSetUpdateManyMutationInput, ChallengePrizeSetUncheckedUpdateManyInput>
    /**
     * Filter which ChallengePrizeSets to update
     */
    where?: ChallengePrizeSetWhereInput
    /**
     * Limit how many ChallengePrizeSets to update.
     */
    limit?: number
  }

  /**
   * ChallengePrizeSet updateManyAndReturn
   */
  export type ChallengePrizeSetUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ChallengePrizeSet
     */
    select?: ChallengePrizeSetSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the ChallengePrizeSet
     */
    omit?: ChallengePrizeSetOmit<ExtArgs> | null
    /**
     * The data used to update ChallengePrizeSets.
     */
    data: XOR<ChallengePrizeSetUpdateManyMutationInput, ChallengePrizeSetUncheckedUpdateManyInput>
    /**
     * Filter which ChallengePrizeSets to update
     */
    where?: ChallengePrizeSetWhereInput
    /**
     * Limit how many ChallengePrizeSets to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ChallengePrizeSetIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * ChallengePrizeSet upsert
   */
  export type ChallengePrizeSetUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ChallengePrizeSet
     */
    select?: ChallengePrizeSetSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ChallengePrizeSet
     */
    omit?: ChallengePrizeSetOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ChallengePrizeSetInclude<ExtArgs> | null
    /**
     * The filter to search for the ChallengePrizeSet to update in case it exists.
     */
    where: ChallengePrizeSetWhereUniqueInput
    /**
     * In case the ChallengePrizeSet found by the `where` argument doesn't exist, create a new ChallengePrizeSet with this data.
     */
    create: XOR<ChallengePrizeSetCreateInput, ChallengePrizeSetUncheckedCreateInput>
    /**
     * In case the ChallengePrizeSet was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ChallengePrizeSetUpdateInput, ChallengePrizeSetUncheckedUpdateInput>
  }

  /**
   * ChallengePrizeSet delete
   */
  export type ChallengePrizeSetDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ChallengePrizeSet
     */
    select?: ChallengePrizeSetSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ChallengePrizeSet
     */
    omit?: ChallengePrizeSetOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ChallengePrizeSetInclude<ExtArgs> | null
    /**
     * Filter which ChallengePrizeSet to delete.
     */
    where: ChallengePrizeSetWhereUniqueInput
  }

  /**
   * ChallengePrizeSet deleteMany
   */
  export type ChallengePrizeSetDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ChallengePrizeSets to delete
     */
    where?: ChallengePrizeSetWhereInput
    /**
     * Limit how many ChallengePrizeSets to delete.
     */
    limit?: number
  }

  /**
   * ChallengePrizeSet.prizes
   */
  export type ChallengePrizeSet$prizesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Prize
     */
    select?: PrizeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Prize
     */
    omit?: PrizeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PrizeInclude<ExtArgs> | null
    where?: PrizeWhereInput
    orderBy?: PrizeOrderByWithRelationInput | PrizeOrderByWithRelationInput[]
    cursor?: PrizeWhereUniqueInput
    take?: number
    skip?: number
    distinct?: PrizeScalarFieldEnum | PrizeScalarFieldEnum[]
  }

  /**
   * ChallengePrizeSet without action
   */
  export type ChallengePrizeSetDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ChallengePrizeSet
     */
    select?: ChallengePrizeSetSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ChallengePrizeSet
     */
    omit?: ChallengePrizeSetOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ChallengePrizeSetInclude<ExtArgs> | null
  }


  /**
   * Model ChallengeReviewer
   */

  export type AggregateChallengeReviewer = {
    _count: ChallengeReviewerCountAggregateOutputType | null
    _avg: ChallengeReviewerAvgAggregateOutputType | null
    _sum: ChallengeReviewerSumAggregateOutputType | null
    _min: ChallengeReviewerMinAggregateOutputType | null
    _max: ChallengeReviewerMaxAggregateOutputType | null
  }

  export type ChallengeReviewerAvgAggregateOutputType = {
    memberReviewerCount: number | null
    fixedAmount: number | null
    baseCoefficient: number | null
    incrementalCoefficient: number | null
  }

  export type ChallengeReviewerSumAggregateOutputType = {
    memberReviewerCount: number | null
    fixedAmount: number | null
    baseCoefficient: number | null
    incrementalCoefficient: number | null
  }

  export type ChallengeReviewerMinAggregateOutputType = {
    id: string | null
    challengeId: string | null
    scorecardId: string | null
    isMemberReview: boolean | null
    memberReviewerCount: number | null
    phaseId: string | null
    fixedAmount: number | null
    baseCoefficient: number | null
    incrementalCoefficient: number | null
    type: $Enums.ReviewOpportunityTypeEnum | null
    aiWorkflowId: string | null
    shouldOpenOpportunity: boolean | null
    createdAt: Date | null
    createdBy: string | null
    updatedAt: Date | null
    updatedBy: string | null
  }

  export type ChallengeReviewerMaxAggregateOutputType = {
    id: string | null
    challengeId: string | null
    scorecardId: string | null
    isMemberReview: boolean | null
    memberReviewerCount: number | null
    phaseId: string | null
    fixedAmount: number | null
    baseCoefficient: number | null
    incrementalCoefficient: number | null
    type: $Enums.ReviewOpportunityTypeEnum | null
    aiWorkflowId: string | null
    shouldOpenOpportunity: boolean | null
    createdAt: Date | null
    createdBy: string | null
    updatedAt: Date | null
    updatedBy: string | null
  }

  export type ChallengeReviewerCountAggregateOutputType = {
    id: number
    challengeId: number
    scorecardId: number
    isMemberReview: number
    memberReviewerCount: number
    phaseId: number
    fixedAmount: number
    baseCoefficient: number
    incrementalCoefficient: number
    type: number
    aiWorkflowId: number
    shouldOpenOpportunity: number
    createdAt: number
    createdBy: number
    updatedAt: number
    updatedBy: number
    _all: number
  }


  export type ChallengeReviewerAvgAggregateInputType = {
    memberReviewerCount?: true
    fixedAmount?: true
    baseCoefficient?: true
    incrementalCoefficient?: true
  }

  export type ChallengeReviewerSumAggregateInputType = {
    memberReviewerCount?: true
    fixedAmount?: true
    baseCoefficient?: true
    incrementalCoefficient?: true
  }

  export type ChallengeReviewerMinAggregateInputType = {
    id?: true
    challengeId?: true
    scorecardId?: true
    isMemberReview?: true
    memberReviewerCount?: true
    phaseId?: true
    fixedAmount?: true
    baseCoefficient?: true
    incrementalCoefficient?: true
    type?: true
    aiWorkflowId?: true
    shouldOpenOpportunity?: true
    createdAt?: true
    createdBy?: true
    updatedAt?: true
    updatedBy?: true
  }

  export type ChallengeReviewerMaxAggregateInputType = {
    id?: true
    challengeId?: true
    scorecardId?: true
    isMemberReview?: true
    memberReviewerCount?: true
    phaseId?: true
    fixedAmount?: true
    baseCoefficient?: true
    incrementalCoefficient?: true
    type?: true
    aiWorkflowId?: true
    shouldOpenOpportunity?: true
    createdAt?: true
    createdBy?: true
    updatedAt?: true
    updatedBy?: true
  }

  export type ChallengeReviewerCountAggregateInputType = {
    id?: true
    challengeId?: true
    scorecardId?: true
    isMemberReview?: true
    memberReviewerCount?: true
    phaseId?: true
    fixedAmount?: true
    baseCoefficient?: true
    incrementalCoefficient?: true
    type?: true
    aiWorkflowId?: true
    shouldOpenOpportunity?: true
    createdAt?: true
    createdBy?: true
    updatedAt?: true
    updatedBy?: true
    _all?: true
  }

  export type ChallengeReviewerAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ChallengeReviewer to aggregate.
     */
    where?: ChallengeReviewerWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ChallengeReviewers to fetch.
     */
    orderBy?: ChallengeReviewerOrderByWithRelationInput | ChallengeReviewerOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ChallengeReviewerWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ChallengeReviewers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ChallengeReviewers.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned ChallengeReviewers
    **/
    _count?: true | ChallengeReviewerCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: ChallengeReviewerAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: ChallengeReviewerSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ChallengeReviewerMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ChallengeReviewerMaxAggregateInputType
  }

  export type GetChallengeReviewerAggregateType<T extends ChallengeReviewerAggregateArgs> = {
        [P in keyof T & keyof AggregateChallengeReviewer]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateChallengeReviewer[P]>
      : GetScalarType<T[P], AggregateChallengeReviewer[P]>
  }




  export type ChallengeReviewerGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ChallengeReviewerWhereInput
    orderBy?: ChallengeReviewerOrderByWithAggregationInput | ChallengeReviewerOrderByWithAggregationInput[]
    by: ChallengeReviewerScalarFieldEnum[] | ChallengeReviewerScalarFieldEnum
    having?: ChallengeReviewerScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ChallengeReviewerCountAggregateInputType | true
    _avg?: ChallengeReviewerAvgAggregateInputType
    _sum?: ChallengeReviewerSumAggregateInputType
    _min?: ChallengeReviewerMinAggregateInputType
    _max?: ChallengeReviewerMaxAggregateInputType
  }

  export type ChallengeReviewerGroupByOutputType = {
    id: string
    challengeId: string
    scorecardId: string
    isMemberReview: boolean
    memberReviewerCount: number | null
    phaseId: string
    fixedAmount: number | null
    baseCoefficient: number | null
    incrementalCoefficient: number | null
    type: $Enums.ReviewOpportunityTypeEnum | null
    aiWorkflowId: string | null
    shouldOpenOpportunity: boolean
    createdAt: Date
    createdBy: string
    updatedAt: Date
    updatedBy: string
    _count: ChallengeReviewerCountAggregateOutputType | null
    _avg: ChallengeReviewerAvgAggregateOutputType | null
    _sum: ChallengeReviewerSumAggregateOutputType | null
    _min: ChallengeReviewerMinAggregateOutputType | null
    _max: ChallengeReviewerMaxAggregateOutputType | null
  }

  type GetChallengeReviewerGroupByPayload<T extends ChallengeReviewerGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ChallengeReviewerGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ChallengeReviewerGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ChallengeReviewerGroupByOutputType[P]>
            : GetScalarType<T[P], ChallengeReviewerGroupByOutputType[P]>
        }
      >
    >


  export type ChallengeReviewerSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    challengeId?: boolean
    scorecardId?: boolean
    isMemberReview?: boolean
    memberReviewerCount?: boolean
    phaseId?: boolean
    fixedAmount?: boolean
    baseCoefficient?: boolean
    incrementalCoefficient?: boolean
    type?: boolean
    aiWorkflowId?: boolean
    shouldOpenOpportunity?: boolean
    createdAt?: boolean
    createdBy?: boolean
    updatedAt?: boolean
    updatedBy?: boolean
    challenge?: boolean | ChallengeDefaultArgs<ExtArgs>
    phase?: boolean | PhaseDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["challengeReviewer"]>

  export type ChallengeReviewerSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    challengeId?: boolean
    scorecardId?: boolean
    isMemberReview?: boolean
    memberReviewerCount?: boolean
    phaseId?: boolean
    fixedAmount?: boolean
    baseCoefficient?: boolean
    incrementalCoefficient?: boolean
    type?: boolean
    aiWorkflowId?: boolean
    shouldOpenOpportunity?: boolean
    createdAt?: boolean
    createdBy?: boolean
    updatedAt?: boolean
    updatedBy?: boolean
    challenge?: boolean | ChallengeDefaultArgs<ExtArgs>
    phase?: boolean | PhaseDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["challengeReviewer"]>

  export type ChallengeReviewerSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    challengeId?: boolean
    scorecardId?: boolean
    isMemberReview?: boolean
    memberReviewerCount?: boolean
    phaseId?: boolean
    fixedAmount?: boolean
    baseCoefficient?: boolean
    incrementalCoefficient?: boolean
    type?: boolean
    aiWorkflowId?: boolean
    shouldOpenOpportunity?: boolean
    createdAt?: boolean
    createdBy?: boolean
    updatedAt?: boolean
    updatedBy?: boolean
    challenge?: boolean | ChallengeDefaultArgs<ExtArgs>
    phase?: boolean | PhaseDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["challengeReviewer"]>

  export type ChallengeReviewerSelectScalar = {
    id?: boolean
    challengeId?: boolean
    scorecardId?: boolean
    isMemberReview?: boolean
    memberReviewerCount?: boolean
    phaseId?: boolean
    fixedAmount?: boolean
    baseCoefficient?: boolean
    incrementalCoefficient?: boolean
    type?: boolean
    aiWorkflowId?: boolean
    shouldOpenOpportunity?: boolean
    createdAt?: boolean
    createdBy?: boolean
    updatedAt?: boolean
    updatedBy?: boolean
  }

  export type ChallengeReviewerOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "challengeId" | "scorecardId" | "isMemberReview" | "memberReviewerCount" | "phaseId" | "fixedAmount" | "baseCoefficient" | "incrementalCoefficient" | "type" | "aiWorkflowId" | "shouldOpenOpportunity" | "createdAt" | "createdBy" | "updatedAt" | "updatedBy", ExtArgs["result"]["challengeReviewer"]>
  export type ChallengeReviewerInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    challenge?: boolean | ChallengeDefaultArgs<ExtArgs>
    phase?: boolean | PhaseDefaultArgs<ExtArgs>
  }
  export type ChallengeReviewerIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    challenge?: boolean | ChallengeDefaultArgs<ExtArgs>
    phase?: boolean | PhaseDefaultArgs<ExtArgs>
  }
  export type ChallengeReviewerIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    challenge?: boolean | ChallengeDefaultArgs<ExtArgs>
    phase?: boolean | PhaseDefaultArgs<ExtArgs>
  }

  export type $ChallengeReviewerPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "ChallengeReviewer"
    objects: {
      challenge: Prisma.$ChallengePayload<ExtArgs>
      phase: Prisma.$PhasePayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      challengeId: string
      scorecardId: string
      isMemberReview: boolean
      memberReviewerCount: number | null
      phaseId: string
      fixedAmount: number | null
      baseCoefficient: number | null
      incrementalCoefficient: number | null
      type: $Enums.ReviewOpportunityTypeEnum | null
      aiWorkflowId: string | null
      shouldOpenOpportunity: boolean
      createdAt: Date
      createdBy: string
      updatedAt: Date
      updatedBy: string
    }, ExtArgs["result"]["challengeReviewer"]>
    composites: {}
  }

  type ChallengeReviewerGetPayload<S extends boolean | null | undefined | ChallengeReviewerDefaultArgs> = $Result.GetResult<Prisma.$ChallengeReviewerPayload, S>

  type ChallengeReviewerCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<ChallengeReviewerFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: ChallengeReviewerCountAggregateInputType | true
    }

  export interface ChallengeReviewerDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['ChallengeReviewer'], meta: { name: 'ChallengeReviewer' } }
    /**
     * Find zero or one ChallengeReviewer that matches the filter.
     * @param {ChallengeReviewerFindUniqueArgs} args - Arguments to find a ChallengeReviewer
     * @example
     * // Get one ChallengeReviewer
     * const challengeReviewer = await prisma.challengeReviewer.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends ChallengeReviewerFindUniqueArgs>(args: SelectSubset<T, ChallengeReviewerFindUniqueArgs<ExtArgs>>): Prisma__ChallengeReviewerClient<$Result.GetResult<Prisma.$ChallengeReviewerPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one ChallengeReviewer that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {ChallengeReviewerFindUniqueOrThrowArgs} args - Arguments to find a ChallengeReviewer
     * @example
     * // Get one ChallengeReviewer
     * const challengeReviewer = await prisma.challengeReviewer.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends ChallengeReviewerFindUniqueOrThrowArgs>(args: SelectSubset<T, ChallengeReviewerFindUniqueOrThrowArgs<ExtArgs>>): Prisma__ChallengeReviewerClient<$Result.GetResult<Prisma.$ChallengeReviewerPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first ChallengeReviewer that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ChallengeReviewerFindFirstArgs} args - Arguments to find a ChallengeReviewer
     * @example
     * // Get one ChallengeReviewer
     * const challengeReviewer = await prisma.challengeReviewer.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends ChallengeReviewerFindFirstArgs>(args?: SelectSubset<T, ChallengeReviewerFindFirstArgs<ExtArgs>>): Prisma__ChallengeReviewerClient<$Result.GetResult<Prisma.$ChallengeReviewerPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first ChallengeReviewer that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ChallengeReviewerFindFirstOrThrowArgs} args - Arguments to find a ChallengeReviewer
     * @example
     * // Get one ChallengeReviewer
     * const challengeReviewer = await prisma.challengeReviewer.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends ChallengeReviewerFindFirstOrThrowArgs>(args?: SelectSubset<T, ChallengeReviewerFindFirstOrThrowArgs<ExtArgs>>): Prisma__ChallengeReviewerClient<$Result.GetResult<Prisma.$ChallengeReviewerPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more ChallengeReviewers that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ChallengeReviewerFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all ChallengeReviewers
     * const challengeReviewers = await prisma.challengeReviewer.findMany()
     * 
     * // Get first 10 ChallengeReviewers
     * const challengeReviewers = await prisma.challengeReviewer.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const challengeReviewerWithIdOnly = await prisma.challengeReviewer.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends ChallengeReviewerFindManyArgs>(args?: SelectSubset<T, ChallengeReviewerFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ChallengeReviewerPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a ChallengeReviewer.
     * @param {ChallengeReviewerCreateArgs} args - Arguments to create a ChallengeReviewer.
     * @example
     * // Create one ChallengeReviewer
     * const ChallengeReviewer = await prisma.challengeReviewer.create({
     *   data: {
     *     // ... data to create a ChallengeReviewer
     *   }
     * })
     * 
     */
    create<T extends ChallengeReviewerCreateArgs>(args: SelectSubset<T, ChallengeReviewerCreateArgs<ExtArgs>>): Prisma__ChallengeReviewerClient<$Result.GetResult<Prisma.$ChallengeReviewerPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many ChallengeReviewers.
     * @param {ChallengeReviewerCreateManyArgs} args - Arguments to create many ChallengeReviewers.
     * @example
     * // Create many ChallengeReviewers
     * const challengeReviewer = await prisma.challengeReviewer.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends ChallengeReviewerCreateManyArgs>(args?: SelectSubset<T, ChallengeReviewerCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many ChallengeReviewers and returns the data saved in the database.
     * @param {ChallengeReviewerCreateManyAndReturnArgs} args - Arguments to create many ChallengeReviewers.
     * @example
     * // Create many ChallengeReviewers
     * const challengeReviewer = await prisma.challengeReviewer.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many ChallengeReviewers and only return the `id`
     * const challengeReviewerWithIdOnly = await prisma.challengeReviewer.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends ChallengeReviewerCreateManyAndReturnArgs>(args?: SelectSubset<T, ChallengeReviewerCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ChallengeReviewerPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a ChallengeReviewer.
     * @param {ChallengeReviewerDeleteArgs} args - Arguments to delete one ChallengeReviewer.
     * @example
     * // Delete one ChallengeReviewer
     * const ChallengeReviewer = await prisma.challengeReviewer.delete({
     *   where: {
     *     // ... filter to delete one ChallengeReviewer
     *   }
     * })
     * 
     */
    delete<T extends ChallengeReviewerDeleteArgs>(args: SelectSubset<T, ChallengeReviewerDeleteArgs<ExtArgs>>): Prisma__ChallengeReviewerClient<$Result.GetResult<Prisma.$ChallengeReviewerPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one ChallengeReviewer.
     * @param {ChallengeReviewerUpdateArgs} args - Arguments to update one ChallengeReviewer.
     * @example
     * // Update one ChallengeReviewer
     * const challengeReviewer = await prisma.challengeReviewer.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends ChallengeReviewerUpdateArgs>(args: SelectSubset<T, ChallengeReviewerUpdateArgs<ExtArgs>>): Prisma__ChallengeReviewerClient<$Result.GetResult<Prisma.$ChallengeReviewerPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more ChallengeReviewers.
     * @param {ChallengeReviewerDeleteManyArgs} args - Arguments to filter ChallengeReviewers to delete.
     * @example
     * // Delete a few ChallengeReviewers
     * const { count } = await prisma.challengeReviewer.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends ChallengeReviewerDeleteManyArgs>(args?: SelectSubset<T, ChallengeReviewerDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more ChallengeReviewers.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ChallengeReviewerUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many ChallengeReviewers
     * const challengeReviewer = await prisma.challengeReviewer.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends ChallengeReviewerUpdateManyArgs>(args: SelectSubset<T, ChallengeReviewerUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more ChallengeReviewers and returns the data updated in the database.
     * @param {ChallengeReviewerUpdateManyAndReturnArgs} args - Arguments to update many ChallengeReviewers.
     * @example
     * // Update many ChallengeReviewers
     * const challengeReviewer = await prisma.challengeReviewer.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more ChallengeReviewers and only return the `id`
     * const challengeReviewerWithIdOnly = await prisma.challengeReviewer.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends ChallengeReviewerUpdateManyAndReturnArgs>(args: SelectSubset<T, ChallengeReviewerUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ChallengeReviewerPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one ChallengeReviewer.
     * @param {ChallengeReviewerUpsertArgs} args - Arguments to update or create a ChallengeReviewer.
     * @example
     * // Update or create a ChallengeReviewer
     * const challengeReviewer = await prisma.challengeReviewer.upsert({
     *   create: {
     *     // ... data to create a ChallengeReviewer
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the ChallengeReviewer we want to update
     *   }
     * })
     */
    upsert<T extends ChallengeReviewerUpsertArgs>(args: SelectSubset<T, ChallengeReviewerUpsertArgs<ExtArgs>>): Prisma__ChallengeReviewerClient<$Result.GetResult<Prisma.$ChallengeReviewerPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of ChallengeReviewers.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ChallengeReviewerCountArgs} args - Arguments to filter ChallengeReviewers to count.
     * @example
     * // Count the number of ChallengeReviewers
     * const count = await prisma.challengeReviewer.count({
     *   where: {
     *     // ... the filter for the ChallengeReviewers we want to count
     *   }
     * })
    **/
    count<T extends ChallengeReviewerCountArgs>(
      args?: Subset<T, ChallengeReviewerCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ChallengeReviewerCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a ChallengeReviewer.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ChallengeReviewerAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ChallengeReviewerAggregateArgs>(args: Subset<T, ChallengeReviewerAggregateArgs>): Prisma.PrismaPromise<GetChallengeReviewerAggregateType<T>>

    /**
     * Group by ChallengeReviewer.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ChallengeReviewerGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ChallengeReviewerGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ChallengeReviewerGroupByArgs['orderBy'] }
        : { orderBy?: ChallengeReviewerGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ChallengeReviewerGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetChallengeReviewerGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the ChallengeReviewer model
   */
  readonly fields: ChallengeReviewerFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for ChallengeReviewer.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ChallengeReviewerClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    challenge<T extends ChallengeDefaultArgs<ExtArgs> = {}>(args?: Subset<T, ChallengeDefaultArgs<ExtArgs>>): Prisma__ChallengeClient<$Result.GetResult<Prisma.$ChallengePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    phase<T extends PhaseDefaultArgs<ExtArgs> = {}>(args?: Subset<T, PhaseDefaultArgs<ExtArgs>>): Prisma__PhaseClient<$Result.GetResult<Prisma.$PhasePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the ChallengeReviewer model
   */
  interface ChallengeReviewerFieldRefs {
    readonly id: FieldRef<"ChallengeReviewer", 'String'>
    readonly challengeId: FieldRef<"ChallengeReviewer", 'String'>
    readonly scorecardId: FieldRef<"ChallengeReviewer", 'String'>
    readonly isMemberReview: FieldRef<"ChallengeReviewer", 'Boolean'>
    readonly memberReviewerCount: FieldRef<"ChallengeReviewer", 'Int'>
    readonly phaseId: FieldRef<"ChallengeReviewer", 'String'>
    readonly fixedAmount: FieldRef<"ChallengeReviewer", 'Float'>
    readonly baseCoefficient: FieldRef<"ChallengeReviewer", 'Float'>
    readonly incrementalCoefficient: FieldRef<"ChallengeReviewer", 'Float'>
    readonly type: FieldRef<"ChallengeReviewer", 'ReviewOpportunityTypeEnum'>
    readonly aiWorkflowId: FieldRef<"ChallengeReviewer", 'String'>
    readonly shouldOpenOpportunity: FieldRef<"ChallengeReviewer", 'Boolean'>
    readonly createdAt: FieldRef<"ChallengeReviewer", 'DateTime'>
    readonly createdBy: FieldRef<"ChallengeReviewer", 'String'>
    readonly updatedAt: FieldRef<"ChallengeReviewer", 'DateTime'>
    readonly updatedBy: FieldRef<"ChallengeReviewer", 'String'>
  }
    

  // Custom InputTypes
  /**
   * ChallengeReviewer findUnique
   */
  export type ChallengeReviewerFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ChallengeReviewer
     */
    select?: ChallengeReviewerSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ChallengeReviewer
     */
    omit?: ChallengeReviewerOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ChallengeReviewerInclude<ExtArgs> | null
    /**
     * Filter, which ChallengeReviewer to fetch.
     */
    where: ChallengeReviewerWhereUniqueInput
  }

  /**
   * ChallengeReviewer findUniqueOrThrow
   */
  export type ChallengeReviewerFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ChallengeReviewer
     */
    select?: ChallengeReviewerSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ChallengeReviewer
     */
    omit?: ChallengeReviewerOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ChallengeReviewerInclude<ExtArgs> | null
    /**
     * Filter, which ChallengeReviewer to fetch.
     */
    where: ChallengeReviewerWhereUniqueInput
  }

  /**
   * ChallengeReviewer findFirst
   */
  export type ChallengeReviewerFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ChallengeReviewer
     */
    select?: ChallengeReviewerSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ChallengeReviewer
     */
    omit?: ChallengeReviewerOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ChallengeReviewerInclude<ExtArgs> | null
    /**
     * Filter, which ChallengeReviewer to fetch.
     */
    where?: ChallengeReviewerWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ChallengeReviewers to fetch.
     */
    orderBy?: ChallengeReviewerOrderByWithRelationInput | ChallengeReviewerOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ChallengeReviewers.
     */
    cursor?: ChallengeReviewerWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ChallengeReviewers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ChallengeReviewers.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ChallengeReviewers.
     */
    distinct?: ChallengeReviewerScalarFieldEnum | ChallengeReviewerScalarFieldEnum[]
  }

  /**
   * ChallengeReviewer findFirstOrThrow
   */
  export type ChallengeReviewerFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ChallengeReviewer
     */
    select?: ChallengeReviewerSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ChallengeReviewer
     */
    omit?: ChallengeReviewerOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ChallengeReviewerInclude<ExtArgs> | null
    /**
     * Filter, which ChallengeReviewer to fetch.
     */
    where?: ChallengeReviewerWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ChallengeReviewers to fetch.
     */
    orderBy?: ChallengeReviewerOrderByWithRelationInput | ChallengeReviewerOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ChallengeReviewers.
     */
    cursor?: ChallengeReviewerWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ChallengeReviewers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ChallengeReviewers.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ChallengeReviewers.
     */
    distinct?: ChallengeReviewerScalarFieldEnum | ChallengeReviewerScalarFieldEnum[]
  }

  /**
   * ChallengeReviewer findMany
   */
  export type ChallengeReviewerFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ChallengeReviewer
     */
    select?: ChallengeReviewerSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ChallengeReviewer
     */
    omit?: ChallengeReviewerOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ChallengeReviewerInclude<ExtArgs> | null
    /**
     * Filter, which ChallengeReviewers to fetch.
     */
    where?: ChallengeReviewerWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ChallengeReviewers to fetch.
     */
    orderBy?: ChallengeReviewerOrderByWithRelationInput | ChallengeReviewerOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing ChallengeReviewers.
     */
    cursor?: ChallengeReviewerWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ChallengeReviewers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ChallengeReviewers.
     */
    skip?: number
    distinct?: ChallengeReviewerScalarFieldEnum | ChallengeReviewerScalarFieldEnum[]
  }

  /**
   * ChallengeReviewer create
   */
  export type ChallengeReviewerCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ChallengeReviewer
     */
    select?: ChallengeReviewerSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ChallengeReviewer
     */
    omit?: ChallengeReviewerOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ChallengeReviewerInclude<ExtArgs> | null
    /**
     * The data needed to create a ChallengeReviewer.
     */
    data: XOR<ChallengeReviewerCreateInput, ChallengeReviewerUncheckedCreateInput>
  }

  /**
   * ChallengeReviewer createMany
   */
  export type ChallengeReviewerCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many ChallengeReviewers.
     */
    data: ChallengeReviewerCreateManyInput | ChallengeReviewerCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * ChallengeReviewer createManyAndReturn
   */
  export type ChallengeReviewerCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ChallengeReviewer
     */
    select?: ChallengeReviewerSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the ChallengeReviewer
     */
    omit?: ChallengeReviewerOmit<ExtArgs> | null
    /**
     * The data used to create many ChallengeReviewers.
     */
    data: ChallengeReviewerCreateManyInput | ChallengeReviewerCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ChallengeReviewerIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * ChallengeReviewer update
   */
  export type ChallengeReviewerUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ChallengeReviewer
     */
    select?: ChallengeReviewerSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ChallengeReviewer
     */
    omit?: ChallengeReviewerOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ChallengeReviewerInclude<ExtArgs> | null
    /**
     * The data needed to update a ChallengeReviewer.
     */
    data: XOR<ChallengeReviewerUpdateInput, ChallengeReviewerUncheckedUpdateInput>
    /**
     * Choose, which ChallengeReviewer to update.
     */
    where: ChallengeReviewerWhereUniqueInput
  }

  /**
   * ChallengeReviewer updateMany
   */
  export type ChallengeReviewerUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update ChallengeReviewers.
     */
    data: XOR<ChallengeReviewerUpdateManyMutationInput, ChallengeReviewerUncheckedUpdateManyInput>
    /**
     * Filter which ChallengeReviewers to update
     */
    where?: ChallengeReviewerWhereInput
    /**
     * Limit how many ChallengeReviewers to update.
     */
    limit?: number
  }

  /**
   * ChallengeReviewer updateManyAndReturn
   */
  export type ChallengeReviewerUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ChallengeReviewer
     */
    select?: ChallengeReviewerSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the ChallengeReviewer
     */
    omit?: ChallengeReviewerOmit<ExtArgs> | null
    /**
     * The data used to update ChallengeReviewers.
     */
    data: XOR<ChallengeReviewerUpdateManyMutationInput, ChallengeReviewerUncheckedUpdateManyInput>
    /**
     * Filter which ChallengeReviewers to update
     */
    where?: ChallengeReviewerWhereInput
    /**
     * Limit how many ChallengeReviewers to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ChallengeReviewerIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * ChallengeReviewer upsert
   */
  export type ChallengeReviewerUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ChallengeReviewer
     */
    select?: ChallengeReviewerSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ChallengeReviewer
     */
    omit?: ChallengeReviewerOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ChallengeReviewerInclude<ExtArgs> | null
    /**
     * The filter to search for the ChallengeReviewer to update in case it exists.
     */
    where: ChallengeReviewerWhereUniqueInput
    /**
     * In case the ChallengeReviewer found by the `where` argument doesn't exist, create a new ChallengeReviewer with this data.
     */
    create: XOR<ChallengeReviewerCreateInput, ChallengeReviewerUncheckedCreateInput>
    /**
     * In case the ChallengeReviewer was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ChallengeReviewerUpdateInput, ChallengeReviewerUncheckedUpdateInput>
  }

  /**
   * ChallengeReviewer delete
   */
  export type ChallengeReviewerDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ChallengeReviewer
     */
    select?: ChallengeReviewerSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ChallengeReviewer
     */
    omit?: ChallengeReviewerOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ChallengeReviewerInclude<ExtArgs> | null
    /**
     * Filter which ChallengeReviewer to delete.
     */
    where: ChallengeReviewerWhereUniqueInput
  }

  /**
   * ChallengeReviewer deleteMany
   */
  export type ChallengeReviewerDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ChallengeReviewers to delete
     */
    where?: ChallengeReviewerWhereInput
    /**
     * Limit how many ChallengeReviewers to delete.
     */
    limit?: number
  }

  /**
   * ChallengeReviewer without action
   */
  export type ChallengeReviewerDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ChallengeReviewer
     */
    select?: ChallengeReviewerSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ChallengeReviewer
     */
    omit?: ChallengeReviewerOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ChallengeReviewerInclude<ExtArgs> | null
  }


  /**
   * Model DefaultChallengeReviewer
   */

  export type AggregateDefaultChallengeReviewer = {
    _count: DefaultChallengeReviewerCountAggregateOutputType | null
    _avg: DefaultChallengeReviewerAvgAggregateOutputType | null
    _sum: DefaultChallengeReviewerSumAggregateOutputType | null
    _min: DefaultChallengeReviewerMinAggregateOutputType | null
    _max: DefaultChallengeReviewerMaxAggregateOutputType | null
  }

  export type DefaultChallengeReviewerAvgAggregateOutputType = {
    memberReviewerCount: number | null
    fixedAmount: number | null
    baseCoefficient: number | null
    incrementalCoefficient: number | null
  }

  export type DefaultChallengeReviewerSumAggregateOutputType = {
    memberReviewerCount: number | null
    fixedAmount: number | null
    baseCoefficient: number | null
    incrementalCoefficient: number | null
  }

  export type DefaultChallengeReviewerMinAggregateOutputType = {
    id: string | null
    typeId: string | null
    trackId: string | null
    timelineTemplateId: string | null
    scorecardId: string | null
    isMemberReview: boolean | null
    memberReviewerCount: number | null
    phaseName: string | null
    phaseId: string | null
    fixedAmount: number | null
    baseCoefficient: number | null
    incrementalCoefficient: number | null
    opportunityType: $Enums.ReviewOpportunityTypeEnum | null
    aiWorkflowId: string | null
    shouldOpenOpportunity: boolean | null
    createdAt: Date | null
    createdBy: string | null
    updatedAt: Date | null
    updatedBy: string | null
  }

  export type DefaultChallengeReviewerMaxAggregateOutputType = {
    id: string | null
    typeId: string | null
    trackId: string | null
    timelineTemplateId: string | null
    scorecardId: string | null
    isMemberReview: boolean | null
    memberReviewerCount: number | null
    phaseName: string | null
    phaseId: string | null
    fixedAmount: number | null
    baseCoefficient: number | null
    incrementalCoefficient: number | null
    opportunityType: $Enums.ReviewOpportunityTypeEnum | null
    aiWorkflowId: string | null
    shouldOpenOpportunity: boolean | null
    createdAt: Date | null
    createdBy: string | null
    updatedAt: Date | null
    updatedBy: string | null
  }

  export type DefaultChallengeReviewerCountAggregateOutputType = {
    id: number
    typeId: number
    trackId: number
    timelineTemplateId: number
    scorecardId: number
    isMemberReview: number
    memberReviewerCount: number
    phaseName: number
    phaseId: number
    fixedAmount: number
    baseCoefficient: number
    incrementalCoefficient: number
    opportunityType: number
    aiWorkflowId: number
    shouldOpenOpportunity: number
    createdAt: number
    createdBy: number
    updatedAt: number
    updatedBy: number
    _all: number
  }


  export type DefaultChallengeReviewerAvgAggregateInputType = {
    memberReviewerCount?: true
    fixedAmount?: true
    baseCoefficient?: true
    incrementalCoefficient?: true
  }

  export type DefaultChallengeReviewerSumAggregateInputType = {
    memberReviewerCount?: true
    fixedAmount?: true
    baseCoefficient?: true
    incrementalCoefficient?: true
  }

  export type DefaultChallengeReviewerMinAggregateInputType = {
    id?: true
    typeId?: true
    trackId?: true
    timelineTemplateId?: true
    scorecardId?: true
    isMemberReview?: true
    memberReviewerCount?: true
    phaseName?: true
    phaseId?: true
    fixedAmount?: true
    baseCoefficient?: true
    incrementalCoefficient?: true
    opportunityType?: true
    aiWorkflowId?: true
    shouldOpenOpportunity?: true
    createdAt?: true
    createdBy?: true
    updatedAt?: true
    updatedBy?: true
  }

  export type DefaultChallengeReviewerMaxAggregateInputType = {
    id?: true
    typeId?: true
    trackId?: true
    timelineTemplateId?: true
    scorecardId?: true
    isMemberReview?: true
    memberReviewerCount?: true
    phaseName?: true
    phaseId?: true
    fixedAmount?: true
    baseCoefficient?: true
    incrementalCoefficient?: true
    opportunityType?: true
    aiWorkflowId?: true
    shouldOpenOpportunity?: true
    createdAt?: true
    createdBy?: true
    updatedAt?: true
    updatedBy?: true
  }

  export type DefaultChallengeReviewerCountAggregateInputType = {
    id?: true
    typeId?: true
    trackId?: true
    timelineTemplateId?: true
    scorecardId?: true
    isMemberReview?: true
    memberReviewerCount?: true
    phaseName?: true
    phaseId?: true
    fixedAmount?: true
    baseCoefficient?: true
    incrementalCoefficient?: true
    opportunityType?: true
    aiWorkflowId?: true
    shouldOpenOpportunity?: true
    createdAt?: true
    createdBy?: true
    updatedAt?: true
    updatedBy?: true
    _all?: true
  }

  export type DefaultChallengeReviewerAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which DefaultChallengeReviewer to aggregate.
     */
    where?: DefaultChallengeReviewerWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of DefaultChallengeReviewers to fetch.
     */
    orderBy?: DefaultChallengeReviewerOrderByWithRelationInput | DefaultChallengeReviewerOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: DefaultChallengeReviewerWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` DefaultChallengeReviewers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` DefaultChallengeReviewers.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned DefaultChallengeReviewers
    **/
    _count?: true | DefaultChallengeReviewerCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: DefaultChallengeReviewerAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: DefaultChallengeReviewerSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: DefaultChallengeReviewerMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: DefaultChallengeReviewerMaxAggregateInputType
  }

  export type GetDefaultChallengeReviewerAggregateType<T extends DefaultChallengeReviewerAggregateArgs> = {
        [P in keyof T & keyof AggregateDefaultChallengeReviewer]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateDefaultChallengeReviewer[P]>
      : GetScalarType<T[P], AggregateDefaultChallengeReviewer[P]>
  }




  export type DefaultChallengeReviewerGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: DefaultChallengeReviewerWhereInput
    orderBy?: DefaultChallengeReviewerOrderByWithAggregationInput | DefaultChallengeReviewerOrderByWithAggregationInput[]
    by: DefaultChallengeReviewerScalarFieldEnum[] | DefaultChallengeReviewerScalarFieldEnum
    having?: DefaultChallengeReviewerScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: DefaultChallengeReviewerCountAggregateInputType | true
    _avg?: DefaultChallengeReviewerAvgAggregateInputType
    _sum?: DefaultChallengeReviewerSumAggregateInputType
    _min?: DefaultChallengeReviewerMinAggregateInputType
    _max?: DefaultChallengeReviewerMaxAggregateInputType
  }

  export type DefaultChallengeReviewerGroupByOutputType = {
    id: string
    typeId: string
    trackId: string
    timelineTemplateId: string | null
    scorecardId: string | null
    isMemberReview: boolean
    memberReviewerCount: number | null
    phaseName: string
    phaseId: string | null
    fixedAmount: number | null
    baseCoefficient: number | null
    incrementalCoefficient: number | null
    opportunityType: $Enums.ReviewOpportunityTypeEnum | null
    aiWorkflowId: string | null
    shouldOpenOpportunity: boolean
    createdAt: Date
    createdBy: string
    updatedAt: Date
    updatedBy: string
    _count: DefaultChallengeReviewerCountAggregateOutputType | null
    _avg: DefaultChallengeReviewerAvgAggregateOutputType | null
    _sum: DefaultChallengeReviewerSumAggregateOutputType | null
    _min: DefaultChallengeReviewerMinAggregateOutputType | null
    _max: DefaultChallengeReviewerMaxAggregateOutputType | null
  }

  type GetDefaultChallengeReviewerGroupByPayload<T extends DefaultChallengeReviewerGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<DefaultChallengeReviewerGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof DefaultChallengeReviewerGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], DefaultChallengeReviewerGroupByOutputType[P]>
            : GetScalarType<T[P], DefaultChallengeReviewerGroupByOutputType[P]>
        }
      >
    >


  export type DefaultChallengeReviewerSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    typeId?: boolean
    trackId?: boolean
    timelineTemplateId?: boolean
    scorecardId?: boolean
    isMemberReview?: boolean
    memberReviewerCount?: boolean
    phaseName?: boolean
    phaseId?: boolean
    fixedAmount?: boolean
    baseCoefficient?: boolean
    incrementalCoefficient?: boolean
    opportunityType?: boolean
    aiWorkflowId?: boolean
    shouldOpenOpportunity?: boolean
    createdAt?: boolean
    createdBy?: boolean
    updatedAt?: boolean
    updatedBy?: boolean
    challengeType?: boolean | ChallengeTypeDefaultArgs<ExtArgs>
    challengeTrack?: boolean | ChallengeTrackDefaultArgs<ExtArgs>
    timelineTemplate?: boolean | DefaultChallengeReviewer$timelineTemplateArgs<ExtArgs>
    phase?: boolean | DefaultChallengeReviewer$phaseArgs<ExtArgs>
  }, ExtArgs["result"]["defaultChallengeReviewer"]>

  export type DefaultChallengeReviewerSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    typeId?: boolean
    trackId?: boolean
    timelineTemplateId?: boolean
    scorecardId?: boolean
    isMemberReview?: boolean
    memberReviewerCount?: boolean
    phaseName?: boolean
    phaseId?: boolean
    fixedAmount?: boolean
    baseCoefficient?: boolean
    incrementalCoefficient?: boolean
    opportunityType?: boolean
    aiWorkflowId?: boolean
    shouldOpenOpportunity?: boolean
    createdAt?: boolean
    createdBy?: boolean
    updatedAt?: boolean
    updatedBy?: boolean
    challengeType?: boolean | ChallengeTypeDefaultArgs<ExtArgs>
    challengeTrack?: boolean | ChallengeTrackDefaultArgs<ExtArgs>
    timelineTemplate?: boolean | DefaultChallengeReviewer$timelineTemplateArgs<ExtArgs>
    phase?: boolean | DefaultChallengeReviewer$phaseArgs<ExtArgs>
  }, ExtArgs["result"]["defaultChallengeReviewer"]>

  export type DefaultChallengeReviewerSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    typeId?: boolean
    trackId?: boolean
    timelineTemplateId?: boolean
    scorecardId?: boolean
    isMemberReview?: boolean
    memberReviewerCount?: boolean
    phaseName?: boolean
    phaseId?: boolean
    fixedAmount?: boolean
    baseCoefficient?: boolean
    incrementalCoefficient?: boolean
    opportunityType?: boolean
    aiWorkflowId?: boolean
    shouldOpenOpportunity?: boolean
    createdAt?: boolean
    createdBy?: boolean
    updatedAt?: boolean
    updatedBy?: boolean
    challengeType?: boolean | ChallengeTypeDefaultArgs<ExtArgs>
    challengeTrack?: boolean | ChallengeTrackDefaultArgs<ExtArgs>
    timelineTemplate?: boolean | DefaultChallengeReviewer$timelineTemplateArgs<ExtArgs>
    phase?: boolean | DefaultChallengeReviewer$phaseArgs<ExtArgs>
  }, ExtArgs["result"]["defaultChallengeReviewer"]>

  export type DefaultChallengeReviewerSelectScalar = {
    id?: boolean
    typeId?: boolean
    trackId?: boolean
    timelineTemplateId?: boolean
    scorecardId?: boolean
    isMemberReview?: boolean
    memberReviewerCount?: boolean
    phaseName?: boolean
    phaseId?: boolean
    fixedAmount?: boolean
    baseCoefficient?: boolean
    incrementalCoefficient?: boolean
    opportunityType?: boolean
    aiWorkflowId?: boolean
    shouldOpenOpportunity?: boolean
    createdAt?: boolean
    createdBy?: boolean
    updatedAt?: boolean
    updatedBy?: boolean
  }

  export type DefaultChallengeReviewerOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "typeId" | "trackId" | "timelineTemplateId" | "scorecardId" | "isMemberReview" | "memberReviewerCount" | "phaseName" | "phaseId" | "fixedAmount" | "baseCoefficient" | "incrementalCoefficient" | "opportunityType" | "aiWorkflowId" | "shouldOpenOpportunity" | "createdAt" | "createdBy" | "updatedAt" | "updatedBy", ExtArgs["result"]["defaultChallengeReviewer"]>
  export type DefaultChallengeReviewerInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    challengeType?: boolean | ChallengeTypeDefaultArgs<ExtArgs>
    challengeTrack?: boolean | ChallengeTrackDefaultArgs<ExtArgs>
    timelineTemplate?: boolean | DefaultChallengeReviewer$timelineTemplateArgs<ExtArgs>
    phase?: boolean | DefaultChallengeReviewer$phaseArgs<ExtArgs>
  }
  export type DefaultChallengeReviewerIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    challengeType?: boolean | ChallengeTypeDefaultArgs<ExtArgs>
    challengeTrack?: boolean | ChallengeTrackDefaultArgs<ExtArgs>
    timelineTemplate?: boolean | DefaultChallengeReviewer$timelineTemplateArgs<ExtArgs>
    phase?: boolean | DefaultChallengeReviewer$phaseArgs<ExtArgs>
  }
  export type DefaultChallengeReviewerIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    challengeType?: boolean | ChallengeTypeDefaultArgs<ExtArgs>
    challengeTrack?: boolean | ChallengeTrackDefaultArgs<ExtArgs>
    timelineTemplate?: boolean | DefaultChallengeReviewer$timelineTemplateArgs<ExtArgs>
    phase?: boolean | DefaultChallengeReviewer$phaseArgs<ExtArgs>
  }

  export type $DefaultChallengeReviewerPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "DefaultChallengeReviewer"
    objects: {
      challengeType: Prisma.$ChallengeTypePayload<ExtArgs>
      challengeTrack: Prisma.$ChallengeTrackPayload<ExtArgs>
      timelineTemplate: Prisma.$TimelineTemplatePayload<ExtArgs> | null
      phase: Prisma.$PhasePayload<ExtArgs> | null
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      typeId: string
      trackId: string
      timelineTemplateId: string | null
      scorecardId: string | null
      isMemberReview: boolean
      memberReviewerCount: number | null
      phaseName: string
      phaseId: string | null
      fixedAmount: number | null
      baseCoefficient: number | null
      incrementalCoefficient: number | null
      opportunityType: $Enums.ReviewOpportunityTypeEnum | null
      aiWorkflowId: string | null
      shouldOpenOpportunity: boolean
      createdAt: Date
      createdBy: string
      updatedAt: Date
      updatedBy: string
    }, ExtArgs["result"]["defaultChallengeReviewer"]>
    composites: {}
  }

  type DefaultChallengeReviewerGetPayload<S extends boolean | null | undefined | DefaultChallengeReviewerDefaultArgs> = $Result.GetResult<Prisma.$DefaultChallengeReviewerPayload, S>

  type DefaultChallengeReviewerCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<DefaultChallengeReviewerFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: DefaultChallengeReviewerCountAggregateInputType | true
    }

  export interface DefaultChallengeReviewerDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['DefaultChallengeReviewer'], meta: { name: 'DefaultChallengeReviewer' } }
    /**
     * Find zero or one DefaultChallengeReviewer that matches the filter.
     * @param {DefaultChallengeReviewerFindUniqueArgs} args - Arguments to find a DefaultChallengeReviewer
     * @example
     * // Get one DefaultChallengeReviewer
     * const defaultChallengeReviewer = await prisma.defaultChallengeReviewer.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends DefaultChallengeReviewerFindUniqueArgs>(args: SelectSubset<T, DefaultChallengeReviewerFindUniqueArgs<ExtArgs>>): Prisma__DefaultChallengeReviewerClient<$Result.GetResult<Prisma.$DefaultChallengeReviewerPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one DefaultChallengeReviewer that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {DefaultChallengeReviewerFindUniqueOrThrowArgs} args - Arguments to find a DefaultChallengeReviewer
     * @example
     * // Get one DefaultChallengeReviewer
     * const defaultChallengeReviewer = await prisma.defaultChallengeReviewer.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends DefaultChallengeReviewerFindUniqueOrThrowArgs>(args: SelectSubset<T, DefaultChallengeReviewerFindUniqueOrThrowArgs<ExtArgs>>): Prisma__DefaultChallengeReviewerClient<$Result.GetResult<Prisma.$DefaultChallengeReviewerPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first DefaultChallengeReviewer that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DefaultChallengeReviewerFindFirstArgs} args - Arguments to find a DefaultChallengeReviewer
     * @example
     * // Get one DefaultChallengeReviewer
     * const defaultChallengeReviewer = await prisma.defaultChallengeReviewer.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends DefaultChallengeReviewerFindFirstArgs>(args?: SelectSubset<T, DefaultChallengeReviewerFindFirstArgs<ExtArgs>>): Prisma__DefaultChallengeReviewerClient<$Result.GetResult<Prisma.$DefaultChallengeReviewerPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first DefaultChallengeReviewer that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DefaultChallengeReviewerFindFirstOrThrowArgs} args - Arguments to find a DefaultChallengeReviewer
     * @example
     * // Get one DefaultChallengeReviewer
     * const defaultChallengeReviewer = await prisma.defaultChallengeReviewer.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends DefaultChallengeReviewerFindFirstOrThrowArgs>(args?: SelectSubset<T, DefaultChallengeReviewerFindFirstOrThrowArgs<ExtArgs>>): Prisma__DefaultChallengeReviewerClient<$Result.GetResult<Prisma.$DefaultChallengeReviewerPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more DefaultChallengeReviewers that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DefaultChallengeReviewerFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all DefaultChallengeReviewers
     * const defaultChallengeReviewers = await prisma.defaultChallengeReviewer.findMany()
     * 
     * // Get first 10 DefaultChallengeReviewers
     * const defaultChallengeReviewers = await prisma.defaultChallengeReviewer.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const defaultChallengeReviewerWithIdOnly = await prisma.defaultChallengeReviewer.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends DefaultChallengeReviewerFindManyArgs>(args?: SelectSubset<T, DefaultChallengeReviewerFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$DefaultChallengeReviewerPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a DefaultChallengeReviewer.
     * @param {DefaultChallengeReviewerCreateArgs} args - Arguments to create a DefaultChallengeReviewer.
     * @example
     * // Create one DefaultChallengeReviewer
     * const DefaultChallengeReviewer = await prisma.defaultChallengeReviewer.create({
     *   data: {
     *     // ... data to create a DefaultChallengeReviewer
     *   }
     * })
     * 
     */
    create<T extends DefaultChallengeReviewerCreateArgs>(args: SelectSubset<T, DefaultChallengeReviewerCreateArgs<ExtArgs>>): Prisma__DefaultChallengeReviewerClient<$Result.GetResult<Prisma.$DefaultChallengeReviewerPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many DefaultChallengeReviewers.
     * @param {DefaultChallengeReviewerCreateManyArgs} args - Arguments to create many DefaultChallengeReviewers.
     * @example
     * // Create many DefaultChallengeReviewers
     * const defaultChallengeReviewer = await prisma.defaultChallengeReviewer.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends DefaultChallengeReviewerCreateManyArgs>(args?: SelectSubset<T, DefaultChallengeReviewerCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many DefaultChallengeReviewers and returns the data saved in the database.
     * @param {DefaultChallengeReviewerCreateManyAndReturnArgs} args - Arguments to create many DefaultChallengeReviewers.
     * @example
     * // Create many DefaultChallengeReviewers
     * const defaultChallengeReviewer = await prisma.defaultChallengeReviewer.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many DefaultChallengeReviewers and only return the `id`
     * const defaultChallengeReviewerWithIdOnly = await prisma.defaultChallengeReviewer.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends DefaultChallengeReviewerCreateManyAndReturnArgs>(args?: SelectSubset<T, DefaultChallengeReviewerCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$DefaultChallengeReviewerPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a DefaultChallengeReviewer.
     * @param {DefaultChallengeReviewerDeleteArgs} args - Arguments to delete one DefaultChallengeReviewer.
     * @example
     * // Delete one DefaultChallengeReviewer
     * const DefaultChallengeReviewer = await prisma.defaultChallengeReviewer.delete({
     *   where: {
     *     // ... filter to delete one DefaultChallengeReviewer
     *   }
     * })
     * 
     */
    delete<T extends DefaultChallengeReviewerDeleteArgs>(args: SelectSubset<T, DefaultChallengeReviewerDeleteArgs<ExtArgs>>): Prisma__DefaultChallengeReviewerClient<$Result.GetResult<Prisma.$DefaultChallengeReviewerPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one DefaultChallengeReviewer.
     * @param {DefaultChallengeReviewerUpdateArgs} args - Arguments to update one DefaultChallengeReviewer.
     * @example
     * // Update one DefaultChallengeReviewer
     * const defaultChallengeReviewer = await prisma.defaultChallengeReviewer.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends DefaultChallengeReviewerUpdateArgs>(args: SelectSubset<T, DefaultChallengeReviewerUpdateArgs<ExtArgs>>): Prisma__DefaultChallengeReviewerClient<$Result.GetResult<Prisma.$DefaultChallengeReviewerPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more DefaultChallengeReviewers.
     * @param {DefaultChallengeReviewerDeleteManyArgs} args - Arguments to filter DefaultChallengeReviewers to delete.
     * @example
     * // Delete a few DefaultChallengeReviewers
     * const { count } = await prisma.defaultChallengeReviewer.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends DefaultChallengeReviewerDeleteManyArgs>(args?: SelectSubset<T, DefaultChallengeReviewerDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more DefaultChallengeReviewers.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DefaultChallengeReviewerUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many DefaultChallengeReviewers
     * const defaultChallengeReviewer = await prisma.defaultChallengeReviewer.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends DefaultChallengeReviewerUpdateManyArgs>(args: SelectSubset<T, DefaultChallengeReviewerUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more DefaultChallengeReviewers and returns the data updated in the database.
     * @param {DefaultChallengeReviewerUpdateManyAndReturnArgs} args - Arguments to update many DefaultChallengeReviewers.
     * @example
     * // Update many DefaultChallengeReviewers
     * const defaultChallengeReviewer = await prisma.defaultChallengeReviewer.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more DefaultChallengeReviewers and only return the `id`
     * const defaultChallengeReviewerWithIdOnly = await prisma.defaultChallengeReviewer.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends DefaultChallengeReviewerUpdateManyAndReturnArgs>(args: SelectSubset<T, DefaultChallengeReviewerUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$DefaultChallengeReviewerPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one DefaultChallengeReviewer.
     * @param {DefaultChallengeReviewerUpsertArgs} args - Arguments to update or create a DefaultChallengeReviewer.
     * @example
     * // Update or create a DefaultChallengeReviewer
     * const defaultChallengeReviewer = await prisma.defaultChallengeReviewer.upsert({
     *   create: {
     *     // ... data to create a DefaultChallengeReviewer
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the DefaultChallengeReviewer we want to update
     *   }
     * })
     */
    upsert<T extends DefaultChallengeReviewerUpsertArgs>(args: SelectSubset<T, DefaultChallengeReviewerUpsertArgs<ExtArgs>>): Prisma__DefaultChallengeReviewerClient<$Result.GetResult<Prisma.$DefaultChallengeReviewerPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of DefaultChallengeReviewers.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DefaultChallengeReviewerCountArgs} args - Arguments to filter DefaultChallengeReviewers to count.
     * @example
     * // Count the number of DefaultChallengeReviewers
     * const count = await prisma.defaultChallengeReviewer.count({
     *   where: {
     *     // ... the filter for the DefaultChallengeReviewers we want to count
     *   }
     * })
    **/
    count<T extends DefaultChallengeReviewerCountArgs>(
      args?: Subset<T, DefaultChallengeReviewerCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], DefaultChallengeReviewerCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a DefaultChallengeReviewer.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DefaultChallengeReviewerAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends DefaultChallengeReviewerAggregateArgs>(args: Subset<T, DefaultChallengeReviewerAggregateArgs>): Prisma.PrismaPromise<GetDefaultChallengeReviewerAggregateType<T>>

    /**
     * Group by DefaultChallengeReviewer.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DefaultChallengeReviewerGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends DefaultChallengeReviewerGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: DefaultChallengeReviewerGroupByArgs['orderBy'] }
        : { orderBy?: DefaultChallengeReviewerGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, DefaultChallengeReviewerGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetDefaultChallengeReviewerGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the DefaultChallengeReviewer model
   */
  readonly fields: DefaultChallengeReviewerFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for DefaultChallengeReviewer.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__DefaultChallengeReviewerClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    challengeType<T extends ChallengeTypeDefaultArgs<ExtArgs> = {}>(args?: Subset<T, ChallengeTypeDefaultArgs<ExtArgs>>): Prisma__ChallengeTypeClient<$Result.GetResult<Prisma.$ChallengeTypePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    challengeTrack<T extends ChallengeTrackDefaultArgs<ExtArgs> = {}>(args?: Subset<T, ChallengeTrackDefaultArgs<ExtArgs>>): Prisma__ChallengeTrackClient<$Result.GetResult<Prisma.$ChallengeTrackPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    timelineTemplate<T extends DefaultChallengeReviewer$timelineTemplateArgs<ExtArgs> = {}>(args?: Subset<T, DefaultChallengeReviewer$timelineTemplateArgs<ExtArgs>>): Prisma__TimelineTemplateClient<$Result.GetResult<Prisma.$TimelineTemplatePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    phase<T extends DefaultChallengeReviewer$phaseArgs<ExtArgs> = {}>(args?: Subset<T, DefaultChallengeReviewer$phaseArgs<ExtArgs>>): Prisma__PhaseClient<$Result.GetResult<Prisma.$PhasePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the DefaultChallengeReviewer model
   */
  interface DefaultChallengeReviewerFieldRefs {
    readonly id: FieldRef<"DefaultChallengeReviewer", 'String'>
    readonly typeId: FieldRef<"DefaultChallengeReviewer", 'String'>
    readonly trackId: FieldRef<"DefaultChallengeReviewer", 'String'>
    readonly timelineTemplateId: FieldRef<"DefaultChallengeReviewer", 'String'>
    readonly scorecardId: FieldRef<"DefaultChallengeReviewer", 'String'>
    readonly isMemberReview: FieldRef<"DefaultChallengeReviewer", 'Boolean'>
    readonly memberReviewerCount: FieldRef<"DefaultChallengeReviewer", 'Int'>
    readonly phaseName: FieldRef<"DefaultChallengeReviewer", 'String'>
    readonly phaseId: FieldRef<"DefaultChallengeReviewer", 'String'>
    readonly fixedAmount: FieldRef<"DefaultChallengeReviewer", 'Float'>
    readonly baseCoefficient: FieldRef<"DefaultChallengeReviewer", 'Float'>
    readonly incrementalCoefficient: FieldRef<"DefaultChallengeReviewer", 'Float'>
    readonly opportunityType: FieldRef<"DefaultChallengeReviewer", 'ReviewOpportunityTypeEnum'>
    readonly aiWorkflowId: FieldRef<"DefaultChallengeReviewer", 'String'>
    readonly shouldOpenOpportunity: FieldRef<"DefaultChallengeReviewer", 'Boolean'>
    readonly createdAt: FieldRef<"DefaultChallengeReviewer", 'DateTime'>
    readonly createdBy: FieldRef<"DefaultChallengeReviewer", 'String'>
    readonly updatedAt: FieldRef<"DefaultChallengeReviewer", 'DateTime'>
    readonly updatedBy: FieldRef<"DefaultChallengeReviewer", 'String'>
  }
    

  // Custom InputTypes
  /**
   * DefaultChallengeReviewer findUnique
   */
  export type DefaultChallengeReviewerFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DefaultChallengeReviewer
     */
    select?: DefaultChallengeReviewerSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DefaultChallengeReviewer
     */
    omit?: DefaultChallengeReviewerOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DefaultChallengeReviewerInclude<ExtArgs> | null
    /**
     * Filter, which DefaultChallengeReviewer to fetch.
     */
    where: DefaultChallengeReviewerWhereUniqueInput
  }

  /**
   * DefaultChallengeReviewer findUniqueOrThrow
   */
  export type DefaultChallengeReviewerFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DefaultChallengeReviewer
     */
    select?: DefaultChallengeReviewerSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DefaultChallengeReviewer
     */
    omit?: DefaultChallengeReviewerOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DefaultChallengeReviewerInclude<ExtArgs> | null
    /**
     * Filter, which DefaultChallengeReviewer to fetch.
     */
    where: DefaultChallengeReviewerWhereUniqueInput
  }

  /**
   * DefaultChallengeReviewer findFirst
   */
  export type DefaultChallengeReviewerFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DefaultChallengeReviewer
     */
    select?: DefaultChallengeReviewerSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DefaultChallengeReviewer
     */
    omit?: DefaultChallengeReviewerOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DefaultChallengeReviewerInclude<ExtArgs> | null
    /**
     * Filter, which DefaultChallengeReviewer to fetch.
     */
    where?: DefaultChallengeReviewerWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of DefaultChallengeReviewers to fetch.
     */
    orderBy?: DefaultChallengeReviewerOrderByWithRelationInput | DefaultChallengeReviewerOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for DefaultChallengeReviewers.
     */
    cursor?: DefaultChallengeReviewerWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` DefaultChallengeReviewers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` DefaultChallengeReviewers.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of DefaultChallengeReviewers.
     */
    distinct?: DefaultChallengeReviewerScalarFieldEnum | DefaultChallengeReviewerScalarFieldEnum[]
  }

  /**
   * DefaultChallengeReviewer findFirstOrThrow
   */
  export type DefaultChallengeReviewerFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DefaultChallengeReviewer
     */
    select?: DefaultChallengeReviewerSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DefaultChallengeReviewer
     */
    omit?: DefaultChallengeReviewerOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DefaultChallengeReviewerInclude<ExtArgs> | null
    /**
     * Filter, which DefaultChallengeReviewer to fetch.
     */
    where?: DefaultChallengeReviewerWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of DefaultChallengeReviewers to fetch.
     */
    orderBy?: DefaultChallengeReviewerOrderByWithRelationInput | DefaultChallengeReviewerOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for DefaultChallengeReviewers.
     */
    cursor?: DefaultChallengeReviewerWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` DefaultChallengeReviewers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` DefaultChallengeReviewers.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of DefaultChallengeReviewers.
     */
    distinct?: DefaultChallengeReviewerScalarFieldEnum | DefaultChallengeReviewerScalarFieldEnum[]
  }

  /**
   * DefaultChallengeReviewer findMany
   */
  export type DefaultChallengeReviewerFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DefaultChallengeReviewer
     */
    select?: DefaultChallengeReviewerSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DefaultChallengeReviewer
     */
    omit?: DefaultChallengeReviewerOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DefaultChallengeReviewerInclude<ExtArgs> | null
    /**
     * Filter, which DefaultChallengeReviewers to fetch.
     */
    where?: DefaultChallengeReviewerWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of DefaultChallengeReviewers to fetch.
     */
    orderBy?: DefaultChallengeReviewerOrderByWithRelationInput | DefaultChallengeReviewerOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing DefaultChallengeReviewers.
     */
    cursor?: DefaultChallengeReviewerWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` DefaultChallengeReviewers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` DefaultChallengeReviewers.
     */
    skip?: number
    distinct?: DefaultChallengeReviewerScalarFieldEnum | DefaultChallengeReviewerScalarFieldEnum[]
  }

  /**
   * DefaultChallengeReviewer create
   */
  export type DefaultChallengeReviewerCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DefaultChallengeReviewer
     */
    select?: DefaultChallengeReviewerSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DefaultChallengeReviewer
     */
    omit?: DefaultChallengeReviewerOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DefaultChallengeReviewerInclude<ExtArgs> | null
    /**
     * The data needed to create a DefaultChallengeReviewer.
     */
    data: XOR<DefaultChallengeReviewerCreateInput, DefaultChallengeReviewerUncheckedCreateInput>
  }

  /**
   * DefaultChallengeReviewer createMany
   */
  export type DefaultChallengeReviewerCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many DefaultChallengeReviewers.
     */
    data: DefaultChallengeReviewerCreateManyInput | DefaultChallengeReviewerCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * DefaultChallengeReviewer createManyAndReturn
   */
  export type DefaultChallengeReviewerCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DefaultChallengeReviewer
     */
    select?: DefaultChallengeReviewerSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the DefaultChallengeReviewer
     */
    omit?: DefaultChallengeReviewerOmit<ExtArgs> | null
    /**
     * The data used to create many DefaultChallengeReviewers.
     */
    data: DefaultChallengeReviewerCreateManyInput | DefaultChallengeReviewerCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DefaultChallengeReviewerIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * DefaultChallengeReviewer update
   */
  export type DefaultChallengeReviewerUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DefaultChallengeReviewer
     */
    select?: DefaultChallengeReviewerSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DefaultChallengeReviewer
     */
    omit?: DefaultChallengeReviewerOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DefaultChallengeReviewerInclude<ExtArgs> | null
    /**
     * The data needed to update a DefaultChallengeReviewer.
     */
    data: XOR<DefaultChallengeReviewerUpdateInput, DefaultChallengeReviewerUncheckedUpdateInput>
    /**
     * Choose, which DefaultChallengeReviewer to update.
     */
    where: DefaultChallengeReviewerWhereUniqueInput
  }

  /**
   * DefaultChallengeReviewer updateMany
   */
  export type DefaultChallengeReviewerUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update DefaultChallengeReviewers.
     */
    data: XOR<DefaultChallengeReviewerUpdateManyMutationInput, DefaultChallengeReviewerUncheckedUpdateManyInput>
    /**
     * Filter which DefaultChallengeReviewers to update
     */
    where?: DefaultChallengeReviewerWhereInput
    /**
     * Limit how many DefaultChallengeReviewers to update.
     */
    limit?: number
  }

  /**
   * DefaultChallengeReviewer updateManyAndReturn
   */
  export type DefaultChallengeReviewerUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DefaultChallengeReviewer
     */
    select?: DefaultChallengeReviewerSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the DefaultChallengeReviewer
     */
    omit?: DefaultChallengeReviewerOmit<ExtArgs> | null
    /**
     * The data used to update DefaultChallengeReviewers.
     */
    data: XOR<DefaultChallengeReviewerUpdateManyMutationInput, DefaultChallengeReviewerUncheckedUpdateManyInput>
    /**
     * Filter which DefaultChallengeReviewers to update
     */
    where?: DefaultChallengeReviewerWhereInput
    /**
     * Limit how many DefaultChallengeReviewers to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DefaultChallengeReviewerIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * DefaultChallengeReviewer upsert
   */
  export type DefaultChallengeReviewerUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DefaultChallengeReviewer
     */
    select?: DefaultChallengeReviewerSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DefaultChallengeReviewer
     */
    omit?: DefaultChallengeReviewerOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DefaultChallengeReviewerInclude<ExtArgs> | null
    /**
     * The filter to search for the DefaultChallengeReviewer to update in case it exists.
     */
    where: DefaultChallengeReviewerWhereUniqueInput
    /**
     * In case the DefaultChallengeReviewer found by the `where` argument doesn't exist, create a new DefaultChallengeReviewer with this data.
     */
    create: XOR<DefaultChallengeReviewerCreateInput, DefaultChallengeReviewerUncheckedCreateInput>
    /**
     * In case the DefaultChallengeReviewer was found with the provided `where` argument, update it with this data.
     */
    update: XOR<DefaultChallengeReviewerUpdateInput, DefaultChallengeReviewerUncheckedUpdateInput>
  }

  /**
   * DefaultChallengeReviewer delete
   */
  export type DefaultChallengeReviewerDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DefaultChallengeReviewer
     */
    select?: DefaultChallengeReviewerSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DefaultChallengeReviewer
     */
    omit?: DefaultChallengeReviewerOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DefaultChallengeReviewerInclude<ExtArgs> | null
    /**
     * Filter which DefaultChallengeReviewer to delete.
     */
    where: DefaultChallengeReviewerWhereUniqueInput
  }

  /**
   * DefaultChallengeReviewer deleteMany
   */
  export type DefaultChallengeReviewerDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which DefaultChallengeReviewers to delete
     */
    where?: DefaultChallengeReviewerWhereInput
    /**
     * Limit how many DefaultChallengeReviewers to delete.
     */
    limit?: number
  }

  /**
   * DefaultChallengeReviewer.timelineTemplate
   */
  export type DefaultChallengeReviewer$timelineTemplateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TimelineTemplate
     */
    select?: TimelineTemplateSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TimelineTemplate
     */
    omit?: TimelineTemplateOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TimelineTemplateInclude<ExtArgs> | null
    where?: TimelineTemplateWhereInput
  }

  /**
   * DefaultChallengeReviewer.phase
   */
  export type DefaultChallengeReviewer$phaseArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Phase
     */
    select?: PhaseSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Phase
     */
    omit?: PhaseOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PhaseInclude<ExtArgs> | null
    where?: PhaseWhereInput
  }

  /**
   * DefaultChallengeReviewer without action
   */
  export type DefaultChallengeReviewerDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DefaultChallengeReviewer
     */
    select?: DefaultChallengeReviewerSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DefaultChallengeReviewer
     */
    omit?: DefaultChallengeReviewerOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DefaultChallengeReviewerInclude<ExtArgs> | null
  }


  /**
   * Model TimelineTemplate
   */

  export type AggregateTimelineTemplate = {
    _count: TimelineTemplateCountAggregateOutputType | null
    _min: TimelineTemplateMinAggregateOutputType | null
    _max: TimelineTemplateMaxAggregateOutputType | null
  }

  export type TimelineTemplateMinAggregateOutputType = {
    id: string | null
    name: string | null
    description: string | null
    isActive: boolean | null
    createdAt: Date | null
    createdBy: string | null
    updatedAt: Date | null
    updatedBy: string | null
  }

  export type TimelineTemplateMaxAggregateOutputType = {
    id: string | null
    name: string | null
    description: string | null
    isActive: boolean | null
    createdAt: Date | null
    createdBy: string | null
    updatedAt: Date | null
    updatedBy: string | null
  }

  export type TimelineTemplateCountAggregateOutputType = {
    id: number
    name: number
    description: number
    isActive: number
    createdAt: number
    createdBy: number
    updatedAt: number
    updatedBy: number
    _all: number
  }


  export type TimelineTemplateMinAggregateInputType = {
    id?: true
    name?: true
    description?: true
    isActive?: true
    createdAt?: true
    createdBy?: true
    updatedAt?: true
    updatedBy?: true
  }

  export type TimelineTemplateMaxAggregateInputType = {
    id?: true
    name?: true
    description?: true
    isActive?: true
    createdAt?: true
    createdBy?: true
    updatedAt?: true
    updatedBy?: true
  }

  export type TimelineTemplateCountAggregateInputType = {
    id?: true
    name?: true
    description?: true
    isActive?: true
    createdAt?: true
    createdBy?: true
    updatedAt?: true
    updatedBy?: true
    _all?: true
  }

  export type TimelineTemplateAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which TimelineTemplate to aggregate.
     */
    where?: TimelineTemplateWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of TimelineTemplates to fetch.
     */
    orderBy?: TimelineTemplateOrderByWithRelationInput | TimelineTemplateOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: TimelineTemplateWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` TimelineTemplates from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` TimelineTemplates.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned TimelineTemplates
    **/
    _count?: true | TimelineTemplateCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: TimelineTemplateMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: TimelineTemplateMaxAggregateInputType
  }

  export type GetTimelineTemplateAggregateType<T extends TimelineTemplateAggregateArgs> = {
        [P in keyof T & keyof AggregateTimelineTemplate]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateTimelineTemplate[P]>
      : GetScalarType<T[P], AggregateTimelineTemplate[P]>
  }




  export type TimelineTemplateGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: TimelineTemplateWhereInput
    orderBy?: TimelineTemplateOrderByWithAggregationInput | TimelineTemplateOrderByWithAggregationInput[]
    by: TimelineTemplateScalarFieldEnum[] | TimelineTemplateScalarFieldEnum
    having?: TimelineTemplateScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: TimelineTemplateCountAggregateInputType | true
    _min?: TimelineTemplateMinAggregateInputType
    _max?: TimelineTemplateMaxAggregateInputType
  }

  export type TimelineTemplateGroupByOutputType = {
    id: string
    name: string
    description: string | null
    isActive: boolean
    createdAt: Date
    createdBy: string
    updatedAt: Date
    updatedBy: string
    _count: TimelineTemplateCountAggregateOutputType | null
    _min: TimelineTemplateMinAggregateOutputType | null
    _max: TimelineTemplateMaxAggregateOutputType | null
  }

  type GetTimelineTemplateGroupByPayload<T extends TimelineTemplateGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<TimelineTemplateGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof TimelineTemplateGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], TimelineTemplateGroupByOutputType[P]>
            : GetScalarType<T[P], TimelineTemplateGroupByOutputType[P]>
        }
      >
    >


  export type TimelineTemplateSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    description?: boolean
    isActive?: boolean
    createdAt?: boolean
    createdBy?: boolean
    updatedAt?: boolean
    updatedBy?: boolean
    phases?: boolean | TimelineTemplate$phasesArgs<ExtArgs>
    challengeTimelineTemplates?: boolean | TimelineTemplate$challengeTimelineTemplatesArgs<ExtArgs>
    challenges?: boolean | TimelineTemplate$challengesArgs<ExtArgs>
    DefaultChallengeReviewer?: boolean | TimelineTemplate$DefaultChallengeReviewerArgs<ExtArgs>
    _count?: boolean | TimelineTemplateCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["timelineTemplate"]>

  export type TimelineTemplateSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    description?: boolean
    isActive?: boolean
    createdAt?: boolean
    createdBy?: boolean
    updatedAt?: boolean
    updatedBy?: boolean
  }, ExtArgs["result"]["timelineTemplate"]>

  export type TimelineTemplateSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    description?: boolean
    isActive?: boolean
    createdAt?: boolean
    createdBy?: boolean
    updatedAt?: boolean
    updatedBy?: boolean
  }, ExtArgs["result"]["timelineTemplate"]>

  export type TimelineTemplateSelectScalar = {
    id?: boolean
    name?: boolean
    description?: boolean
    isActive?: boolean
    createdAt?: boolean
    createdBy?: boolean
    updatedAt?: boolean
    updatedBy?: boolean
  }

  export type TimelineTemplateOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "name" | "description" | "isActive" | "createdAt" | "createdBy" | "updatedAt" | "updatedBy", ExtArgs["result"]["timelineTemplate"]>
  export type TimelineTemplateInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    phases?: boolean | TimelineTemplate$phasesArgs<ExtArgs>
    challengeTimelineTemplates?: boolean | TimelineTemplate$challengeTimelineTemplatesArgs<ExtArgs>
    challenges?: boolean | TimelineTemplate$challengesArgs<ExtArgs>
    DefaultChallengeReviewer?: boolean | TimelineTemplate$DefaultChallengeReviewerArgs<ExtArgs>
    _count?: boolean | TimelineTemplateCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type TimelineTemplateIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}
  export type TimelineTemplateIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}

  export type $TimelineTemplatePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "TimelineTemplate"
    objects: {
      phases: Prisma.$TimelineTemplatePhasePayload<ExtArgs>[]
      challengeTimelineTemplates: Prisma.$ChallengeTimelineTemplatePayload<ExtArgs>[]
      challenges: Prisma.$ChallengePayload<ExtArgs>[]
      DefaultChallengeReviewer: Prisma.$DefaultChallengeReviewerPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      name: string
      description: string | null
      isActive: boolean
      createdAt: Date
      createdBy: string
      updatedAt: Date
      updatedBy: string
    }, ExtArgs["result"]["timelineTemplate"]>
    composites: {}
  }

  type TimelineTemplateGetPayload<S extends boolean | null | undefined | TimelineTemplateDefaultArgs> = $Result.GetResult<Prisma.$TimelineTemplatePayload, S>

  type TimelineTemplateCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<TimelineTemplateFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: TimelineTemplateCountAggregateInputType | true
    }

  export interface TimelineTemplateDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['TimelineTemplate'], meta: { name: 'TimelineTemplate' } }
    /**
     * Find zero or one TimelineTemplate that matches the filter.
     * @param {TimelineTemplateFindUniqueArgs} args - Arguments to find a TimelineTemplate
     * @example
     * // Get one TimelineTemplate
     * const timelineTemplate = await prisma.timelineTemplate.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends TimelineTemplateFindUniqueArgs>(args: SelectSubset<T, TimelineTemplateFindUniqueArgs<ExtArgs>>): Prisma__TimelineTemplateClient<$Result.GetResult<Prisma.$TimelineTemplatePayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one TimelineTemplate that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {TimelineTemplateFindUniqueOrThrowArgs} args - Arguments to find a TimelineTemplate
     * @example
     * // Get one TimelineTemplate
     * const timelineTemplate = await prisma.timelineTemplate.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends TimelineTemplateFindUniqueOrThrowArgs>(args: SelectSubset<T, TimelineTemplateFindUniqueOrThrowArgs<ExtArgs>>): Prisma__TimelineTemplateClient<$Result.GetResult<Prisma.$TimelineTemplatePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first TimelineTemplate that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TimelineTemplateFindFirstArgs} args - Arguments to find a TimelineTemplate
     * @example
     * // Get one TimelineTemplate
     * const timelineTemplate = await prisma.timelineTemplate.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends TimelineTemplateFindFirstArgs>(args?: SelectSubset<T, TimelineTemplateFindFirstArgs<ExtArgs>>): Prisma__TimelineTemplateClient<$Result.GetResult<Prisma.$TimelineTemplatePayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first TimelineTemplate that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TimelineTemplateFindFirstOrThrowArgs} args - Arguments to find a TimelineTemplate
     * @example
     * // Get one TimelineTemplate
     * const timelineTemplate = await prisma.timelineTemplate.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends TimelineTemplateFindFirstOrThrowArgs>(args?: SelectSubset<T, TimelineTemplateFindFirstOrThrowArgs<ExtArgs>>): Prisma__TimelineTemplateClient<$Result.GetResult<Prisma.$TimelineTemplatePayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more TimelineTemplates that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TimelineTemplateFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all TimelineTemplates
     * const timelineTemplates = await prisma.timelineTemplate.findMany()
     * 
     * // Get first 10 TimelineTemplates
     * const timelineTemplates = await prisma.timelineTemplate.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const timelineTemplateWithIdOnly = await prisma.timelineTemplate.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends TimelineTemplateFindManyArgs>(args?: SelectSubset<T, TimelineTemplateFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TimelineTemplatePayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a TimelineTemplate.
     * @param {TimelineTemplateCreateArgs} args - Arguments to create a TimelineTemplate.
     * @example
     * // Create one TimelineTemplate
     * const TimelineTemplate = await prisma.timelineTemplate.create({
     *   data: {
     *     // ... data to create a TimelineTemplate
     *   }
     * })
     * 
     */
    create<T extends TimelineTemplateCreateArgs>(args: SelectSubset<T, TimelineTemplateCreateArgs<ExtArgs>>): Prisma__TimelineTemplateClient<$Result.GetResult<Prisma.$TimelineTemplatePayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many TimelineTemplates.
     * @param {TimelineTemplateCreateManyArgs} args - Arguments to create many TimelineTemplates.
     * @example
     * // Create many TimelineTemplates
     * const timelineTemplate = await prisma.timelineTemplate.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends TimelineTemplateCreateManyArgs>(args?: SelectSubset<T, TimelineTemplateCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many TimelineTemplates and returns the data saved in the database.
     * @param {TimelineTemplateCreateManyAndReturnArgs} args - Arguments to create many TimelineTemplates.
     * @example
     * // Create many TimelineTemplates
     * const timelineTemplate = await prisma.timelineTemplate.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many TimelineTemplates and only return the `id`
     * const timelineTemplateWithIdOnly = await prisma.timelineTemplate.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends TimelineTemplateCreateManyAndReturnArgs>(args?: SelectSubset<T, TimelineTemplateCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TimelineTemplatePayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a TimelineTemplate.
     * @param {TimelineTemplateDeleteArgs} args - Arguments to delete one TimelineTemplate.
     * @example
     * // Delete one TimelineTemplate
     * const TimelineTemplate = await prisma.timelineTemplate.delete({
     *   where: {
     *     // ... filter to delete one TimelineTemplate
     *   }
     * })
     * 
     */
    delete<T extends TimelineTemplateDeleteArgs>(args: SelectSubset<T, TimelineTemplateDeleteArgs<ExtArgs>>): Prisma__TimelineTemplateClient<$Result.GetResult<Prisma.$TimelineTemplatePayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one TimelineTemplate.
     * @param {TimelineTemplateUpdateArgs} args - Arguments to update one TimelineTemplate.
     * @example
     * // Update one TimelineTemplate
     * const timelineTemplate = await prisma.timelineTemplate.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends TimelineTemplateUpdateArgs>(args: SelectSubset<T, TimelineTemplateUpdateArgs<ExtArgs>>): Prisma__TimelineTemplateClient<$Result.GetResult<Prisma.$TimelineTemplatePayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more TimelineTemplates.
     * @param {TimelineTemplateDeleteManyArgs} args - Arguments to filter TimelineTemplates to delete.
     * @example
     * // Delete a few TimelineTemplates
     * const { count } = await prisma.timelineTemplate.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends TimelineTemplateDeleteManyArgs>(args?: SelectSubset<T, TimelineTemplateDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more TimelineTemplates.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TimelineTemplateUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many TimelineTemplates
     * const timelineTemplate = await prisma.timelineTemplate.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends TimelineTemplateUpdateManyArgs>(args: SelectSubset<T, TimelineTemplateUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more TimelineTemplates and returns the data updated in the database.
     * @param {TimelineTemplateUpdateManyAndReturnArgs} args - Arguments to update many TimelineTemplates.
     * @example
     * // Update many TimelineTemplates
     * const timelineTemplate = await prisma.timelineTemplate.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more TimelineTemplates and only return the `id`
     * const timelineTemplateWithIdOnly = await prisma.timelineTemplate.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends TimelineTemplateUpdateManyAndReturnArgs>(args: SelectSubset<T, TimelineTemplateUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TimelineTemplatePayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one TimelineTemplate.
     * @param {TimelineTemplateUpsertArgs} args - Arguments to update or create a TimelineTemplate.
     * @example
     * // Update or create a TimelineTemplate
     * const timelineTemplate = await prisma.timelineTemplate.upsert({
     *   create: {
     *     // ... data to create a TimelineTemplate
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the TimelineTemplate we want to update
     *   }
     * })
     */
    upsert<T extends TimelineTemplateUpsertArgs>(args: SelectSubset<T, TimelineTemplateUpsertArgs<ExtArgs>>): Prisma__TimelineTemplateClient<$Result.GetResult<Prisma.$TimelineTemplatePayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of TimelineTemplates.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TimelineTemplateCountArgs} args - Arguments to filter TimelineTemplates to count.
     * @example
     * // Count the number of TimelineTemplates
     * const count = await prisma.timelineTemplate.count({
     *   where: {
     *     // ... the filter for the TimelineTemplates we want to count
     *   }
     * })
    **/
    count<T extends TimelineTemplateCountArgs>(
      args?: Subset<T, TimelineTemplateCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], TimelineTemplateCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a TimelineTemplate.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TimelineTemplateAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends TimelineTemplateAggregateArgs>(args: Subset<T, TimelineTemplateAggregateArgs>): Prisma.PrismaPromise<GetTimelineTemplateAggregateType<T>>

    /**
     * Group by TimelineTemplate.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TimelineTemplateGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends TimelineTemplateGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: TimelineTemplateGroupByArgs['orderBy'] }
        : { orderBy?: TimelineTemplateGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, TimelineTemplateGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetTimelineTemplateGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the TimelineTemplate model
   */
  readonly fields: TimelineTemplateFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for TimelineTemplate.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__TimelineTemplateClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    phases<T extends TimelineTemplate$phasesArgs<ExtArgs> = {}>(args?: Subset<T, TimelineTemplate$phasesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TimelineTemplatePhasePayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    challengeTimelineTemplates<T extends TimelineTemplate$challengeTimelineTemplatesArgs<ExtArgs> = {}>(args?: Subset<T, TimelineTemplate$challengeTimelineTemplatesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ChallengeTimelineTemplatePayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    challenges<T extends TimelineTemplate$challengesArgs<ExtArgs> = {}>(args?: Subset<T, TimelineTemplate$challengesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ChallengePayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    DefaultChallengeReviewer<T extends TimelineTemplate$DefaultChallengeReviewerArgs<ExtArgs> = {}>(args?: Subset<T, TimelineTemplate$DefaultChallengeReviewerArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$DefaultChallengeReviewerPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the TimelineTemplate model
   */
  interface TimelineTemplateFieldRefs {
    readonly id: FieldRef<"TimelineTemplate", 'String'>
    readonly name: FieldRef<"TimelineTemplate", 'String'>
    readonly description: FieldRef<"TimelineTemplate", 'String'>
    readonly isActive: FieldRef<"TimelineTemplate", 'Boolean'>
    readonly createdAt: FieldRef<"TimelineTemplate", 'DateTime'>
    readonly createdBy: FieldRef<"TimelineTemplate", 'String'>
    readonly updatedAt: FieldRef<"TimelineTemplate", 'DateTime'>
    readonly updatedBy: FieldRef<"TimelineTemplate", 'String'>
  }
    

  // Custom InputTypes
  /**
   * TimelineTemplate findUnique
   */
  export type TimelineTemplateFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TimelineTemplate
     */
    select?: TimelineTemplateSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TimelineTemplate
     */
    omit?: TimelineTemplateOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TimelineTemplateInclude<ExtArgs> | null
    /**
     * Filter, which TimelineTemplate to fetch.
     */
    where: TimelineTemplateWhereUniqueInput
  }

  /**
   * TimelineTemplate findUniqueOrThrow
   */
  export type TimelineTemplateFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TimelineTemplate
     */
    select?: TimelineTemplateSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TimelineTemplate
     */
    omit?: TimelineTemplateOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TimelineTemplateInclude<ExtArgs> | null
    /**
     * Filter, which TimelineTemplate to fetch.
     */
    where: TimelineTemplateWhereUniqueInput
  }

  /**
   * TimelineTemplate findFirst
   */
  export type TimelineTemplateFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TimelineTemplate
     */
    select?: TimelineTemplateSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TimelineTemplate
     */
    omit?: TimelineTemplateOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TimelineTemplateInclude<ExtArgs> | null
    /**
     * Filter, which TimelineTemplate to fetch.
     */
    where?: TimelineTemplateWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of TimelineTemplates to fetch.
     */
    orderBy?: TimelineTemplateOrderByWithRelationInput | TimelineTemplateOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for TimelineTemplates.
     */
    cursor?: TimelineTemplateWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` TimelineTemplates from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` TimelineTemplates.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of TimelineTemplates.
     */
    distinct?: TimelineTemplateScalarFieldEnum | TimelineTemplateScalarFieldEnum[]
  }

  /**
   * TimelineTemplate findFirstOrThrow
   */
  export type TimelineTemplateFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TimelineTemplate
     */
    select?: TimelineTemplateSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TimelineTemplate
     */
    omit?: TimelineTemplateOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TimelineTemplateInclude<ExtArgs> | null
    /**
     * Filter, which TimelineTemplate to fetch.
     */
    where?: TimelineTemplateWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of TimelineTemplates to fetch.
     */
    orderBy?: TimelineTemplateOrderByWithRelationInput | TimelineTemplateOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for TimelineTemplates.
     */
    cursor?: TimelineTemplateWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` TimelineTemplates from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` TimelineTemplates.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of TimelineTemplates.
     */
    distinct?: TimelineTemplateScalarFieldEnum | TimelineTemplateScalarFieldEnum[]
  }

  /**
   * TimelineTemplate findMany
   */
  export type TimelineTemplateFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TimelineTemplate
     */
    select?: TimelineTemplateSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TimelineTemplate
     */
    omit?: TimelineTemplateOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TimelineTemplateInclude<ExtArgs> | null
    /**
     * Filter, which TimelineTemplates to fetch.
     */
    where?: TimelineTemplateWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of TimelineTemplates to fetch.
     */
    orderBy?: TimelineTemplateOrderByWithRelationInput | TimelineTemplateOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing TimelineTemplates.
     */
    cursor?: TimelineTemplateWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` TimelineTemplates from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` TimelineTemplates.
     */
    skip?: number
    distinct?: TimelineTemplateScalarFieldEnum | TimelineTemplateScalarFieldEnum[]
  }

  /**
   * TimelineTemplate create
   */
  export type TimelineTemplateCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TimelineTemplate
     */
    select?: TimelineTemplateSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TimelineTemplate
     */
    omit?: TimelineTemplateOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TimelineTemplateInclude<ExtArgs> | null
    /**
     * The data needed to create a TimelineTemplate.
     */
    data: XOR<TimelineTemplateCreateInput, TimelineTemplateUncheckedCreateInput>
  }

  /**
   * TimelineTemplate createMany
   */
  export type TimelineTemplateCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many TimelineTemplates.
     */
    data: TimelineTemplateCreateManyInput | TimelineTemplateCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * TimelineTemplate createManyAndReturn
   */
  export type TimelineTemplateCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TimelineTemplate
     */
    select?: TimelineTemplateSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the TimelineTemplate
     */
    omit?: TimelineTemplateOmit<ExtArgs> | null
    /**
     * The data used to create many TimelineTemplates.
     */
    data: TimelineTemplateCreateManyInput | TimelineTemplateCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * TimelineTemplate update
   */
  export type TimelineTemplateUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TimelineTemplate
     */
    select?: TimelineTemplateSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TimelineTemplate
     */
    omit?: TimelineTemplateOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TimelineTemplateInclude<ExtArgs> | null
    /**
     * The data needed to update a TimelineTemplate.
     */
    data: XOR<TimelineTemplateUpdateInput, TimelineTemplateUncheckedUpdateInput>
    /**
     * Choose, which TimelineTemplate to update.
     */
    where: TimelineTemplateWhereUniqueInput
  }

  /**
   * TimelineTemplate updateMany
   */
  export type TimelineTemplateUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update TimelineTemplates.
     */
    data: XOR<TimelineTemplateUpdateManyMutationInput, TimelineTemplateUncheckedUpdateManyInput>
    /**
     * Filter which TimelineTemplates to update
     */
    where?: TimelineTemplateWhereInput
    /**
     * Limit how many TimelineTemplates to update.
     */
    limit?: number
  }

  /**
   * TimelineTemplate updateManyAndReturn
   */
  export type TimelineTemplateUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TimelineTemplate
     */
    select?: TimelineTemplateSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the TimelineTemplate
     */
    omit?: TimelineTemplateOmit<ExtArgs> | null
    /**
     * The data used to update TimelineTemplates.
     */
    data: XOR<TimelineTemplateUpdateManyMutationInput, TimelineTemplateUncheckedUpdateManyInput>
    /**
     * Filter which TimelineTemplates to update
     */
    where?: TimelineTemplateWhereInput
    /**
     * Limit how many TimelineTemplates to update.
     */
    limit?: number
  }

  /**
   * TimelineTemplate upsert
   */
  export type TimelineTemplateUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TimelineTemplate
     */
    select?: TimelineTemplateSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TimelineTemplate
     */
    omit?: TimelineTemplateOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TimelineTemplateInclude<ExtArgs> | null
    /**
     * The filter to search for the TimelineTemplate to update in case it exists.
     */
    where: TimelineTemplateWhereUniqueInput
    /**
     * In case the TimelineTemplate found by the `where` argument doesn't exist, create a new TimelineTemplate with this data.
     */
    create: XOR<TimelineTemplateCreateInput, TimelineTemplateUncheckedCreateInput>
    /**
     * In case the TimelineTemplate was found with the provided `where` argument, update it with this data.
     */
    update: XOR<TimelineTemplateUpdateInput, TimelineTemplateUncheckedUpdateInput>
  }

  /**
   * TimelineTemplate delete
   */
  export type TimelineTemplateDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TimelineTemplate
     */
    select?: TimelineTemplateSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TimelineTemplate
     */
    omit?: TimelineTemplateOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TimelineTemplateInclude<ExtArgs> | null
    /**
     * Filter which TimelineTemplate to delete.
     */
    where: TimelineTemplateWhereUniqueInput
  }

  /**
   * TimelineTemplate deleteMany
   */
  export type TimelineTemplateDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which TimelineTemplates to delete
     */
    where?: TimelineTemplateWhereInput
    /**
     * Limit how many TimelineTemplates to delete.
     */
    limit?: number
  }

  /**
   * TimelineTemplate.phases
   */
  export type TimelineTemplate$phasesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TimelineTemplatePhase
     */
    select?: TimelineTemplatePhaseSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TimelineTemplatePhase
     */
    omit?: TimelineTemplatePhaseOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TimelineTemplatePhaseInclude<ExtArgs> | null
    where?: TimelineTemplatePhaseWhereInput
    orderBy?: TimelineTemplatePhaseOrderByWithRelationInput | TimelineTemplatePhaseOrderByWithRelationInput[]
    cursor?: TimelineTemplatePhaseWhereUniqueInput
    take?: number
    skip?: number
    distinct?: TimelineTemplatePhaseScalarFieldEnum | TimelineTemplatePhaseScalarFieldEnum[]
  }

  /**
   * TimelineTemplate.challengeTimelineTemplates
   */
  export type TimelineTemplate$challengeTimelineTemplatesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ChallengeTimelineTemplate
     */
    select?: ChallengeTimelineTemplateSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ChallengeTimelineTemplate
     */
    omit?: ChallengeTimelineTemplateOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ChallengeTimelineTemplateInclude<ExtArgs> | null
    where?: ChallengeTimelineTemplateWhereInput
    orderBy?: ChallengeTimelineTemplateOrderByWithRelationInput | ChallengeTimelineTemplateOrderByWithRelationInput[]
    cursor?: ChallengeTimelineTemplateWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ChallengeTimelineTemplateScalarFieldEnum | ChallengeTimelineTemplateScalarFieldEnum[]
  }

  /**
   * TimelineTemplate.challenges
   */
  export type TimelineTemplate$challengesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Challenge
     */
    select?: ChallengeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Challenge
     */
    omit?: ChallengeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ChallengeInclude<ExtArgs> | null
    where?: ChallengeWhereInput
    orderBy?: ChallengeOrderByWithRelationInput | ChallengeOrderByWithRelationInput[]
    cursor?: ChallengeWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ChallengeScalarFieldEnum | ChallengeScalarFieldEnum[]
  }

  /**
   * TimelineTemplate.DefaultChallengeReviewer
   */
  export type TimelineTemplate$DefaultChallengeReviewerArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DefaultChallengeReviewer
     */
    select?: DefaultChallengeReviewerSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DefaultChallengeReviewer
     */
    omit?: DefaultChallengeReviewerOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DefaultChallengeReviewerInclude<ExtArgs> | null
    where?: DefaultChallengeReviewerWhereInput
    orderBy?: DefaultChallengeReviewerOrderByWithRelationInput | DefaultChallengeReviewerOrderByWithRelationInput[]
    cursor?: DefaultChallengeReviewerWhereUniqueInput
    take?: number
    skip?: number
    distinct?: DefaultChallengeReviewerScalarFieldEnum | DefaultChallengeReviewerScalarFieldEnum[]
  }

  /**
   * TimelineTemplate without action
   */
  export type TimelineTemplateDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TimelineTemplate
     */
    select?: TimelineTemplateSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TimelineTemplate
     */
    omit?: TimelineTemplateOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TimelineTemplateInclude<ExtArgs> | null
  }


  /**
   * Model TimelineTemplatePhase
   */

  export type AggregateTimelineTemplatePhase = {
    _count: TimelineTemplatePhaseCountAggregateOutputType | null
    _avg: TimelineTemplatePhaseAvgAggregateOutputType | null
    _sum: TimelineTemplatePhaseSumAggregateOutputType | null
    _min: TimelineTemplatePhaseMinAggregateOutputType | null
    _max: TimelineTemplatePhaseMaxAggregateOutputType | null
  }

  export type TimelineTemplatePhaseAvgAggregateOutputType = {
    defaultDuration: number | null
  }

  export type TimelineTemplatePhaseSumAggregateOutputType = {
    defaultDuration: number | null
  }

  export type TimelineTemplatePhaseMinAggregateOutputType = {
    id: string | null
    timelineTemplateId: string | null
    phaseId: string | null
    predecessor: string | null
    defaultDuration: number | null
    createdAt: Date | null
    createdBy: string | null
    updatedAt: Date | null
    updatedBy: string | null
  }

  export type TimelineTemplatePhaseMaxAggregateOutputType = {
    id: string | null
    timelineTemplateId: string | null
    phaseId: string | null
    predecessor: string | null
    defaultDuration: number | null
    createdAt: Date | null
    createdBy: string | null
    updatedAt: Date | null
    updatedBy: string | null
  }

  export type TimelineTemplatePhaseCountAggregateOutputType = {
    id: number
    timelineTemplateId: number
    phaseId: number
    predecessor: number
    defaultDuration: number
    createdAt: number
    createdBy: number
    updatedAt: number
    updatedBy: number
    _all: number
  }


  export type TimelineTemplatePhaseAvgAggregateInputType = {
    defaultDuration?: true
  }

  export type TimelineTemplatePhaseSumAggregateInputType = {
    defaultDuration?: true
  }

  export type TimelineTemplatePhaseMinAggregateInputType = {
    id?: true
    timelineTemplateId?: true
    phaseId?: true
    predecessor?: true
    defaultDuration?: true
    createdAt?: true
    createdBy?: true
    updatedAt?: true
    updatedBy?: true
  }

  export type TimelineTemplatePhaseMaxAggregateInputType = {
    id?: true
    timelineTemplateId?: true
    phaseId?: true
    predecessor?: true
    defaultDuration?: true
    createdAt?: true
    createdBy?: true
    updatedAt?: true
    updatedBy?: true
  }

  export type TimelineTemplatePhaseCountAggregateInputType = {
    id?: true
    timelineTemplateId?: true
    phaseId?: true
    predecessor?: true
    defaultDuration?: true
    createdAt?: true
    createdBy?: true
    updatedAt?: true
    updatedBy?: true
    _all?: true
  }

  export type TimelineTemplatePhaseAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which TimelineTemplatePhase to aggregate.
     */
    where?: TimelineTemplatePhaseWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of TimelineTemplatePhases to fetch.
     */
    orderBy?: TimelineTemplatePhaseOrderByWithRelationInput | TimelineTemplatePhaseOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: TimelineTemplatePhaseWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` TimelineTemplatePhases from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` TimelineTemplatePhases.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned TimelineTemplatePhases
    **/
    _count?: true | TimelineTemplatePhaseCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: TimelineTemplatePhaseAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: TimelineTemplatePhaseSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: TimelineTemplatePhaseMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: TimelineTemplatePhaseMaxAggregateInputType
  }

  export type GetTimelineTemplatePhaseAggregateType<T extends TimelineTemplatePhaseAggregateArgs> = {
        [P in keyof T & keyof AggregateTimelineTemplatePhase]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateTimelineTemplatePhase[P]>
      : GetScalarType<T[P], AggregateTimelineTemplatePhase[P]>
  }




  export type TimelineTemplatePhaseGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: TimelineTemplatePhaseWhereInput
    orderBy?: TimelineTemplatePhaseOrderByWithAggregationInput | TimelineTemplatePhaseOrderByWithAggregationInput[]
    by: TimelineTemplatePhaseScalarFieldEnum[] | TimelineTemplatePhaseScalarFieldEnum
    having?: TimelineTemplatePhaseScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: TimelineTemplatePhaseCountAggregateInputType | true
    _avg?: TimelineTemplatePhaseAvgAggregateInputType
    _sum?: TimelineTemplatePhaseSumAggregateInputType
    _min?: TimelineTemplatePhaseMinAggregateInputType
    _max?: TimelineTemplatePhaseMaxAggregateInputType
  }

  export type TimelineTemplatePhaseGroupByOutputType = {
    id: string
    timelineTemplateId: string
    phaseId: string
    predecessor: string | null
    defaultDuration: number
    createdAt: Date
    createdBy: string
    updatedAt: Date
    updatedBy: string
    _count: TimelineTemplatePhaseCountAggregateOutputType | null
    _avg: TimelineTemplatePhaseAvgAggregateOutputType | null
    _sum: TimelineTemplatePhaseSumAggregateOutputType | null
    _min: TimelineTemplatePhaseMinAggregateOutputType | null
    _max: TimelineTemplatePhaseMaxAggregateOutputType | null
  }

  type GetTimelineTemplatePhaseGroupByPayload<T extends TimelineTemplatePhaseGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<TimelineTemplatePhaseGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof TimelineTemplatePhaseGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], TimelineTemplatePhaseGroupByOutputType[P]>
            : GetScalarType<T[P], TimelineTemplatePhaseGroupByOutputType[P]>
        }
      >
    >


  export type TimelineTemplatePhaseSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    timelineTemplateId?: boolean
    phaseId?: boolean
    predecessor?: boolean
    defaultDuration?: boolean
    createdAt?: boolean
    createdBy?: boolean
    updatedAt?: boolean
    updatedBy?: boolean
    timelineTemplate?: boolean | TimelineTemplateDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["timelineTemplatePhase"]>

  export type TimelineTemplatePhaseSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    timelineTemplateId?: boolean
    phaseId?: boolean
    predecessor?: boolean
    defaultDuration?: boolean
    createdAt?: boolean
    createdBy?: boolean
    updatedAt?: boolean
    updatedBy?: boolean
    timelineTemplate?: boolean | TimelineTemplateDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["timelineTemplatePhase"]>

  export type TimelineTemplatePhaseSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    timelineTemplateId?: boolean
    phaseId?: boolean
    predecessor?: boolean
    defaultDuration?: boolean
    createdAt?: boolean
    createdBy?: boolean
    updatedAt?: boolean
    updatedBy?: boolean
    timelineTemplate?: boolean | TimelineTemplateDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["timelineTemplatePhase"]>

  export type TimelineTemplatePhaseSelectScalar = {
    id?: boolean
    timelineTemplateId?: boolean
    phaseId?: boolean
    predecessor?: boolean
    defaultDuration?: boolean
    createdAt?: boolean
    createdBy?: boolean
    updatedAt?: boolean
    updatedBy?: boolean
  }

  export type TimelineTemplatePhaseOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "timelineTemplateId" | "phaseId" | "predecessor" | "defaultDuration" | "createdAt" | "createdBy" | "updatedAt" | "updatedBy", ExtArgs["result"]["timelineTemplatePhase"]>
  export type TimelineTemplatePhaseInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    timelineTemplate?: boolean | TimelineTemplateDefaultArgs<ExtArgs>
  }
  export type TimelineTemplatePhaseIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    timelineTemplate?: boolean | TimelineTemplateDefaultArgs<ExtArgs>
  }
  export type TimelineTemplatePhaseIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    timelineTemplate?: boolean | TimelineTemplateDefaultArgs<ExtArgs>
  }

  export type $TimelineTemplatePhasePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "TimelineTemplatePhase"
    objects: {
      timelineTemplate: Prisma.$TimelineTemplatePayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      timelineTemplateId: string
      phaseId: string
      predecessor: string | null
      defaultDuration: number
      createdAt: Date
      createdBy: string
      updatedAt: Date
      updatedBy: string
    }, ExtArgs["result"]["timelineTemplatePhase"]>
    composites: {}
  }

  type TimelineTemplatePhaseGetPayload<S extends boolean | null | undefined | TimelineTemplatePhaseDefaultArgs> = $Result.GetResult<Prisma.$TimelineTemplatePhasePayload, S>

  type TimelineTemplatePhaseCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<TimelineTemplatePhaseFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: TimelineTemplatePhaseCountAggregateInputType | true
    }

  export interface TimelineTemplatePhaseDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['TimelineTemplatePhase'], meta: { name: 'TimelineTemplatePhase' } }
    /**
     * Find zero or one TimelineTemplatePhase that matches the filter.
     * @param {TimelineTemplatePhaseFindUniqueArgs} args - Arguments to find a TimelineTemplatePhase
     * @example
     * // Get one TimelineTemplatePhase
     * const timelineTemplatePhase = await prisma.timelineTemplatePhase.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends TimelineTemplatePhaseFindUniqueArgs>(args: SelectSubset<T, TimelineTemplatePhaseFindUniqueArgs<ExtArgs>>): Prisma__TimelineTemplatePhaseClient<$Result.GetResult<Prisma.$TimelineTemplatePhasePayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one TimelineTemplatePhase that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {TimelineTemplatePhaseFindUniqueOrThrowArgs} args - Arguments to find a TimelineTemplatePhase
     * @example
     * // Get one TimelineTemplatePhase
     * const timelineTemplatePhase = await prisma.timelineTemplatePhase.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends TimelineTemplatePhaseFindUniqueOrThrowArgs>(args: SelectSubset<T, TimelineTemplatePhaseFindUniqueOrThrowArgs<ExtArgs>>): Prisma__TimelineTemplatePhaseClient<$Result.GetResult<Prisma.$TimelineTemplatePhasePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first TimelineTemplatePhase that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TimelineTemplatePhaseFindFirstArgs} args - Arguments to find a TimelineTemplatePhase
     * @example
     * // Get one TimelineTemplatePhase
     * const timelineTemplatePhase = await prisma.timelineTemplatePhase.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends TimelineTemplatePhaseFindFirstArgs>(args?: SelectSubset<T, TimelineTemplatePhaseFindFirstArgs<ExtArgs>>): Prisma__TimelineTemplatePhaseClient<$Result.GetResult<Prisma.$TimelineTemplatePhasePayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first TimelineTemplatePhase that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TimelineTemplatePhaseFindFirstOrThrowArgs} args - Arguments to find a TimelineTemplatePhase
     * @example
     * // Get one TimelineTemplatePhase
     * const timelineTemplatePhase = await prisma.timelineTemplatePhase.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends TimelineTemplatePhaseFindFirstOrThrowArgs>(args?: SelectSubset<T, TimelineTemplatePhaseFindFirstOrThrowArgs<ExtArgs>>): Prisma__TimelineTemplatePhaseClient<$Result.GetResult<Prisma.$TimelineTemplatePhasePayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more TimelineTemplatePhases that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TimelineTemplatePhaseFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all TimelineTemplatePhases
     * const timelineTemplatePhases = await prisma.timelineTemplatePhase.findMany()
     * 
     * // Get first 10 TimelineTemplatePhases
     * const timelineTemplatePhases = await prisma.timelineTemplatePhase.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const timelineTemplatePhaseWithIdOnly = await prisma.timelineTemplatePhase.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends TimelineTemplatePhaseFindManyArgs>(args?: SelectSubset<T, TimelineTemplatePhaseFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TimelineTemplatePhasePayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a TimelineTemplatePhase.
     * @param {TimelineTemplatePhaseCreateArgs} args - Arguments to create a TimelineTemplatePhase.
     * @example
     * // Create one TimelineTemplatePhase
     * const TimelineTemplatePhase = await prisma.timelineTemplatePhase.create({
     *   data: {
     *     // ... data to create a TimelineTemplatePhase
     *   }
     * })
     * 
     */
    create<T extends TimelineTemplatePhaseCreateArgs>(args: SelectSubset<T, TimelineTemplatePhaseCreateArgs<ExtArgs>>): Prisma__TimelineTemplatePhaseClient<$Result.GetResult<Prisma.$TimelineTemplatePhasePayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many TimelineTemplatePhases.
     * @param {TimelineTemplatePhaseCreateManyArgs} args - Arguments to create many TimelineTemplatePhases.
     * @example
     * // Create many TimelineTemplatePhases
     * const timelineTemplatePhase = await prisma.timelineTemplatePhase.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends TimelineTemplatePhaseCreateManyArgs>(args?: SelectSubset<T, TimelineTemplatePhaseCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many TimelineTemplatePhases and returns the data saved in the database.
     * @param {TimelineTemplatePhaseCreateManyAndReturnArgs} args - Arguments to create many TimelineTemplatePhases.
     * @example
     * // Create many TimelineTemplatePhases
     * const timelineTemplatePhase = await prisma.timelineTemplatePhase.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many TimelineTemplatePhases and only return the `id`
     * const timelineTemplatePhaseWithIdOnly = await prisma.timelineTemplatePhase.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends TimelineTemplatePhaseCreateManyAndReturnArgs>(args?: SelectSubset<T, TimelineTemplatePhaseCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TimelineTemplatePhasePayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a TimelineTemplatePhase.
     * @param {TimelineTemplatePhaseDeleteArgs} args - Arguments to delete one TimelineTemplatePhase.
     * @example
     * // Delete one TimelineTemplatePhase
     * const TimelineTemplatePhase = await prisma.timelineTemplatePhase.delete({
     *   where: {
     *     // ... filter to delete one TimelineTemplatePhase
     *   }
     * })
     * 
     */
    delete<T extends TimelineTemplatePhaseDeleteArgs>(args: SelectSubset<T, TimelineTemplatePhaseDeleteArgs<ExtArgs>>): Prisma__TimelineTemplatePhaseClient<$Result.GetResult<Prisma.$TimelineTemplatePhasePayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one TimelineTemplatePhase.
     * @param {TimelineTemplatePhaseUpdateArgs} args - Arguments to update one TimelineTemplatePhase.
     * @example
     * // Update one TimelineTemplatePhase
     * const timelineTemplatePhase = await prisma.timelineTemplatePhase.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends TimelineTemplatePhaseUpdateArgs>(args: SelectSubset<T, TimelineTemplatePhaseUpdateArgs<ExtArgs>>): Prisma__TimelineTemplatePhaseClient<$Result.GetResult<Prisma.$TimelineTemplatePhasePayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more TimelineTemplatePhases.
     * @param {TimelineTemplatePhaseDeleteManyArgs} args - Arguments to filter TimelineTemplatePhases to delete.
     * @example
     * // Delete a few TimelineTemplatePhases
     * const { count } = await prisma.timelineTemplatePhase.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends TimelineTemplatePhaseDeleteManyArgs>(args?: SelectSubset<T, TimelineTemplatePhaseDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more TimelineTemplatePhases.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TimelineTemplatePhaseUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many TimelineTemplatePhases
     * const timelineTemplatePhase = await prisma.timelineTemplatePhase.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends TimelineTemplatePhaseUpdateManyArgs>(args: SelectSubset<T, TimelineTemplatePhaseUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more TimelineTemplatePhases and returns the data updated in the database.
     * @param {TimelineTemplatePhaseUpdateManyAndReturnArgs} args - Arguments to update many TimelineTemplatePhases.
     * @example
     * // Update many TimelineTemplatePhases
     * const timelineTemplatePhase = await prisma.timelineTemplatePhase.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more TimelineTemplatePhases and only return the `id`
     * const timelineTemplatePhaseWithIdOnly = await prisma.timelineTemplatePhase.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends TimelineTemplatePhaseUpdateManyAndReturnArgs>(args: SelectSubset<T, TimelineTemplatePhaseUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TimelineTemplatePhasePayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one TimelineTemplatePhase.
     * @param {TimelineTemplatePhaseUpsertArgs} args - Arguments to update or create a TimelineTemplatePhase.
     * @example
     * // Update or create a TimelineTemplatePhase
     * const timelineTemplatePhase = await prisma.timelineTemplatePhase.upsert({
     *   create: {
     *     // ... data to create a TimelineTemplatePhase
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the TimelineTemplatePhase we want to update
     *   }
     * })
     */
    upsert<T extends TimelineTemplatePhaseUpsertArgs>(args: SelectSubset<T, TimelineTemplatePhaseUpsertArgs<ExtArgs>>): Prisma__TimelineTemplatePhaseClient<$Result.GetResult<Prisma.$TimelineTemplatePhasePayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of TimelineTemplatePhases.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TimelineTemplatePhaseCountArgs} args - Arguments to filter TimelineTemplatePhases to count.
     * @example
     * // Count the number of TimelineTemplatePhases
     * const count = await prisma.timelineTemplatePhase.count({
     *   where: {
     *     // ... the filter for the TimelineTemplatePhases we want to count
     *   }
     * })
    **/
    count<T extends TimelineTemplatePhaseCountArgs>(
      args?: Subset<T, TimelineTemplatePhaseCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], TimelineTemplatePhaseCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a TimelineTemplatePhase.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TimelineTemplatePhaseAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends TimelineTemplatePhaseAggregateArgs>(args: Subset<T, TimelineTemplatePhaseAggregateArgs>): Prisma.PrismaPromise<GetTimelineTemplatePhaseAggregateType<T>>

    /**
     * Group by TimelineTemplatePhase.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TimelineTemplatePhaseGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends TimelineTemplatePhaseGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: TimelineTemplatePhaseGroupByArgs['orderBy'] }
        : { orderBy?: TimelineTemplatePhaseGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, TimelineTemplatePhaseGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetTimelineTemplatePhaseGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the TimelineTemplatePhase model
   */
  readonly fields: TimelineTemplatePhaseFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for TimelineTemplatePhase.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__TimelineTemplatePhaseClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    timelineTemplate<T extends TimelineTemplateDefaultArgs<ExtArgs> = {}>(args?: Subset<T, TimelineTemplateDefaultArgs<ExtArgs>>): Prisma__TimelineTemplateClient<$Result.GetResult<Prisma.$TimelineTemplatePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the TimelineTemplatePhase model
   */
  interface TimelineTemplatePhaseFieldRefs {
    readonly id: FieldRef<"TimelineTemplatePhase", 'String'>
    readonly timelineTemplateId: FieldRef<"TimelineTemplatePhase", 'String'>
    readonly phaseId: FieldRef<"TimelineTemplatePhase", 'String'>
    readonly predecessor: FieldRef<"TimelineTemplatePhase", 'String'>
    readonly defaultDuration: FieldRef<"TimelineTemplatePhase", 'Int'>
    readonly createdAt: FieldRef<"TimelineTemplatePhase", 'DateTime'>
    readonly createdBy: FieldRef<"TimelineTemplatePhase", 'String'>
    readonly updatedAt: FieldRef<"TimelineTemplatePhase", 'DateTime'>
    readonly updatedBy: FieldRef<"TimelineTemplatePhase", 'String'>
  }
    

  // Custom InputTypes
  /**
   * TimelineTemplatePhase findUnique
   */
  export type TimelineTemplatePhaseFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TimelineTemplatePhase
     */
    select?: TimelineTemplatePhaseSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TimelineTemplatePhase
     */
    omit?: TimelineTemplatePhaseOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TimelineTemplatePhaseInclude<ExtArgs> | null
    /**
     * Filter, which TimelineTemplatePhase to fetch.
     */
    where: TimelineTemplatePhaseWhereUniqueInput
  }

  /**
   * TimelineTemplatePhase findUniqueOrThrow
   */
  export type TimelineTemplatePhaseFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TimelineTemplatePhase
     */
    select?: TimelineTemplatePhaseSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TimelineTemplatePhase
     */
    omit?: TimelineTemplatePhaseOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TimelineTemplatePhaseInclude<ExtArgs> | null
    /**
     * Filter, which TimelineTemplatePhase to fetch.
     */
    where: TimelineTemplatePhaseWhereUniqueInput
  }

  /**
   * TimelineTemplatePhase findFirst
   */
  export type TimelineTemplatePhaseFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TimelineTemplatePhase
     */
    select?: TimelineTemplatePhaseSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TimelineTemplatePhase
     */
    omit?: TimelineTemplatePhaseOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TimelineTemplatePhaseInclude<ExtArgs> | null
    /**
     * Filter, which TimelineTemplatePhase to fetch.
     */
    where?: TimelineTemplatePhaseWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of TimelineTemplatePhases to fetch.
     */
    orderBy?: TimelineTemplatePhaseOrderByWithRelationInput | TimelineTemplatePhaseOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for TimelineTemplatePhases.
     */
    cursor?: TimelineTemplatePhaseWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` TimelineTemplatePhases from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` TimelineTemplatePhases.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of TimelineTemplatePhases.
     */
    distinct?: TimelineTemplatePhaseScalarFieldEnum | TimelineTemplatePhaseScalarFieldEnum[]
  }

  /**
   * TimelineTemplatePhase findFirstOrThrow
   */
  export type TimelineTemplatePhaseFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TimelineTemplatePhase
     */
    select?: TimelineTemplatePhaseSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TimelineTemplatePhase
     */
    omit?: TimelineTemplatePhaseOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TimelineTemplatePhaseInclude<ExtArgs> | null
    /**
     * Filter, which TimelineTemplatePhase to fetch.
     */
    where?: TimelineTemplatePhaseWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of TimelineTemplatePhases to fetch.
     */
    orderBy?: TimelineTemplatePhaseOrderByWithRelationInput | TimelineTemplatePhaseOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for TimelineTemplatePhases.
     */
    cursor?: TimelineTemplatePhaseWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` TimelineTemplatePhases from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` TimelineTemplatePhases.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of TimelineTemplatePhases.
     */
    distinct?: TimelineTemplatePhaseScalarFieldEnum | TimelineTemplatePhaseScalarFieldEnum[]
  }

  /**
   * TimelineTemplatePhase findMany
   */
  export type TimelineTemplatePhaseFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TimelineTemplatePhase
     */
    select?: TimelineTemplatePhaseSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TimelineTemplatePhase
     */
    omit?: TimelineTemplatePhaseOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TimelineTemplatePhaseInclude<ExtArgs> | null
    /**
     * Filter, which TimelineTemplatePhases to fetch.
     */
    where?: TimelineTemplatePhaseWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of TimelineTemplatePhases to fetch.
     */
    orderBy?: TimelineTemplatePhaseOrderByWithRelationInput | TimelineTemplatePhaseOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing TimelineTemplatePhases.
     */
    cursor?: TimelineTemplatePhaseWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` TimelineTemplatePhases from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` TimelineTemplatePhases.
     */
    skip?: number
    distinct?: TimelineTemplatePhaseScalarFieldEnum | TimelineTemplatePhaseScalarFieldEnum[]
  }

  /**
   * TimelineTemplatePhase create
   */
  export type TimelineTemplatePhaseCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TimelineTemplatePhase
     */
    select?: TimelineTemplatePhaseSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TimelineTemplatePhase
     */
    omit?: TimelineTemplatePhaseOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TimelineTemplatePhaseInclude<ExtArgs> | null
    /**
     * The data needed to create a TimelineTemplatePhase.
     */
    data: XOR<TimelineTemplatePhaseCreateInput, TimelineTemplatePhaseUncheckedCreateInput>
  }

  /**
   * TimelineTemplatePhase createMany
   */
  export type TimelineTemplatePhaseCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many TimelineTemplatePhases.
     */
    data: TimelineTemplatePhaseCreateManyInput | TimelineTemplatePhaseCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * TimelineTemplatePhase createManyAndReturn
   */
  export type TimelineTemplatePhaseCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TimelineTemplatePhase
     */
    select?: TimelineTemplatePhaseSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the TimelineTemplatePhase
     */
    omit?: TimelineTemplatePhaseOmit<ExtArgs> | null
    /**
     * The data used to create many TimelineTemplatePhases.
     */
    data: TimelineTemplatePhaseCreateManyInput | TimelineTemplatePhaseCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TimelineTemplatePhaseIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * TimelineTemplatePhase update
   */
  export type TimelineTemplatePhaseUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TimelineTemplatePhase
     */
    select?: TimelineTemplatePhaseSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TimelineTemplatePhase
     */
    omit?: TimelineTemplatePhaseOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TimelineTemplatePhaseInclude<ExtArgs> | null
    /**
     * The data needed to update a TimelineTemplatePhase.
     */
    data: XOR<TimelineTemplatePhaseUpdateInput, TimelineTemplatePhaseUncheckedUpdateInput>
    /**
     * Choose, which TimelineTemplatePhase to update.
     */
    where: TimelineTemplatePhaseWhereUniqueInput
  }

  /**
   * TimelineTemplatePhase updateMany
   */
  export type TimelineTemplatePhaseUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update TimelineTemplatePhases.
     */
    data: XOR<TimelineTemplatePhaseUpdateManyMutationInput, TimelineTemplatePhaseUncheckedUpdateManyInput>
    /**
     * Filter which TimelineTemplatePhases to update
     */
    where?: TimelineTemplatePhaseWhereInput
    /**
     * Limit how many TimelineTemplatePhases to update.
     */
    limit?: number
  }

  /**
   * TimelineTemplatePhase updateManyAndReturn
   */
  export type TimelineTemplatePhaseUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TimelineTemplatePhase
     */
    select?: TimelineTemplatePhaseSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the TimelineTemplatePhase
     */
    omit?: TimelineTemplatePhaseOmit<ExtArgs> | null
    /**
     * The data used to update TimelineTemplatePhases.
     */
    data: XOR<TimelineTemplatePhaseUpdateManyMutationInput, TimelineTemplatePhaseUncheckedUpdateManyInput>
    /**
     * Filter which TimelineTemplatePhases to update
     */
    where?: TimelineTemplatePhaseWhereInput
    /**
     * Limit how many TimelineTemplatePhases to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TimelineTemplatePhaseIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * TimelineTemplatePhase upsert
   */
  export type TimelineTemplatePhaseUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TimelineTemplatePhase
     */
    select?: TimelineTemplatePhaseSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TimelineTemplatePhase
     */
    omit?: TimelineTemplatePhaseOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TimelineTemplatePhaseInclude<ExtArgs> | null
    /**
     * The filter to search for the TimelineTemplatePhase to update in case it exists.
     */
    where: TimelineTemplatePhaseWhereUniqueInput
    /**
     * In case the TimelineTemplatePhase found by the `where` argument doesn't exist, create a new TimelineTemplatePhase with this data.
     */
    create: XOR<TimelineTemplatePhaseCreateInput, TimelineTemplatePhaseUncheckedCreateInput>
    /**
     * In case the TimelineTemplatePhase was found with the provided `where` argument, update it with this data.
     */
    update: XOR<TimelineTemplatePhaseUpdateInput, TimelineTemplatePhaseUncheckedUpdateInput>
  }

  /**
   * TimelineTemplatePhase delete
   */
  export type TimelineTemplatePhaseDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TimelineTemplatePhase
     */
    select?: TimelineTemplatePhaseSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TimelineTemplatePhase
     */
    omit?: TimelineTemplatePhaseOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TimelineTemplatePhaseInclude<ExtArgs> | null
    /**
     * Filter which TimelineTemplatePhase to delete.
     */
    where: TimelineTemplatePhaseWhereUniqueInput
  }

  /**
   * TimelineTemplatePhase deleteMany
   */
  export type TimelineTemplatePhaseDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which TimelineTemplatePhases to delete
     */
    where?: TimelineTemplatePhaseWhereInput
    /**
     * Limit how many TimelineTemplatePhases to delete.
     */
    limit?: number
  }

  /**
   * TimelineTemplatePhase without action
   */
  export type TimelineTemplatePhaseDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TimelineTemplatePhase
     */
    select?: TimelineTemplatePhaseSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TimelineTemplatePhase
     */
    omit?: TimelineTemplatePhaseOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TimelineTemplatePhaseInclude<ExtArgs> | null
  }


  /**
   * Model MemberChallengeAccess
   */

  export type AggregateMemberChallengeAccess = {
    _count: MemberChallengeAccessCountAggregateOutputType | null
    _min: MemberChallengeAccessMinAggregateOutputType | null
    _max: MemberChallengeAccessMaxAggregateOutputType | null
  }

  export type MemberChallengeAccessMinAggregateOutputType = {
    challengeId: string | null
    memberId: string | null
  }

  export type MemberChallengeAccessMaxAggregateOutputType = {
    challengeId: string | null
    memberId: string | null
  }

  export type MemberChallengeAccessCountAggregateOutputType = {
    challengeId: number
    memberId: number
    _all: number
  }


  export type MemberChallengeAccessMinAggregateInputType = {
    challengeId?: true
    memberId?: true
  }

  export type MemberChallengeAccessMaxAggregateInputType = {
    challengeId?: true
    memberId?: true
  }

  export type MemberChallengeAccessCountAggregateInputType = {
    challengeId?: true
    memberId?: true
    _all?: true
  }

  export type MemberChallengeAccessAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which MemberChallengeAccess to aggregate.
     */
    where?: MemberChallengeAccessWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of MemberChallengeAccesses to fetch.
     */
    orderBy?: MemberChallengeAccessOrderByWithRelationInput | MemberChallengeAccessOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` MemberChallengeAccesses from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` MemberChallengeAccesses.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned MemberChallengeAccesses
    **/
    _count?: true | MemberChallengeAccessCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: MemberChallengeAccessMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: MemberChallengeAccessMaxAggregateInputType
  }

  export type GetMemberChallengeAccessAggregateType<T extends MemberChallengeAccessAggregateArgs> = {
        [P in keyof T & keyof AggregateMemberChallengeAccess]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateMemberChallengeAccess[P]>
      : GetScalarType<T[P], AggregateMemberChallengeAccess[P]>
  }




  export type MemberChallengeAccessGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: MemberChallengeAccessWhereInput
    orderBy?: MemberChallengeAccessOrderByWithAggregationInput | MemberChallengeAccessOrderByWithAggregationInput[]
    by: MemberChallengeAccessScalarFieldEnum[] | MemberChallengeAccessScalarFieldEnum
    having?: MemberChallengeAccessScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: MemberChallengeAccessCountAggregateInputType | true
    _min?: MemberChallengeAccessMinAggregateInputType
    _max?: MemberChallengeAccessMaxAggregateInputType
  }

  export type MemberChallengeAccessGroupByOutputType = {
    challengeId: string
    memberId: string
    _count: MemberChallengeAccessCountAggregateOutputType | null
    _min: MemberChallengeAccessMinAggregateOutputType | null
    _max: MemberChallengeAccessMaxAggregateOutputType | null
  }

  type GetMemberChallengeAccessGroupByPayload<T extends MemberChallengeAccessGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<MemberChallengeAccessGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof MemberChallengeAccessGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], MemberChallengeAccessGroupByOutputType[P]>
            : GetScalarType<T[P], MemberChallengeAccessGroupByOutputType[P]>
        }
      >
    >


  export type MemberChallengeAccessSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    challengeId?: boolean
    memberId?: boolean
    challenge?: boolean | ChallengeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["memberChallengeAccess"]>



  export type MemberChallengeAccessSelectScalar = {
    challengeId?: boolean
    memberId?: boolean
  }

  export type MemberChallengeAccessOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"challengeId" | "memberId", ExtArgs["result"]["memberChallengeAccess"]>
  export type MemberChallengeAccessInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    challenge?: boolean | ChallengeDefaultArgs<ExtArgs>
  }

  export type $MemberChallengeAccessPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "MemberChallengeAccess"
    objects: {
      challenge: Prisma.$ChallengePayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      challengeId: string
      memberId: string
    }, ExtArgs["result"]["memberChallengeAccess"]>
    composites: {}
  }

  type MemberChallengeAccessGetPayload<S extends boolean | null | undefined | MemberChallengeAccessDefaultArgs> = $Result.GetResult<Prisma.$MemberChallengeAccessPayload, S>

  type MemberChallengeAccessCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<MemberChallengeAccessFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: MemberChallengeAccessCountAggregateInputType | true
    }

  export interface MemberChallengeAccessDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['MemberChallengeAccess'], meta: { name: 'MemberChallengeAccess' } }
    /**
     * Find the first MemberChallengeAccess that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MemberChallengeAccessFindFirstArgs} args - Arguments to find a MemberChallengeAccess
     * @example
     * // Get one MemberChallengeAccess
     * const memberChallengeAccess = await prisma.memberChallengeAccess.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends MemberChallengeAccessFindFirstArgs, TakeDependenciesValidator extends "take" extends Prisma.Keys<T> ? {
      orderBy: {}
    } : {}, SkipDependenciesValidator extends "skip" extends Prisma.Keys<T> ? {
      orderBy: {}
    } : {}>(args?: SelectSubset<T, MemberChallengeAccessFindFirstArgs<ExtArgs>> & TakeDependenciesValidator & SkipDependenciesValidator): Prisma__MemberChallengeAccessClient<$Result.GetResult<Prisma.$MemberChallengeAccessPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first MemberChallengeAccess that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MemberChallengeAccessFindFirstOrThrowArgs} args - Arguments to find a MemberChallengeAccess
     * @example
     * // Get one MemberChallengeAccess
     * const memberChallengeAccess = await prisma.memberChallengeAccess.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends MemberChallengeAccessFindFirstOrThrowArgs, TakeDependenciesValidator extends "take" extends Prisma.Keys<T> ? {
      orderBy: {}
    } : {}, SkipDependenciesValidator extends "skip" extends Prisma.Keys<T> ? {
      orderBy: {}
    } : {}>(args?: SelectSubset<T, MemberChallengeAccessFindFirstOrThrowArgs<ExtArgs>> & TakeDependenciesValidator & SkipDependenciesValidator): Prisma__MemberChallengeAccessClient<$Result.GetResult<Prisma.$MemberChallengeAccessPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more MemberChallengeAccesses that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MemberChallengeAccessFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all MemberChallengeAccesses
     * const memberChallengeAccesses = await prisma.memberChallengeAccess.findMany()
     * 
     * // Get first 10 MemberChallengeAccesses
     * const memberChallengeAccesses = await prisma.memberChallengeAccess.findMany({ take: 10 })
     * 
     * // Only select the `challengeId`
     * const memberChallengeAccessWithChallengeIdOnly = await prisma.memberChallengeAccess.findMany({ select: { challengeId: true } })
     * 
     */
    findMany<T extends MemberChallengeAccessFindManyArgs, TakeDependenciesValidator extends "take" extends Prisma.Keys<T> ? {
      orderBy: {}
    } : {}, SkipDependenciesValidator extends "skip" extends Prisma.Keys<T> ? {
      orderBy: {}
    } : {}>(args?: SelectSubset<T, MemberChallengeAccessFindManyArgs<ExtArgs>> & TakeDependenciesValidator & SkipDependenciesValidator): Prisma.PrismaPromise<$Result.GetResult<Prisma.$MemberChallengeAccessPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>


    /**
     * Count the number of MemberChallengeAccesses.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MemberChallengeAccessCountArgs} args - Arguments to filter MemberChallengeAccesses to count.
     * @example
     * // Count the number of MemberChallengeAccesses
     * const count = await prisma.memberChallengeAccess.count({
     *   where: {
     *     // ... the filter for the MemberChallengeAccesses we want to count
     *   }
     * })
    **/
    count<T extends MemberChallengeAccessCountArgs>(
      args?: Subset<T, MemberChallengeAccessCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], MemberChallengeAccessCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a MemberChallengeAccess.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MemberChallengeAccessAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends MemberChallengeAccessAggregateArgs>(args: Subset<T, MemberChallengeAccessAggregateArgs>): Prisma.PrismaPromise<GetMemberChallengeAccessAggregateType<T>>

    /**
     * Group by MemberChallengeAccess.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MemberChallengeAccessGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends MemberChallengeAccessGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: MemberChallengeAccessGroupByArgs['orderBy'] }
        : { orderBy?: MemberChallengeAccessGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, MemberChallengeAccessGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetMemberChallengeAccessGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the MemberChallengeAccess model
   */
  readonly fields: MemberChallengeAccessFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for MemberChallengeAccess.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__MemberChallengeAccessClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    challenge<T extends ChallengeDefaultArgs<ExtArgs> = {}>(args?: Subset<T, ChallengeDefaultArgs<ExtArgs>>): Prisma__ChallengeClient<$Result.GetResult<Prisma.$ChallengePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the MemberChallengeAccess model
   */
  interface MemberChallengeAccessFieldRefs {
    readonly challengeId: FieldRef<"MemberChallengeAccess", 'String'>
    readonly memberId: FieldRef<"MemberChallengeAccess", 'String'>
  }
    

  // Custom InputTypes
  /**
   * MemberChallengeAccess findFirst
   */
  export type MemberChallengeAccessFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MemberChallengeAccess
     */
    select?: MemberChallengeAccessSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MemberChallengeAccess
     */
    omit?: MemberChallengeAccessOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MemberChallengeAccessInclude<ExtArgs> | null
    /**
     * Filter, which MemberChallengeAccess to fetch.
     */
    where?: MemberChallengeAccessWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of MemberChallengeAccesses to fetch.
     */
    orderBy?: MemberChallengeAccessOrderByWithRelationInput | MemberChallengeAccessOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` MemberChallengeAccesses from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` MemberChallengeAccesses.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of MemberChallengeAccesses.
     */
    distinct?: MemberChallengeAccessScalarFieldEnum | MemberChallengeAccessScalarFieldEnum[]
  }

  /**
   * MemberChallengeAccess findFirstOrThrow
   */
  export type MemberChallengeAccessFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MemberChallengeAccess
     */
    select?: MemberChallengeAccessSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MemberChallengeAccess
     */
    omit?: MemberChallengeAccessOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MemberChallengeAccessInclude<ExtArgs> | null
    /**
     * Filter, which MemberChallengeAccess to fetch.
     */
    where?: MemberChallengeAccessWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of MemberChallengeAccesses to fetch.
     */
    orderBy?: MemberChallengeAccessOrderByWithRelationInput | MemberChallengeAccessOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` MemberChallengeAccesses from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` MemberChallengeAccesses.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of MemberChallengeAccesses.
     */
    distinct?: MemberChallengeAccessScalarFieldEnum | MemberChallengeAccessScalarFieldEnum[]
  }

  /**
   * MemberChallengeAccess findMany
   */
  export type MemberChallengeAccessFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MemberChallengeAccess
     */
    select?: MemberChallengeAccessSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MemberChallengeAccess
     */
    omit?: MemberChallengeAccessOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MemberChallengeAccessInclude<ExtArgs> | null
    /**
     * Filter, which MemberChallengeAccesses to fetch.
     */
    where?: MemberChallengeAccessWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of MemberChallengeAccesses to fetch.
     */
    orderBy?: MemberChallengeAccessOrderByWithRelationInput | MemberChallengeAccessOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` MemberChallengeAccesses from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` MemberChallengeAccesses.
     */
    skip?: number
    distinct?: MemberChallengeAccessScalarFieldEnum | MemberChallengeAccessScalarFieldEnum[]
  }

  /**
   * MemberChallengeAccess without action
   */
  export type MemberChallengeAccessDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MemberChallengeAccess
     */
    select?: MemberChallengeAccessSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MemberChallengeAccess
     */
    omit?: MemberChallengeAccessOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MemberChallengeAccessInclude<ExtArgs> | null
  }


  /**
   * Enums
   */

  export const TransactionIsolationLevel: {
    ReadUncommitted: 'ReadUncommitted',
    ReadCommitted: 'ReadCommitted',
    RepeatableRead: 'RepeatableRead',
    Serializable: 'Serializable'
  };

  export type TransactionIsolationLevel = (typeof TransactionIsolationLevel)[keyof typeof TransactionIsolationLevel]


  export const ChallengeScalarFieldEnum: {
    id: 'id',
    name: 'name',
    description: 'description',
    privateDescription: 'privateDescription',
    challengeSource: 'challengeSource',
    descriptionFormat: 'descriptionFormat',
    projectId: 'projectId',
    typeId: 'typeId',
    trackId: 'trackId',
    timelineTemplateId: 'timelineTemplateId',
    overviewTotalPrizes: 'overviewTotalPrizes',
    numOfRegistrants: 'numOfRegistrants',
    numOfSubmissions: 'numOfSubmissions',
    numOfCheckpointSubmissions: 'numOfCheckpointSubmissions',
    currentPhaseNames: 'currentPhaseNames',
    wiproAllowed: 'wiproAllowed',
    tags: 'tags',
    groups: 'groups',
    taskIsTask: 'taskIsTask',
    taskIsAssigned: 'taskIsAssigned',
    taskMemberId: 'taskMemberId',
    submissionStartDate: 'submissionStartDate',
    submissionEndDate: 'submissionEndDate',
    registrationStartDate: 'registrationStartDate',
    registrationEndDate: 'registrationEndDate',
    startDate: 'startDate',
    endDate: 'endDate',
    legacyId: 'legacyId',
    status: 'status',
    createdAt: 'createdAt',
    createdBy: 'createdBy',
    updatedAt: 'updatedAt',
    updatedBy: 'updatedBy'
  };

  export type ChallengeScalarFieldEnum = (typeof ChallengeScalarFieldEnum)[keyof typeof ChallengeScalarFieldEnum]


  export const ChallengeTypeScalarFieldEnum: {
    id: 'id',
    name: 'name',
    description: 'description',
    isActive: 'isActive',
    isTask: 'isTask',
    abbreviation: 'abbreviation',
    createdAt: 'createdAt',
    createdBy: 'createdBy',
    updatedAt: 'updatedAt',
    updatedBy: 'updatedBy'
  };

  export type ChallengeTypeScalarFieldEnum = (typeof ChallengeTypeScalarFieldEnum)[keyof typeof ChallengeTypeScalarFieldEnum]


  export const ChallengeTrackScalarFieldEnum: {
    id: 'id',
    name: 'name',
    description: 'description',
    isActive: 'isActive',
    abbreviation: 'abbreviation',
    legacyId: 'legacyId',
    track: 'track',
    createdAt: 'createdAt',
    createdBy: 'createdBy',
    updatedAt: 'updatedAt',
    updatedBy: 'updatedBy'
  };

  export type ChallengeTrackScalarFieldEnum = (typeof ChallengeTrackScalarFieldEnum)[keyof typeof ChallengeTrackScalarFieldEnum]


  export const ChallengeTimelineTemplateScalarFieldEnum: {
    id: 'id',
    typeId: 'typeId',
    trackId: 'trackId',
    timelineTemplateId: 'timelineTemplateId',
    isDefault: 'isDefault',
    createdAt: 'createdAt',
    createdBy: 'createdBy',
    updatedAt: 'updatedAt',
    updatedBy: 'updatedBy'
  };

  export type ChallengeTimelineTemplateScalarFieldEnum = (typeof ChallengeTimelineTemplateScalarFieldEnum)[keyof typeof ChallengeTimelineTemplateScalarFieldEnum]


  export const AuditLogScalarFieldEnum: {
    id: 'id',
    challengeId: 'challengeId',
    fieldName: 'fieldName',
    oldValue: 'oldValue',
    newValue: 'newValue',
    createdAt: 'createdAt',
    createdBy: 'createdBy',
    memberId: 'memberId'
  };

  export type AuditLogScalarFieldEnum = (typeof AuditLogScalarFieldEnum)[keyof typeof AuditLogScalarFieldEnum]


  export const AttachmentScalarFieldEnum: {
    id: 'id',
    challengeId: 'challengeId',
    name: 'name',
    fileSize: 'fileSize',
    url: 'url',
    description: 'description',
    createdAt: 'createdAt',
    createdBy: 'createdBy',
    updatedAt: 'updatedAt',
    updatedBy: 'updatedBy'
  };

  export type AttachmentScalarFieldEnum = (typeof AttachmentScalarFieldEnum)[keyof typeof AttachmentScalarFieldEnum]


  export const ChallengeMetadataScalarFieldEnum: {
    id: 'id',
    challengeId: 'challengeId',
    name: 'name',
    value: 'value',
    createdAt: 'createdAt',
    createdBy: 'createdBy',
    updatedAt: 'updatedAt',
    updatedBy: 'updatedBy'
  };

  export type ChallengeMetadataScalarFieldEnum = (typeof ChallengeMetadataScalarFieldEnum)[keyof typeof ChallengeMetadataScalarFieldEnum]


  export const PrizeScalarFieldEnum: {
    id: 'id',
    description: 'description',
    prizeSetId: 'prizeSetId',
    type: 'type',
    value: 'value',
    createdAt: 'createdAt',
    createdBy: 'createdBy',
    updatedAt: 'updatedAt',
    updatedBy: 'updatedBy'
  };

  export type PrizeScalarFieldEnum = (typeof PrizeScalarFieldEnum)[keyof typeof PrizeScalarFieldEnum]


  export const ChallengeWinnerScalarFieldEnum: {
    id: 'id',
    challengeId: 'challengeId',
    userId: 'userId',
    handle: 'handle',
    placement: 'placement',
    type: 'type',
    createdAt: 'createdAt',
    createdBy: 'createdBy',
    updatedAt: 'updatedAt',
    updatedBy: 'updatedBy'
  };

  export type ChallengeWinnerScalarFieldEnum = (typeof ChallengeWinnerScalarFieldEnum)[keyof typeof ChallengeWinnerScalarFieldEnum]


  export const ChallengeTermScalarFieldEnum: {
    id: 'id',
    challengeId: 'challengeId',
    termId: 'termId',
    roleId: 'roleId',
    createdAt: 'createdAt',
    createdBy: 'createdBy',
    updatedAt: 'updatedAt',
    updatedBy: 'updatedBy'
  };

  export type ChallengeTermScalarFieldEnum = (typeof ChallengeTermScalarFieldEnum)[keyof typeof ChallengeTermScalarFieldEnum]


  export const ChallengeSkillScalarFieldEnum: {
    id: 'id',
    challengeId: 'challengeId',
    skillId: 'skillId',
    createdAt: 'createdAt',
    createdBy: 'createdBy',
    updatedAt: 'updatedAt',
    updatedBy: 'updatedBy'
  };

  export type ChallengeSkillScalarFieldEnum = (typeof ChallengeSkillScalarFieldEnum)[keyof typeof ChallengeSkillScalarFieldEnum]


  export const ChallengeBillingScalarFieldEnum: {
    id: 'id',
    billingAccountId: 'billingAccountId',
    markup: 'markup',
    clientBillingRate: 'clientBillingRate',
    challengeId: 'challengeId',
    createdAt: 'createdAt',
    createdBy: 'createdBy',
    updatedAt: 'updatedAt',
    updatedBy: 'updatedBy'
  };

  export type ChallengeBillingScalarFieldEnum = (typeof ChallengeBillingScalarFieldEnum)[keyof typeof ChallengeBillingScalarFieldEnum]


  export const ChallengeLegacyScalarFieldEnum: {
    id: 'id',
    reviewType: 'reviewType',
    confidentialityType: 'confidentialityType',
    forumId: 'forumId',
    directProjectId: 'directProjectId',
    screeningScorecardId: 'screeningScorecardId',
    reviewScorecardId: 'reviewScorecardId',
    isTask: 'isTask',
    useSchedulingAPI: 'useSchedulingAPI',
    pureV5Task: 'pureV5Task',
    pureV5: 'pureV5',
    selfService: 'selfService',
    selfServiceCopilot: 'selfServiceCopilot',
    track: 'track',
    subTrack: 'subTrack',
    legacySystemId: 'legacySystemId',
    challengeId: 'challengeId',
    createdAt: 'createdAt',
    createdBy: 'createdBy',
    updatedAt: 'updatedAt',
    updatedBy: 'updatedBy'
  };

  export type ChallengeLegacyScalarFieldEnum = (typeof ChallengeLegacyScalarFieldEnum)[keyof typeof ChallengeLegacyScalarFieldEnum]


  export const ChallengeEventScalarFieldEnum: {
    id: 'id',
    challengeId: 'challengeId',
    eventId: 'eventId',
    name: 'name',
    key: 'key',
    createdAt: 'createdAt',
    createdBy: 'createdBy',
    updatedAt: 'updatedAt',
    updatedBy: 'updatedBy'
  };

  export type ChallengeEventScalarFieldEnum = (typeof ChallengeEventScalarFieldEnum)[keyof typeof ChallengeEventScalarFieldEnum]


  export const ChallengeDiscussionScalarFieldEnum: {
    id: 'id',
    challengeId: 'challengeId',
    discussionId: 'discussionId',
    name: 'name',
    type: 'type',
    provider: 'provider',
    url: 'url',
    createdAt: 'createdAt',
    createdBy: 'createdBy',
    updatedAt: 'updatedAt',
    updatedBy: 'updatedBy'
  };

  export type ChallengeDiscussionScalarFieldEnum = (typeof ChallengeDiscussionScalarFieldEnum)[keyof typeof ChallengeDiscussionScalarFieldEnum]


  export const ChallengeDiscussionOptionScalarFieldEnum: {
    id: 'id',
    discussionId: 'discussionId',
    optionKey: 'optionKey',
    optionValue: 'optionValue',
    createdAt: 'createdAt',
    createdBy: 'createdBy',
    updatedAt: 'updatedAt',
    updatedBy: 'updatedBy'
  };

  export type ChallengeDiscussionOptionScalarFieldEnum = (typeof ChallengeDiscussionOptionScalarFieldEnum)[keyof typeof ChallengeDiscussionOptionScalarFieldEnum]


  export const ChallengeConstraintScalarFieldEnum: {
    id: 'id',
    challengeId: 'challengeId',
    allowedRegistrants: 'allowedRegistrants',
    createdAt: 'createdAt',
    createdBy: 'createdBy',
    updatedAt: 'updatedAt',
    updatedBy: 'updatedBy'
  };

  export type ChallengeConstraintScalarFieldEnum = (typeof ChallengeConstraintScalarFieldEnum)[keyof typeof ChallengeConstraintScalarFieldEnum]


  export const PhaseScalarFieldEnum: {
    id: 'id',
    name: 'name',
    description: 'description',
    isOpen: 'isOpen',
    duration: 'duration',
    createdAt: 'createdAt',
    createdBy: 'createdBy',
    updatedAt: 'updatedAt',
    updatedBy: 'updatedBy'
  };

  export type PhaseScalarFieldEnum = (typeof PhaseScalarFieldEnum)[keyof typeof PhaseScalarFieldEnum]


  export const ChallengePhaseScalarFieldEnum: {
    id: 'id',
    challengeId: 'challengeId',
    phaseId: 'phaseId',
    name: 'name',
    description: 'description',
    isOpen: 'isOpen',
    predecessor: 'predecessor',
    duration: 'duration',
    scheduledStartDate: 'scheduledStartDate',
    scheduledEndDate: 'scheduledEndDate',
    actualStartDate: 'actualStartDate',
    actualEndDate: 'actualEndDate',
    createdAt: 'createdAt',
    createdBy: 'createdBy',
    updatedAt: 'updatedAt',
    updatedBy: 'updatedBy'
  };

  export type ChallengePhaseScalarFieldEnum = (typeof ChallengePhaseScalarFieldEnum)[keyof typeof ChallengePhaseScalarFieldEnum]


  export const ChallengePhaseConstraintScalarFieldEnum: {
    id: 'id',
    challengePhaseId: 'challengePhaseId',
    name: 'name',
    value: 'value',
    createdAt: 'createdAt',
    createdBy: 'createdBy',
    updatedAt: 'updatedAt',
    updatedBy: 'updatedBy'
  };

  export type ChallengePhaseConstraintScalarFieldEnum = (typeof ChallengePhaseConstraintScalarFieldEnum)[keyof typeof ChallengePhaseConstraintScalarFieldEnum]


  export const ChallengePrizeSetScalarFieldEnum: {
    id: 'id',
    challengeId: 'challengeId',
    type: 'type',
    description: 'description',
    createdAt: 'createdAt',
    createdBy: 'createdBy',
    updatedAt: 'updatedAt',
    updatedBy: 'updatedBy'
  };

  export type ChallengePrizeSetScalarFieldEnum = (typeof ChallengePrizeSetScalarFieldEnum)[keyof typeof ChallengePrizeSetScalarFieldEnum]


  export const ChallengeReviewerScalarFieldEnum: {
    id: 'id',
    challengeId: 'challengeId',
    scorecardId: 'scorecardId',
    isMemberReview: 'isMemberReview',
    memberReviewerCount: 'memberReviewerCount',
    phaseId: 'phaseId',
    fixedAmount: 'fixedAmount',
    baseCoefficient: 'baseCoefficient',
    incrementalCoefficient: 'incrementalCoefficient',
    type: 'type',
    aiWorkflowId: 'aiWorkflowId',
    shouldOpenOpportunity: 'shouldOpenOpportunity',
    createdAt: 'createdAt',
    createdBy: 'createdBy',
    updatedAt: 'updatedAt',
    updatedBy: 'updatedBy'
  };

  export type ChallengeReviewerScalarFieldEnum = (typeof ChallengeReviewerScalarFieldEnum)[keyof typeof ChallengeReviewerScalarFieldEnum]


  export const DefaultChallengeReviewerScalarFieldEnum: {
    id: 'id',
    typeId: 'typeId',
    trackId: 'trackId',
    timelineTemplateId: 'timelineTemplateId',
    scorecardId: 'scorecardId',
    isMemberReview: 'isMemberReview',
    memberReviewerCount: 'memberReviewerCount',
    phaseName: 'phaseName',
    phaseId: 'phaseId',
    fixedAmount: 'fixedAmount',
    baseCoefficient: 'baseCoefficient',
    incrementalCoefficient: 'incrementalCoefficient',
    opportunityType: 'opportunityType',
    aiWorkflowId: 'aiWorkflowId',
    shouldOpenOpportunity: 'shouldOpenOpportunity',
    createdAt: 'createdAt',
    createdBy: 'createdBy',
    updatedAt: 'updatedAt',
    updatedBy: 'updatedBy'
  };

  export type DefaultChallengeReviewerScalarFieldEnum = (typeof DefaultChallengeReviewerScalarFieldEnum)[keyof typeof DefaultChallengeReviewerScalarFieldEnum]


  export const TimelineTemplateScalarFieldEnum: {
    id: 'id',
    name: 'name',
    description: 'description',
    isActive: 'isActive',
    createdAt: 'createdAt',
    createdBy: 'createdBy',
    updatedAt: 'updatedAt',
    updatedBy: 'updatedBy'
  };

  export type TimelineTemplateScalarFieldEnum = (typeof TimelineTemplateScalarFieldEnum)[keyof typeof TimelineTemplateScalarFieldEnum]


  export const TimelineTemplatePhaseScalarFieldEnum: {
    id: 'id',
    timelineTemplateId: 'timelineTemplateId',
    phaseId: 'phaseId',
    predecessor: 'predecessor',
    defaultDuration: 'defaultDuration',
    createdAt: 'createdAt',
    createdBy: 'createdBy',
    updatedAt: 'updatedAt',
    updatedBy: 'updatedBy'
  };

  export type TimelineTemplatePhaseScalarFieldEnum = (typeof TimelineTemplatePhaseScalarFieldEnum)[keyof typeof TimelineTemplatePhaseScalarFieldEnum]


  export const MemberChallengeAccessScalarFieldEnum: {
    challengeId: 'challengeId',
    memberId: 'memberId'
  };

  export type MemberChallengeAccessScalarFieldEnum = (typeof MemberChallengeAccessScalarFieldEnum)[keyof typeof MemberChallengeAccessScalarFieldEnum]


  export const SortOrder: {
    asc: 'asc',
    desc: 'desc'
  };

  export type SortOrder = (typeof SortOrder)[keyof typeof SortOrder]


  export const QueryMode: {
    default: 'default',
    insensitive: 'insensitive'
  };

  export type QueryMode = (typeof QueryMode)[keyof typeof QueryMode]


  export const NullsOrder: {
    first: 'first',
    last: 'last'
  };

  export type NullsOrder = (typeof NullsOrder)[keyof typeof NullsOrder]


  export const ChallengeOrderByRelevanceFieldEnum: {
    id: 'id',
    name: 'name',
    description: 'description',
    privateDescription: 'privateDescription',
    challengeSource: 'challengeSource',
    descriptionFormat: 'descriptionFormat',
    typeId: 'typeId',
    trackId: 'trackId',
    timelineTemplateId: 'timelineTemplateId',
    currentPhaseNames: 'currentPhaseNames',
    tags: 'tags',
    groups: 'groups',
    taskMemberId: 'taskMemberId',
    createdBy: 'createdBy',
    updatedBy: 'updatedBy'
  };

  export type ChallengeOrderByRelevanceFieldEnum = (typeof ChallengeOrderByRelevanceFieldEnum)[keyof typeof ChallengeOrderByRelevanceFieldEnum]


  export const ChallengeTypeOrderByRelevanceFieldEnum: {
    id: 'id',
    name: 'name',
    description: 'description',
    abbreviation: 'abbreviation',
    createdBy: 'createdBy',
    updatedBy: 'updatedBy'
  };

  export type ChallengeTypeOrderByRelevanceFieldEnum = (typeof ChallengeTypeOrderByRelevanceFieldEnum)[keyof typeof ChallengeTypeOrderByRelevanceFieldEnum]


  export const ChallengeTrackOrderByRelevanceFieldEnum: {
    id: 'id',
    name: 'name',
    description: 'description',
    abbreviation: 'abbreviation',
    createdBy: 'createdBy',
    updatedBy: 'updatedBy'
  };

  export type ChallengeTrackOrderByRelevanceFieldEnum = (typeof ChallengeTrackOrderByRelevanceFieldEnum)[keyof typeof ChallengeTrackOrderByRelevanceFieldEnum]


  export const ChallengeTimelineTemplateOrderByRelevanceFieldEnum: {
    id: 'id',
    typeId: 'typeId',
    trackId: 'trackId',
    timelineTemplateId: 'timelineTemplateId',
    createdBy: 'createdBy',
    updatedBy: 'updatedBy'
  };

  export type ChallengeTimelineTemplateOrderByRelevanceFieldEnum = (typeof ChallengeTimelineTemplateOrderByRelevanceFieldEnum)[keyof typeof ChallengeTimelineTemplateOrderByRelevanceFieldEnum]


  export const AuditLogOrderByRelevanceFieldEnum: {
    id: 'id',
    challengeId: 'challengeId',
    fieldName: 'fieldName',
    oldValue: 'oldValue',
    newValue: 'newValue',
    createdBy: 'createdBy',
    memberId: 'memberId'
  };

  export type AuditLogOrderByRelevanceFieldEnum = (typeof AuditLogOrderByRelevanceFieldEnum)[keyof typeof AuditLogOrderByRelevanceFieldEnum]


  export const AttachmentOrderByRelevanceFieldEnum: {
    id: 'id',
    challengeId: 'challengeId',
    name: 'name',
    url: 'url',
    description: 'description',
    createdBy: 'createdBy',
    updatedBy: 'updatedBy'
  };

  export type AttachmentOrderByRelevanceFieldEnum = (typeof AttachmentOrderByRelevanceFieldEnum)[keyof typeof AttachmentOrderByRelevanceFieldEnum]


  export const ChallengeMetadataOrderByRelevanceFieldEnum: {
    id: 'id',
    challengeId: 'challengeId',
    name: 'name',
    value: 'value',
    createdBy: 'createdBy',
    updatedBy: 'updatedBy'
  };

  export type ChallengeMetadataOrderByRelevanceFieldEnum = (typeof ChallengeMetadataOrderByRelevanceFieldEnum)[keyof typeof ChallengeMetadataOrderByRelevanceFieldEnum]


  export const PrizeOrderByRelevanceFieldEnum: {
    id: 'id',
    description: 'description',
    prizeSetId: 'prizeSetId',
    type: 'type',
    createdBy: 'createdBy',
    updatedBy: 'updatedBy'
  };

  export type PrizeOrderByRelevanceFieldEnum = (typeof PrizeOrderByRelevanceFieldEnum)[keyof typeof PrizeOrderByRelevanceFieldEnum]


  export const ChallengeWinnerOrderByRelevanceFieldEnum: {
    id: 'id',
    challengeId: 'challengeId',
    handle: 'handle',
    createdBy: 'createdBy',
    updatedBy: 'updatedBy'
  };

  export type ChallengeWinnerOrderByRelevanceFieldEnum = (typeof ChallengeWinnerOrderByRelevanceFieldEnum)[keyof typeof ChallengeWinnerOrderByRelevanceFieldEnum]


  export const ChallengeTermOrderByRelevanceFieldEnum: {
    id: 'id',
    challengeId: 'challengeId',
    termId: 'termId',
    roleId: 'roleId',
    createdBy: 'createdBy',
    updatedBy: 'updatedBy'
  };

  export type ChallengeTermOrderByRelevanceFieldEnum = (typeof ChallengeTermOrderByRelevanceFieldEnum)[keyof typeof ChallengeTermOrderByRelevanceFieldEnum]


  export const ChallengeSkillOrderByRelevanceFieldEnum: {
    id: 'id',
    challengeId: 'challengeId',
    skillId: 'skillId',
    createdBy: 'createdBy',
    updatedBy: 'updatedBy'
  };

  export type ChallengeSkillOrderByRelevanceFieldEnum = (typeof ChallengeSkillOrderByRelevanceFieldEnum)[keyof typeof ChallengeSkillOrderByRelevanceFieldEnum]


  export const ChallengeBillingOrderByRelevanceFieldEnum: {
    id: 'id',
    billingAccountId: 'billingAccountId',
    challengeId: 'challengeId',
    createdBy: 'createdBy',
    updatedBy: 'updatedBy'
  };

  export type ChallengeBillingOrderByRelevanceFieldEnum = (typeof ChallengeBillingOrderByRelevanceFieldEnum)[keyof typeof ChallengeBillingOrderByRelevanceFieldEnum]


  export const ChallengeLegacyOrderByRelevanceFieldEnum: {
    id: 'id',
    confidentialityType: 'confidentialityType',
    selfServiceCopilot: 'selfServiceCopilot',
    track: 'track',
    subTrack: 'subTrack',
    challengeId: 'challengeId',
    createdBy: 'createdBy',
    updatedBy: 'updatedBy'
  };

  export type ChallengeLegacyOrderByRelevanceFieldEnum = (typeof ChallengeLegacyOrderByRelevanceFieldEnum)[keyof typeof ChallengeLegacyOrderByRelevanceFieldEnum]


  export const ChallengeEventOrderByRelevanceFieldEnum: {
    id: 'id',
    challengeId: 'challengeId',
    name: 'name',
    key: 'key',
    createdBy: 'createdBy',
    updatedBy: 'updatedBy'
  };

  export type ChallengeEventOrderByRelevanceFieldEnum = (typeof ChallengeEventOrderByRelevanceFieldEnum)[keyof typeof ChallengeEventOrderByRelevanceFieldEnum]


  export const ChallengeDiscussionOrderByRelevanceFieldEnum: {
    id: 'id',
    challengeId: 'challengeId',
    discussionId: 'discussionId',
    name: 'name',
    provider: 'provider',
    url: 'url',
    createdBy: 'createdBy',
    updatedBy: 'updatedBy'
  };

  export type ChallengeDiscussionOrderByRelevanceFieldEnum = (typeof ChallengeDiscussionOrderByRelevanceFieldEnum)[keyof typeof ChallengeDiscussionOrderByRelevanceFieldEnum]


  export const ChallengeDiscussionOptionOrderByRelevanceFieldEnum: {
    id: 'id',
    discussionId: 'discussionId',
    optionKey: 'optionKey',
    optionValue: 'optionValue',
    createdBy: 'createdBy',
    updatedBy: 'updatedBy'
  };

  export type ChallengeDiscussionOptionOrderByRelevanceFieldEnum = (typeof ChallengeDiscussionOptionOrderByRelevanceFieldEnum)[keyof typeof ChallengeDiscussionOptionOrderByRelevanceFieldEnum]


  export const ChallengeConstraintOrderByRelevanceFieldEnum: {
    id: 'id',
    challengeId: 'challengeId',
    allowedRegistrants: 'allowedRegistrants',
    createdBy: 'createdBy',
    updatedBy: 'updatedBy'
  };

  export type ChallengeConstraintOrderByRelevanceFieldEnum = (typeof ChallengeConstraintOrderByRelevanceFieldEnum)[keyof typeof ChallengeConstraintOrderByRelevanceFieldEnum]


  export const PhaseOrderByRelevanceFieldEnum: {
    id: 'id',
    name: 'name',
    description: 'description',
    createdBy: 'createdBy',
    updatedBy: 'updatedBy'
  };

  export type PhaseOrderByRelevanceFieldEnum = (typeof PhaseOrderByRelevanceFieldEnum)[keyof typeof PhaseOrderByRelevanceFieldEnum]


  export const ChallengePhaseOrderByRelevanceFieldEnum: {
    id: 'id',
    challengeId: 'challengeId',
    phaseId: 'phaseId',
    name: 'name',
    description: 'description',
    predecessor: 'predecessor',
    createdBy: 'createdBy',
    updatedBy: 'updatedBy'
  };

  export type ChallengePhaseOrderByRelevanceFieldEnum = (typeof ChallengePhaseOrderByRelevanceFieldEnum)[keyof typeof ChallengePhaseOrderByRelevanceFieldEnum]


  export const ChallengePhaseConstraintOrderByRelevanceFieldEnum: {
    id: 'id',
    challengePhaseId: 'challengePhaseId',
    name: 'name',
    createdBy: 'createdBy',
    updatedBy: 'updatedBy'
  };

  export type ChallengePhaseConstraintOrderByRelevanceFieldEnum = (typeof ChallengePhaseConstraintOrderByRelevanceFieldEnum)[keyof typeof ChallengePhaseConstraintOrderByRelevanceFieldEnum]


  export const ChallengePrizeSetOrderByRelevanceFieldEnum: {
    id: 'id',
    challengeId: 'challengeId',
    description: 'description',
    createdBy: 'createdBy',
    updatedBy: 'updatedBy'
  };

  export type ChallengePrizeSetOrderByRelevanceFieldEnum = (typeof ChallengePrizeSetOrderByRelevanceFieldEnum)[keyof typeof ChallengePrizeSetOrderByRelevanceFieldEnum]


  export const ChallengeReviewerOrderByRelevanceFieldEnum: {
    id: 'id',
    challengeId: 'challengeId',
    scorecardId: 'scorecardId',
    phaseId: 'phaseId',
    aiWorkflowId: 'aiWorkflowId',
    createdBy: 'createdBy',
    updatedBy: 'updatedBy'
  };

  export type ChallengeReviewerOrderByRelevanceFieldEnum = (typeof ChallengeReviewerOrderByRelevanceFieldEnum)[keyof typeof ChallengeReviewerOrderByRelevanceFieldEnum]


  export const DefaultChallengeReviewerOrderByRelevanceFieldEnum: {
    id: 'id',
    typeId: 'typeId',
    trackId: 'trackId',
    timelineTemplateId: 'timelineTemplateId',
    scorecardId: 'scorecardId',
    phaseName: 'phaseName',
    phaseId: 'phaseId',
    aiWorkflowId: 'aiWorkflowId',
    createdBy: 'createdBy',
    updatedBy: 'updatedBy'
  };

  export type DefaultChallengeReviewerOrderByRelevanceFieldEnum = (typeof DefaultChallengeReviewerOrderByRelevanceFieldEnum)[keyof typeof DefaultChallengeReviewerOrderByRelevanceFieldEnum]


  export const TimelineTemplateOrderByRelevanceFieldEnum: {
    id: 'id',
    name: 'name',
    description: 'description',
    createdBy: 'createdBy',
    updatedBy: 'updatedBy'
  };

  export type TimelineTemplateOrderByRelevanceFieldEnum = (typeof TimelineTemplateOrderByRelevanceFieldEnum)[keyof typeof TimelineTemplateOrderByRelevanceFieldEnum]


  export const TimelineTemplatePhaseOrderByRelevanceFieldEnum: {
    id: 'id',
    timelineTemplateId: 'timelineTemplateId',
    phaseId: 'phaseId',
    predecessor: 'predecessor',
    createdBy: 'createdBy',
    updatedBy: 'updatedBy'
  };

  export type TimelineTemplatePhaseOrderByRelevanceFieldEnum = (typeof TimelineTemplatePhaseOrderByRelevanceFieldEnum)[keyof typeof TimelineTemplatePhaseOrderByRelevanceFieldEnum]


  export const MemberChallengeAccessOrderByRelevanceFieldEnum: {
    challengeId: 'challengeId',
    memberId: 'memberId'
  };

  export type MemberChallengeAccessOrderByRelevanceFieldEnum = (typeof MemberChallengeAccessOrderByRelevanceFieldEnum)[keyof typeof MemberChallengeAccessOrderByRelevanceFieldEnum]


  /**
   * Field references
   */


  /**
   * Reference to a field of type 'String'
   */
  export type StringFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'String'>
    


  /**
   * Reference to a field of type 'String[]'
   */
  export type ListStringFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'String[]'>
    


  /**
   * Reference to a field of type 'Int'
   */
  export type IntFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Int'>
    


  /**
   * Reference to a field of type 'Int[]'
   */
  export type ListIntFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Int[]'>
    


  /**
   * Reference to a field of type 'Float'
   */
  export type FloatFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Float'>
    


  /**
   * Reference to a field of type 'Float[]'
   */
  export type ListFloatFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Float[]'>
    


  /**
   * Reference to a field of type 'Boolean'
   */
  export type BooleanFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Boolean'>
    


  /**
   * Reference to a field of type 'DateTime'
   */
  export type DateTimeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'DateTime'>
    


  /**
   * Reference to a field of type 'DateTime[]'
   */
  export type ListDateTimeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'DateTime[]'>
    


  /**
   * Reference to a field of type 'ChallengeStatusEnum'
   */
  export type EnumChallengeStatusEnumFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'ChallengeStatusEnum'>
    


  /**
   * Reference to a field of type 'ChallengeStatusEnum[]'
   */
  export type ListEnumChallengeStatusEnumFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'ChallengeStatusEnum[]'>
    


  /**
   * Reference to a field of type 'ChallengeTrackEnum'
   */
  export type EnumChallengeTrackEnumFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'ChallengeTrackEnum'>
    


  /**
   * Reference to a field of type 'ChallengeTrackEnum[]'
   */
  export type ListEnumChallengeTrackEnumFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'ChallengeTrackEnum[]'>
    


  /**
   * Reference to a field of type 'PrizeSetTypeEnum'
   */
  export type EnumPrizeSetTypeEnumFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'PrizeSetTypeEnum'>
    


  /**
   * Reference to a field of type 'PrizeSetTypeEnum[]'
   */
  export type ListEnumPrizeSetTypeEnumFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'PrizeSetTypeEnum[]'>
    


  /**
   * Reference to a field of type 'ReviewTypeEnum'
   */
  export type EnumReviewTypeEnumFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'ReviewTypeEnum'>
    


  /**
   * Reference to a field of type 'ReviewTypeEnum[]'
   */
  export type ListEnumReviewTypeEnumFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'ReviewTypeEnum[]'>
    


  /**
   * Reference to a field of type 'DiscussionTypeEnum'
   */
  export type EnumDiscussionTypeEnumFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'DiscussionTypeEnum'>
    


  /**
   * Reference to a field of type 'DiscussionTypeEnum[]'
   */
  export type ListEnumDiscussionTypeEnumFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'DiscussionTypeEnum[]'>
    


  /**
   * Reference to a field of type 'ReviewOpportunityTypeEnum'
   */
  export type EnumReviewOpportunityTypeEnumFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'ReviewOpportunityTypeEnum'>
    


  /**
   * Reference to a field of type 'ReviewOpportunityTypeEnum[]'
   */
  export type ListEnumReviewOpportunityTypeEnumFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'ReviewOpportunityTypeEnum[]'>
    
  /**
   * Deep Input Types
   */


  export type ChallengeWhereInput = {
    AND?: ChallengeWhereInput | ChallengeWhereInput[]
    OR?: ChallengeWhereInput[]
    NOT?: ChallengeWhereInput | ChallengeWhereInput[]
    id?: StringFilter<"Challenge"> | string
    name?: StringFilter<"Challenge"> | string
    description?: StringNullableFilter<"Challenge"> | string | null
    privateDescription?: StringNullableFilter<"Challenge"> | string | null
    challengeSource?: StringNullableFilter<"Challenge"> | string | null
    descriptionFormat?: StringNullableFilter<"Challenge"> | string | null
    projectId?: IntNullableFilter<"Challenge"> | number | null
    typeId?: StringFilter<"Challenge"> | string
    trackId?: StringFilter<"Challenge"> | string
    timelineTemplateId?: StringNullableFilter<"Challenge"> | string | null
    overviewTotalPrizes?: FloatNullableFilter<"Challenge"> | number | null
    numOfRegistrants?: IntFilter<"Challenge"> | number
    numOfSubmissions?: IntFilter<"Challenge"> | number
    numOfCheckpointSubmissions?: IntFilter<"Challenge"> | number
    currentPhaseNames?: StringNullableListFilter<"Challenge">
    wiproAllowed?: BoolFilter<"Challenge"> | boolean
    tags?: StringNullableListFilter<"Challenge">
    groups?: StringNullableListFilter<"Challenge">
    taskIsTask?: BoolFilter<"Challenge"> | boolean
    taskIsAssigned?: BoolFilter<"Challenge"> | boolean
    taskMemberId?: StringNullableFilter<"Challenge"> | string | null
    submissionStartDate?: DateTimeNullableFilter<"Challenge"> | Date | string | null
    submissionEndDate?: DateTimeNullableFilter<"Challenge"> | Date | string | null
    registrationStartDate?: DateTimeNullableFilter<"Challenge"> | Date | string | null
    registrationEndDate?: DateTimeNullableFilter<"Challenge"> | Date | string | null
    startDate?: DateTimeNullableFilter<"Challenge"> | Date | string | null
    endDate?: DateTimeNullableFilter<"Challenge"> | Date | string | null
    legacyId?: IntNullableFilter<"Challenge"> | number | null
    status?: EnumChallengeStatusEnumFilter<"Challenge"> | $Enums.ChallengeStatusEnum
    createdAt?: DateTimeFilter<"Challenge"> | Date | string
    createdBy?: StringFilter<"Challenge"> | string
    updatedAt?: DateTimeFilter<"Challenge"> | Date | string
    updatedBy?: StringFilter<"Challenge"> | string
    billingRecord?: XOR<ChallengeBillingNullableScalarRelationFilter, ChallengeBillingWhereInput> | null
    legacyRecord?: XOR<ChallengeLegacyNullableScalarRelationFilter, ChallengeLegacyWhereInput> | null
    constraintRecord?: XOR<ChallengeConstraintNullableScalarRelationFilter, ChallengeConstraintWhereInput> | null
    events?: ChallengeEventListRelationFilter
    discussions?: ChallengeDiscussionListRelationFilter
    metadata?: ChallengeMetadataListRelationFilter
    phases?: ChallengePhaseListRelationFilter
    prizeSets?: ChallengePrizeSetListRelationFilter
    reviewers?: ChallengeReviewerListRelationFilter
    winners?: ChallengeWinnerListRelationFilter
    attachments?: AttachmentListRelationFilter
    terms?: ChallengeTermListRelationFilter
    skills?: ChallengeSkillListRelationFilter
    auditLogs?: AuditLogListRelationFilter
    memberAccesses?: MemberChallengeAccessListRelationFilter
    type?: XOR<ChallengeTypeScalarRelationFilter, ChallengeTypeWhereInput>
    track?: XOR<ChallengeTrackScalarRelationFilter, ChallengeTrackWhereInput>
    timelineTemplate?: XOR<TimelineTemplateNullableScalarRelationFilter, TimelineTemplateWhereInput> | null
  }

  export type ChallengeOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrderInput | SortOrder
    privateDescription?: SortOrderInput | SortOrder
    challengeSource?: SortOrderInput | SortOrder
    descriptionFormat?: SortOrderInput | SortOrder
    projectId?: SortOrderInput | SortOrder
    typeId?: SortOrder
    trackId?: SortOrder
    timelineTemplateId?: SortOrderInput | SortOrder
    overviewTotalPrizes?: SortOrderInput | SortOrder
    numOfRegistrants?: SortOrder
    numOfSubmissions?: SortOrder
    numOfCheckpointSubmissions?: SortOrder
    currentPhaseNames?: SortOrder
    wiproAllowed?: SortOrder
    tags?: SortOrder
    groups?: SortOrder
    taskIsTask?: SortOrder
    taskIsAssigned?: SortOrder
    taskMemberId?: SortOrderInput | SortOrder
    submissionStartDate?: SortOrderInput | SortOrder
    submissionEndDate?: SortOrderInput | SortOrder
    registrationStartDate?: SortOrderInput | SortOrder
    registrationEndDate?: SortOrderInput | SortOrder
    startDate?: SortOrderInput | SortOrder
    endDate?: SortOrderInput | SortOrder
    legacyId?: SortOrderInput | SortOrder
    status?: SortOrder
    createdAt?: SortOrder
    createdBy?: SortOrder
    updatedAt?: SortOrder
    updatedBy?: SortOrder
    billingRecord?: ChallengeBillingOrderByWithRelationInput
    legacyRecord?: ChallengeLegacyOrderByWithRelationInput
    constraintRecord?: ChallengeConstraintOrderByWithRelationInput
    events?: ChallengeEventOrderByRelationAggregateInput
    discussions?: ChallengeDiscussionOrderByRelationAggregateInput
    metadata?: ChallengeMetadataOrderByRelationAggregateInput
    phases?: ChallengePhaseOrderByRelationAggregateInput
    prizeSets?: ChallengePrizeSetOrderByRelationAggregateInput
    reviewers?: ChallengeReviewerOrderByRelationAggregateInput
    winners?: ChallengeWinnerOrderByRelationAggregateInput
    attachments?: AttachmentOrderByRelationAggregateInput
    terms?: ChallengeTermOrderByRelationAggregateInput
    skills?: ChallengeSkillOrderByRelationAggregateInput
    auditLogs?: AuditLogOrderByRelationAggregateInput
    memberAccesses?: MemberChallengeAccessOrderByRelationAggregateInput
    type?: ChallengeTypeOrderByWithRelationInput
    track?: ChallengeTrackOrderByWithRelationInput
    timelineTemplate?: TimelineTemplateOrderByWithRelationInput
    _relevance?: ChallengeOrderByRelevanceInput
  }

  export type ChallengeWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: ChallengeWhereInput | ChallengeWhereInput[]
    OR?: ChallengeWhereInput[]
    NOT?: ChallengeWhereInput | ChallengeWhereInput[]
    name?: StringFilter<"Challenge"> | string
    description?: StringNullableFilter<"Challenge"> | string | null
    privateDescription?: StringNullableFilter<"Challenge"> | string | null
    challengeSource?: StringNullableFilter<"Challenge"> | string | null
    descriptionFormat?: StringNullableFilter<"Challenge"> | string | null
    projectId?: IntNullableFilter<"Challenge"> | number | null
    typeId?: StringFilter<"Challenge"> | string
    trackId?: StringFilter<"Challenge"> | string
    timelineTemplateId?: StringNullableFilter<"Challenge"> | string | null
    overviewTotalPrizes?: FloatNullableFilter<"Challenge"> | number | null
    numOfRegistrants?: IntFilter<"Challenge"> | number
    numOfSubmissions?: IntFilter<"Challenge"> | number
    numOfCheckpointSubmissions?: IntFilter<"Challenge"> | number
    currentPhaseNames?: StringNullableListFilter<"Challenge">
    wiproAllowed?: BoolFilter<"Challenge"> | boolean
    tags?: StringNullableListFilter<"Challenge">
    groups?: StringNullableListFilter<"Challenge">
    taskIsTask?: BoolFilter<"Challenge"> | boolean
    taskIsAssigned?: BoolFilter<"Challenge"> | boolean
    taskMemberId?: StringNullableFilter<"Challenge"> | string | null
    submissionStartDate?: DateTimeNullableFilter<"Challenge"> | Date | string | null
    submissionEndDate?: DateTimeNullableFilter<"Challenge"> | Date | string | null
    registrationStartDate?: DateTimeNullableFilter<"Challenge"> | Date | string | null
    registrationEndDate?: DateTimeNullableFilter<"Challenge"> | Date | string | null
    startDate?: DateTimeNullableFilter<"Challenge"> | Date | string | null
    endDate?: DateTimeNullableFilter<"Challenge"> | Date | string | null
    legacyId?: IntNullableFilter<"Challenge"> | number | null
    status?: EnumChallengeStatusEnumFilter<"Challenge"> | $Enums.ChallengeStatusEnum
    createdAt?: DateTimeFilter<"Challenge"> | Date | string
    createdBy?: StringFilter<"Challenge"> | string
    updatedAt?: DateTimeFilter<"Challenge"> | Date | string
    updatedBy?: StringFilter<"Challenge"> | string
    billingRecord?: XOR<ChallengeBillingNullableScalarRelationFilter, ChallengeBillingWhereInput> | null
    legacyRecord?: XOR<ChallengeLegacyNullableScalarRelationFilter, ChallengeLegacyWhereInput> | null
    constraintRecord?: XOR<ChallengeConstraintNullableScalarRelationFilter, ChallengeConstraintWhereInput> | null
    events?: ChallengeEventListRelationFilter
    discussions?: ChallengeDiscussionListRelationFilter
    metadata?: ChallengeMetadataListRelationFilter
    phases?: ChallengePhaseListRelationFilter
    prizeSets?: ChallengePrizeSetListRelationFilter
    reviewers?: ChallengeReviewerListRelationFilter
    winners?: ChallengeWinnerListRelationFilter
    attachments?: AttachmentListRelationFilter
    terms?: ChallengeTermListRelationFilter
    skills?: ChallengeSkillListRelationFilter
    auditLogs?: AuditLogListRelationFilter
    memberAccesses?: MemberChallengeAccessListRelationFilter
    type?: XOR<ChallengeTypeScalarRelationFilter, ChallengeTypeWhereInput>
    track?: XOR<ChallengeTrackScalarRelationFilter, ChallengeTrackWhereInput>
    timelineTemplate?: XOR<TimelineTemplateNullableScalarRelationFilter, TimelineTemplateWhereInput> | null
  }, "id">

  export type ChallengeOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrderInput | SortOrder
    privateDescription?: SortOrderInput | SortOrder
    challengeSource?: SortOrderInput | SortOrder
    descriptionFormat?: SortOrderInput | SortOrder
    projectId?: SortOrderInput | SortOrder
    typeId?: SortOrder
    trackId?: SortOrder
    timelineTemplateId?: SortOrderInput | SortOrder
    overviewTotalPrizes?: SortOrderInput | SortOrder
    numOfRegistrants?: SortOrder
    numOfSubmissions?: SortOrder
    numOfCheckpointSubmissions?: SortOrder
    currentPhaseNames?: SortOrder
    wiproAllowed?: SortOrder
    tags?: SortOrder
    groups?: SortOrder
    taskIsTask?: SortOrder
    taskIsAssigned?: SortOrder
    taskMemberId?: SortOrderInput | SortOrder
    submissionStartDate?: SortOrderInput | SortOrder
    submissionEndDate?: SortOrderInput | SortOrder
    registrationStartDate?: SortOrderInput | SortOrder
    registrationEndDate?: SortOrderInput | SortOrder
    startDate?: SortOrderInput | SortOrder
    endDate?: SortOrderInput | SortOrder
    legacyId?: SortOrderInput | SortOrder
    status?: SortOrder
    createdAt?: SortOrder
    createdBy?: SortOrder
    updatedAt?: SortOrder
    updatedBy?: SortOrder
    _count?: ChallengeCountOrderByAggregateInput
    _avg?: ChallengeAvgOrderByAggregateInput
    _max?: ChallengeMaxOrderByAggregateInput
    _min?: ChallengeMinOrderByAggregateInput
    _sum?: ChallengeSumOrderByAggregateInput
  }

  export type ChallengeScalarWhereWithAggregatesInput = {
    AND?: ChallengeScalarWhereWithAggregatesInput | ChallengeScalarWhereWithAggregatesInput[]
    OR?: ChallengeScalarWhereWithAggregatesInput[]
    NOT?: ChallengeScalarWhereWithAggregatesInput | ChallengeScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Challenge"> | string
    name?: StringWithAggregatesFilter<"Challenge"> | string
    description?: StringNullableWithAggregatesFilter<"Challenge"> | string | null
    privateDescription?: StringNullableWithAggregatesFilter<"Challenge"> | string | null
    challengeSource?: StringNullableWithAggregatesFilter<"Challenge"> | string | null
    descriptionFormat?: StringNullableWithAggregatesFilter<"Challenge"> | string | null
    projectId?: IntNullableWithAggregatesFilter<"Challenge"> | number | null
    typeId?: StringWithAggregatesFilter<"Challenge"> | string
    trackId?: StringWithAggregatesFilter<"Challenge"> | string
    timelineTemplateId?: StringNullableWithAggregatesFilter<"Challenge"> | string | null
    overviewTotalPrizes?: FloatNullableWithAggregatesFilter<"Challenge"> | number | null
    numOfRegistrants?: IntWithAggregatesFilter<"Challenge"> | number
    numOfSubmissions?: IntWithAggregatesFilter<"Challenge"> | number
    numOfCheckpointSubmissions?: IntWithAggregatesFilter<"Challenge"> | number
    currentPhaseNames?: StringNullableListFilter<"Challenge">
    wiproAllowed?: BoolWithAggregatesFilter<"Challenge"> | boolean
    tags?: StringNullableListFilter<"Challenge">
    groups?: StringNullableListFilter<"Challenge">
    taskIsTask?: BoolWithAggregatesFilter<"Challenge"> | boolean
    taskIsAssigned?: BoolWithAggregatesFilter<"Challenge"> | boolean
    taskMemberId?: StringNullableWithAggregatesFilter<"Challenge"> | string | null
    submissionStartDate?: DateTimeNullableWithAggregatesFilter<"Challenge"> | Date | string | null
    submissionEndDate?: DateTimeNullableWithAggregatesFilter<"Challenge"> | Date | string | null
    registrationStartDate?: DateTimeNullableWithAggregatesFilter<"Challenge"> | Date | string | null
    registrationEndDate?: DateTimeNullableWithAggregatesFilter<"Challenge"> | Date | string | null
    startDate?: DateTimeNullableWithAggregatesFilter<"Challenge"> | Date | string | null
    endDate?: DateTimeNullableWithAggregatesFilter<"Challenge"> | Date | string | null
    legacyId?: IntNullableWithAggregatesFilter<"Challenge"> | number | null
    status?: EnumChallengeStatusEnumWithAggregatesFilter<"Challenge"> | $Enums.ChallengeStatusEnum
    createdAt?: DateTimeWithAggregatesFilter<"Challenge"> | Date | string
    createdBy?: StringWithAggregatesFilter<"Challenge"> | string
    updatedAt?: DateTimeWithAggregatesFilter<"Challenge"> | Date | string
    updatedBy?: StringWithAggregatesFilter<"Challenge"> | string
  }

  export type ChallengeTypeWhereInput = {
    AND?: ChallengeTypeWhereInput | ChallengeTypeWhereInput[]
    OR?: ChallengeTypeWhereInput[]
    NOT?: ChallengeTypeWhereInput | ChallengeTypeWhereInput[]
    id?: StringFilter<"ChallengeType"> | string
    name?: StringFilter<"ChallengeType"> | string
    description?: StringNullableFilter<"ChallengeType"> | string | null
    isActive?: BoolFilter<"ChallengeType"> | boolean
    isTask?: BoolFilter<"ChallengeType"> | boolean
    abbreviation?: StringFilter<"ChallengeType"> | string
    createdAt?: DateTimeFilter<"ChallengeType"> | Date | string
    createdBy?: StringFilter<"ChallengeType"> | string
    updatedAt?: DateTimeFilter<"ChallengeType"> | Date | string
    updatedBy?: StringFilter<"ChallengeType"> | string
    challenges?: ChallengeListRelationFilter
    timelineTemplates?: ChallengeTimelineTemplateListRelationFilter
    defaultReviewers?: DefaultChallengeReviewerListRelationFilter
  }

  export type ChallengeTypeOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrderInput | SortOrder
    isActive?: SortOrder
    isTask?: SortOrder
    abbreviation?: SortOrder
    createdAt?: SortOrder
    createdBy?: SortOrder
    updatedAt?: SortOrder
    updatedBy?: SortOrder
    challenges?: ChallengeOrderByRelationAggregateInput
    timelineTemplates?: ChallengeTimelineTemplateOrderByRelationAggregateInput
    defaultReviewers?: DefaultChallengeReviewerOrderByRelationAggregateInput
    _relevance?: ChallengeTypeOrderByRelevanceInput
  }

  export type ChallengeTypeWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: ChallengeTypeWhereInput | ChallengeTypeWhereInput[]
    OR?: ChallengeTypeWhereInput[]
    NOT?: ChallengeTypeWhereInput | ChallengeTypeWhereInput[]
    name?: StringFilter<"ChallengeType"> | string
    description?: StringNullableFilter<"ChallengeType"> | string | null
    isActive?: BoolFilter<"ChallengeType"> | boolean
    isTask?: BoolFilter<"ChallengeType"> | boolean
    abbreviation?: StringFilter<"ChallengeType"> | string
    createdAt?: DateTimeFilter<"ChallengeType"> | Date | string
    createdBy?: StringFilter<"ChallengeType"> | string
    updatedAt?: DateTimeFilter<"ChallengeType"> | Date | string
    updatedBy?: StringFilter<"ChallengeType"> | string
    challenges?: ChallengeListRelationFilter
    timelineTemplates?: ChallengeTimelineTemplateListRelationFilter
    defaultReviewers?: DefaultChallengeReviewerListRelationFilter
  }, "id">

  export type ChallengeTypeOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrderInput | SortOrder
    isActive?: SortOrder
    isTask?: SortOrder
    abbreviation?: SortOrder
    createdAt?: SortOrder
    createdBy?: SortOrder
    updatedAt?: SortOrder
    updatedBy?: SortOrder
    _count?: ChallengeTypeCountOrderByAggregateInput
    _max?: ChallengeTypeMaxOrderByAggregateInput
    _min?: ChallengeTypeMinOrderByAggregateInput
  }

  export type ChallengeTypeScalarWhereWithAggregatesInput = {
    AND?: ChallengeTypeScalarWhereWithAggregatesInput | ChallengeTypeScalarWhereWithAggregatesInput[]
    OR?: ChallengeTypeScalarWhereWithAggregatesInput[]
    NOT?: ChallengeTypeScalarWhereWithAggregatesInput | ChallengeTypeScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"ChallengeType"> | string
    name?: StringWithAggregatesFilter<"ChallengeType"> | string
    description?: StringNullableWithAggregatesFilter<"ChallengeType"> | string | null
    isActive?: BoolWithAggregatesFilter<"ChallengeType"> | boolean
    isTask?: BoolWithAggregatesFilter<"ChallengeType"> | boolean
    abbreviation?: StringWithAggregatesFilter<"ChallengeType"> | string
    createdAt?: DateTimeWithAggregatesFilter<"ChallengeType"> | Date | string
    createdBy?: StringWithAggregatesFilter<"ChallengeType"> | string
    updatedAt?: DateTimeWithAggregatesFilter<"ChallengeType"> | Date | string
    updatedBy?: StringWithAggregatesFilter<"ChallengeType"> | string
  }

  export type ChallengeTrackWhereInput = {
    AND?: ChallengeTrackWhereInput | ChallengeTrackWhereInput[]
    OR?: ChallengeTrackWhereInput[]
    NOT?: ChallengeTrackWhereInput | ChallengeTrackWhereInput[]
    id?: StringFilter<"ChallengeTrack"> | string
    name?: StringFilter<"ChallengeTrack"> | string
    description?: StringNullableFilter<"ChallengeTrack"> | string | null
    isActive?: BoolFilter<"ChallengeTrack"> | boolean
    abbreviation?: StringFilter<"ChallengeTrack"> | string
    legacyId?: IntNullableFilter<"ChallengeTrack"> | number | null
    track?: EnumChallengeTrackEnumNullableFilter<"ChallengeTrack"> | $Enums.ChallengeTrackEnum | null
    createdAt?: DateTimeFilter<"ChallengeTrack"> | Date | string
    createdBy?: StringFilter<"ChallengeTrack"> | string
    updatedAt?: DateTimeFilter<"ChallengeTrack"> | Date | string
    updatedBy?: StringFilter<"ChallengeTrack"> | string
    challenges?: ChallengeListRelationFilter
    timelineTemplates?: ChallengeTimelineTemplateListRelationFilter
    defaultReviewers?: DefaultChallengeReviewerListRelationFilter
  }

  export type ChallengeTrackOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrderInput | SortOrder
    isActive?: SortOrder
    abbreviation?: SortOrder
    legacyId?: SortOrderInput | SortOrder
    track?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    createdBy?: SortOrder
    updatedAt?: SortOrder
    updatedBy?: SortOrder
    challenges?: ChallengeOrderByRelationAggregateInput
    timelineTemplates?: ChallengeTimelineTemplateOrderByRelationAggregateInput
    defaultReviewers?: DefaultChallengeReviewerOrderByRelationAggregateInput
    _relevance?: ChallengeTrackOrderByRelevanceInput
  }

  export type ChallengeTrackWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: ChallengeTrackWhereInput | ChallengeTrackWhereInput[]
    OR?: ChallengeTrackWhereInput[]
    NOT?: ChallengeTrackWhereInput | ChallengeTrackWhereInput[]
    name?: StringFilter<"ChallengeTrack"> | string
    description?: StringNullableFilter<"ChallengeTrack"> | string | null
    isActive?: BoolFilter<"ChallengeTrack"> | boolean
    abbreviation?: StringFilter<"ChallengeTrack"> | string
    legacyId?: IntNullableFilter<"ChallengeTrack"> | number | null
    track?: EnumChallengeTrackEnumNullableFilter<"ChallengeTrack"> | $Enums.ChallengeTrackEnum | null
    createdAt?: DateTimeFilter<"ChallengeTrack"> | Date | string
    createdBy?: StringFilter<"ChallengeTrack"> | string
    updatedAt?: DateTimeFilter<"ChallengeTrack"> | Date | string
    updatedBy?: StringFilter<"ChallengeTrack"> | string
    challenges?: ChallengeListRelationFilter
    timelineTemplates?: ChallengeTimelineTemplateListRelationFilter
    defaultReviewers?: DefaultChallengeReviewerListRelationFilter
  }, "id">

  export type ChallengeTrackOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrderInput | SortOrder
    isActive?: SortOrder
    abbreviation?: SortOrder
    legacyId?: SortOrderInput | SortOrder
    track?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    createdBy?: SortOrder
    updatedAt?: SortOrder
    updatedBy?: SortOrder
    _count?: ChallengeTrackCountOrderByAggregateInput
    _avg?: ChallengeTrackAvgOrderByAggregateInput
    _max?: ChallengeTrackMaxOrderByAggregateInput
    _min?: ChallengeTrackMinOrderByAggregateInput
    _sum?: ChallengeTrackSumOrderByAggregateInput
  }

  export type ChallengeTrackScalarWhereWithAggregatesInput = {
    AND?: ChallengeTrackScalarWhereWithAggregatesInput | ChallengeTrackScalarWhereWithAggregatesInput[]
    OR?: ChallengeTrackScalarWhereWithAggregatesInput[]
    NOT?: ChallengeTrackScalarWhereWithAggregatesInput | ChallengeTrackScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"ChallengeTrack"> | string
    name?: StringWithAggregatesFilter<"ChallengeTrack"> | string
    description?: StringNullableWithAggregatesFilter<"ChallengeTrack"> | string | null
    isActive?: BoolWithAggregatesFilter<"ChallengeTrack"> | boolean
    abbreviation?: StringWithAggregatesFilter<"ChallengeTrack"> | string
    legacyId?: IntNullableWithAggregatesFilter<"ChallengeTrack"> | number | null
    track?: EnumChallengeTrackEnumNullableWithAggregatesFilter<"ChallengeTrack"> | $Enums.ChallengeTrackEnum | null
    createdAt?: DateTimeWithAggregatesFilter<"ChallengeTrack"> | Date | string
    createdBy?: StringWithAggregatesFilter<"ChallengeTrack"> | string
    updatedAt?: DateTimeWithAggregatesFilter<"ChallengeTrack"> | Date | string
    updatedBy?: StringWithAggregatesFilter<"ChallengeTrack"> | string
  }

  export type ChallengeTimelineTemplateWhereInput = {
    AND?: ChallengeTimelineTemplateWhereInput | ChallengeTimelineTemplateWhereInput[]
    OR?: ChallengeTimelineTemplateWhereInput[]
    NOT?: ChallengeTimelineTemplateWhereInput | ChallengeTimelineTemplateWhereInput[]
    id?: StringFilter<"ChallengeTimelineTemplate"> | string
    typeId?: StringFilter<"ChallengeTimelineTemplate"> | string
    trackId?: StringFilter<"ChallengeTimelineTemplate"> | string
    timelineTemplateId?: StringFilter<"ChallengeTimelineTemplate"> | string
    isDefault?: BoolFilter<"ChallengeTimelineTemplate"> | boolean
    createdAt?: DateTimeFilter<"ChallengeTimelineTemplate"> | Date | string
    createdBy?: StringFilter<"ChallengeTimelineTemplate"> | string
    updatedAt?: DateTimeFilter<"ChallengeTimelineTemplate"> | Date | string
    updatedBy?: StringFilter<"ChallengeTimelineTemplate"> | string
    timelineTemplate?: XOR<TimelineTemplateScalarRelationFilter, TimelineTemplateWhereInput>
    track?: XOR<ChallengeTrackScalarRelationFilter, ChallengeTrackWhereInput>
    type?: XOR<ChallengeTypeScalarRelationFilter, ChallengeTypeWhereInput>
  }

  export type ChallengeTimelineTemplateOrderByWithRelationInput = {
    id?: SortOrder
    typeId?: SortOrder
    trackId?: SortOrder
    timelineTemplateId?: SortOrder
    isDefault?: SortOrder
    createdAt?: SortOrder
    createdBy?: SortOrder
    updatedAt?: SortOrder
    updatedBy?: SortOrder
    timelineTemplate?: TimelineTemplateOrderByWithRelationInput
    track?: ChallengeTrackOrderByWithRelationInput
    type?: ChallengeTypeOrderByWithRelationInput
    _relevance?: ChallengeTimelineTemplateOrderByRelevanceInput
  }

  export type ChallengeTimelineTemplateWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: ChallengeTimelineTemplateWhereInput | ChallengeTimelineTemplateWhereInput[]
    OR?: ChallengeTimelineTemplateWhereInput[]
    NOT?: ChallengeTimelineTemplateWhereInput | ChallengeTimelineTemplateWhereInput[]
    typeId?: StringFilter<"ChallengeTimelineTemplate"> | string
    trackId?: StringFilter<"ChallengeTimelineTemplate"> | string
    timelineTemplateId?: StringFilter<"ChallengeTimelineTemplate"> | string
    isDefault?: BoolFilter<"ChallengeTimelineTemplate"> | boolean
    createdAt?: DateTimeFilter<"ChallengeTimelineTemplate"> | Date | string
    createdBy?: StringFilter<"ChallengeTimelineTemplate"> | string
    updatedAt?: DateTimeFilter<"ChallengeTimelineTemplate"> | Date | string
    updatedBy?: StringFilter<"ChallengeTimelineTemplate"> | string
    timelineTemplate?: XOR<TimelineTemplateScalarRelationFilter, TimelineTemplateWhereInput>
    track?: XOR<ChallengeTrackScalarRelationFilter, ChallengeTrackWhereInput>
    type?: XOR<ChallengeTypeScalarRelationFilter, ChallengeTypeWhereInput>
  }, "id">

  export type ChallengeTimelineTemplateOrderByWithAggregationInput = {
    id?: SortOrder
    typeId?: SortOrder
    trackId?: SortOrder
    timelineTemplateId?: SortOrder
    isDefault?: SortOrder
    createdAt?: SortOrder
    createdBy?: SortOrder
    updatedAt?: SortOrder
    updatedBy?: SortOrder
    _count?: ChallengeTimelineTemplateCountOrderByAggregateInput
    _max?: ChallengeTimelineTemplateMaxOrderByAggregateInput
    _min?: ChallengeTimelineTemplateMinOrderByAggregateInput
  }

  export type ChallengeTimelineTemplateScalarWhereWithAggregatesInput = {
    AND?: ChallengeTimelineTemplateScalarWhereWithAggregatesInput | ChallengeTimelineTemplateScalarWhereWithAggregatesInput[]
    OR?: ChallengeTimelineTemplateScalarWhereWithAggregatesInput[]
    NOT?: ChallengeTimelineTemplateScalarWhereWithAggregatesInput | ChallengeTimelineTemplateScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"ChallengeTimelineTemplate"> | string
    typeId?: StringWithAggregatesFilter<"ChallengeTimelineTemplate"> | string
    trackId?: StringWithAggregatesFilter<"ChallengeTimelineTemplate"> | string
    timelineTemplateId?: StringWithAggregatesFilter<"ChallengeTimelineTemplate"> | string
    isDefault?: BoolWithAggregatesFilter<"ChallengeTimelineTemplate"> | boolean
    createdAt?: DateTimeWithAggregatesFilter<"ChallengeTimelineTemplate"> | Date | string
    createdBy?: StringWithAggregatesFilter<"ChallengeTimelineTemplate"> | string
    updatedAt?: DateTimeWithAggregatesFilter<"ChallengeTimelineTemplate"> | Date | string
    updatedBy?: StringWithAggregatesFilter<"ChallengeTimelineTemplate"> | string
  }

  export type AuditLogWhereInput = {
    AND?: AuditLogWhereInput | AuditLogWhereInput[]
    OR?: AuditLogWhereInput[]
    NOT?: AuditLogWhereInput | AuditLogWhereInput[]
    id?: StringFilter<"AuditLog"> | string
    challengeId?: StringNullableFilter<"AuditLog"> | string | null
    fieldName?: StringFilter<"AuditLog"> | string
    oldValue?: StringNullableFilter<"AuditLog"> | string | null
    newValue?: StringNullableFilter<"AuditLog"> | string | null
    createdAt?: DateTimeFilter<"AuditLog"> | Date | string
    createdBy?: StringFilter<"AuditLog"> | string
    memberId?: StringNullableFilter<"AuditLog"> | string | null
    challenge?: XOR<ChallengeNullableScalarRelationFilter, ChallengeWhereInput> | null
  }

  export type AuditLogOrderByWithRelationInput = {
    id?: SortOrder
    challengeId?: SortOrderInput | SortOrder
    fieldName?: SortOrder
    oldValue?: SortOrderInput | SortOrder
    newValue?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    createdBy?: SortOrder
    memberId?: SortOrderInput | SortOrder
    challenge?: ChallengeOrderByWithRelationInput
    _relevance?: AuditLogOrderByRelevanceInput
  }

  export type AuditLogWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: AuditLogWhereInput | AuditLogWhereInput[]
    OR?: AuditLogWhereInput[]
    NOT?: AuditLogWhereInput | AuditLogWhereInput[]
    challengeId?: StringNullableFilter<"AuditLog"> | string | null
    fieldName?: StringFilter<"AuditLog"> | string
    oldValue?: StringNullableFilter<"AuditLog"> | string | null
    newValue?: StringNullableFilter<"AuditLog"> | string | null
    createdAt?: DateTimeFilter<"AuditLog"> | Date | string
    createdBy?: StringFilter<"AuditLog"> | string
    memberId?: StringNullableFilter<"AuditLog"> | string | null
    challenge?: XOR<ChallengeNullableScalarRelationFilter, ChallengeWhereInput> | null
  }, "id">

  export type AuditLogOrderByWithAggregationInput = {
    id?: SortOrder
    challengeId?: SortOrderInput | SortOrder
    fieldName?: SortOrder
    oldValue?: SortOrderInput | SortOrder
    newValue?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    createdBy?: SortOrder
    memberId?: SortOrderInput | SortOrder
    _count?: AuditLogCountOrderByAggregateInput
    _max?: AuditLogMaxOrderByAggregateInput
    _min?: AuditLogMinOrderByAggregateInput
  }

  export type AuditLogScalarWhereWithAggregatesInput = {
    AND?: AuditLogScalarWhereWithAggregatesInput | AuditLogScalarWhereWithAggregatesInput[]
    OR?: AuditLogScalarWhereWithAggregatesInput[]
    NOT?: AuditLogScalarWhereWithAggregatesInput | AuditLogScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"AuditLog"> | string
    challengeId?: StringNullableWithAggregatesFilter<"AuditLog"> | string | null
    fieldName?: StringWithAggregatesFilter<"AuditLog"> | string
    oldValue?: StringNullableWithAggregatesFilter<"AuditLog"> | string | null
    newValue?: StringNullableWithAggregatesFilter<"AuditLog"> | string | null
    createdAt?: DateTimeWithAggregatesFilter<"AuditLog"> | Date | string
    createdBy?: StringWithAggregatesFilter<"AuditLog"> | string
    memberId?: StringNullableWithAggregatesFilter<"AuditLog"> | string | null
  }

  export type AttachmentWhereInput = {
    AND?: AttachmentWhereInput | AttachmentWhereInput[]
    OR?: AttachmentWhereInput[]
    NOT?: AttachmentWhereInput | AttachmentWhereInput[]
    id?: StringFilter<"Attachment"> | string
    challengeId?: StringFilter<"Attachment"> | string
    name?: StringFilter<"Attachment"> | string
    fileSize?: IntFilter<"Attachment"> | number
    url?: StringFilter<"Attachment"> | string
    description?: StringNullableFilter<"Attachment"> | string | null
    createdAt?: DateTimeFilter<"Attachment"> | Date | string
    createdBy?: StringFilter<"Attachment"> | string
    updatedAt?: DateTimeFilter<"Attachment"> | Date | string
    updatedBy?: StringFilter<"Attachment"> | string
    challenge?: XOR<ChallengeScalarRelationFilter, ChallengeWhereInput>
  }

  export type AttachmentOrderByWithRelationInput = {
    id?: SortOrder
    challengeId?: SortOrder
    name?: SortOrder
    fileSize?: SortOrder
    url?: SortOrder
    description?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    createdBy?: SortOrder
    updatedAt?: SortOrder
    updatedBy?: SortOrder
    challenge?: ChallengeOrderByWithRelationInput
    _relevance?: AttachmentOrderByRelevanceInput
  }

  export type AttachmentWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: AttachmentWhereInput | AttachmentWhereInput[]
    OR?: AttachmentWhereInput[]
    NOT?: AttachmentWhereInput | AttachmentWhereInput[]
    challengeId?: StringFilter<"Attachment"> | string
    name?: StringFilter<"Attachment"> | string
    fileSize?: IntFilter<"Attachment"> | number
    url?: StringFilter<"Attachment"> | string
    description?: StringNullableFilter<"Attachment"> | string | null
    createdAt?: DateTimeFilter<"Attachment"> | Date | string
    createdBy?: StringFilter<"Attachment"> | string
    updatedAt?: DateTimeFilter<"Attachment"> | Date | string
    updatedBy?: StringFilter<"Attachment"> | string
    challenge?: XOR<ChallengeScalarRelationFilter, ChallengeWhereInput>
  }, "id">

  export type AttachmentOrderByWithAggregationInput = {
    id?: SortOrder
    challengeId?: SortOrder
    name?: SortOrder
    fileSize?: SortOrder
    url?: SortOrder
    description?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    createdBy?: SortOrder
    updatedAt?: SortOrder
    updatedBy?: SortOrder
    _count?: AttachmentCountOrderByAggregateInput
    _avg?: AttachmentAvgOrderByAggregateInput
    _max?: AttachmentMaxOrderByAggregateInput
    _min?: AttachmentMinOrderByAggregateInput
    _sum?: AttachmentSumOrderByAggregateInput
  }

  export type AttachmentScalarWhereWithAggregatesInput = {
    AND?: AttachmentScalarWhereWithAggregatesInput | AttachmentScalarWhereWithAggregatesInput[]
    OR?: AttachmentScalarWhereWithAggregatesInput[]
    NOT?: AttachmentScalarWhereWithAggregatesInput | AttachmentScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Attachment"> | string
    challengeId?: StringWithAggregatesFilter<"Attachment"> | string
    name?: StringWithAggregatesFilter<"Attachment"> | string
    fileSize?: IntWithAggregatesFilter<"Attachment"> | number
    url?: StringWithAggregatesFilter<"Attachment"> | string
    description?: StringNullableWithAggregatesFilter<"Attachment"> | string | null
    createdAt?: DateTimeWithAggregatesFilter<"Attachment"> | Date | string
    createdBy?: StringWithAggregatesFilter<"Attachment"> | string
    updatedAt?: DateTimeWithAggregatesFilter<"Attachment"> | Date | string
    updatedBy?: StringWithAggregatesFilter<"Attachment"> | string
  }

  export type ChallengeMetadataWhereInput = {
    AND?: ChallengeMetadataWhereInput | ChallengeMetadataWhereInput[]
    OR?: ChallengeMetadataWhereInput[]
    NOT?: ChallengeMetadataWhereInput | ChallengeMetadataWhereInput[]
    id?: StringFilter<"ChallengeMetadata"> | string
    challengeId?: StringFilter<"ChallengeMetadata"> | string
    name?: StringFilter<"ChallengeMetadata"> | string
    value?: StringFilter<"ChallengeMetadata"> | string
    createdAt?: DateTimeFilter<"ChallengeMetadata"> | Date | string
    createdBy?: StringFilter<"ChallengeMetadata"> | string
    updatedAt?: DateTimeFilter<"ChallengeMetadata"> | Date | string
    updatedBy?: StringFilter<"ChallengeMetadata"> | string
    challenge?: XOR<ChallengeScalarRelationFilter, ChallengeWhereInput>
  }

  export type ChallengeMetadataOrderByWithRelationInput = {
    id?: SortOrder
    challengeId?: SortOrder
    name?: SortOrder
    value?: SortOrder
    createdAt?: SortOrder
    createdBy?: SortOrder
    updatedAt?: SortOrder
    updatedBy?: SortOrder
    challenge?: ChallengeOrderByWithRelationInput
    _relevance?: ChallengeMetadataOrderByRelevanceInput
  }

  export type ChallengeMetadataWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: ChallengeMetadataWhereInput | ChallengeMetadataWhereInput[]
    OR?: ChallengeMetadataWhereInput[]
    NOT?: ChallengeMetadataWhereInput | ChallengeMetadataWhereInput[]
    challengeId?: StringFilter<"ChallengeMetadata"> | string
    name?: StringFilter<"ChallengeMetadata"> | string
    value?: StringFilter<"ChallengeMetadata"> | string
    createdAt?: DateTimeFilter<"ChallengeMetadata"> | Date | string
    createdBy?: StringFilter<"ChallengeMetadata"> | string
    updatedAt?: DateTimeFilter<"ChallengeMetadata"> | Date | string
    updatedBy?: StringFilter<"ChallengeMetadata"> | string
    challenge?: XOR<ChallengeScalarRelationFilter, ChallengeWhereInput>
  }, "id">

  export type ChallengeMetadataOrderByWithAggregationInput = {
    id?: SortOrder
    challengeId?: SortOrder
    name?: SortOrder
    value?: SortOrder
    createdAt?: SortOrder
    createdBy?: SortOrder
    updatedAt?: SortOrder
    updatedBy?: SortOrder
    _count?: ChallengeMetadataCountOrderByAggregateInput
    _max?: ChallengeMetadataMaxOrderByAggregateInput
    _min?: ChallengeMetadataMinOrderByAggregateInput
  }

  export type ChallengeMetadataScalarWhereWithAggregatesInput = {
    AND?: ChallengeMetadataScalarWhereWithAggregatesInput | ChallengeMetadataScalarWhereWithAggregatesInput[]
    OR?: ChallengeMetadataScalarWhereWithAggregatesInput[]
    NOT?: ChallengeMetadataScalarWhereWithAggregatesInput | ChallengeMetadataScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"ChallengeMetadata"> | string
    challengeId?: StringWithAggregatesFilter<"ChallengeMetadata"> | string
    name?: StringWithAggregatesFilter<"ChallengeMetadata"> | string
    value?: StringWithAggregatesFilter<"ChallengeMetadata"> | string
    createdAt?: DateTimeWithAggregatesFilter<"ChallengeMetadata"> | Date | string
    createdBy?: StringWithAggregatesFilter<"ChallengeMetadata"> | string
    updatedAt?: DateTimeWithAggregatesFilter<"ChallengeMetadata"> | Date | string
    updatedBy?: StringWithAggregatesFilter<"ChallengeMetadata"> | string
  }

  export type PrizeWhereInput = {
    AND?: PrizeWhereInput | PrizeWhereInput[]
    OR?: PrizeWhereInput[]
    NOT?: PrizeWhereInput | PrizeWhereInput[]
    id?: StringFilter<"Prize"> | string
    description?: StringNullableFilter<"Prize"> | string | null
    prizeSetId?: StringFilter<"Prize"> | string
    type?: StringFilter<"Prize"> | string
    value?: FloatFilter<"Prize"> | number
    createdAt?: DateTimeFilter<"Prize"> | Date | string
    createdBy?: StringFilter<"Prize"> | string
    updatedAt?: DateTimeFilter<"Prize"> | Date | string
    updatedBy?: StringFilter<"Prize"> | string
    prizeSet?: XOR<ChallengePrizeSetScalarRelationFilter, ChallengePrizeSetWhereInput>
  }

  export type PrizeOrderByWithRelationInput = {
    id?: SortOrder
    description?: SortOrderInput | SortOrder
    prizeSetId?: SortOrder
    type?: SortOrder
    value?: SortOrder
    createdAt?: SortOrder
    createdBy?: SortOrder
    updatedAt?: SortOrder
    updatedBy?: SortOrder
    prizeSet?: ChallengePrizeSetOrderByWithRelationInput
    _relevance?: PrizeOrderByRelevanceInput
  }

  export type PrizeWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: PrizeWhereInput | PrizeWhereInput[]
    OR?: PrizeWhereInput[]
    NOT?: PrizeWhereInput | PrizeWhereInput[]
    description?: StringNullableFilter<"Prize"> | string | null
    prizeSetId?: StringFilter<"Prize"> | string
    type?: StringFilter<"Prize"> | string
    value?: FloatFilter<"Prize"> | number
    createdAt?: DateTimeFilter<"Prize"> | Date | string
    createdBy?: StringFilter<"Prize"> | string
    updatedAt?: DateTimeFilter<"Prize"> | Date | string
    updatedBy?: StringFilter<"Prize"> | string
    prizeSet?: XOR<ChallengePrizeSetScalarRelationFilter, ChallengePrizeSetWhereInput>
  }, "id">

  export type PrizeOrderByWithAggregationInput = {
    id?: SortOrder
    description?: SortOrderInput | SortOrder
    prizeSetId?: SortOrder
    type?: SortOrder
    value?: SortOrder
    createdAt?: SortOrder
    createdBy?: SortOrder
    updatedAt?: SortOrder
    updatedBy?: SortOrder
    _count?: PrizeCountOrderByAggregateInput
    _avg?: PrizeAvgOrderByAggregateInput
    _max?: PrizeMaxOrderByAggregateInput
    _min?: PrizeMinOrderByAggregateInput
    _sum?: PrizeSumOrderByAggregateInput
  }

  export type PrizeScalarWhereWithAggregatesInput = {
    AND?: PrizeScalarWhereWithAggregatesInput | PrizeScalarWhereWithAggregatesInput[]
    OR?: PrizeScalarWhereWithAggregatesInput[]
    NOT?: PrizeScalarWhereWithAggregatesInput | PrizeScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Prize"> | string
    description?: StringNullableWithAggregatesFilter<"Prize"> | string | null
    prizeSetId?: StringWithAggregatesFilter<"Prize"> | string
    type?: StringWithAggregatesFilter<"Prize"> | string
    value?: FloatWithAggregatesFilter<"Prize"> | number
    createdAt?: DateTimeWithAggregatesFilter<"Prize"> | Date | string
    createdBy?: StringWithAggregatesFilter<"Prize"> | string
    updatedAt?: DateTimeWithAggregatesFilter<"Prize"> | Date | string
    updatedBy?: StringWithAggregatesFilter<"Prize"> | string
  }

  export type ChallengeWinnerWhereInput = {
    AND?: ChallengeWinnerWhereInput | ChallengeWinnerWhereInput[]
    OR?: ChallengeWinnerWhereInput[]
    NOT?: ChallengeWinnerWhereInput | ChallengeWinnerWhereInput[]
    id?: StringFilter<"ChallengeWinner"> | string
    challengeId?: StringFilter<"ChallengeWinner"> | string
    userId?: IntFilter<"ChallengeWinner"> | number
    handle?: StringFilter<"ChallengeWinner"> | string
    placement?: IntFilter<"ChallengeWinner"> | number
    type?: EnumPrizeSetTypeEnumFilter<"ChallengeWinner"> | $Enums.PrizeSetTypeEnum
    createdAt?: DateTimeFilter<"ChallengeWinner"> | Date | string
    createdBy?: StringFilter<"ChallengeWinner"> | string
    updatedAt?: DateTimeFilter<"ChallengeWinner"> | Date | string
    updatedBy?: StringFilter<"ChallengeWinner"> | string
    challenge?: XOR<ChallengeScalarRelationFilter, ChallengeWhereInput>
  }

  export type ChallengeWinnerOrderByWithRelationInput = {
    id?: SortOrder
    challengeId?: SortOrder
    userId?: SortOrder
    handle?: SortOrder
    placement?: SortOrder
    type?: SortOrder
    createdAt?: SortOrder
    createdBy?: SortOrder
    updatedAt?: SortOrder
    updatedBy?: SortOrder
    challenge?: ChallengeOrderByWithRelationInput
    _relevance?: ChallengeWinnerOrderByRelevanceInput
  }

  export type ChallengeWinnerWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: ChallengeWinnerWhereInput | ChallengeWinnerWhereInput[]
    OR?: ChallengeWinnerWhereInput[]
    NOT?: ChallengeWinnerWhereInput | ChallengeWinnerWhereInput[]
    challengeId?: StringFilter<"ChallengeWinner"> | string
    userId?: IntFilter<"ChallengeWinner"> | number
    handle?: StringFilter<"ChallengeWinner"> | string
    placement?: IntFilter<"ChallengeWinner"> | number
    type?: EnumPrizeSetTypeEnumFilter<"ChallengeWinner"> | $Enums.PrizeSetTypeEnum
    createdAt?: DateTimeFilter<"ChallengeWinner"> | Date | string
    createdBy?: StringFilter<"ChallengeWinner"> | string
    updatedAt?: DateTimeFilter<"ChallengeWinner"> | Date | string
    updatedBy?: StringFilter<"ChallengeWinner"> | string
    challenge?: XOR<ChallengeScalarRelationFilter, ChallengeWhereInput>
  }, "id">

  export type ChallengeWinnerOrderByWithAggregationInput = {
    id?: SortOrder
    challengeId?: SortOrder
    userId?: SortOrder
    handle?: SortOrder
    placement?: SortOrder
    type?: SortOrder
    createdAt?: SortOrder
    createdBy?: SortOrder
    updatedAt?: SortOrder
    updatedBy?: SortOrder
    _count?: ChallengeWinnerCountOrderByAggregateInput
    _avg?: ChallengeWinnerAvgOrderByAggregateInput
    _max?: ChallengeWinnerMaxOrderByAggregateInput
    _min?: ChallengeWinnerMinOrderByAggregateInput
    _sum?: ChallengeWinnerSumOrderByAggregateInput
  }

  export type ChallengeWinnerScalarWhereWithAggregatesInput = {
    AND?: ChallengeWinnerScalarWhereWithAggregatesInput | ChallengeWinnerScalarWhereWithAggregatesInput[]
    OR?: ChallengeWinnerScalarWhereWithAggregatesInput[]
    NOT?: ChallengeWinnerScalarWhereWithAggregatesInput | ChallengeWinnerScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"ChallengeWinner"> | string
    challengeId?: StringWithAggregatesFilter<"ChallengeWinner"> | string
    userId?: IntWithAggregatesFilter<"ChallengeWinner"> | number
    handle?: StringWithAggregatesFilter<"ChallengeWinner"> | string
    placement?: IntWithAggregatesFilter<"ChallengeWinner"> | number
    type?: EnumPrizeSetTypeEnumWithAggregatesFilter<"ChallengeWinner"> | $Enums.PrizeSetTypeEnum
    createdAt?: DateTimeWithAggregatesFilter<"ChallengeWinner"> | Date | string
    createdBy?: StringWithAggregatesFilter<"ChallengeWinner"> | string
    updatedAt?: DateTimeWithAggregatesFilter<"ChallengeWinner"> | Date | string
    updatedBy?: StringWithAggregatesFilter<"ChallengeWinner"> | string
  }

  export type ChallengeTermWhereInput = {
    AND?: ChallengeTermWhereInput | ChallengeTermWhereInput[]
    OR?: ChallengeTermWhereInput[]
    NOT?: ChallengeTermWhereInput | ChallengeTermWhereInput[]
    id?: StringFilter<"ChallengeTerm"> | string
    challengeId?: StringFilter<"ChallengeTerm"> | string
    termId?: StringFilter<"ChallengeTerm"> | string
    roleId?: StringFilter<"ChallengeTerm"> | string
    createdAt?: DateTimeFilter<"ChallengeTerm"> | Date | string
    createdBy?: StringFilter<"ChallengeTerm"> | string
    updatedAt?: DateTimeFilter<"ChallengeTerm"> | Date | string
    updatedBy?: StringFilter<"ChallengeTerm"> | string
    challenge?: XOR<ChallengeScalarRelationFilter, ChallengeWhereInput>
  }

  export type ChallengeTermOrderByWithRelationInput = {
    id?: SortOrder
    challengeId?: SortOrder
    termId?: SortOrder
    roleId?: SortOrder
    createdAt?: SortOrder
    createdBy?: SortOrder
    updatedAt?: SortOrder
    updatedBy?: SortOrder
    challenge?: ChallengeOrderByWithRelationInput
    _relevance?: ChallengeTermOrderByRelevanceInput
  }

  export type ChallengeTermWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: ChallengeTermWhereInput | ChallengeTermWhereInput[]
    OR?: ChallengeTermWhereInput[]
    NOT?: ChallengeTermWhereInput | ChallengeTermWhereInput[]
    challengeId?: StringFilter<"ChallengeTerm"> | string
    termId?: StringFilter<"ChallengeTerm"> | string
    roleId?: StringFilter<"ChallengeTerm"> | string
    createdAt?: DateTimeFilter<"ChallengeTerm"> | Date | string
    createdBy?: StringFilter<"ChallengeTerm"> | string
    updatedAt?: DateTimeFilter<"ChallengeTerm"> | Date | string
    updatedBy?: StringFilter<"ChallengeTerm"> | string
    challenge?: XOR<ChallengeScalarRelationFilter, ChallengeWhereInput>
  }, "id">

  export type ChallengeTermOrderByWithAggregationInput = {
    id?: SortOrder
    challengeId?: SortOrder
    termId?: SortOrder
    roleId?: SortOrder
    createdAt?: SortOrder
    createdBy?: SortOrder
    updatedAt?: SortOrder
    updatedBy?: SortOrder
    _count?: ChallengeTermCountOrderByAggregateInput
    _max?: ChallengeTermMaxOrderByAggregateInput
    _min?: ChallengeTermMinOrderByAggregateInput
  }

  export type ChallengeTermScalarWhereWithAggregatesInput = {
    AND?: ChallengeTermScalarWhereWithAggregatesInput | ChallengeTermScalarWhereWithAggregatesInput[]
    OR?: ChallengeTermScalarWhereWithAggregatesInput[]
    NOT?: ChallengeTermScalarWhereWithAggregatesInput | ChallengeTermScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"ChallengeTerm"> | string
    challengeId?: StringWithAggregatesFilter<"ChallengeTerm"> | string
    termId?: StringWithAggregatesFilter<"ChallengeTerm"> | string
    roleId?: StringWithAggregatesFilter<"ChallengeTerm"> | string
    createdAt?: DateTimeWithAggregatesFilter<"ChallengeTerm"> | Date | string
    createdBy?: StringWithAggregatesFilter<"ChallengeTerm"> | string
    updatedAt?: DateTimeWithAggregatesFilter<"ChallengeTerm"> | Date | string
    updatedBy?: StringWithAggregatesFilter<"ChallengeTerm"> | string
  }

  export type ChallengeSkillWhereInput = {
    AND?: ChallengeSkillWhereInput | ChallengeSkillWhereInput[]
    OR?: ChallengeSkillWhereInput[]
    NOT?: ChallengeSkillWhereInput | ChallengeSkillWhereInput[]
    id?: StringFilter<"ChallengeSkill"> | string
    challengeId?: StringFilter<"ChallengeSkill"> | string
    skillId?: StringFilter<"ChallengeSkill"> | string
    createdAt?: DateTimeFilter<"ChallengeSkill"> | Date | string
    createdBy?: StringFilter<"ChallengeSkill"> | string
    updatedAt?: DateTimeFilter<"ChallengeSkill"> | Date | string
    updatedBy?: StringFilter<"ChallengeSkill"> | string
    challenge?: XOR<ChallengeScalarRelationFilter, ChallengeWhereInput>
  }

  export type ChallengeSkillOrderByWithRelationInput = {
    id?: SortOrder
    challengeId?: SortOrder
    skillId?: SortOrder
    createdAt?: SortOrder
    createdBy?: SortOrder
    updatedAt?: SortOrder
    updatedBy?: SortOrder
    challenge?: ChallengeOrderByWithRelationInput
    _relevance?: ChallengeSkillOrderByRelevanceInput
  }

  export type ChallengeSkillWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: ChallengeSkillWhereInput | ChallengeSkillWhereInput[]
    OR?: ChallengeSkillWhereInput[]
    NOT?: ChallengeSkillWhereInput | ChallengeSkillWhereInput[]
    challengeId?: StringFilter<"ChallengeSkill"> | string
    skillId?: StringFilter<"ChallengeSkill"> | string
    createdAt?: DateTimeFilter<"ChallengeSkill"> | Date | string
    createdBy?: StringFilter<"ChallengeSkill"> | string
    updatedAt?: DateTimeFilter<"ChallengeSkill"> | Date | string
    updatedBy?: StringFilter<"ChallengeSkill"> | string
    challenge?: XOR<ChallengeScalarRelationFilter, ChallengeWhereInput>
  }, "id">

  export type ChallengeSkillOrderByWithAggregationInput = {
    id?: SortOrder
    challengeId?: SortOrder
    skillId?: SortOrder
    createdAt?: SortOrder
    createdBy?: SortOrder
    updatedAt?: SortOrder
    updatedBy?: SortOrder
    _count?: ChallengeSkillCountOrderByAggregateInput
    _max?: ChallengeSkillMaxOrderByAggregateInput
    _min?: ChallengeSkillMinOrderByAggregateInput
  }

  export type ChallengeSkillScalarWhereWithAggregatesInput = {
    AND?: ChallengeSkillScalarWhereWithAggregatesInput | ChallengeSkillScalarWhereWithAggregatesInput[]
    OR?: ChallengeSkillScalarWhereWithAggregatesInput[]
    NOT?: ChallengeSkillScalarWhereWithAggregatesInput | ChallengeSkillScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"ChallengeSkill"> | string
    challengeId?: StringWithAggregatesFilter<"ChallengeSkill"> | string
    skillId?: StringWithAggregatesFilter<"ChallengeSkill"> | string
    createdAt?: DateTimeWithAggregatesFilter<"ChallengeSkill"> | Date | string
    createdBy?: StringWithAggregatesFilter<"ChallengeSkill"> | string
    updatedAt?: DateTimeWithAggregatesFilter<"ChallengeSkill"> | Date | string
    updatedBy?: StringWithAggregatesFilter<"ChallengeSkill"> | string
  }

  export type ChallengeBillingWhereInput = {
    AND?: ChallengeBillingWhereInput | ChallengeBillingWhereInput[]
    OR?: ChallengeBillingWhereInput[]
    NOT?: ChallengeBillingWhereInput | ChallengeBillingWhereInput[]
    id?: StringFilter<"ChallengeBilling"> | string
    billingAccountId?: StringNullableFilter<"ChallengeBilling"> | string | null
    markup?: FloatNullableFilter<"ChallengeBilling"> | number | null
    clientBillingRate?: FloatNullableFilter<"ChallengeBilling"> | number | null
    challengeId?: StringFilter<"ChallengeBilling"> | string
    createdAt?: DateTimeFilter<"ChallengeBilling"> | Date | string
    createdBy?: StringFilter<"ChallengeBilling"> | string
    updatedAt?: DateTimeFilter<"ChallengeBilling"> | Date | string
    updatedBy?: StringFilter<"ChallengeBilling"> | string
    challenge?: XOR<ChallengeScalarRelationFilter, ChallengeWhereInput>
  }

  export type ChallengeBillingOrderByWithRelationInput = {
    id?: SortOrder
    billingAccountId?: SortOrderInput | SortOrder
    markup?: SortOrderInput | SortOrder
    clientBillingRate?: SortOrderInput | SortOrder
    challengeId?: SortOrder
    createdAt?: SortOrder
    createdBy?: SortOrder
    updatedAt?: SortOrder
    updatedBy?: SortOrder
    challenge?: ChallengeOrderByWithRelationInput
    _relevance?: ChallengeBillingOrderByRelevanceInput
  }

  export type ChallengeBillingWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    challengeId?: string
    AND?: ChallengeBillingWhereInput | ChallengeBillingWhereInput[]
    OR?: ChallengeBillingWhereInput[]
    NOT?: ChallengeBillingWhereInput | ChallengeBillingWhereInput[]
    billingAccountId?: StringNullableFilter<"ChallengeBilling"> | string | null
    markup?: FloatNullableFilter<"ChallengeBilling"> | number | null
    clientBillingRate?: FloatNullableFilter<"ChallengeBilling"> | number | null
    createdAt?: DateTimeFilter<"ChallengeBilling"> | Date | string
    createdBy?: StringFilter<"ChallengeBilling"> | string
    updatedAt?: DateTimeFilter<"ChallengeBilling"> | Date | string
    updatedBy?: StringFilter<"ChallengeBilling"> | string
    challenge?: XOR<ChallengeScalarRelationFilter, ChallengeWhereInput>
  }, "id" | "challengeId">

  export type ChallengeBillingOrderByWithAggregationInput = {
    id?: SortOrder
    billingAccountId?: SortOrderInput | SortOrder
    markup?: SortOrderInput | SortOrder
    clientBillingRate?: SortOrderInput | SortOrder
    challengeId?: SortOrder
    createdAt?: SortOrder
    createdBy?: SortOrder
    updatedAt?: SortOrder
    updatedBy?: SortOrder
    _count?: ChallengeBillingCountOrderByAggregateInput
    _avg?: ChallengeBillingAvgOrderByAggregateInput
    _max?: ChallengeBillingMaxOrderByAggregateInput
    _min?: ChallengeBillingMinOrderByAggregateInput
    _sum?: ChallengeBillingSumOrderByAggregateInput
  }

  export type ChallengeBillingScalarWhereWithAggregatesInput = {
    AND?: ChallengeBillingScalarWhereWithAggregatesInput | ChallengeBillingScalarWhereWithAggregatesInput[]
    OR?: ChallengeBillingScalarWhereWithAggregatesInput[]
    NOT?: ChallengeBillingScalarWhereWithAggregatesInput | ChallengeBillingScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"ChallengeBilling"> | string
    billingAccountId?: StringNullableWithAggregatesFilter<"ChallengeBilling"> | string | null
    markup?: FloatNullableWithAggregatesFilter<"ChallengeBilling"> | number | null
    clientBillingRate?: FloatNullableWithAggregatesFilter<"ChallengeBilling"> | number | null
    challengeId?: StringWithAggregatesFilter<"ChallengeBilling"> | string
    createdAt?: DateTimeWithAggregatesFilter<"ChallengeBilling"> | Date | string
    createdBy?: StringWithAggregatesFilter<"ChallengeBilling"> | string
    updatedAt?: DateTimeWithAggregatesFilter<"ChallengeBilling"> | Date | string
    updatedBy?: StringWithAggregatesFilter<"ChallengeBilling"> | string
  }

  export type ChallengeLegacyWhereInput = {
    AND?: ChallengeLegacyWhereInput | ChallengeLegacyWhereInput[]
    OR?: ChallengeLegacyWhereInput[]
    NOT?: ChallengeLegacyWhereInput | ChallengeLegacyWhereInput[]
    id?: StringFilter<"ChallengeLegacy"> | string
    reviewType?: EnumReviewTypeEnumFilter<"ChallengeLegacy"> | $Enums.ReviewTypeEnum
    confidentialityType?: StringFilter<"ChallengeLegacy"> | string
    forumId?: IntNullableFilter<"ChallengeLegacy"> | number | null
    directProjectId?: IntNullableFilter<"ChallengeLegacy"> | number | null
    screeningScorecardId?: IntNullableFilter<"ChallengeLegacy"> | number | null
    reviewScorecardId?: IntNullableFilter<"ChallengeLegacy"> | number | null
    isTask?: BoolFilter<"ChallengeLegacy"> | boolean
    useSchedulingAPI?: BoolFilter<"ChallengeLegacy"> | boolean
    pureV5Task?: BoolFilter<"ChallengeLegacy"> | boolean
    pureV5?: BoolFilter<"ChallengeLegacy"> | boolean
    selfService?: BoolFilter<"ChallengeLegacy"> | boolean
    selfServiceCopilot?: StringNullableFilter<"ChallengeLegacy"> | string | null
    track?: StringNullableFilter<"ChallengeLegacy"> | string | null
    subTrack?: StringNullableFilter<"ChallengeLegacy"> | string | null
    legacySystemId?: IntNullableFilter<"ChallengeLegacy"> | number | null
    challengeId?: StringFilter<"ChallengeLegacy"> | string
    createdAt?: DateTimeFilter<"ChallengeLegacy"> | Date | string
    createdBy?: StringFilter<"ChallengeLegacy"> | string
    updatedAt?: DateTimeFilter<"ChallengeLegacy"> | Date | string
    updatedBy?: StringFilter<"ChallengeLegacy"> | string
    challenge?: XOR<ChallengeScalarRelationFilter, ChallengeWhereInput>
  }

  export type ChallengeLegacyOrderByWithRelationInput = {
    id?: SortOrder
    reviewType?: SortOrder
    confidentialityType?: SortOrder
    forumId?: SortOrderInput | SortOrder
    directProjectId?: SortOrderInput | SortOrder
    screeningScorecardId?: SortOrderInput | SortOrder
    reviewScorecardId?: SortOrderInput | SortOrder
    isTask?: SortOrder
    useSchedulingAPI?: SortOrder
    pureV5Task?: SortOrder
    pureV5?: SortOrder
    selfService?: SortOrder
    selfServiceCopilot?: SortOrderInput | SortOrder
    track?: SortOrderInput | SortOrder
    subTrack?: SortOrderInput | SortOrder
    legacySystemId?: SortOrderInput | SortOrder
    challengeId?: SortOrder
    createdAt?: SortOrder
    createdBy?: SortOrder
    updatedAt?: SortOrder
    updatedBy?: SortOrder
    challenge?: ChallengeOrderByWithRelationInput
    _relevance?: ChallengeLegacyOrderByRelevanceInput
  }

  export type ChallengeLegacyWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    challengeId?: string
    AND?: ChallengeLegacyWhereInput | ChallengeLegacyWhereInput[]
    OR?: ChallengeLegacyWhereInput[]
    NOT?: ChallengeLegacyWhereInput | ChallengeLegacyWhereInput[]
    reviewType?: EnumReviewTypeEnumFilter<"ChallengeLegacy"> | $Enums.ReviewTypeEnum
    confidentialityType?: StringFilter<"ChallengeLegacy"> | string
    forumId?: IntNullableFilter<"ChallengeLegacy"> | number | null
    directProjectId?: IntNullableFilter<"ChallengeLegacy"> | number | null
    screeningScorecardId?: IntNullableFilter<"ChallengeLegacy"> | number | null
    reviewScorecardId?: IntNullableFilter<"ChallengeLegacy"> | number | null
    isTask?: BoolFilter<"ChallengeLegacy"> | boolean
    useSchedulingAPI?: BoolFilter<"ChallengeLegacy"> | boolean
    pureV5Task?: BoolFilter<"ChallengeLegacy"> | boolean
    pureV5?: BoolFilter<"ChallengeLegacy"> | boolean
    selfService?: BoolFilter<"ChallengeLegacy"> | boolean
    selfServiceCopilot?: StringNullableFilter<"ChallengeLegacy"> | string | null
    track?: StringNullableFilter<"ChallengeLegacy"> | string | null
    subTrack?: StringNullableFilter<"ChallengeLegacy"> | string | null
    legacySystemId?: IntNullableFilter<"ChallengeLegacy"> | number | null
    createdAt?: DateTimeFilter<"ChallengeLegacy"> | Date | string
    createdBy?: StringFilter<"ChallengeLegacy"> | string
    updatedAt?: DateTimeFilter<"ChallengeLegacy"> | Date | string
    updatedBy?: StringFilter<"ChallengeLegacy"> | string
    challenge?: XOR<ChallengeScalarRelationFilter, ChallengeWhereInput>
  }, "id" | "challengeId">

  export type ChallengeLegacyOrderByWithAggregationInput = {
    id?: SortOrder
    reviewType?: SortOrder
    confidentialityType?: SortOrder
    forumId?: SortOrderInput | SortOrder
    directProjectId?: SortOrderInput | SortOrder
    screeningScorecardId?: SortOrderInput | SortOrder
    reviewScorecardId?: SortOrderInput | SortOrder
    isTask?: SortOrder
    useSchedulingAPI?: SortOrder
    pureV5Task?: SortOrder
    pureV5?: SortOrder
    selfService?: SortOrder
    selfServiceCopilot?: SortOrderInput | SortOrder
    track?: SortOrderInput | SortOrder
    subTrack?: SortOrderInput | SortOrder
    legacySystemId?: SortOrderInput | SortOrder
    challengeId?: SortOrder
    createdAt?: SortOrder
    createdBy?: SortOrder
    updatedAt?: SortOrder
    updatedBy?: SortOrder
    _count?: ChallengeLegacyCountOrderByAggregateInput
    _avg?: ChallengeLegacyAvgOrderByAggregateInput
    _max?: ChallengeLegacyMaxOrderByAggregateInput
    _min?: ChallengeLegacyMinOrderByAggregateInput
    _sum?: ChallengeLegacySumOrderByAggregateInput
  }

  export type ChallengeLegacyScalarWhereWithAggregatesInput = {
    AND?: ChallengeLegacyScalarWhereWithAggregatesInput | ChallengeLegacyScalarWhereWithAggregatesInput[]
    OR?: ChallengeLegacyScalarWhereWithAggregatesInput[]
    NOT?: ChallengeLegacyScalarWhereWithAggregatesInput | ChallengeLegacyScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"ChallengeLegacy"> | string
    reviewType?: EnumReviewTypeEnumWithAggregatesFilter<"ChallengeLegacy"> | $Enums.ReviewTypeEnum
    confidentialityType?: StringWithAggregatesFilter<"ChallengeLegacy"> | string
    forumId?: IntNullableWithAggregatesFilter<"ChallengeLegacy"> | number | null
    directProjectId?: IntNullableWithAggregatesFilter<"ChallengeLegacy"> | number | null
    screeningScorecardId?: IntNullableWithAggregatesFilter<"ChallengeLegacy"> | number | null
    reviewScorecardId?: IntNullableWithAggregatesFilter<"ChallengeLegacy"> | number | null
    isTask?: BoolWithAggregatesFilter<"ChallengeLegacy"> | boolean
    useSchedulingAPI?: BoolWithAggregatesFilter<"ChallengeLegacy"> | boolean
    pureV5Task?: BoolWithAggregatesFilter<"ChallengeLegacy"> | boolean
    pureV5?: BoolWithAggregatesFilter<"ChallengeLegacy"> | boolean
    selfService?: BoolWithAggregatesFilter<"ChallengeLegacy"> | boolean
    selfServiceCopilot?: StringNullableWithAggregatesFilter<"ChallengeLegacy"> | string | null
    track?: StringNullableWithAggregatesFilter<"ChallengeLegacy"> | string | null
    subTrack?: StringNullableWithAggregatesFilter<"ChallengeLegacy"> | string | null
    legacySystemId?: IntNullableWithAggregatesFilter<"ChallengeLegacy"> | number | null
    challengeId?: StringWithAggregatesFilter<"ChallengeLegacy"> | string
    createdAt?: DateTimeWithAggregatesFilter<"ChallengeLegacy"> | Date | string
    createdBy?: StringWithAggregatesFilter<"ChallengeLegacy"> | string
    updatedAt?: DateTimeWithAggregatesFilter<"ChallengeLegacy"> | Date | string
    updatedBy?: StringWithAggregatesFilter<"ChallengeLegacy"> | string
  }

  export type ChallengeEventWhereInput = {
    AND?: ChallengeEventWhereInput | ChallengeEventWhereInput[]
    OR?: ChallengeEventWhereInput[]
    NOT?: ChallengeEventWhereInput | ChallengeEventWhereInput[]
    id?: StringFilter<"ChallengeEvent"> | string
    challengeId?: StringFilter<"ChallengeEvent"> | string
    eventId?: IntFilter<"ChallengeEvent"> | number
    name?: StringNullableFilter<"ChallengeEvent"> | string | null
    key?: StringNullableFilter<"ChallengeEvent"> | string | null
    createdAt?: DateTimeFilter<"ChallengeEvent"> | Date | string
    createdBy?: StringFilter<"ChallengeEvent"> | string
    updatedAt?: DateTimeFilter<"ChallengeEvent"> | Date | string
    updatedBy?: StringFilter<"ChallengeEvent"> | string
    challenge?: XOR<ChallengeScalarRelationFilter, ChallengeWhereInput>
  }

  export type ChallengeEventOrderByWithRelationInput = {
    id?: SortOrder
    challengeId?: SortOrder
    eventId?: SortOrder
    name?: SortOrderInput | SortOrder
    key?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    createdBy?: SortOrder
    updatedAt?: SortOrder
    updatedBy?: SortOrder
    challenge?: ChallengeOrderByWithRelationInput
    _relevance?: ChallengeEventOrderByRelevanceInput
  }

  export type ChallengeEventWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: ChallengeEventWhereInput | ChallengeEventWhereInput[]
    OR?: ChallengeEventWhereInput[]
    NOT?: ChallengeEventWhereInput | ChallengeEventWhereInput[]
    challengeId?: StringFilter<"ChallengeEvent"> | string
    eventId?: IntFilter<"ChallengeEvent"> | number
    name?: StringNullableFilter<"ChallengeEvent"> | string | null
    key?: StringNullableFilter<"ChallengeEvent"> | string | null
    createdAt?: DateTimeFilter<"ChallengeEvent"> | Date | string
    createdBy?: StringFilter<"ChallengeEvent"> | string
    updatedAt?: DateTimeFilter<"ChallengeEvent"> | Date | string
    updatedBy?: StringFilter<"ChallengeEvent"> | string
    challenge?: XOR<ChallengeScalarRelationFilter, ChallengeWhereInput>
  }, "id">

  export type ChallengeEventOrderByWithAggregationInput = {
    id?: SortOrder
    challengeId?: SortOrder
    eventId?: SortOrder
    name?: SortOrderInput | SortOrder
    key?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    createdBy?: SortOrder
    updatedAt?: SortOrder
    updatedBy?: SortOrder
    _count?: ChallengeEventCountOrderByAggregateInput
    _avg?: ChallengeEventAvgOrderByAggregateInput
    _max?: ChallengeEventMaxOrderByAggregateInput
    _min?: ChallengeEventMinOrderByAggregateInput
    _sum?: ChallengeEventSumOrderByAggregateInput
  }

  export type ChallengeEventScalarWhereWithAggregatesInput = {
    AND?: ChallengeEventScalarWhereWithAggregatesInput | ChallengeEventScalarWhereWithAggregatesInput[]
    OR?: ChallengeEventScalarWhereWithAggregatesInput[]
    NOT?: ChallengeEventScalarWhereWithAggregatesInput | ChallengeEventScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"ChallengeEvent"> | string
    challengeId?: StringWithAggregatesFilter<"ChallengeEvent"> | string
    eventId?: IntWithAggregatesFilter<"ChallengeEvent"> | number
    name?: StringNullableWithAggregatesFilter<"ChallengeEvent"> | string | null
    key?: StringNullableWithAggregatesFilter<"ChallengeEvent"> | string | null
    createdAt?: DateTimeWithAggregatesFilter<"ChallengeEvent"> | Date | string
    createdBy?: StringWithAggregatesFilter<"ChallengeEvent"> | string
    updatedAt?: DateTimeWithAggregatesFilter<"ChallengeEvent"> | Date | string
    updatedBy?: StringWithAggregatesFilter<"ChallengeEvent"> | string
  }

  export type ChallengeDiscussionWhereInput = {
    AND?: ChallengeDiscussionWhereInput | ChallengeDiscussionWhereInput[]
    OR?: ChallengeDiscussionWhereInput[]
    NOT?: ChallengeDiscussionWhereInput | ChallengeDiscussionWhereInput[]
    id?: StringFilter<"ChallengeDiscussion"> | string
    challengeId?: StringFilter<"ChallengeDiscussion"> | string
    discussionId?: StringNullableFilter<"ChallengeDiscussion"> | string | null
    name?: StringFilter<"ChallengeDiscussion"> | string
    type?: EnumDiscussionTypeEnumFilter<"ChallengeDiscussion"> | $Enums.DiscussionTypeEnum
    provider?: StringFilter<"ChallengeDiscussion"> | string
    url?: StringNullableFilter<"ChallengeDiscussion"> | string | null
    createdAt?: DateTimeFilter<"ChallengeDiscussion"> | Date | string
    createdBy?: StringFilter<"ChallengeDiscussion"> | string
    updatedAt?: DateTimeFilter<"ChallengeDiscussion"> | Date | string
    updatedBy?: StringFilter<"ChallengeDiscussion"> | string
    challenge?: XOR<ChallengeScalarRelationFilter, ChallengeWhereInput>
    options?: ChallengeDiscussionOptionListRelationFilter
  }

  export type ChallengeDiscussionOrderByWithRelationInput = {
    id?: SortOrder
    challengeId?: SortOrder
    discussionId?: SortOrderInput | SortOrder
    name?: SortOrder
    type?: SortOrder
    provider?: SortOrder
    url?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    createdBy?: SortOrder
    updatedAt?: SortOrder
    updatedBy?: SortOrder
    challenge?: ChallengeOrderByWithRelationInput
    options?: ChallengeDiscussionOptionOrderByRelationAggregateInput
    _relevance?: ChallengeDiscussionOrderByRelevanceInput
  }

  export type ChallengeDiscussionWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: ChallengeDiscussionWhereInput | ChallengeDiscussionWhereInput[]
    OR?: ChallengeDiscussionWhereInput[]
    NOT?: ChallengeDiscussionWhereInput | ChallengeDiscussionWhereInput[]
    challengeId?: StringFilter<"ChallengeDiscussion"> | string
    discussionId?: StringNullableFilter<"ChallengeDiscussion"> | string | null
    name?: StringFilter<"ChallengeDiscussion"> | string
    type?: EnumDiscussionTypeEnumFilter<"ChallengeDiscussion"> | $Enums.DiscussionTypeEnum
    provider?: StringFilter<"ChallengeDiscussion"> | string
    url?: StringNullableFilter<"ChallengeDiscussion"> | string | null
    createdAt?: DateTimeFilter<"ChallengeDiscussion"> | Date | string
    createdBy?: StringFilter<"ChallengeDiscussion"> | string
    updatedAt?: DateTimeFilter<"ChallengeDiscussion"> | Date | string
    updatedBy?: StringFilter<"ChallengeDiscussion"> | string
    challenge?: XOR<ChallengeScalarRelationFilter, ChallengeWhereInput>
    options?: ChallengeDiscussionOptionListRelationFilter
  }, "id">

  export type ChallengeDiscussionOrderByWithAggregationInput = {
    id?: SortOrder
    challengeId?: SortOrder
    discussionId?: SortOrderInput | SortOrder
    name?: SortOrder
    type?: SortOrder
    provider?: SortOrder
    url?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    createdBy?: SortOrder
    updatedAt?: SortOrder
    updatedBy?: SortOrder
    _count?: ChallengeDiscussionCountOrderByAggregateInput
    _max?: ChallengeDiscussionMaxOrderByAggregateInput
    _min?: ChallengeDiscussionMinOrderByAggregateInput
  }

  export type ChallengeDiscussionScalarWhereWithAggregatesInput = {
    AND?: ChallengeDiscussionScalarWhereWithAggregatesInput | ChallengeDiscussionScalarWhereWithAggregatesInput[]
    OR?: ChallengeDiscussionScalarWhereWithAggregatesInput[]
    NOT?: ChallengeDiscussionScalarWhereWithAggregatesInput | ChallengeDiscussionScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"ChallengeDiscussion"> | string
    challengeId?: StringWithAggregatesFilter<"ChallengeDiscussion"> | string
    discussionId?: StringNullableWithAggregatesFilter<"ChallengeDiscussion"> | string | null
    name?: StringWithAggregatesFilter<"ChallengeDiscussion"> | string
    type?: EnumDiscussionTypeEnumWithAggregatesFilter<"ChallengeDiscussion"> | $Enums.DiscussionTypeEnum
    provider?: StringWithAggregatesFilter<"ChallengeDiscussion"> | string
    url?: StringNullableWithAggregatesFilter<"ChallengeDiscussion"> | string | null
    createdAt?: DateTimeWithAggregatesFilter<"ChallengeDiscussion"> | Date | string
    createdBy?: StringWithAggregatesFilter<"ChallengeDiscussion"> | string
    updatedAt?: DateTimeWithAggregatesFilter<"ChallengeDiscussion"> | Date | string
    updatedBy?: StringWithAggregatesFilter<"ChallengeDiscussion"> | string
  }

  export type ChallengeDiscussionOptionWhereInput = {
    AND?: ChallengeDiscussionOptionWhereInput | ChallengeDiscussionOptionWhereInput[]
    OR?: ChallengeDiscussionOptionWhereInput[]
    NOT?: ChallengeDiscussionOptionWhereInput | ChallengeDiscussionOptionWhereInput[]
    id?: StringFilter<"ChallengeDiscussionOption"> | string
    discussionId?: StringFilter<"ChallengeDiscussionOption"> | string
    optionKey?: StringFilter<"ChallengeDiscussionOption"> | string
    optionValue?: StringFilter<"ChallengeDiscussionOption"> | string
    createdAt?: DateTimeFilter<"ChallengeDiscussionOption"> | Date | string
    createdBy?: StringFilter<"ChallengeDiscussionOption"> | string
    updatedAt?: DateTimeFilter<"ChallengeDiscussionOption"> | Date | string
    updatedBy?: StringFilter<"ChallengeDiscussionOption"> | string
    discussion?: XOR<ChallengeDiscussionScalarRelationFilter, ChallengeDiscussionWhereInput>
  }

  export type ChallengeDiscussionOptionOrderByWithRelationInput = {
    id?: SortOrder
    discussionId?: SortOrder
    optionKey?: SortOrder
    optionValue?: SortOrder
    createdAt?: SortOrder
    createdBy?: SortOrder
    updatedAt?: SortOrder
    updatedBy?: SortOrder
    discussion?: ChallengeDiscussionOrderByWithRelationInput
    _relevance?: ChallengeDiscussionOptionOrderByRelevanceInput
  }

  export type ChallengeDiscussionOptionWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: ChallengeDiscussionOptionWhereInput | ChallengeDiscussionOptionWhereInput[]
    OR?: ChallengeDiscussionOptionWhereInput[]
    NOT?: ChallengeDiscussionOptionWhereInput | ChallengeDiscussionOptionWhereInput[]
    discussionId?: StringFilter<"ChallengeDiscussionOption"> | string
    optionKey?: StringFilter<"ChallengeDiscussionOption"> | string
    optionValue?: StringFilter<"ChallengeDiscussionOption"> | string
    createdAt?: DateTimeFilter<"ChallengeDiscussionOption"> | Date | string
    createdBy?: StringFilter<"ChallengeDiscussionOption"> | string
    updatedAt?: DateTimeFilter<"ChallengeDiscussionOption"> | Date | string
    updatedBy?: StringFilter<"ChallengeDiscussionOption"> | string
    discussion?: XOR<ChallengeDiscussionScalarRelationFilter, ChallengeDiscussionWhereInput>
  }, "id">

  export type ChallengeDiscussionOptionOrderByWithAggregationInput = {
    id?: SortOrder
    discussionId?: SortOrder
    optionKey?: SortOrder
    optionValue?: SortOrder
    createdAt?: SortOrder
    createdBy?: SortOrder
    updatedAt?: SortOrder
    updatedBy?: SortOrder
    _count?: ChallengeDiscussionOptionCountOrderByAggregateInput
    _max?: ChallengeDiscussionOptionMaxOrderByAggregateInput
    _min?: ChallengeDiscussionOptionMinOrderByAggregateInput
  }

  export type ChallengeDiscussionOptionScalarWhereWithAggregatesInput = {
    AND?: ChallengeDiscussionOptionScalarWhereWithAggregatesInput | ChallengeDiscussionOptionScalarWhereWithAggregatesInput[]
    OR?: ChallengeDiscussionOptionScalarWhereWithAggregatesInput[]
    NOT?: ChallengeDiscussionOptionScalarWhereWithAggregatesInput | ChallengeDiscussionOptionScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"ChallengeDiscussionOption"> | string
    discussionId?: StringWithAggregatesFilter<"ChallengeDiscussionOption"> | string
    optionKey?: StringWithAggregatesFilter<"ChallengeDiscussionOption"> | string
    optionValue?: StringWithAggregatesFilter<"ChallengeDiscussionOption"> | string
    createdAt?: DateTimeWithAggregatesFilter<"ChallengeDiscussionOption"> | Date | string
    createdBy?: StringWithAggregatesFilter<"ChallengeDiscussionOption"> | string
    updatedAt?: DateTimeWithAggregatesFilter<"ChallengeDiscussionOption"> | Date | string
    updatedBy?: StringWithAggregatesFilter<"ChallengeDiscussionOption"> | string
  }

  export type ChallengeConstraintWhereInput = {
    AND?: ChallengeConstraintWhereInput | ChallengeConstraintWhereInput[]
    OR?: ChallengeConstraintWhereInput[]
    NOT?: ChallengeConstraintWhereInput | ChallengeConstraintWhereInput[]
    id?: StringFilter<"ChallengeConstraint"> | string
    challengeId?: StringFilter<"ChallengeConstraint"> | string
    allowedRegistrants?: StringNullableListFilter<"ChallengeConstraint">
    createdAt?: DateTimeFilter<"ChallengeConstraint"> | Date | string
    createdBy?: StringFilter<"ChallengeConstraint"> | string
    updatedAt?: DateTimeFilter<"ChallengeConstraint"> | Date | string
    updatedBy?: StringFilter<"ChallengeConstraint"> | string
    challenge?: XOR<ChallengeScalarRelationFilter, ChallengeWhereInput>
  }

  export type ChallengeConstraintOrderByWithRelationInput = {
    id?: SortOrder
    challengeId?: SortOrder
    allowedRegistrants?: SortOrder
    createdAt?: SortOrder
    createdBy?: SortOrder
    updatedAt?: SortOrder
    updatedBy?: SortOrder
    challenge?: ChallengeOrderByWithRelationInput
    _relevance?: ChallengeConstraintOrderByRelevanceInput
  }

  export type ChallengeConstraintWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    challengeId?: string
    AND?: ChallengeConstraintWhereInput | ChallengeConstraintWhereInput[]
    OR?: ChallengeConstraintWhereInput[]
    NOT?: ChallengeConstraintWhereInput | ChallengeConstraintWhereInput[]
    allowedRegistrants?: StringNullableListFilter<"ChallengeConstraint">
    createdAt?: DateTimeFilter<"ChallengeConstraint"> | Date | string
    createdBy?: StringFilter<"ChallengeConstraint"> | string
    updatedAt?: DateTimeFilter<"ChallengeConstraint"> | Date | string
    updatedBy?: StringFilter<"ChallengeConstraint"> | string
    challenge?: XOR<ChallengeScalarRelationFilter, ChallengeWhereInput>
  }, "id" | "challengeId">

  export type ChallengeConstraintOrderByWithAggregationInput = {
    id?: SortOrder
    challengeId?: SortOrder
    allowedRegistrants?: SortOrder
    createdAt?: SortOrder
    createdBy?: SortOrder
    updatedAt?: SortOrder
    updatedBy?: SortOrder
    _count?: ChallengeConstraintCountOrderByAggregateInput
    _max?: ChallengeConstraintMaxOrderByAggregateInput
    _min?: ChallengeConstraintMinOrderByAggregateInput
  }

  export type ChallengeConstraintScalarWhereWithAggregatesInput = {
    AND?: ChallengeConstraintScalarWhereWithAggregatesInput | ChallengeConstraintScalarWhereWithAggregatesInput[]
    OR?: ChallengeConstraintScalarWhereWithAggregatesInput[]
    NOT?: ChallengeConstraintScalarWhereWithAggregatesInput | ChallengeConstraintScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"ChallengeConstraint"> | string
    challengeId?: StringWithAggregatesFilter<"ChallengeConstraint"> | string
    allowedRegistrants?: StringNullableListFilter<"ChallengeConstraint">
    createdAt?: DateTimeWithAggregatesFilter<"ChallengeConstraint"> | Date | string
    createdBy?: StringWithAggregatesFilter<"ChallengeConstraint"> | string
    updatedAt?: DateTimeWithAggregatesFilter<"ChallengeConstraint"> | Date | string
    updatedBy?: StringWithAggregatesFilter<"ChallengeConstraint"> | string
  }

  export type PhaseWhereInput = {
    AND?: PhaseWhereInput | PhaseWhereInput[]
    OR?: PhaseWhereInput[]
    NOT?: PhaseWhereInput | PhaseWhereInput[]
    id?: StringFilter<"Phase"> | string
    name?: StringFilter<"Phase"> | string
    description?: StringNullableFilter<"Phase"> | string | null
    isOpen?: BoolFilter<"Phase"> | boolean
    duration?: IntFilter<"Phase"> | number
    createdAt?: DateTimeFilter<"Phase"> | Date | string
    createdBy?: StringFilter<"Phase"> | string
    updatedAt?: DateTimeFilter<"Phase"> | Date | string
    updatedBy?: StringFilter<"Phase"> | string
    challengePhases?: ChallengePhaseListRelationFilter
    ChallengeReviewer?: ChallengeReviewerListRelationFilter
    DefaultChallengeReviewer?: DefaultChallengeReviewerListRelationFilter
  }

  export type PhaseOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrderInput | SortOrder
    isOpen?: SortOrder
    duration?: SortOrder
    createdAt?: SortOrder
    createdBy?: SortOrder
    updatedAt?: SortOrder
    updatedBy?: SortOrder
    challengePhases?: ChallengePhaseOrderByRelationAggregateInput
    ChallengeReviewer?: ChallengeReviewerOrderByRelationAggregateInput
    DefaultChallengeReviewer?: DefaultChallengeReviewerOrderByRelationAggregateInput
    _relevance?: PhaseOrderByRelevanceInput
  }

  export type PhaseWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    name?: string
    AND?: PhaseWhereInput | PhaseWhereInput[]
    OR?: PhaseWhereInput[]
    NOT?: PhaseWhereInput | PhaseWhereInput[]
    description?: StringNullableFilter<"Phase"> | string | null
    isOpen?: BoolFilter<"Phase"> | boolean
    duration?: IntFilter<"Phase"> | number
    createdAt?: DateTimeFilter<"Phase"> | Date | string
    createdBy?: StringFilter<"Phase"> | string
    updatedAt?: DateTimeFilter<"Phase"> | Date | string
    updatedBy?: StringFilter<"Phase"> | string
    challengePhases?: ChallengePhaseListRelationFilter
    ChallengeReviewer?: ChallengeReviewerListRelationFilter
    DefaultChallengeReviewer?: DefaultChallengeReviewerListRelationFilter
  }, "id" | "name">

  export type PhaseOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrderInput | SortOrder
    isOpen?: SortOrder
    duration?: SortOrder
    createdAt?: SortOrder
    createdBy?: SortOrder
    updatedAt?: SortOrder
    updatedBy?: SortOrder
    _count?: PhaseCountOrderByAggregateInput
    _avg?: PhaseAvgOrderByAggregateInput
    _max?: PhaseMaxOrderByAggregateInput
    _min?: PhaseMinOrderByAggregateInput
    _sum?: PhaseSumOrderByAggregateInput
  }

  export type PhaseScalarWhereWithAggregatesInput = {
    AND?: PhaseScalarWhereWithAggregatesInput | PhaseScalarWhereWithAggregatesInput[]
    OR?: PhaseScalarWhereWithAggregatesInput[]
    NOT?: PhaseScalarWhereWithAggregatesInput | PhaseScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Phase"> | string
    name?: StringWithAggregatesFilter<"Phase"> | string
    description?: StringNullableWithAggregatesFilter<"Phase"> | string | null
    isOpen?: BoolWithAggregatesFilter<"Phase"> | boolean
    duration?: IntWithAggregatesFilter<"Phase"> | number
    createdAt?: DateTimeWithAggregatesFilter<"Phase"> | Date | string
    createdBy?: StringWithAggregatesFilter<"Phase"> | string
    updatedAt?: DateTimeWithAggregatesFilter<"Phase"> | Date | string
    updatedBy?: StringWithAggregatesFilter<"Phase"> | string
  }

  export type ChallengePhaseWhereInput = {
    AND?: ChallengePhaseWhereInput | ChallengePhaseWhereInput[]
    OR?: ChallengePhaseWhereInput[]
    NOT?: ChallengePhaseWhereInput | ChallengePhaseWhereInput[]
    id?: StringFilter<"ChallengePhase"> | string
    challengeId?: StringFilter<"ChallengePhase"> | string
    phaseId?: StringFilter<"ChallengePhase"> | string
    name?: StringFilter<"ChallengePhase"> | string
    description?: StringNullableFilter<"ChallengePhase"> | string | null
    isOpen?: BoolNullableFilter<"ChallengePhase"> | boolean | null
    predecessor?: StringNullableFilter<"ChallengePhase"> | string | null
    duration?: IntNullableFilter<"ChallengePhase"> | number | null
    scheduledStartDate?: DateTimeNullableFilter<"ChallengePhase"> | Date | string | null
    scheduledEndDate?: DateTimeNullableFilter<"ChallengePhase"> | Date | string | null
    actualStartDate?: DateTimeNullableFilter<"ChallengePhase"> | Date | string | null
    actualEndDate?: DateTimeNullableFilter<"ChallengePhase"> | Date | string | null
    createdAt?: DateTimeFilter<"ChallengePhase"> | Date | string
    createdBy?: StringFilter<"ChallengePhase"> | string
    updatedAt?: DateTimeFilter<"ChallengePhase"> | Date | string
    updatedBy?: StringFilter<"ChallengePhase"> | string
    constraints?: ChallengePhaseConstraintListRelationFilter
    challenge?: XOR<ChallengeScalarRelationFilter, ChallengeWhereInput>
    phase?: XOR<PhaseScalarRelationFilter, PhaseWhereInput>
  }

  export type ChallengePhaseOrderByWithRelationInput = {
    id?: SortOrder
    challengeId?: SortOrder
    phaseId?: SortOrder
    name?: SortOrder
    description?: SortOrderInput | SortOrder
    isOpen?: SortOrderInput | SortOrder
    predecessor?: SortOrderInput | SortOrder
    duration?: SortOrderInput | SortOrder
    scheduledStartDate?: SortOrderInput | SortOrder
    scheduledEndDate?: SortOrderInput | SortOrder
    actualStartDate?: SortOrderInput | SortOrder
    actualEndDate?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    createdBy?: SortOrder
    updatedAt?: SortOrder
    updatedBy?: SortOrder
    constraints?: ChallengePhaseConstraintOrderByRelationAggregateInput
    challenge?: ChallengeOrderByWithRelationInput
    phase?: PhaseOrderByWithRelationInput
    _relevance?: ChallengePhaseOrderByRelevanceInput
  }

  export type ChallengePhaseWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: ChallengePhaseWhereInput | ChallengePhaseWhereInput[]
    OR?: ChallengePhaseWhereInput[]
    NOT?: ChallengePhaseWhereInput | ChallengePhaseWhereInput[]
    challengeId?: StringFilter<"ChallengePhase"> | string
    phaseId?: StringFilter<"ChallengePhase"> | string
    name?: StringFilter<"ChallengePhase"> | string
    description?: StringNullableFilter<"ChallengePhase"> | string | null
    isOpen?: BoolNullableFilter<"ChallengePhase"> | boolean | null
    predecessor?: StringNullableFilter<"ChallengePhase"> | string | null
    duration?: IntNullableFilter<"ChallengePhase"> | number | null
    scheduledStartDate?: DateTimeNullableFilter<"ChallengePhase"> | Date | string | null
    scheduledEndDate?: DateTimeNullableFilter<"ChallengePhase"> | Date | string | null
    actualStartDate?: DateTimeNullableFilter<"ChallengePhase"> | Date | string | null
    actualEndDate?: DateTimeNullableFilter<"ChallengePhase"> | Date | string | null
    createdAt?: DateTimeFilter<"ChallengePhase"> | Date | string
    createdBy?: StringFilter<"ChallengePhase"> | string
    updatedAt?: DateTimeFilter<"ChallengePhase"> | Date | string
    updatedBy?: StringFilter<"ChallengePhase"> | string
    constraints?: ChallengePhaseConstraintListRelationFilter
    challenge?: XOR<ChallengeScalarRelationFilter, ChallengeWhereInput>
    phase?: XOR<PhaseScalarRelationFilter, PhaseWhereInput>
  }, "id">

  export type ChallengePhaseOrderByWithAggregationInput = {
    id?: SortOrder
    challengeId?: SortOrder
    phaseId?: SortOrder
    name?: SortOrder
    description?: SortOrderInput | SortOrder
    isOpen?: SortOrderInput | SortOrder
    predecessor?: SortOrderInput | SortOrder
    duration?: SortOrderInput | SortOrder
    scheduledStartDate?: SortOrderInput | SortOrder
    scheduledEndDate?: SortOrderInput | SortOrder
    actualStartDate?: SortOrderInput | SortOrder
    actualEndDate?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    createdBy?: SortOrder
    updatedAt?: SortOrder
    updatedBy?: SortOrder
    _count?: ChallengePhaseCountOrderByAggregateInput
    _avg?: ChallengePhaseAvgOrderByAggregateInput
    _max?: ChallengePhaseMaxOrderByAggregateInput
    _min?: ChallengePhaseMinOrderByAggregateInput
    _sum?: ChallengePhaseSumOrderByAggregateInput
  }

  export type ChallengePhaseScalarWhereWithAggregatesInput = {
    AND?: ChallengePhaseScalarWhereWithAggregatesInput | ChallengePhaseScalarWhereWithAggregatesInput[]
    OR?: ChallengePhaseScalarWhereWithAggregatesInput[]
    NOT?: ChallengePhaseScalarWhereWithAggregatesInput | ChallengePhaseScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"ChallengePhase"> | string
    challengeId?: StringWithAggregatesFilter<"ChallengePhase"> | string
    phaseId?: StringWithAggregatesFilter<"ChallengePhase"> | string
    name?: StringWithAggregatesFilter<"ChallengePhase"> | string
    description?: StringNullableWithAggregatesFilter<"ChallengePhase"> | string | null
    isOpen?: BoolNullableWithAggregatesFilter<"ChallengePhase"> | boolean | null
    predecessor?: StringNullableWithAggregatesFilter<"ChallengePhase"> | string | null
    duration?: IntNullableWithAggregatesFilter<"ChallengePhase"> | number | null
    scheduledStartDate?: DateTimeNullableWithAggregatesFilter<"ChallengePhase"> | Date | string | null
    scheduledEndDate?: DateTimeNullableWithAggregatesFilter<"ChallengePhase"> | Date | string | null
    actualStartDate?: DateTimeNullableWithAggregatesFilter<"ChallengePhase"> | Date | string | null
    actualEndDate?: DateTimeNullableWithAggregatesFilter<"ChallengePhase"> | Date | string | null
    createdAt?: DateTimeWithAggregatesFilter<"ChallengePhase"> | Date | string
    createdBy?: StringWithAggregatesFilter<"ChallengePhase"> | string
    updatedAt?: DateTimeWithAggregatesFilter<"ChallengePhase"> | Date | string
    updatedBy?: StringWithAggregatesFilter<"ChallengePhase"> | string
  }

  export type ChallengePhaseConstraintWhereInput = {
    AND?: ChallengePhaseConstraintWhereInput | ChallengePhaseConstraintWhereInput[]
    OR?: ChallengePhaseConstraintWhereInput[]
    NOT?: ChallengePhaseConstraintWhereInput | ChallengePhaseConstraintWhereInput[]
    id?: StringFilter<"ChallengePhaseConstraint"> | string
    challengePhaseId?: StringFilter<"ChallengePhaseConstraint"> | string
    name?: StringFilter<"ChallengePhaseConstraint"> | string
    value?: IntFilter<"ChallengePhaseConstraint"> | number
    createdAt?: DateTimeFilter<"ChallengePhaseConstraint"> | Date | string
    createdBy?: StringFilter<"ChallengePhaseConstraint"> | string
    updatedAt?: DateTimeFilter<"ChallengePhaseConstraint"> | Date | string
    updatedBy?: StringFilter<"ChallengePhaseConstraint"> | string
    challengePhase?: XOR<ChallengePhaseScalarRelationFilter, ChallengePhaseWhereInput>
  }

  export type ChallengePhaseConstraintOrderByWithRelationInput = {
    id?: SortOrder
    challengePhaseId?: SortOrder
    name?: SortOrder
    value?: SortOrder
    createdAt?: SortOrder
    createdBy?: SortOrder
    updatedAt?: SortOrder
    updatedBy?: SortOrder
    challengePhase?: ChallengePhaseOrderByWithRelationInput
    _relevance?: ChallengePhaseConstraintOrderByRelevanceInput
  }

  export type ChallengePhaseConstraintWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: ChallengePhaseConstraintWhereInput | ChallengePhaseConstraintWhereInput[]
    OR?: ChallengePhaseConstraintWhereInput[]
    NOT?: ChallengePhaseConstraintWhereInput | ChallengePhaseConstraintWhereInput[]
    challengePhaseId?: StringFilter<"ChallengePhaseConstraint"> | string
    name?: StringFilter<"ChallengePhaseConstraint"> | string
    value?: IntFilter<"ChallengePhaseConstraint"> | number
    createdAt?: DateTimeFilter<"ChallengePhaseConstraint"> | Date | string
    createdBy?: StringFilter<"ChallengePhaseConstraint"> | string
    updatedAt?: DateTimeFilter<"ChallengePhaseConstraint"> | Date | string
    updatedBy?: StringFilter<"ChallengePhaseConstraint"> | string
    challengePhase?: XOR<ChallengePhaseScalarRelationFilter, ChallengePhaseWhereInput>
  }, "id">

  export type ChallengePhaseConstraintOrderByWithAggregationInput = {
    id?: SortOrder
    challengePhaseId?: SortOrder
    name?: SortOrder
    value?: SortOrder
    createdAt?: SortOrder
    createdBy?: SortOrder
    updatedAt?: SortOrder
    updatedBy?: SortOrder
    _count?: ChallengePhaseConstraintCountOrderByAggregateInput
    _avg?: ChallengePhaseConstraintAvgOrderByAggregateInput
    _max?: ChallengePhaseConstraintMaxOrderByAggregateInput
    _min?: ChallengePhaseConstraintMinOrderByAggregateInput
    _sum?: ChallengePhaseConstraintSumOrderByAggregateInput
  }

  export type ChallengePhaseConstraintScalarWhereWithAggregatesInput = {
    AND?: ChallengePhaseConstraintScalarWhereWithAggregatesInput | ChallengePhaseConstraintScalarWhereWithAggregatesInput[]
    OR?: ChallengePhaseConstraintScalarWhereWithAggregatesInput[]
    NOT?: ChallengePhaseConstraintScalarWhereWithAggregatesInput | ChallengePhaseConstraintScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"ChallengePhaseConstraint"> | string
    challengePhaseId?: StringWithAggregatesFilter<"ChallengePhaseConstraint"> | string
    name?: StringWithAggregatesFilter<"ChallengePhaseConstraint"> | string
    value?: IntWithAggregatesFilter<"ChallengePhaseConstraint"> | number
    createdAt?: DateTimeWithAggregatesFilter<"ChallengePhaseConstraint"> | Date | string
    createdBy?: StringWithAggregatesFilter<"ChallengePhaseConstraint"> | string
    updatedAt?: DateTimeWithAggregatesFilter<"ChallengePhaseConstraint"> | Date | string
    updatedBy?: StringWithAggregatesFilter<"ChallengePhaseConstraint"> | string
  }

  export type ChallengePrizeSetWhereInput = {
    AND?: ChallengePrizeSetWhereInput | ChallengePrizeSetWhereInput[]
    OR?: ChallengePrizeSetWhereInput[]
    NOT?: ChallengePrizeSetWhereInput | ChallengePrizeSetWhereInput[]
    id?: StringFilter<"ChallengePrizeSet"> | string
    challengeId?: StringFilter<"ChallengePrizeSet"> | string
    type?: EnumPrizeSetTypeEnumFilter<"ChallengePrizeSet"> | $Enums.PrizeSetTypeEnum
    description?: StringNullableFilter<"ChallengePrizeSet"> | string | null
    createdAt?: DateTimeFilter<"ChallengePrizeSet"> | Date | string
    createdBy?: StringFilter<"ChallengePrizeSet"> | string
    updatedAt?: DateTimeFilter<"ChallengePrizeSet"> | Date | string
    updatedBy?: StringFilter<"ChallengePrizeSet"> | string
    prizes?: PrizeListRelationFilter
    challenge?: XOR<ChallengeScalarRelationFilter, ChallengeWhereInput>
  }

  export type ChallengePrizeSetOrderByWithRelationInput = {
    id?: SortOrder
    challengeId?: SortOrder
    type?: SortOrder
    description?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    createdBy?: SortOrder
    updatedAt?: SortOrder
    updatedBy?: SortOrder
    prizes?: PrizeOrderByRelationAggregateInput
    challenge?: ChallengeOrderByWithRelationInput
    _relevance?: ChallengePrizeSetOrderByRelevanceInput
  }

  export type ChallengePrizeSetWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: ChallengePrizeSetWhereInput | ChallengePrizeSetWhereInput[]
    OR?: ChallengePrizeSetWhereInput[]
    NOT?: ChallengePrizeSetWhereInput | ChallengePrizeSetWhereInput[]
    challengeId?: StringFilter<"ChallengePrizeSet"> | string
    type?: EnumPrizeSetTypeEnumFilter<"ChallengePrizeSet"> | $Enums.PrizeSetTypeEnum
    description?: StringNullableFilter<"ChallengePrizeSet"> | string | null
    createdAt?: DateTimeFilter<"ChallengePrizeSet"> | Date | string
    createdBy?: StringFilter<"ChallengePrizeSet"> | string
    updatedAt?: DateTimeFilter<"ChallengePrizeSet"> | Date | string
    updatedBy?: StringFilter<"ChallengePrizeSet"> | string
    prizes?: PrizeListRelationFilter
    challenge?: XOR<ChallengeScalarRelationFilter, ChallengeWhereInput>
  }, "id">

  export type ChallengePrizeSetOrderByWithAggregationInput = {
    id?: SortOrder
    challengeId?: SortOrder
    type?: SortOrder
    description?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    createdBy?: SortOrder
    updatedAt?: SortOrder
    updatedBy?: SortOrder
    _count?: ChallengePrizeSetCountOrderByAggregateInput
    _max?: ChallengePrizeSetMaxOrderByAggregateInput
    _min?: ChallengePrizeSetMinOrderByAggregateInput
  }

  export type ChallengePrizeSetScalarWhereWithAggregatesInput = {
    AND?: ChallengePrizeSetScalarWhereWithAggregatesInput | ChallengePrizeSetScalarWhereWithAggregatesInput[]
    OR?: ChallengePrizeSetScalarWhereWithAggregatesInput[]
    NOT?: ChallengePrizeSetScalarWhereWithAggregatesInput | ChallengePrizeSetScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"ChallengePrizeSet"> | string
    challengeId?: StringWithAggregatesFilter<"ChallengePrizeSet"> | string
    type?: EnumPrizeSetTypeEnumWithAggregatesFilter<"ChallengePrizeSet"> | $Enums.PrizeSetTypeEnum
    description?: StringNullableWithAggregatesFilter<"ChallengePrizeSet"> | string | null
    createdAt?: DateTimeWithAggregatesFilter<"ChallengePrizeSet"> | Date | string
    createdBy?: StringWithAggregatesFilter<"ChallengePrizeSet"> | string
    updatedAt?: DateTimeWithAggregatesFilter<"ChallengePrizeSet"> | Date | string
    updatedBy?: StringWithAggregatesFilter<"ChallengePrizeSet"> | string
  }

  export type ChallengeReviewerWhereInput = {
    AND?: ChallengeReviewerWhereInput | ChallengeReviewerWhereInput[]
    OR?: ChallengeReviewerWhereInput[]
    NOT?: ChallengeReviewerWhereInput | ChallengeReviewerWhereInput[]
    id?: StringFilter<"ChallengeReviewer"> | string
    challengeId?: StringFilter<"ChallengeReviewer"> | string
    scorecardId?: StringFilter<"ChallengeReviewer"> | string
    isMemberReview?: BoolFilter<"ChallengeReviewer"> | boolean
    memberReviewerCount?: IntNullableFilter<"ChallengeReviewer"> | number | null
    phaseId?: StringFilter<"ChallengeReviewer"> | string
    fixedAmount?: FloatNullableFilter<"ChallengeReviewer"> | number | null
    baseCoefficient?: FloatNullableFilter<"ChallengeReviewer"> | number | null
    incrementalCoefficient?: FloatNullableFilter<"ChallengeReviewer"> | number | null
    type?: EnumReviewOpportunityTypeEnumNullableFilter<"ChallengeReviewer"> | $Enums.ReviewOpportunityTypeEnum | null
    aiWorkflowId?: StringNullableFilter<"ChallengeReviewer"> | string | null
    shouldOpenOpportunity?: BoolFilter<"ChallengeReviewer"> | boolean
    createdAt?: DateTimeFilter<"ChallengeReviewer"> | Date | string
    createdBy?: StringFilter<"ChallengeReviewer"> | string
    updatedAt?: DateTimeFilter<"ChallengeReviewer"> | Date | string
    updatedBy?: StringFilter<"ChallengeReviewer"> | string
    challenge?: XOR<ChallengeScalarRelationFilter, ChallengeWhereInput>
    phase?: XOR<PhaseScalarRelationFilter, PhaseWhereInput>
  }

  export type ChallengeReviewerOrderByWithRelationInput = {
    id?: SortOrder
    challengeId?: SortOrder
    scorecardId?: SortOrder
    isMemberReview?: SortOrder
    memberReviewerCount?: SortOrderInput | SortOrder
    phaseId?: SortOrder
    fixedAmount?: SortOrderInput | SortOrder
    baseCoefficient?: SortOrderInput | SortOrder
    incrementalCoefficient?: SortOrderInput | SortOrder
    type?: SortOrderInput | SortOrder
    aiWorkflowId?: SortOrderInput | SortOrder
    shouldOpenOpportunity?: SortOrder
    createdAt?: SortOrder
    createdBy?: SortOrder
    updatedAt?: SortOrder
    updatedBy?: SortOrder
    challenge?: ChallengeOrderByWithRelationInput
    phase?: PhaseOrderByWithRelationInput
    _relevance?: ChallengeReviewerOrderByRelevanceInput
  }

  export type ChallengeReviewerWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: ChallengeReviewerWhereInput | ChallengeReviewerWhereInput[]
    OR?: ChallengeReviewerWhereInput[]
    NOT?: ChallengeReviewerWhereInput | ChallengeReviewerWhereInput[]
    challengeId?: StringFilter<"ChallengeReviewer"> | string
    scorecardId?: StringFilter<"ChallengeReviewer"> | string
    isMemberReview?: BoolFilter<"ChallengeReviewer"> | boolean
    memberReviewerCount?: IntNullableFilter<"ChallengeReviewer"> | number | null
    phaseId?: StringFilter<"ChallengeReviewer"> | string
    fixedAmount?: FloatNullableFilter<"ChallengeReviewer"> | number | null
    baseCoefficient?: FloatNullableFilter<"ChallengeReviewer"> | number | null
    incrementalCoefficient?: FloatNullableFilter<"ChallengeReviewer"> | number | null
    type?: EnumReviewOpportunityTypeEnumNullableFilter<"ChallengeReviewer"> | $Enums.ReviewOpportunityTypeEnum | null
    aiWorkflowId?: StringNullableFilter<"ChallengeReviewer"> | string | null
    shouldOpenOpportunity?: BoolFilter<"ChallengeReviewer"> | boolean
    createdAt?: DateTimeFilter<"ChallengeReviewer"> | Date | string
    createdBy?: StringFilter<"ChallengeReviewer"> | string
    updatedAt?: DateTimeFilter<"ChallengeReviewer"> | Date | string
    updatedBy?: StringFilter<"ChallengeReviewer"> | string
    challenge?: XOR<ChallengeScalarRelationFilter, ChallengeWhereInput>
    phase?: XOR<PhaseScalarRelationFilter, PhaseWhereInput>
  }, "id">

  export type ChallengeReviewerOrderByWithAggregationInput = {
    id?: SortOrder
    challengeId?: SortOrder
    scorecardId?: SortOrder
    isMemberReview?: SortOrder
    memberReviewerCount?: SortOrderInput | SortOrder
    phaseId?: SortOrder
    fixedAmount?: SortOrderInput | SortOrder
    baseCoefficient?: SortOrderInput | SortOrder
    incrementalCoefficient?: SortOrderInput | SortOrder
    type?: SortOrderInput | SortOrder
    aiWorkflowId?: SortOrderInput | SortOrder
    shouldOpenOpportunity?: SortOrder
    createdAt?: SortOrder
    createdBy?: SortOrder
    updatedAt?: SortOrder
    updatedBy?: SortOrder
    _count?: ChallengeReviewerCountOrderByAggregateInput
    _avg?: ChallengeReviewerAvgOrderByAggregateInput
    _max?: ChallengeReviewerMaxOrderByAggregateInput
    _min?: ChallengeReviewerMinOrderByAggregateInput
    _sum?: ChallengeReviewerSumOrderByAggregateInput
  }

  export type ChallengeReviewerScalarWhereWithAggregatesInput = {
    AND?: ChallengeReviewerScalarWhereWithAggregatesInput | ChallengeReviewerScalarWhereWithAggregatesInput[]
    OR?: ChallengeReviewerScalarWhereWithAggregatesInput[]
    NOT?: ChallengeReviewerScalarWhereWithAggregatesInput | ChallengeReviewerScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"ChallengeReviewer"> | string
    challengeId?: StringWithAggregatesFilter<"ChallengeReviewer"> | string
    scorecardId?: StringWithAggregatesFilter<"ChallengeReviewer"> | string
    isMemberReview?: BoolWithAggregatesFilter<"ChallengeReviewer"> | boolean
    memberReviewerCount?: IntNullableWithAggregatesFilter<"ChallengeReviewer"> | number | null
    phaseId?: StringWithAggregatesFilter<"ChallengeReviewer"> | string
    fixedAmount?: FloatNullableWithAggregatesFilter<"ChallengeReviewer"> | number | null
    baseCoefficient?: FloatNullableWithAggregatesFilter<"ChallengeReviewer"> | number | null
    incrementalCoefficient?: FloatNullableWithAggregatesFilter<"ChallengeReviewer"> | number | null
    type?: EnumReviewOpportunityTypeEnumNullableWithAggregatesFilter<"ChallengeReviewer"> | $Enums.ReviewOpportunityTypeEnum | null
    aiWorkflowId?: StringNullableWithAggregatesFilter<"ChallengeReviewer"> | string | null
    shouldOpenOpportunity?: BoolWithAggregatesFilter<"ChallengeReviewer"> | boolean
    createdAt?: DateTimeWithAggregatesFilter<"ChallengeReviewer"> | Date | string
    createdBy?: StringWithAggregatesFilter<"ChallengeReviewer"> | string
    updatedAt?: DateTimeWithAggregatesFilter<"ChallengeReviewer"> | Date | string
    updatedBy?: StringWithAggregatesFilter<"ChallengeReviewer"> | string
  }

  export type DefaultChallengeReviewerWhereInput = {
    AND?: DefaultChallengeReviewerWhereInput | DefaultChallengeReviewerWhereInput[]
    OR?: DefaultChallengeReviewerWhereInput[]
    NOT?: DefaultChallengeReviewerWhereInput | DefaultChallengeReviewerWhereInput[]
    id?: StringFilter<"DefaultChallengeReviewer"> | string
    typeId?: StringFilter<"DefaultChallengeReviewer"> | string
    trackId?: StringFilter<"DefaultChallengeReviewer"> | string
    timelineTemplateId?: StringNullableFilter<"DefaultChallengeReviewer"> | string | null
    scorecardId?: StringNullableFilter<"DefaultChallengeReviewer"> | string | null
    isMemberReview?: BoolFilter<"DefaultChallengeReviewer"> | boolean
    memberReviewerCount?: IntNullableFilter<"DefaultChallengeReviewer"> | number | null
    phaseName?: StringFilter<"DefaultChallengeReviewer"> | string
    phaseId?: StringNullableFilter<"DefaultChallengeReviewer"> | string | null
    fixedAmount?: FloatNullableFilter<"DefaultChallengeReviewer"> | number | null
    baseCoefficient?: FloatNullableFilter<"DefaultChallengeReviewer"> | number | null
    incrementalCoefficient?: FloatNullableFilter<"DefaultChallengeReviewer"> | number | null
    opportunityType?: EnumReviewOpportunityTypeEnumNullableFilter<"DefaultChallengeReviewer"> | $Enums.ReviewOpportunityTypeEnum | null
    aiWorkflowId?: StringNullableFilter<"DefaultChallengeReviewer"> | string | null
    shouldOpenOpportunity?: BoolFilter<"DefaultChallengeReviewer"> | boolean
    createdAt?: DateTimeFilter<"DefaultChallengeReviewer"> | Date | string
    createdBy?: StringFilter<"DefaultChallengeReviewer"> | string
    updatedAt?: DateTimeFilter<"DefaultChallengeReviewer"> | Date | string
    updatedBy?: StringFilter<"DefaultChallengeReviewer"> | string
    challengeType?: XOR<ChallengeTypeScalarRelationFilter, ChallengeTypeWhereInput>
    challengeTrack?: XOR<ChallengeTrackScalarRelationFilter, ChallengeTrackWhereInput>
    timelineTemplate?: XOR<TimelineTemplateNullableScalarRelationFilter, TimelineTemplateWhereInput> | null
    phase?: XOR<PhaseNullableScalarRelationFilter, PhaseWhereInput> | null
  }

  export type DefaultChallengeReviewerOrderByWithRelationInput = {
    id?: SortOrder
    typeId?: SortOrder
    trackId?: SortOrder
    timelineTemplateId?: SortOrderInput | SortOrder
    scorecardId?: SortOrderInput | SortOrder
    isMemberReview?: SortOrder
    memberReviewerCount?: SortOrderInput | SortOrder
    phaseName?: SortOrder
    phaseId?: SortOrderInput | SortOrder
    fixedAmount?: SortOrderInput | SortOrder
    baseCoefficient?: SortOrderInput | SortOrder
    incrementalCoefficient?: SortOrderInput | SortOrder
    opportunityType?: SortOrderInput | SortOrder
    aiWorkflowId?: SortOrderInput | SortOrder
    shouldOpenOpportunity?: SortOrder
    createdAt?: SortOrder
    createdBy?: SortOrder
    updatedAt?: SortOrder
    updatedBy?: SortOrder
    challengeType?: ChallengeTypeOrderByWithRelationInput
    challengeTrack?: ChallengeTrackOrderByWithRelationInput
    timelineTemplate?: TimelineTemplateOrderByWithRelationInput
    phase?: PhaseOrderByWithRelationInput
    _relevance?: DefaultChallengeReviewerOrderByRelevanceInput
  }

  export type DefaultChallengeReviewerWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: DefaultChallengeReviewerWhereInput | DefaultChallengeReviewerWhereInput[]
    OR?: DefaultChallengeReviewerWhereInput[]
    NOT?: DefaultChallengeReviewerWhereInput | DefaultChallengeReviewerWhereInput[]
    typeId?: StringFilter<"DefaultChallengeReviewer"> | string
    trackId?: StringFilter<"DefaultChallengeReviewer"> | string
    timelineTemplateId?: StringNullableFilter<"DefaultChallengeReviewer"> | string | null
    scorecardId?: StringNullableFilter<"DefaultChallengeReviewer"> | string | null
    isMemberReview?: BoolFilter<"DefaultChallengeReviewer"> | boolean
    memberReviewerCount?: IntNullableFilter<"DefaultChallengeReviewer"> | number | null
    phaseName?: StringFilter<"DefaultChallengeReviewer"> | string
    phaseId?: StringNullableFilter<"DefaultChallengeReviewer"> | string | null
    fixedAmount?: FloatNullableFilter<"DefaultChallengeReviewer"> | number | null
    baseCoefficient?: FloatNullableFilter<"DefaultChallengeReviewer"> | number | null
    incrementalCoefficient?: FloatNullableFilter<"DefaultChallengeReviewer"> | number | null
    opportunityType?: EnumReviewOpportunityTypeEnumNullableFilter<"DefaultChallengeReviewer"> | $Enums.ReviewOpportunityTypeEnum | null
    aiWorkflowId?: StringNullableFilter<"DefaultChallengeReviewer"> | string | null
    shouldOpenOpportunity?: BoolFilter<"DefaultChallengeReviewer"> | boolean
    createdAt?: DateTimeFilter<"DefaultChallengeReviewer"> | Date | string
    createdBy?: StringFilter<"DefaultChallengeReviewer"> | string
    updatedAt?: DateTimeFilter<"DefaultChallengeReviewer"> | Date | string
    updatedBy?: StringFilter<"DefaultChallengeReviewer"> | string
    challengeType?: XOR<ChallengeTypeScalarRelationFilter, ChallengeTypeWhereInput>
    challengeTrack?: XOR<ChallengeTrackScalarRelationFilter, ChallengeTrackWhereInput>
    timelineTemplate?: XOR<TimelineTemplateNullableScalarRelationFilter, TimelineTemplateWhereInput> | null
    phase?: XOR<PhaseNullableScalarRelationFilter, PhaseWhereInput> | null
  }, "id">

  export type DefaultChallengeReviewerOrderByWithAggregationInput = {
    id?: SortOrder
    typeId?: SortOrder
    trackId?: SortOrder
    timelineTemplateId?: SortOrderInput | SortOrder
    scorecardId?: SortOrderInput | SortOrder
    isMemberReview?: SortOrder
    memberReviewerCount?: SortOrderInput | SortOrder
    phaseName?: SortOrder
    phaseId?: SortOrderInput | SortOrder
    fixedAmount?: SortOrderInput | SortOrder
    baseCoefficient?: SortOrderInput | SortOrder
    incrementalCoefficient?: SortOrderInput | SortOrder
    opportunityType?: SortOrderInput | SortOrder
    aiWorkflowId?: SortOrderInput | SortOrder
    shouldOpenOpportunity?: SortOrder
    createdAt?: SortOrder
    createdBy?: SortOrder
    updatedAt?: SortOrder
    updatedBy?: SortOrder
    _count?: DefaultChallengeReviewerCountOrderByAggregateInput
    _avg?: DefaultChallengeReviewerAvgOrderByAggregateInput
    _max?: DefaultChallengeReviewerMaxOrderByAggregateInput
    _min?: DefaultChallengeReviewerMinOrderByAggregateInput
    _sum?: DefaultChallengeReviewerSumOrderByAggregateInput
  }

  export type DefaultChallengeReviewerScalarWhereWithAggregatesInput = {
    AND?: DefaultChallengeReviewerScalarWhereWithAggregatesInput | DefaultChallengeReviewerScalarWhereWithAggregatesInput[]
    OR?: DefaultChallengeReviewerScalarWhereWithAggregatesInput[]
    NOT?: DefaultChallengeReviewerScalarWhereWithAggregatesInput | DefaultChallengeReviewerScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"DefaultChallengeReviewer"> | string
    typeId?: StringWithAggregatesFilter<"DefaultChallengeReviewer"> | string
    trackId?: StringWithAggregatesFilter<"DefaultChallengeReviewer"> | string
    timelineTemplateId?: StringNullableWithAggregatesFilter<"DefaultChallengeReviewer"> | string | null
    scorecardId?: StringNullableWithAggregatesFilter<"DefaultChallengeReviewer"> | string | null
    isMemberReview?: BoolWithAggregatesFilter<"DefaultChallengeReviewer"> | boolean
    memberReviewerCount?: IntNullableWithAggregatesFilter<"DefaultChallengeReviewer"> | number | null
    phaseName?: StringWithAggregatesFilter<"DefaultChallengeReviewer"> | string
    phaseId?: StringNullableWithAggregatesFilter<"DefaultChallengeReviewer"> | string | null
    fixedAmount?: FloatNullableWithAggregatesFilter<"DefaultChallengeReviewer"> | number | null
    baseCoefficient?: FloatNullableWithAggregatesFilter<"DefaultChallengeReviewer"> | number | null
    incrementalCoefficient?: FloatNullableWithAggregatesFilter<"DefaultChallengeReviewer"> | number | null
    opportunityType?: EnumReviewOpportunityTypeEnumNullableWithAggregatesFilter<"DefaultChallengeReviewer"> | $Enums.ReviewOpportunityTypeEnum | null
    aiWorkflowId?: StringNullableWithAggregatesFilter<"DefaultChallengeReviewer"> | string | null
    shouldOpenOpportunity?: BoolWithAggregatesFilter<"DefaultChallengeReviewer"> | boolean
    createdAt?: DateTimeWithAggregatesFilter<"DefaultChallengeReviewer"> | Date | string
    createdBy?: StringWithAggregatesFilter<"DefaultChallengeReviewer"> | string
    updatedAt?: DateTimeWithAggregatesFilter<"DefaultChallengeReviewer"> | Date | string
    updatedBy?: StringWithAggregatesFilter<"DefaultChallengeReviewer"> | string
  }

  export type TimelineTemplateWhereInput = {
    AND?: TimelineTemplateWhereInput | TimelineTemplateWhereInput[]
    OR?: TimelineTemplateWhereInput[]
    NOT?: TimelineTemplateWhereInput | TimelineTemplateWhereInput[]
    id?: StringFilter<"TimelineTemplate"> | string
    name?: StringFilter<"TimelineTemplate"> | string
    description?: StringNullableFilter<"TimelineTemplate"> | string | null
    isActive?: BoolFilter<"TimelineTemplate"> | boolean
    createdAt?: DateTimeFilter<"TimelineTemplate"> | Date | string
    createdBy?: StringFilter<"TimelineTemplate"> | string
    updatedAt?: DateTimeFilter<"TimelineTemplate"> | Date | string
    updatedBy?: StringFilter<"TimelineTemplate"> | string
    phases?: TimelineTemplatePhaseListRelationFilter
    challengeTimelineTemplates?: ChallengeTimelineTemplateListRelationFilter
    challenges?: ChallengeListRelationFilter
    DefaultChallengeReviewer?: DefaultChallengeReviewerListRelationFilter
  }

  export type TimelineTemplateOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrderInput | SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    createdBy?: SortOrder
    updatedAt?: SortOrder
    updatedBy?: SortOrder
    phases?: TimelineTemplatePhaseOrderByRelationAggregateInput
    challengeTimelineTemplates?: ChallengeTimelineTemplateOrderByRelationAggregateInput
    challenges?: ChallengeOrderByRelationAggregateInput
    DefaultChallengeReviewer?: DefaultChallengeReviewerOrderByRelationAggregateInput
    _relevance?: TimelineTemplateOrderByRelevanceInput
  }

  export type TimelineTemplateWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    name?: string
    AND?: TimelineTemplateWhereInput | TimelineTemplateWhereInput[]
    OR?: TimelineTemplateWhereInput[]
    NOT?: TimelineTemplateWhereInput | TimelineTemplateWhereInput[]
    description?: StringNullableFilter<"TimelineTemplate"> | string | null
    isActive?: BoolFilter<"TimelineTemplate"> | boolean
    createdAt?: DateTimeFilter<"TimelineTemplate"> | Date | string
    createdBy?: StringFilter<"TimelineTemplate"> | string
    updatedAt?: DateTimeFilter<"TimelineTemplate"> | Date | string
    updatedBy?: StringFilter<"TimelineTemplate"> | string
    phases?: TimelineTemplatePhaseListRelationFilter
    challengeTimelineTemplates?: ChallengeTimelineTemplateListRelationFilter
    challenges?: ChallengeListRelationFilter
    DefaultChallengeReviewer?: DefaultChallengeReviewerListRelationFilter
  }, "id" | "name">

  export type TimelineTemplateOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrderInput | SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    createdBy?: SortOrder
    updatedAt?: SortOrder
    updatedBy?: SortOrder
    _count?: TimelineTemplateCountOrderByAggregateInput
    _max?: TimelineTemplateMaxOrderByAggregateInput
    _min?: TimelineTemplateMinOrderByAggregateInput
  }

  export type TimelineTemplateScalarWhereWithAggregatesInput = {
    AND?: TimelineTemplateScalarWhereWithAggregatesInput | TimelineTemplateScalarWhereWithAggregatesInput[]
    OR?: TimelineTemplateScalarWhereWithAggregatesInput[]
    NOT?: TimelineTemplateScalarWhereWithAggregatesInput | TimelineTemplateScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"TimelineTemplate"> | string
    name?: StringWithAggregatesFilter<"TimelineTemplate"> | string
    description?: StringNullableWithAggregatesFilter<"TimelineTemplate"> | string | null
    isActive?: BoolWithAggregatesFilter<"TimelineTemplate"> | boolean
    createdAt?: DateTimeWithAggregatesFilter<"TimelineTemplate"> | Date | string
    createdBy?: StringWithAggregatesFilter<"TimelineTemplate"> | string
    updatedAt?: DateTimeWithAggregatesFilter<"TimelineTemplate"> | Date | string
    updatedBy?: StringWithAggregatesFilter<"TimelineTemplate"> | string
  }

  export type TimelineTemplatePhaseWhereInput = {
    AND?: TimelineTemplatePhaseWhereInput | TimelineTemplatePhaseWhereInput[]
    OR?: TimelineTemplatePhaseWhereInput[]
    NOT?: TimelineTemplatePhaseWhereInput | TimelineTemplatePhaseWhereInput[]
    id?: StringFilter<"TimelineTemplatePhase"> | string
    timelineTemplateId?: StringFilter<"TimelineTemplatePhase"> | string
    phaseId?: StringFilter<"TimelineTemplatePhase"> | string
    predecessor?: StringNullableFilter<"TimelineTemplatePhase"> | string | null
    defaultDuration?: IntFilter<"TimelineTemplatePhase"> | number
    createdAt?: DateTimeFilter<"TimelineTemplatePhase"> | Date | string
    createdBy?: StringFilter<"TimelineTemplatePhase"> | string
    updatedAt?: DateTimeFilter<"TimelineTemplatePhase"> | Date | string
    updatedBy?: StringFilter<"TimelineTemplatePhase"> | string
    timelineTemplate?: XOR<TimelineTemplateScalarRelationFilter, TimelineTemplateWhereInput>
  }

  export type TimelineTemplatePhaseOrderByWithRelationInput = {
    id?: SortOrder
    timelineTemplateId?: SortOrder
    phaseId?: SortOrder
    predecessor?: SortOrderInput | SortOrder
    defaultDuration?: SortOrder
    createdAt?: SortOrder
    createdBy?: SortOrder
    updatedAt?: SortOrder
    updatedBy?: SortOrder
    timelineTemplate?: TimelineTemplateOrderByWithRelationInput
    _relevance?: TimelineTemplatePhaseOrderByRelevanceInput
  }

  export type TimelineTemplatePhaseWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: TimelineTemplatePhaseWhereInput | TimelineTemplatePhaseWhereInput[]
    OR?: TimelineTemplatePhaseWhereInput[]
    NOT?: TimelineTemplatePhaseWhereInput | TimelineTemplatePhaseWhereInput[]
    timelineTemplateId?: StringFilter<"TimelineTemplatePhase"> | string
    phaseId?: StringFilter<"TimelineTemplatePhase"> | string
    predecessor?: StringNullableFilter<"TimelineTemplatePhase"> | string | null
    defaultDuration?: IntFilter<"TimelineTemplatePhase"> | number
    createdAt?: DateTimeFilter<"TimelineTemplatePhase"> | Date | string
    createdBy?: StringFilter<"TimelineTemplatePhase"> | string
    updatedAt?: DateTimeFilter<"TimelineTemplatePhase"> | Date | string
    updatedBy?: StringFilter<"TimelineTemplatePhase"> | string
    timelineTemplate?: XOR<TimelineTemplateScalarRelationFilter, TimelineTemplateWhereInput>
  }, "id">

  export type TimelineTemplatePhaseOrderByWithAggregationInput = {
    id?: SortOrder
    timelineTemplateId?: SortOrder
    phaseId?: SortOrder
    predecessor?: SortOrderInput | SortOrder
    defaultDuration?: SortOrder
    createdAt?: SortOrder
    createdBy?: SortOrder
    updatedAt?: SortOrder
    updatedBy?: SortOrder
    _count?: TimelineTemplatePhaseCountOrderByAggregateInput
    _avg?: TimelineTemplatePhaseAvgOrderByAggregateInput
    _max?: TimelineTemplatePhaseMaxOrderByAggregateInput
    _min?: TimelineTemplatePhaseMinOrderByAggregateInput
    _sum?: TimelineTemplatePhaseSumOrderByAggregateInput
  }

  export type TimelineTemplatePhaseScalarWhereWithAggregatesInput = {
    AND?: TimelineTemplatePhaseScalarWhereWithAggregatesInput | TimelineTemplatePhaseScalarWhereWithAggregatesInput[]
    OR?: TimelineTemplatePhaseScalarWhereWithAggregatesInput[]
    NOT?: TimelineTemplatePhaseScalarWhereWithAggregatesInput | TimelineTemplatePhaseScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"TimelineTemplatePhase"> | string
    timelineTemplateId?: StringWithAggregatesFilter<"TimelineTemplatePhase"> | string
    phaseId?: StringWithAggregatesFilter<"TimelineTemplatePhase"> | string
    predecessor?: StringNullableWithAggregatesFilter<"TimelineTemplatePhase"> | string | null
    defaultDuration?: IntWithAggregatesFilter<"TimelineTemplatePhase"> | number
    createdAt?: DateTimeWithAggregatesFilter<"TimelineTemplatePhase"> | Date | string
    createdBy?: StringWithAggregatesFilter<"TimelineTemplatePhase"> | string
    updatedAt?: DateTimeWithAggregatesFilter<"TimelineTemplatePhase"> | Date | string
    updatedBy?: StringWithAggregatesFilter<"TimelineTemplatePhase"> | string
  }

  export type MemberChallengeAccessWhereInput = {
    AND?: MemberChallengeAccessWhereInput | MemberChallengeAccessWhereInput[]
    OR?: MemberChallengeAccessWhereInput[]
    NOT?: MemberChallengeAccessWhereInput | MemberChallengeAccessWhereInput[]
    challengeId?: StringFilter<"MemberChallengeAccess"> | string
    memberId?: StringFilter<"MemberChallengeAccess"> | string
    challenge?: XOR<ChallengeScalarRelationFilter, ChallengeWhereInput>
  }

  export type MemberChallengeAccessOrderByWithRelationInput = {
    challengeId?: SortOrder
    memberId?: SortOrder
    challenge?: ChallengeOrderByWithRelationInput
    _relevance?: MemberChallengeAccessOrderByRelevanceInput
  }

  export type MemberChallengeAccessOrderByWithAggregationInput = {
    challengeId?: SortOrder
    memberId?: SortOrder
    _count?: MemberChallengeAccessCountOrderByAggregateInput
    _max?: MemberChallengeAccessMaxOrderByAggregateInput
    _min?: MemberChallengeAccessMinOrderByAggregateInput
  }

  export type MemberChallengeAccessScalarWhereWithAggregatesInput = {
    AND?: MemberChallengeAccessScalarWhereWithAggregatesInput | MemberChallengeAccessScalarWhereWithAggregatesInput[]
    OR?: MemberChallengeAccessScalarWhereWithAggregatesInput[]
    NOT?: MemberChallengeAccessScalarWhereWithAggregatesInput | MemberChallengeAccessScalarWhereWithAggregatesInput[]
    challengeId?: StringWithAggregatesFilter<"MemberChallengeAccess"> | string
    memberId?: StringWithAggregatesFilter<"MemberChallengeAccess"> | string
  }

  export type ChallengeCreateInput = {
    id?: string
    name: string
    description?: string | null
    privateDescription?: string | null
    challengeSource?: string | null
    descriptionFormat?: string | null
    projectId?: number | null
    overviewTotalPrizes?: number | null
    numOfRegistrants?: number
    numOfSubmissions?: number
    numOfCheckpointSubmissions?: number
    currentPhaseNames?: ChallengeCreatecurrentPhaseNamesInput | string[]
    wiproAllowed?: boolean
    tags?: ChallengeCreatetagsInput | string[]
    groups?: ChallengeCreategroupsInput | string[]
    taskIsTask?: boolean
    taskIsAssigned?: boolean
    taskMemberId?: string | null
    submissionStartDate?: Date | string | null
    submissionEndDate?: Date | string | null
    registrationStartDate?: Date | string | null
    registrationEndDate?: Date | string | null
    startDate?: Date | string | null
    endDate?: Date | string | null
    legacyId?: number | null
    status?: $Enums.ChallengeStatusEnum
    createdAt?: Date | string
    createdBy: string
    updatedAt?: Date | string
    updatedBy: string
    billingRecord?: ChallengeBillingCreateNestedOneWithoutChallengeInput
    legacyRecord?: ChallengeLegacyCreateNestedOneWithoutChallengeInput
    constraintRecord?: ChallengeConstraintCreateNestedOneWithoutChallengeInput
    events?: ChallengeEventCreateNestedManyWithoutChallengeInput
    discussions?: ChallengeDiscussionCreateNestedManyWithoutChallengeInput
    metadata?: ChallengeMetadataCreateNestedManyWithoutChallengeInput
    phases?: ChallengePhaseCreateNestedManyWithoutChallengeInput
    prizeSets?: ChallengePrizeSetCreateNestedManyWithoutChallengeInput
    reviewers?: ChallengeReviewerCreateNestedManyWithoutChallengeInput
    winners?: ChallengeWinnerCreateNestedManyWithoutChallengeInput
    attachments?: AttachmentCreateNestedManyWithoutChallengeInput
    terms?: ChallengeTermCreateNestedManyWithoutChallengeInput
    skills?: ChallengeSkillCreateNestedManyWithoutChallengeInput
    auditLogs?: AuditLogCreateNestedManyWithoutChallengeInput
    memberAccesses?: MemberChallengeAccessCreateNestedManyWithoutChallengeInput
    type: ChallengeTypeCreateNestedOneWithoutChallengesInput
    track: ChallengeTrackCreateNestedOneWithoutChallengesInput
    timelineTemplate?: TimelineTemplateCreateNestedOneWithoutChallengesInput
  }

  export type ChallengeUncheckedCreateInput = {
    id?: string
    name: string
    description?: string | null
    privateDescription?: string | null
    challengeSource?: string | null
    descriptionFormat?: string | null
    projectId?: number | null
    typeId: string
    trackId: string
    timelineTemplateId?: string | null
    overviewTotalPrizes?: number | null
    numOfRegistrants?: number
    numOfSubmissions?: number
    numOfCheckpointSubmissions?: number
    currentPhaseNames?: ChallengeCreatecurrentPhaseNamesInput | string[]
    wiproAllowed?: boolean
    tags?: ChallengeCreatetagsInput | string[]
    groups?: ChallengeCreategroupsInput | string[]
    taskIsTask?: boolean
    taskIsAssigned?: boolean
    taskMemberId?: string | null
    submissionStartDate?: Date | string | null
    submissionEndDate?: Date | string | null
    registrationStartDate?: Date | string | null
    registrationEndDate?: Date | string | null
    startDate?: Date | string | null
    endDate?: Date | string | null
    legacyId?: number | null
    status?: $Enums.ChallengeStatusEnum
    createdAt?: Date | string
    createdBy: string
    updatedAt?: Date | string
    updatedBy: string
    billingRecord?: ChallengeBillingUncheckedCreateNestedOneWithoutChallengeInput
    legacyRecord?: ChallengeLegacyUncheckedCreateNestedOneWithoutChallengeInput
    constraintRecord?: ChallengeConstraintUncheckedCreateNestedOneWithoutChallengeInput
    events?: ChallengeEventUncheckedCreateNestedManyWithoutChallengeInput
    discussions?: ChallengeDiscussionUncheckedCreateNestedManyWithoutChallengeInput
    metadata?: ChallengeMetadataUncheckedCreateNestedManyWithoutChallengeInput
    phases?: ChallengePhaseUncheckedCreateNestedManyWithoutChallengeInput
    prizeSets?: ChallengePrizeSetUncheckedCreateNestedManyWithoutChallengeInput
    reviewers?: ChallengeReviewerUncheckedCreateNestedManyWithoutChallengeInput
    winners?: ChallengeWinnerUncheckedCreateNestedManyWithoutChallengeInput
    attachments?: AttachmentUncheckedCreateNestedManyWithoutChallengeInput
    terms?: ChallengeTermUncheckedCreateNestedManyWithoutChallengeInput
    skills?: ChallengeSkillUncheckedCreateNestedManyWithoutChallengeInput
    auditLogs?: AuditLogUncheckedCreateNestedManyWithoutChallengeInput
    memberAccesses?: MemberChallengeAccessUncheckedCreateNestedManyWithoutChallengeInput
  }

  export type ChallengeUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    privateDescription?: NullableStringFieldUpdateOperationsInput | string | null
    challengeSource?: NullableStringFieldUpdateOperationsInput | string | null
    descriptionFormat?: NullableStringFieldUpdateOperationsInput | string | null
    projectId?: NullableIntFieldUpdateOperationsInput | number | null
    overviewTotalPrizes?: NullableFloatFieldUpdateOperationsInput | number | null
    numOfRegistrants?: IntFieldUpdateOperationsInput | number
    numOfSubmissions?: IntFieldUpdateOperationsInput | number
    numOfCheckpointSubmissions?: IntFieldUpdateOperationsInput | number
    currentPhaseNames?: ChallengeUpdatecurrentPhaseNamesInput | string[]
    wiproAllowed?: BoolFieldUpdateOperationsInput | boolean
    tags?: ChallengeUpdatetagsInput | string[]
    groups?: ChallengeUpdategroupsInput | string[]
    taskIsTask?: BoolFieldUpdateOperationsInput | boolean
    taskIsAssigned?: BoolFieldUpdateOperationsInput | boolean
    taskMemberId?: NullableStringFieldUpdateOperationsInput | string | null
    submissionStartDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    submissionEndDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    registrationStartDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    registrationEndDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    startDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    endDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    legacyId?: NullableIntFieldUpdateOperationsInput | number | null
    status?: EnumChallengeStatusEnumFieldUpdateOperationsInput | $Enums.ChallengeStatusEnum
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdBy?: StringFieldUpdateOperationsInput | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedBy?: StringFieldUpdateOperationsInput | string
    billingRecord?: ChallengeBillingUpdateOneWithoutChallengeNestedInput
    legacyRecord?: ChallengeLegacyUpdateOneWithoutChallengeNestedInput
    constraintRecord?: ChallengeConstraintUpdateOneWithoutChallengeNestedInput
    events?: ChallengeEventUpdateManyWithoutChallengeNestedInput
    discussions?: ChallengeDiscussionUpdateManyWithoutChallengeNestedInput
    metadata?: ChallengeMetadataUpdateManyWithoutChallengeNestedInput
    phases?: ChallengePhaseUpdateManyWithoutChallengeNestedInput
    prizeSets?: ChallengePrizeSetUpdateManyWithoutChallengeNestedInput
    reviewers?: ChallengeReviewerUpdateManyWithoutChallengeNestedInput
    winners?: ChallengeWinnerUpdateManyWithoutChallengeNestedInput
    attachments?: AttachmentUpdateManyWithoutChallengeNestedInput
    terms?: ChallengeTermUpdateManyWithoutChallengeNestedInput
    skills?: ChallengeSkillUpdateManyWithoutChallengeNestedInput
    auditLogs?: AuditLogUpdateManyWithoutChallengeNestedInput
    memberAccesses?: MemberChallengeAccessUpdateManyWithoutChallengeNestedInput
    type?: ChallengeTypeUpdateOneRequiredWithoutChallengesNestedInput
    track?: ChallengeTrackUpdateOneRequiredWithoutChallengesNestedInput
    timelineTemplate?: TimelineTemplateUpdateOneWithoutChallengesNestedInput
  }

  export type ChallengeUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    privateDescription?: NullableStringFieldUpdateOperationsInput | string | null
    challengeSource?: NullableStringFieldUpdateOperationsInput | string | null
    descriptionFormat?: NullableStringFieldUpdateOperationsInput | string | null
    projectId?: NullableIntFieldUpdateOperationsInput | number | null
    typeId?: StringFieldUpdateOperationsInput | string
    trackId?: StringFieldUpdateOperationsInput | string
    timelineTemplateId?: NullableStringFieldUpdateOperationsInput | string | null
    overviewTotalPrizes?: NullableFloatFieldUpdateOperationsInput | number | null
    numOfRegistrants?: IntFieldUpdateOperationsInput | number
    numOfSubmissions?: IntFieldUpdateOperationsInput | number
    numOfCheckpointSubmissions?: IntFieldUpdateOperationsInput | number
    currentPhaseNames?: ChallengeUpdatecurrentPhaseNamesInput | string[]
    wiproAllowed?: BoolFieldUpdateOperationsInput | boolean
    tags?: ChallengeUpdatetagsInput | string[]
    groups?: ChallengeUpdategroupsInput | string[]
    taskIsTask?: BoolFieldUpdateOperationsInput | boolean
    taskIsAssigned?: BoolFieldUpdateOperationsInput | boolean
    taskMemberId?: NullableStringFieldUpdateOperationsInput | string | null
    submissionStartDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    submissionEndDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    registrationStartDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    registrationEndDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    startDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    endDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    legacyId?: NullableIntFieldUpdateOperationsInput | number | null
    status?: EnumChallengeStatusEnumFieldUpdateOperationsInput | $Enums.ChallengeStatusEnum
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdBy?: StringFieldUpdateOperationsInput | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedBy?: StringFieldUpdateOperationsInput | string
    billingRecord?: ChallengeBillingUncheckedUpdateOneWithoutChallengeNestedInput
    legacyRecord?: ChallengeLegacyUncheckedUpdateOneWithoutChallengeNestedInput
    constraintRecord?: ChallengeConstraintUncheckedUpdateOneWithoutChallengeNestedInput
    events?: ChallengeEventUncheckedUpdateManyWithoutChallengeNestedInput
    discussions?: ChallengeDiscussionUncheckedUpdateManyWithoutChallengeNestedInput
    metadata?: ChallengeMetadataUncheckedUpdateManyWithoutChallengeNestedInput
    phases?: ChallengePhaseUncheckedUpdateManyWithoutChallengeNestedInput
    prizeSets?: ChallengePrizeSetUncheckedUpdateManyWithoutChallengeNestedInput
    reviewers?: ChallengeReviewerUncheckedUpdateManyWithoutChallengeNestedInput
    winners?: ChallengeWinnerUncheckedUpdateManyWithoutChallengeNestedInput
    attachments?: AttachmentUncheckedUpdateManyWithoutChallengeNestedInput
    terms?: ChallengeTermUncheckedUpdateManyWithoutChallengeNestedInput
    skills?: ChallengeSkillUncheckedUpdateManyWithoutChallengeNestedInput
    auditLogs?: AuditLogUncheckedUpdateManyWithoutChallengeNestedInput
    memberAccesses?: MemberChallengeAccessUncheckedUpdateManyWithoutChallengeNestedInput
  }

  export type ChallengeCreateManyInput = {
    id?: string
    name: string
    description?: string | null
    privateDescription?: string | null
    challengeSource?: string | null
    descriptionFormat?: string | null
    projectId?: number | null
    typeId: string
    trackId: string
    timelineTemplateId?: string | null
    overviewTotalPrizes?: number | null
    numOfRegistrants?: number
    numOfSubmissions?: number
    numOfCheckpointSubmissions?: number
    currentPhaseNames?: ChallengeCreatecurrentPhaseNamesInput | string[]
    wiproAllowed?: boolean
    tags?: ChallengeCreatetagsInput | string[]
    groups?: ChallengeCreategroupsInput | string[]
    taskIsTask?: boolean
    taskIsAssigned?: boolean
    taskMemberId?: string | null
    submissionStartDate?: Date | string | null
    submissionEndDate?: Date | string | null
    registrationStartDate?: Date | string | null
    registrationEndDate?: Date | string | null
    startDate?: Date | string | null
    endDate?: Date | string | null
    legacyId?: number | null
    status?: $Enums.ChallengeStatusEnum
    createdAt?: Date | string
    createdBy: string
    updatedAt?: Date | string
    updatedBy: string
  }

  export type ChallengeUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    privateDescription?: NullableStringFieldUpdateOperationsInput | string | null
    challengeSource?: NullableStringFieldUpdateOperationsInput | string | null
    descriptionFormat?: NullableStringFieldUpdateOperationsInput | string | null
    projectId?: NullableIntFieldUpdateOperationsInput | number | null
    overviewTotalPrizes?: NullableFloatFieldUpdateOperationsInput | number | null
    numOfRegistrants?: IntFieldUpdateOperationsInput | number
    numOfSubmissions?: IntFieldUpdateOperationsInput | number
    numOfCheckpointSubmissions?: IntFieldUpdateOperationsInput | number
    currentPhaseNames?: ChallengeUpdatecurrentPhaseNamesInput | string[]
    wiproAllowed?: BoolFieldUpdateOperationsInput | boolean
    tags?: ChallengeUpdatetagsInput | string[]
    groups?: ChallengeUpdategroupsInput | string[]
    taskIsTask?: BoolFieldUpdateOperationsInput | boolean
    taskIsAssigned?: BoolFieldUpdateOperationsInput | boolean
    taskMemberId?: NullableStringFieldUpdateOperationsInput | string | null
    submissionStartDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    submissionEndDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    registrationStartDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    registrationEndDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    startDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    endDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    legacyId?: NullableIntFieldUpdateOperationsInput | number | null
    status?: EnumChallengeStatusEnumFieldUpdateOperationsInput | $Enums.ChallengeStatusEnum
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdBy?: StringFieldUpdateOperationsInput | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedBy?: StringFieldUpdateOperationsInput | string
  }

  export type ChallengeUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    privateDescription?: NullableStringFieldUpdateOperationsInput | string | null
    challengeSource?: NullableStringFieldUpdateOperationsInput | string | null
    descriptionFormat?: NullableStringFieldUpdateOperationsInput | string | null
    projectId?: NullableIntFieldUpdateOperationsInput | number | null
    typeId?: StringFieldUpdateOperationsInput | string
    trackId?: StringFieldUpdateOperationsInput | string
    timelineTemplateId?: NullableStringFieldUpdateOperationsInput | string | null
    overviewTotalPrizes?: NullableFloatFieldUpdateOperationsInput | number | null
    numOfRegistrants?: IntFieldUpdateOperationsInput | number
    numOfSubmissions?: IntFieldUpdateOperationsInput | number
    numOfCheckpointSubmissions?: IntFieldUpdateOperationsInput | number
    currentPhaseNames?: ChallengeUpdatecurrentPhaseNamesInput | string[]
    wiproAllowed?: BoolFieldUpdateOperationsInput | boolean
    tags?: ChallengeUpdatetagsInput | string[]
    groups?: ChallengeUpdategroupsInput | string[]
    taskIsTask?: BoolFieldUpdateOperationsInput | boolean
    taskIsAssigned?: BoolFieldUpdateOperationsInput | boolean
    taskMemberId?: NullableStringFieldUpdateOperationsInput | string | null
    submissionStartDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    submissionEndDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    registrationStartDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    registrationEndDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    startDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    endDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    legacyId?: NullableIntFieldUpdateOperationsInput | number | null
    status?: EnumChallengeStatusEnumFieldUpdateOperationsInput | $Enums.ChallengeStatusEnum
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdBy?: StringFieldUpdateOperationsInput | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedBy?: StringFieldUpdateOperationsInput | string
  }

  export type ChallengeTypeCreateInput = {
    id?: string
    name: string
    description?: string | null
    isActive?: boolean
    isTask?: boolean
    abbreviation: string
    createdAt?: Date | string
    createdBy: string
    updatedAt?: Date | string
    updatedBy: string
    challenges?: ChallengeCreateNestedManyWithoutTypeInput
    timelineTemplates?: ChallengeTimelineTemplateCreateNestedManyWithoutTypeInput
    defaultReviewers?: DefaultChallengeReviewerCreateNestedManyWithoutChallengeTypeInput
  }

  export type ChallengeTypeUncheckedCreateInput = {
    id?: string
    name: string
    description?: string | null
    isActive?: boolean
    isTask?: boolean
    abbreviation: string
    createdAt?: Date | string
    createdBy: string
    updatedAt?: Date | string
    updatedBy: string
    challenges?: ChallengeUncheckedCreateNestedManyWithoutTypeInput
    timelineTemplates?: ChallengeTimelineTemplateUncheckedCreateNestedManyWithoutTypeInput
    defaultReviewers?: DefaultChallengeReviewerUncheckedCreateNestedManyWithoutChallengeTypeInput
  }

  export type ChallengeTypeUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    isTask?: BoolFieldUpdateOperationsInput | boolean
    abbreviation?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdBy?: StringFieldUpdateOperationsInput | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedBy?: StringFieldUpdateOperationsInput | string
    challenges?: ChallengeUpdateManyWithoutTypeNestedInput
    timelineTemplates?: ChallengeTimelineTemplateUpdateManyWithoutTypeNestedInput
    defaultReviewers?: DefaultChallengeReviewerUpdateManyWithoutChallengeTypeNestedInput
  }

  export type ChallengeTypeUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    isTask?: BoolFieldUpdateOperationsInput | boolean
    abbreviation?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdBy?: StringFieldUpdateOperationsInput | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedBy?: StringFieldUpdateOperationsInput | string
    challenges?: ChallengeUncheckedUpdateManyWithoutTypeNestedInput
    timelineTemplates?: ChallengeTimelineTemplateUncheckedUpdateManyWithoutTypeNestedInput
    defaultReviewers?: DefaultChallengeReviewerUncheckedUpdateManyWithoutChallengeTypeNestedInput
  }

  export type ChallengeTypeCreateManyInput = {
    id?: string
    name: string
    description?: string | null
    isActive?: boolean
    isTask?: boolean
    abbreviation: string
    createdAt?: Date | string
    createdBy: string
    updatedAt?: Date | string
    updatedBy: string
  }

  export type ChallengeTypeUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    isTask?: BoolFieldUpdateOperationsInput | boolean
    abbreviation?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdBy?: StringFieldUpdateOperationsInput | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedBy?: StringFieldUpdateOperationsInput | string
  }

  export type ChallengeTypeUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    isTask?: BoolFieldUpdateOperationsInput | boolean
    abbreviation?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdBy?: StringFieldUpdateOperationsInput | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedBy?: StringFieldUpdateOperationsInput | string
  }

  export type ChallengeTrackCreateInput = {
    id?: string
    name: string
    description?: string | null
    isActive: boolean
    abbreviation: string
    legacyId?: number | null
    track?: $Enums.ChallengeTrackEnum | null
    createdAt?: Date | string
    createdBy: string
    updatedAt?: Date | string
    updatedBy: string
    challenges?: ChallengeCreateNestedManyWithoutTrackInput
    timelineTemplates?: ChallengeTimelineTemplateCreateNestedManyWithoutTrackInput
    defaultReviewers?: DefaultChallengeReviewerCreateNestedManyWithoutChallengeTrackInput
  }

  export type ChallengeTrackUncheckedCreateInput = {
    id?: string
    name: string
    description?: string | null
    isActive: boolean
    abbreviation: string
    legacyId?: number | null
    track?: $Enums.ChallengeTrackEnum | null
    createdAt?: Date | string
    createdBy: string
    updatedAt?: Date | string
    updatedBy: string
    challenges?: ChallengeUncheckedCreateNestedManyWithoutTrackInput
    timelineTemplates?: ChallengeTimelineTemplateUncheckedCreateNestedManyWithoutTrackInput
    defaultReviewers?: DefaultChallengeReviewerUncheckedCreateNestedManyWithoutChallengeTrackInput
  }

  export type ChallengeTrackUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    abbreviation?: StringFieldUpdateOperationsInput | string
    legacyId?: NullableIntFieldUpdateOperationsInput | number | null
    track?: NullableEnumChallengeTrackEnumFieldUpdateOperationsInput | $Enums.ChallengeTrackEnum | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdBy?: StringFieldUpdateOperationsInput | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedBy?: StringFieldUpdateOperationsInput | string
    challenges?: ChallengeUpdateManyWithoutTrackNestedInput
    timelineTemplates?: ChallengeTimelineTemplateUpdateManyWithoutTrackNestedInput
    defaultReviewers?: DefaultChallengeReviewerUpdateManyWithoutChallengeTrackNestedInput
  }

  export type ChallengeTrackUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    abbreviation?: StringFieldUpdateOperationsInput | string
    legacyId?: NullableIntFieldUpdateOperationsInput | number | null
    track?: NullableEnumChallengeTrackEnumFieldUpdateOperationsInput | $Enums.ChallengeTrackEnum | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdBy?: StringFieldUpdateOperationsInput | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedBy?: StringFieldUpdateOperationsInput | string
    challenges?: ChallengeUncheckedUpdateManyWithoutTrackNestedInput
    timelineTemplates?: ChallengeTimelineTemplateUncheckedUpdateManyWithoutTrackNestedInput
    defaultReviewers?: DefaultChallengeReviewerUncheckedUpdateManyWithoutChallengeTrackNestedInput
  }

  export type ChallengeTrackCreateManyInput = {
    id?: string
    name: string
    description?: string | null
    isActive: boolean
    abbreviation: string
    legacyId?: number | null
    track?: $Enums.ChallengeTrackEnum | null
    createdAt?: Date | string
    createdBy: string
    updatedAt?: Date | string
    updatedBy: string
  }

  export type ChallengeTrackUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    abbreviation?: StringFieldUpdateOperationsInput | string
    legacyId?: NullableIntFieldUpdateOperationsInput | number | null
    track?: NullableEnumChallengeTrackEnumFieldUpdateOperationsInput | $Enums.ChallengeTrackEnum | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdBy?: StringFieldUpdateOperationsInput | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedBy?: StringFieldUpdateOperationsInput | string
  }

  export type ChallengeTrackUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    abbreviation?: StringFieldUpdateOperationsInput | string
    legacyId?: NullableIntFieldUpdateOperationsInput | number | null
    track?: NullableEnumChallengeTrackEnumFieldUpdateOperationsInput | $Enums.ChallengeTrackEnum | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdBy?: StringFieldUpdateOperationsInput | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedBy?: StringFieldUpdateOperationsInput | string
  }

  export type ChallengeTimelineTemplateCreateInput = {
    id?: string
    isDefault?: boolean
    createdAt?: Date | string
    createdBy: string
    updatedAt?: Date | string
    updatedBy: string
    timelineTemplate: TimelineTemplateCreateNestedOneWithoutChallengeTimelineTemplatesInput
    track: ChallengeTrackCreateNestedOneWithoutTimelineTemplatesInput
    type: ChallengeTypeCreateNestedOneWithoutTimelineTemplatesInput
  }

  export type ChallengeTimelineTemplateUncheckedCreateInput = {
    id?: string
    typeId: string
    trackId: string
    timelineTemplateId: string
    isDefault?: boolean
    createdAt?: Date | string
    createdBy: string
    updatedAt?: Date | string
    updatedBy: string
  }

  export type ChallengeTimelineTemplateUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    isDefault?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdBy?: StringFieldUpdateOperationsInput | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedBy?: StringFieldUpdateOperationsInput | string
    timelineTemplate?: TimelineTemplateUpdateOneRequiredWithoutChallengeTimelineTemplatesNestedInput
    track?: ChallengeTrackUpdateOneRequiredWithoutTimelineTemplatesNestedInput
    type?: ChallengeTypeUpdateOneRequiredWithoutTimelineTemplatesNestedInput
  }

  export type ChallengeTimelineTemplateUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    typeId?: StringFieldUpdateOperationsInput | string
    trackId?: StringFieldUpdateOperationsInput | string
    timelineTemplateId?: StringFieldUpdateOperationsInput | string
    isDefault?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdBy?: StringFieldUpdateOperationsInput | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedBy?: StringFieldUpdateOperationsInput | string
  }

  export type ChallengeTimelineTemplateCreateManyInput = {
    id?: string
    typeId: string
    trackId: string
    timelineTemplateId: string
    isDefault?: boolean
    createdAt?: Date | string
    createdBy: string
    updatedAt?: Date | string
    updatedBy: string
  }

  export type ChallengeTimelineTemplateUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    isDefault?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdBy?: StringFieldUpdateOperationsInput | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedBy?: StringFieldUpdateOperationsInput | string
  }

  export type ChallengeTimelineTemplateUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    typeId?: StringFieldUpdateOperationsInput | string
    trackId?: StringFieldUpdateOperationsInput | string
    timelineTemplateId?: StringFieldUpdateOperationsInput | string
    isDefault?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdBy?: StringFieldUpdateOperationsInput | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedBy?: StringFieldUpdateOperationsInput | string
  }

  export type AuditLogCreateInput = {
    id?: string
    fieldName: string
    oldValue?: string | null
    newValue?: string | null
    createdAt?: Date | string
    createdBy: string
    memberId?: string | null
    challenge?: ChallengeCreateNestedOneWithoutAuditLogsInput
  }

  export type AuditLogUncheckedCreateInput = {
    id?: string
    challengeId?: string | null
    fieldName: string
    oldValue?: string | null
    newValue?: string | null
    createdAt?: Date | string
    createdBy: string
    memberId?: string | null
  }

  export type AuditLogUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    fieldName?: StringFieldUpdateOperationsInput | string
    oldValue?: NullableStringFieldUpdateOperationsInput | string | null
    newValue?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdBy?: StringFieldUpdateOperationsInput | string
    memberId?: NullableStringFieldUpdateOperationsInput | string | null
    challenge?: ChallengeUpdateOneWithoutAuditLogsNestedInput
  }

  export type AuditLogUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    challengeId?: NullableStringFieldUpdateOperationsInput | string | null
    fieldName?: StringFieldUpdateOperationsInput | string
    oldValue?: NullableStringFieldUpdateOperationsInput | string | null
    newValue?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdBy?: StringFieldUpdateOperationsInput | string
    memberId?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type AuditLogCreateManyInput = {
    id?: string
    challengeId?: string | null
    fieldName: string
    oldValue?: string | null
    newValue?: string | null
    createdAt?: Date | string
    createdBy: string
    memberId?: string | null
  }

  export type AuditLogUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    fieldName?: StringFieldUpdateOperationsInput | string
    oldValue?: NullableStringFieldUpdateOperationsInput | string | null
    newValue?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdBy?: StringFieldUpdateOperationsInput | string
    memberId?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type AuditLogUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    challengeId?: NullableStringFieldUpdateOperationsInput | string | null
    fieldName?: StringFieldUpdateOperationsInput | string
    oldValue?: NullableStringFieldUpdateOperationsInput | string | null
    newValue?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdBy?: StringFieldUpdateOperationsInput | string
    memberId?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type AttachmentCreateInput = {
    id?: string
    name: string
    fileSize: number
    url: string
    description?: string | null
    createdAt?: Date | string
    createdBy: string
    updatedAt?: Date | string
    updatedBy: string
    challenge: ChallengeCreateNestedOneWithoutAttachmentsInput
  }

  export type AttachmentUncheckedCreateInput = {
    id?: string
    challengeId: string
    name: string
    fileSize: number
    url: string
    description?: string | null
    createdAt?: Date | string
    createdBy: string
    updatedAt?: Date | string
    updatedBy: string
  }

  export type AttachmentUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    fileSize?: IntFieldUpdateOperationsInput | number
    url?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdBy?: StringFieldUpdateOperationsInput | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedBy?: StringFieldUpdateOperationsInput | string
    challenge?: ChallengeUpdateOneRequiredWithoutAttachmentsNestedInput
  }

  export type AttachmentUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    challengeId?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    fileSize?: IntFieldUpdateOperationsInput | number
    url?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdBy?: StringFieldUpdateOperationsInput | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedBy?: StringFieldUpdateOperationsInput | string
  }

  export type AttachmentCreateManyInput = {
    id?: string
    challengeId: string
    name: string
    fileSize: number
    url: string
    description?: string | null
    createdAt?: Date | string
    createdBy: string
    updatedAt?: Date | string
    updatedBy: string
  }

  export type AttachmentUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    fileSize?: IntFieldUpdateOperationsInput | number
    url?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdBy?: StringFieldUpdateOperationsInput | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedBy?: StringFieldUpdateOperationsInput | string
  }

  export type AttachmentUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    challengeId?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    fileSize?: IntFieldUpdateOperationsInput | number
    url?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdBy?: StringFieldUpdateOperationsInput | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedBy?: StringFieldUpdateOperationsInput | string
  }

  export type ChallengeMetadataCreateInput = {
    id?: string
    name: string
    value: string
    createdAt?: Date | string
    createdBy: string
    updatedAt?: Date | string
    updatedBy: string
    challenge: ChallengeCreateNestedOneWithoutMetadataInput
  }

  export type ChallengeMetadataUncheckedCreateInput = {
    id?: string
    challengeId: string
    name: string
    value: string
    createdAt?: Date | string
    createdBy: string
    updatedAt?: Date | string
    updatedBy: string
  }

  export type ChallengeMetadataUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    value?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdBy?: StringFieldUpdateOperationsInput | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedBy?: StringFieldUpdateOperationsInput | string
    challenge?: ChallengeUpdateOneRequiredWithoutMetadataNestedInput
  }

  export type ChallengeMetadataUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    challengeId?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    value?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdBy?: StringFieldUpdateOperationsInput | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedBy?: StringFieldUpdateOperationsInput | string
  }

  export type ChallengeMetadataCreateManyInput = {
    id?: string
    challengeId: string
    name: string
    value: string
    createdAt?: Date | string
    createdBy: string
    updatedAt?: Date | string
    updatedBy: string
  }

  export type ChallengeMetadataUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    value?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdBy?: StringFieldUpdateOperationsInput | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedBy?: StringFieldUpdateOperationsInput | string
  }

  export type ChallengeMetadataUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    challengeId?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    value?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdBy?: StringFieldUpdateOperationsInput | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedBy?: StringFieldUpdateOperationsInput | string
  }

  export type PrizeCreateInput = {
    id?: string
    description?: string | null
    type: string
    value: number
    createdAt?: Date | string
    createdBy: string
    updatedAt?: Date | string
    updatedBy: string
    prizeSet: ChallengePrizeSetCreateNestedOneWithoutPrizesInput
  }

  export type PrizeUncheckedCreateInput = {
    id?: string
    description?: string | null
    prizeSetId: string
    type: string
    value: number
    createdAt?: Date | string
    createdBy: string
    updatedAt?: Date | string
    updatedBy: string
  }

  export type PrizeUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    type?: StringFieldUpdateOperationsInput | string
    value?: FloatFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdBy?: StringFieldUpdateOperationsInput | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedBy?: StringFieldUpdateOperationsInput | string
    prizeSet?: ChallengePrizeSetUpdateOneRequiredWithoutPrizesNestedInput
  }

  export type PrizeUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    prizeSetId?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    value?: FloatFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdBy?: StringFieldUpdateOperationsInput | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedBy?: StringFieldUpdateOperationsInput | string
  }

  export type PrizeCreateManyInput = {
    id?: string
    description?: string | null
    prizeSetId: string
    type: string
    value: number
    createdAt?: Date | string
    createdBy: string
    updatedAt?: Date | string
    updatedBy: string
  }

  export type PrizeUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    type?: StringFieldUpdateOperationsInput | string
    value?: FloatFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdBy?: StringFieldUpdateOperationsInput | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedBy?: StringFieldUpdateOperationsInput | string
  }

  export type PrizeUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    prizeSetId?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    value?: FloatFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdBy?: StringFieldUpdateOperationsInput | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedBy?: StringFieldUpdateOperationsInput | string
  }

  export type ChallengeWinnerCreateInput = {
    id?: string
    userId: number
    handle: string
    placement: number
    type: $Enums.PrizeSetTypeEnum
    createdAt?: Date | string
    createdBy: string
    updatedAt?: Date | string
    updatedBy: string
    challenge: ChallengeCreateNestedOneWithoutWinnersInput
  }

  export type ChallengeWinnerUncheckedCreateInput = {
    id?: string
    challengeId: string
    userId: number
    handle: string
    placement: number
    type: $Enums.PrizeSetTypeEnum
    createdAt?: Date | string
    createdBy: string
    updatedAt?: Date | string
    updatedBy: string
  }

  export type ChallengeWinnerUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: IntFieldUpdateOperationsInput | number
    handle?: StringFieldUpdateOperationsInput | string
    placement?: IntFieldUpdateOperationsInput | number
    type?: EnumPrizeSetTypeEnumFieldUpdateOperationsInput | $Enums.PrizeSetTypeEnum
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdBy?: StringFieldUpdateOperationsInput | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedBy?: StringFieldUpdateOperationsInput | string
    challenge?: ChallengeUpdateOneRequiredWithoutWinnersNestedInput
  }

  export type ChallengeWinnerUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    challengeId?: StringFieldUpdateOperationsInput | string
    userId?: IntFieldUpdateOperationsInput | number
    handle?: StringFieldUpdateOperationsInput | string
    placement?: IntFieldUpdateOperationsInput | number
    type?: EnumPrizeSetTypeEnumFieldUpdateOperationsInput | $Enums.PrizeSetTypeEnum
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdBy?: StringFieldUpdateOperationsInput | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedBy?: StringFieldUpdateOperationsInput | string
  }

  export type ChallengeWinnerCreateManyInput = {
    id?: string
    challengeId: string
    userId: number
    handle: string
    placement: number
    type: $Enums.PrizeSetTypeEnum
    createdAt?: Date | string
    createdBy: string
    updatedAt?: Date | string
    updatedBy: string
  }

  export type ChallengeWinnerUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: IntFieldUpdateOperationsInput | number
    handle?: StringFieldUpdateOperationsInput | string
    placement?: IntFieldUpdateOperationsInput | number
    type?: EnumPrizeSetTypeEnumFieldUpdateOperationsInput | $Enums.PrizeSetTypeEnum
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdBy?: StringFieldUpdateOperationsInput | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedBy?: StringFieldUpdateOperationsInput | string
  }

  export type ChallengeWinnerUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    challengeId?: StringFieldUpdateOperationsInput | string
    userId?: IntFieldUpdateOperationsInput | number
    handle?: StringFieldUpdateOperationsInput | string
    placement?: IntFieldUpdateOperationsInput | number
    type?: EnumPrizeSetTypeEnumFieldUpdateOperationsInput | $Enums.PrizeSetTypeEnum
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdBy?: StringFieldUpdateOperationsInput | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedBy?: StringFieldUpdateOperationsInput | string
  }

  export type ChallengeTermCreateInput = {
    id?: string
    termId: string
    roleId: string
    createdAt?: Date | string
    createdBy: string
    updatedAt?: Date | string
    updatedBy: string
    challenge: ChallengeCreateNestedOneWithoutTermsInput
  }

  export type ChallengeTermUncheckedCreateInput = {
    id?: string
    challengeId: string
    termId: string
    roleId: string
    createdAt?: Date | string
    createdBy: string
    updatedAt?: Date | string
    updatedBy: string
  }

  export type ChallengeTermUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    termId?: StringFieldUpdateOperationsInput | string
    roleId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdBy?: StringFieldUpdateOperationsInput | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedBy?: StringFieldUpdateOperationsInput | string
    challenge?: ChallengeUpdateOneRequiredWithoutTermsNestedInput
  }

  export type ChallengeTermUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    challengeId?: StringFieldUpdateOperationsInput | string
    termId?: StringFieldUpdateOperationsInput | string
    roleId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdBy?: StringFieldUpdateOperationsInput | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedBy?: StringFieldUpdateOperationsInput | string
  }

  export type ChallengeTermCreateManyInput = {
    id?: string
    challengeId: string
    termId: string
    roleId: string
    createdAt?: Date | string
    createdBy: string
    updatedAt?: Date | string
    updatedBy: string
  }

  export type ChallengeTermUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    termId?: StringFieldUpdateOperationsInput | string
    roleId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdBy?: StringFieldUpdateOperationsInput | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedBy?: StringFieldUpdateOperationsInput | string
  }

  export type ChallengeTermUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    challengeId?: StringFieldUpdateOperationsInput | string
    termId?: StringFieldUpdateOperationsInput | string
    roleId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdBy?: StringFieldUpdateOperationsInput | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedBy?: StringFieldUpdateOperationsInput | string
  }

  export type ChallengeSkillCreateInput = {
    id?: string
    skillId: string
    createdAt?: Date | string
    createdBy: string
    updatedAt?: Date | string
    updatedBy: string
    challenge: ChallengeCreateNestedOneWithoutSkillsInput
  }

  export type ChallengeSkillUncheckedCreateInput = {
    id?: string
    challengeId: string
    skillId: string
    createdAt?: Date | string
    createdBy: string
    updatedAt?: Date | string
    updatedBy: string
  }

  export type ChallengeSkillUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    skillId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdBy?: StringFieldUpdateOperationsInput | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedBy?: StringFieldUpdateOperationsInput | string
    challenge?: ChallengeUpdateOneRequiredWithoutSkillsNestedInput
  }

  export type ChallengeSkillUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    challengeId?: StringFieldUpdateOperationsInput | string
    skillId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdBy?: StringFieldUpdateOperationsInput | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedBy?: StringFieldUpdateOperationsInput | string
  }

  export type ChallengeSkillCreateManyInput = {
    id?: string
    challengeId: string
    skillId: string
    createdAt?: Date | string
    createdBy: string
    updatedAt?: Date | string
    updatedBy: string
  }

  export type ChallengeSkillUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    skillId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdBy?: StringFieldUpdateOperationsInput | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedBy?: StringFieldUpdateOperationsInput | string
  }

  export type ChallengeSkillUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    challengeId?: StringFieldUpdateOperationsInput | string
    skillId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdBy?: StringFieldUpdateOperationsInput | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedBy?: StringFieldUpdateOperationsInput | string
  }

  export type ChallengeBillingCreateInput = {
    id?: string
    billingAccountId?: string | null
    markup?: number | null
    clientBillingRate?: number | null
    createdAt?: Date | string
    createdBy: string
    updatedAt?: Date | string
    updatedBy: string
    challenge: ChallengeCreateNestedOneWithoutBillingRecordInput
  }

  export type ChallengeBillingUncheckedCreateInput = {
    id?: string
    billingAccountId?: string | null
    markup?: number | null
    clientBillingRate?: number | null
    challengeId: string
    createdAt?: Date | string
    createdBy: string
    updatedAt?: Date | string
    updatedBy: string
  }

  export type ChallengeBillingUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    billingAccountId?: NullableStringFieldUpdateOperationsInput | string | null
    markup?: NullableFloatFieldUpdateOperationsInput | number | null
    clientBillingRate?: NullableFloatFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdBy?: StringFieldUpdateOperationsInput | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedBy?: StringFieldUpdateOperationsInput | string
    challenge?: ChallengeUpdateOneRequiredWithoutBillingRecordNestedInput
  }

  export type ChallengeBillingUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    billingAccountId?: NullableStringFieldUpdateOperationsInput | string | null
    markup?: NullableFloatFieldUpdateOperationsInput | number | null
    clientBillingRate?: NullableFloatFieldUpdateOperationsInput | number | null
    challengeId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdBy?: StringFieldUpdateOperationsInput | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedBy?: StringFieldUpdateOperationsInput | string
  }

  export type ChallengeBillingCreateManyInput = {
    id?: string
    billingAccountId?: string | null
    markup?: number | null
    clientBillingRate?: number | null
    challengeId: string
    createdAt?: Date | string
    createdBy: string
    updatedAt?: Date | string
    updatedBy: string
  }

  export type ChallengeBillingUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    billingAccountId?: NullableStringFieldUpdateOperationsInput | string | null
    markup?: NullableFloatFieldUpdateOperationsInput | number | null
    clientBillingRate?: NullableFloatFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdBy?: StringFieldUpdateOperationsInput | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedBy?: StringFieldUpdateOperationsInput | string
  }

  export type ChallengeBillingUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    billingAccountId?: NullableStringFieldUpdateOperationsInput | string | null
    markup?: NullableFloatFieldUpdateOperationsInput | number | null
    clientBillingRate?: NullableFloatFieldUpdateOperationsInput | number | null
    challengeId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdBy?: StringFieldUpdateOperationsInput | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedBy?: StringFieldUpdateOperationsInput | string
  }

  export type ChallengeLegacyCreateInput = {
    id?: string
    reviewType?: $Enums.ReviewTypeEnum
    confidentialityType?: string
    forumId?: number | null
    directProjectId?: number | null
    screeningScorecardId?: number | null
    reviewScorecardId?: number | null
    isTask?: boolean
    useSchedulingAPI?: boolean
    pureV5Task?: boolean
    pureV5?: boolean
    selfService?: boolean
    selfServiceCopilot?: string | null
    track?: string | null
    subTrack?: string | null
    legacySystemId?: number | null
    createdAt?: Date | string
    createdBy: string
    updatedAt?: Date | string
    updatedBy: string
    challenge: ChallengeCreateNestedOneWithoutLegacyRecordInput
  }

  export type ChallengeLegacyUncheckedCreateInput = {
    id?: string
    reviewType?: $Enums.ReviewTypeEnum
    confidentialityType?: string
    forumId?: number | null
    directProjectId?: number | null
    screeningScorecardId?: number | null
    reviewScorecardId?: number | null
    isTask?: boolean
    useSchedulingAPI?: boolean
    pureV5Task?: boolean
    pureV5?: boolean
    selfService?: boolean
    selfServiceCopilot?: string | null
    track?: string | null
    subTrack?: string | null
    legacySystemId?: number | null
    challengeId: string
    createdAt?: Date | string
    createdBy: string
    updatedAt?: Date | string
    updatedBy: string
  }

  export type ChallengeLegacyUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    reviewType?: EnumReviewTypeEnumFieldUpdateOperationsInput | $Enums.ReviewTypeEnum
    confidentialityType?: StringFieldUpdateOperationsInput | string
    forumId?: NullableIntFieldUpdateOperationsInput | number | null
    directProjectId?: NullableIntFieldUpdateOperationsInput | number | null
    screeningScorecardId?: NullableIntFieldUpdateOperationsInput | number | null
    reviewScorecardId?: NullableIntFieldUpdateOperationsInput | number | null
    isTask?: BoolFieldUpdateOperationsInput | boolean
    useSchedulingAPI?: BoolFieldUpdateOperationsInput | boolean
    pureV5Task?: BoolFieldUpdateOperationsInput | boolean
    pureV5?: BoolFieldUpdateOperationsInput | boolean
    selfService?: BoolFieldUpdateOperationsInput | boolean
    selfServiceCopilot?: NullableStringFieldUpdateOperationsInput | string | null
    track?: NullableStringFieldUpdateOperationsInput | string | null
    subTrack?: NullableStringFieldUpdateOperationsInput | string | null
    legacySystemId?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdBy?: StringFieldUpdateOperationsInput | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedBy?: StringFieldUpdateOperationsInput | string
    challenge?: ChallengeUpdateOneRequiredWithoutLegacyRecordNestedInput
  }

  export type ChallengeLegacyUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    reviewType?: EnumReviewTypeEnumFieldUpdateOperationsInput | $Enums.ReviewTypeEnum
    confidentialityType?: StringFieldUpdateOperationsInput | string
    forumId?: NullableIntFieldUpdateOperationsInput | number | null
    directProjectId?: NullableIntFieldUpdateOperationsInput | number | null
    screeningScorecardId?: NullableIntFieldUpdateOperationsInput | number | null
    reviewScorecardId?: NullableIntFieldUpdateOperationsInput | number | null
    isTask?: BoolFieldUpdateOperationsInput | boolean
    useSchedulingAPI?: BoolFieldUpdateOperationsInput | boolean
    pureV5Task?: BoolFieldUpdateOperationsInput | boolean
    pureV5?: BoolFieldUpdateOperationsInput | boolean
    selfService?: BoolFieldUpdateOperationsInput | boolean
    selfServiceCopilot?: NullableStringFieldUpdateOperationsInput | string | null
    track?: NullableStringFieldUpdateOperationsInput | string | null
    subTrack?: NullableStringFieldUpdateOperationsInput | string | null
    legacySystemId?: NullableIntFieldUpdateOperationsInput | number | null
    challengeId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdBy?: StringFieldUpdateOperationsInput | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedBy?: StringFieldUpdateOperationsInput | string
  }

  export type ChallengeLegacyCreateManyInput = {
    id?: string
    reviewType?: $Enums.ReviewTypeEnum
    confidentialityType?: string
    forumId?: number | null
    directProjectId?: number | null
    screeningScorecardId?: number | null
    reviewScorecardId?: number | null
    isTask?: boolean
    useSchedulingAPI?: boolean
    pureV5Task?: boolean
    pureV5?: boolean
    selfService?: boolean
    selfServiceCopilot?: string | null
    track?: string | null
    subTrack?: string | null
    legacySystemId?: number | null
    challengeId: string
    createdAt?: Date | string
    createdBy: string
    updatedAt?: Date | string
    updatedBy: string
  }

  export type ChallengeLegacyUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    reviewType?: EnumReviewTypeEnumFieldUpdateOperationsInput | $Enums.ReviewTypeEnum
    confidentialityType?: StringFieldUpdateOperationsInput | string
    forumId?: NullableIntFieldUpdateOperationsInput | number | null
    directProjectId?: NullableIntFieldUpdateOperationsInput | number | null
    screeningScorecardId?: NullableIntFieldUpdateOperationsInput | number | null
    reviewScorecardId?: NullableIntFieldUpdateOperationsInput | number | null
    isTask?: BoolFieldUpdateOperationsInput | boolean
    useSchedulingAPI?: BoolFieldUpdateOperationsInput | boolean
    pureV5Task?: BoolFieldUpdateOperationsInput | boolean
    pureV5?: BoolFieldUpdateOperationsInput | boolean
    selfService?: BoolFieldUpdateOperationsInput | boolean
    selfServiceCopilot?: NullableStringFieldUpdateOperationsInput | string | null
    track?: NullableStringFieldUpdateOperationsInput | string | null
    subTrack?: NullableStringFieldUpdateOperationsInput | string | null
    legacySystemId?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdBy?: StringFieldUpdateOperationsInput | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedBy?: StringFieldUpdateOperationsInput | string
  }

  export type ChallengeLegacyUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    reviewType?: EnumReviewTypeEnumFieldUpdateOperationsInput | $Enums.ReviewTypeEnum
    confidentialityType?: StringFieldUpdateOperationsInput | string
    forumId?: NullableIntFieldUpdateOperationsInput | number | null
    directProjectId?: NullableIntFieldUpdateOperationsInput | number | null
    screeningScorecardId?: NullableIntFieldUpdateOperationsInput | number | null
    reviewScorecardId?: NullableIntFieldUpdateOperationsInput | number | null
    isTask?: BoolFieldUpdateOperationsInput | boolean
    useSchedulingAPI?: BoolFieldUpdateOperationsInput | boolean
    pureV5Task?: BoolFieldUpdateOperationsInput | boolean
    pureV5?: BoolFieldUpdateOperationsInput | boolean
    selfService?: BoolFieldUpdateOperationsInput | boolean
    selfServiceCopilot?: NullableStringFieldUpdateOperationsInput | string | null
    track?: NullableStringFieldUpdateOperationsInput | string | null
    subTrack?: NullableStringFieldUpdateOperationsInput | string | null
    legacySystemId?: NullableIntFieldUpdateOperationsInput | number | null
    challengeId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdBy?: StringFieldUpdateOperationsInput | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedBy?: StringFieldUpdateOperationsInput | string
  }

  export type ChallengeEventCreateInput = {
    id?: string
    eventId: number
    name?: string | null
    key?: string | null
    createdAt?: Date | string
    createdBy: string
    updatedAt?: Date | string
    updatedBy: string
    challenge: ChallengeCreateNestedOneWithoutEventsInput
  }

  export type ChallengeEventUncheckedCreateInput = {
    id?: string
    challengeId: string
    eventId: number
    name?: string | null
    key?: string | null
    createdAt?: Date | string
    createdBy: string
    updatedAt?: Date | string
    updatedBy: string
  }

  export type ChallengeEventUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    eventId?: IntFieldUpdateOperationsInput | number
    name?: NullableStringFieldUpdateOperationsInput | string | null
    key?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdBy?: StringFieldUpdateOperationsInput | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedBy?: StringFieldUpdateOperationsInput | string
    challenge?: ChallengeUpdateOneRequiredWithoutEventsNestedInput
  }

  export type ChallengeEventUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    challengeId?: StringFieldUpdateOperationsInput | string
    eventId?: IntFieldUpdateOperationsInput | number
    name?: NullableStringFieldUpdateOperationsInput | string | null
    key?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdBy?: StringFieldUpdateOperationsInput | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedBy?: StringFieldUpdateOperationsInput | string
  }

  export type ChallengeEventCreateManyInput = {
    id?: string
    challengeId: string
    eventId: number
    name?: string | null
    key?: string | null
    createdAt?: Date | string
    createdBy: string
    updatedAt?: Date | string
    updatedBy: string
  }

  export type ChallengeEventUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    eventId?: IntFieldUpdateOperationsInput | number
    name?: NullableStringFieldUpdateOperationsInput | string | null
    key?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdBy?: StringFieldUpdateOperationsInput | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedBy?: StringFieldUpdateOperationsInput | string
  }

  export type ChallengeEventUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    challengeId?: StringFieldUpdateOperationsInput | string
    eventId?: IntFieldUpdateOperationsInput | number
    name?: NullableStringFieldUpdateOperationsInput | string | null
    key?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdBy?: StringFieldUpdateOperationsInput | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedBy?: StringFieldUpdateOperationsInput | string
  }

  export type ChallengeDiscussionCreateInput = {
    id?: string
    discussionId?: string | null
    name: string
    type: $Enums.DiscussionTypeEnum
    provider: string
    url?: string | null
    createdAt?: Date | string
    createdBy: string
    updatedAt?: Date | string
    updatedBy: string
    challenge: ChallengeCreateNestedOneWithoutDiscussionsInput
    options?: ChallengeDiscussionOptionCreateNestedManyWithoutDiscussionInput
  }

  export type ChallengeDiscussionUncheckedCreateInput = {
    id?: string
    challengeId: string
    discussionId?: string | null
    name: string
    type: $Enums.DiscussionTypeEnum
    provider: string
    url?: string | null
    createdAt?: Date | string
    createdBy: string
    updatedAt?: Date | string
    updatedBy: string
    options?: ChallengeDiscussionOptionUncheckedCreateNestedManyWithoutDiscussionInput
  }

  export type ChallengeDiscussionUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    discussionId?: NullableStringFieldUpdateOperationsInput | string | null
    name?: StringFieldUpdateOperationsInput | string
    type?: EnumDiscussionTypeEnumFieldUpdateOperationsInput | $Enums.DiscussionTypeEnum
    provider?: StringFieldUpdateOperationsInput | string
    url?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdBy?: StringFieldUpdateOperationsInput | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedBy?: StringFieldUpdateOperationsInput | string
    challenge?: ChallengeUpdateOneRequiredWithoutDiscussionsNestedInput
    options?: ChallengeDiscussionOptionUpdateManyWithoutDiscussionNestedInput
  }

  export type ChallengeDiscussionUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    challengeId?: StringFieldUpdateOperationsInput | string
    discussionId?: NullableStringFieldUpdateOperationsInput | string | null
    name?: StringFieldUpdateOperationsInput | string
    type?: EnumDiscussionTypeEnumFieldUpdateOperationsInput | $Enums.DiscussionTypeEnum
    provider?: StringFieldUpdateOperationsInput | string
    url?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdBy?: StringFieldUpdateOperationsInput | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedBy?: StringFieldUpdateOperationsInput | string
    options?: ChallengeDiscussionOptionUncheckedUpdateManyWithoutDiscussionNestedInput
  }

  export type ChallengeDiscussionCreateManyInput = {
    id?: string
    challengeId: string
    discussionId?: string | null
    name: string
    type: $Enums.DiscussionTypeEnum
    provider: string
    url?: string | null
    createdAt?: Date | string
    createdBy: string
    updatedAt?: Date | string
    updatedBy: string
  }

  export type ChallengeDiscussionUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    discussionId?: NullableStringFieldUpdateOperationsInput | string | null
    name?: StringFieldUpdateOperationsInput | string
    type?: EnumDiscussionTypeEnumFieldUpdateOperationsInput | $Enums.DiscussionTypeEnum
    provider?: StringFieldUpdateOperationsInput | string
    url?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdBy?: StringFieldUpdateOperationsInput | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedBy?: StringFieldUpdateOperationsInput | string
  }

  export type ChallengeDiscussionUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    challengeId?: StringFieldUpdateOperationsInput | string
    discussionId?: NullableStringFieldUpdateOperationsInput | string | null
    name?: StringFieldUpdateOperationsInput | string
    type?: EnumDiscussionTypeEnumFieldUpdateOperationsInput | $Enums.DiscussionTypeEnum
    provider?: StringFieldUpdateOperationsInput | string
    url?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdBy?: StringFieldUpdateOperationsInput | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedBy?: StringFieldUpdateOperationsInput | string
  }

  export type ChallengeDiscussionOptionCreateInput = {
    id?: string
    optionKey: string
    optionValue: string
    createdAt?: Date | string
    createdBy: string
    updatedAt?: Date | string
    updatedBy: string
    discussion: ChallengeDiscussionCreateNestedOneWithoutOptionsInput
  }

  export type ChallengeDiscussionOptionUncheckedCreateInput = {
    id?: string
    discussionId: string
    optionKey: string
    optionValue: string
    createdAt?: Date | string
    createdBy: string
    updatedAt?: Date | string
    updatedBy: string
  }

  export type ChallengeDiscussionOptionUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    optionKey?: StringFieldUpdateOperationsInput | string
    optionValue?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdBy?: StringFieldUpdateOperationsInput | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedBy?: StringFieldUpdateOperationsInput | string
    discussion?: ChallengeDiscussionUpdateOneRequiredWithoutOptionsNestedInput
  }

  export type ChallengeDiscussionOptionUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    discussionId?: StringFieldUpdateOperationsInput | string
    optionKey?: StringFieldUpdateOperationsInput | string
    optionValue?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdBy?: StringFieldUpdateOperationsInput | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedBy?: StringFieldUpdateOperationsInput | string
  }

  export type ChallengeDiscussionOptionCreateManyInput = {
    id?: string
    discussionId: string
    optionKey: string
    optionValue: string
    createdAt?: Date | string
    createdBy: string
    updatedAt?: Date | string
    updatedBy: string
  }

  export type ChallengeDiscussionOptionUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    optionKey?: StringFieldUpdateOperationsInput | string
    optionValue?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdBy?: StringFieldUpdateOperationsInput | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedBy?: StringFieldUpdateOperationsInput | string
  }

  export type ChallengeDiscussionOptionUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    discussionId?: StringFieldUpdateOperationsInput | string
    optionKey?: StringFieldUpdateOperationsInput | string
    optionValue?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdBy?: StringFieldUpdateOperationsInput | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedBy?: StringFieldUpdateOperationsInput | string
  }

  export type ChallengeConstraintCreateInput = {
    id?: string
    allowedRegistrants?: ChallengeConstraintCreateallowedRegistrantsInput | string[]
    createdAt?: Date | string
    createdBy: string
    updatedAt?: Date | string
    updatedBy: string
    challenge: ChallengeCreateNestedOneWithoutConstraintRecordInput
  }

  export type ChallengeConstraintUncheckedCreateInput = {
    id?: string
    challengeId: string
    allowedRegistrants?: ChallengeConstraintCreateallowedRegistrantsInput | string[]
    createdAt?: Date | string
    createdBy: string
    updatedAt?: Date | string
    updatedBy: string
  }

  export type ChallengeConstraintUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    allowedRegistrants?: ChallengeConstraintUpdateallowedRegistrantsInput | string[]
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdBy?: StringFieldUpdateOperationsInput | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedBy?: StringFieldUpdateOperationsInput | string
    challenge?: ChallengeUpdateOneRequiredWithoutConstraintRecordNestedInput
  }

  export type ChallengeConstraintUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    challengeId?: StringFieldUpdateOperationsInput | string
    allowedRegistrants?: ChallengeConstraintUpdateallowedRegistrantsInput | string[]
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdBy?: StringFieldUpdateOperationsInput | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedBy?: StringFieldUpdateOperationsInput | string
  }

  export type ChallengeConstraintCreateManyInput = {
    id?: string
    challengeId: string
    allowedRegistrants?: ChallengeConstraintCreateallowedRegistrantsInput | string[]
    createdAt?: Date | string
    createdBy: string
    updatedAt?: Date | string
    updatedBy: string
  }

  export type ChallengeConstraintUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    allowedRegistrants?: ChallengeConstraintUpdateallowedRegistrantsInput | string[]
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdBy?: StringFieldUpdateOperationsInput | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedBy?: StringFieldUpdateOperationsInput | string
  }

  export type ChallengeConstraintUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    challengeId?: StringFieldUpdateOperationsInput | string
    allowedRegistrants?: ChallengeConstraintUpdateallowedRegistrantsInput | string[]
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdBy?: StringFieldUpdateOperationsInput | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedBy?: StringFieldUpdateOperationsInput | string
  }

  export type PhaseCreateInput = {
    id?: string
    name: string
    description?: string | null
    isOpen: boolean
    duration: number
    createdAt?: Date | string
    createdBy: string
    updatedAt?: Date | string
    updatedBy: string
    challengePhases?: ChallengePhaseCreateNestedManyWithoutPhaseInput
    ChallengeReviewer?: ChallengeReviewerCreateNestedManyWithoutPhaseInput
    DefaultChallengeReviewer?: DefaultChallengeReviewerCreateNestedManyWithoutPhaseInput
  }

  export type PhaseUncheckedCreateInput = {
    id?: string
    name: string
    description?: string | null
    isOpen: boolean
    duration: number
    createdAt?: Date | string
    createdBy: string
    updatedAt?: Date | string
    updatedBy: string
    challengePhases?: ChallengePhaseUncheckedCreateNestedManyWithoutPhaseInput
    ChallengeReviewer?: ChallengeReviewerUncheckedCreateNestedManyWithoutPhaseInput
    DefaultChallengeReviewer?: DefaultChallengeReviewerUncheckedCreateNestedManyWithoutPhaseInput
  }

  export type PhaseUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    isOpen?: BoolFieldUpdateOperationsInput | boolean
    duration?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdBy?: StringFieldUpdateOperationsInput | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedBy?: StringFieldUpdateOperationsInput | string
    challengePhases?: ChallengePhaseUpdateManyWithoutPhaseNestedInput
    ChallengeReviewer?: ChallengeReviewerUpdateManyWithoutPhaseNestedInput
    DefaultChallengeReviewer?: DefaultChallengeReviewerUpdateManyWithoutPhaseNestedInput
  }

  export type PhaseUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    isOpen?: BoolFieldUpdateOperationsInput | boolean
    duration?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdBy?: StringFieldUpdateOperationsInput | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedBy?: StringFieldUpdateOperationsInput | string
    challengePhases?: ChallengePhaseUncheckedUpdateManyWithoutPhaseNestedInput
    ChallengeReviewer?: ChallengeReviewerUncheckedUpdateManyWithoutPhaseNestedInput
    DefaultChallengeReviewer?: DefaultChallengeReviewerUncheckedUpdateManyWithoutPhaseNestedInput
  }

  export type PhaseCreateManyInput = {
    id?: string
    name: string
    description?: string | null
    isOpen: boolean
    duration: number
    createdAt?: Date | string
    createdBy: string
    updatedAt?: Date | string
    updatedBy: string
  }

  export type PhaseUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    isOpen?: BoolFieldUpdateOperationsInput | boolean
    duration?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdBy?: StringFieldUpdateOperationsInput | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedBy?: StringFieldUpdateOperationsInput | string
  }

  export type PhaseUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    isOpen?: BoolFieldUpdateOperationsInput | boolean
    duration?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdBy?: StringFieldUpdateOperationsInput | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedBy?: StringFieldUpdateOperationsInput | string
  }

  export type ChallengePhaseCreateInput = {
    id?: string
    name: string
    description?: string | null
    isOpen?: boolean | null
    predecessor?: string | null
    duration?: number | null
    scheduledStartDate?: Date | string | null
    scheduledEndDate?: Date | string | null
    actualStartDate?: Date | string | null
    actualEndDate?: Date | string | null
    createdAt?: Date | string
    createdBy: string
    updatedAt?: Date | string
    updatedBy: string
    constraints?: ChallengePhaseConstraintCreateNestedManyWithoutChallengePhaseInput
    challenge: ChallengeCreateNestedOneWithoutPhasesInput
    phase: PhaseCreateNestedOneWithoutChallengePhasesInput
  }

  export type ChallengePhaseUncheckedCreateInput = {
    id?: string
    challengeId: string
    phaseId: string
    name: string
    description?: string | null
    isOpen?: boolean | null
    predecessor?: string | null
    duration?: number | null
    scheduledStartDate?: Date | string | null
    scheduledEndDate?: Date | string | null
    actualStartDate?: Date | string | null
    actualEndDate?: Date | string | null
    createdAt?: Date | string
    createdBy: string
    updatedAt?: Date | string
    updatedBy: string
    constraints?: ChallengePhaseConstraintUncheckedCreateNestedManyWithoutChallengePhaseInput
  }

  export type ChallengePhaseUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    isOpen?: NullableBoolFieldUpdateOperationsInput | boolean | null
    predecessor?: NullableStringFieldUpdateOperationsInput | string | null
    duration?: NullableIntFieldUpdateOperationsInput | number | null
    scheduledStartDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    scheduledEndDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    actualStartDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    actualEndDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdBy?: StringFieldUpdateOperationsInput | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedBy?: StringFieldUpdateOperationsInput | string
    constraints?: ChallengePhaseConstraintUpdateManyWithoutChallengePhaseNestedInput
    challenge?: ChallengeUpdateOneRequiredWithoutPhasesNestedInput
    phase?: PhaseUpdateOneRequiredWithoutChallengePhasesNestedInput
  }

  export type ChallengePhaseUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    challengeId?: StringFieldUpdateOperationsInput | string
    phaseId?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    isOpen?: NullableBoolFieldUpdateOperationsInput | boolean | null
    predecessor?: NullableStringFieldUpdateOperationsInput | string | null
    duration?: NullableIntFieldUpdateOperationsInput | number | null
    scheduledStartDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    scheduledEndDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    actualStartDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    actualEndDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdBy?: StringFieldUpdateOperationsInput | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedBy?: StringFieldUpdateOperationsInput | string
    constraints?: ChallengePhaseConstraintUncheckedUpdateManyWithoutChallengePhaseNestedInput
  }

  export type ChallengePhaseCreateManyInput = {
    id?: string
    challengeId: string
    phaseId: string
    name: string
    description?: string | null
    isOpen?: boolean | null
    predecessor?: string | null
    duration?: number | null
    scheduledStartDate?: Date | string | null
    scheduledEndDate?: Date | string | null
    actualStartDate?: Date | string | null
    actualEndDate?: Date | string | null
    createdAt?: Date | string
    createdBy: string
    updatedAt?: Date | string
    updatedBy: string
  }

  export type ChallengePhaseUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    isOpen?: NullableBoolFieldUpdateOperationsInput | boolean | null
    predecessor?: NullableStringFieldUpdateOperationsInput | string | null
    duration?: NullableIntFieldUpdateOperationsInput | number | null
    scheduledStartDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    scheduledEndDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    actualStartDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    actualEndDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdBy?: StringFieldUpdateOperationsInput | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedBy?: StringFieldUpdateOperationsInput | string
  }

  export type ChallengePhaseUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    challengeId?: StringFieldUpdateOperationsInput | string
    phaseId?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    isOpen?: NullableBoolFieldUpdateOperationsInput | boolean | null
    predecessor?: NullableStringFieldUpdateOperationsInput | string | null
    duration?: NullableIntFieldUpdateOperationsInput | number | null
    scheduledStartDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    scheduledEndDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    actualStartDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    actualEndDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdBy?: StringFieldUpdateOperationsInput | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedBy?: StringFieldUpdateOperationsInput | string
  }

  export type ChallengePhaseConstraintCreateInput = {
    id?: string
    name: string
    value: number
    createdAt?: Date | string
    createdBy: string
    updatedAt?: Date | string
    updatedBy: string
    challengePhase: ChallengePhaseCreateNestedOneWithoutConstraintsInput
  }

  export type ChallengePhaseConstraintUncheckedCreateInput = {
    id?: string
    challengePhaseId: string
    name: string
    value: number
    createdAt?: Date | string
    createdBy: string
    updatedAt?: Date | string
    updatedBy: string
  }

  export type ChallengePhaseConstraintUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    value?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdBy?: StringFieldUpdateOperationsInput | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedBy?: StringFieldUpdateOperationsInput | string
    challengePhase?: ChallengePhaseUpdateOneRequiredWithoutConstraintsNestedInput
  }

  export type ChallengePhaseConstraintUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    challengePhaseId?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    value?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdBy?: StringFieldUpdateOperationsInput | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedBy?: StringFieldUpdateOperationsInput | string
  }

  export type ChallengePhaseConstraintCreateManyInput = {
    id?: string
    challengePhaseId: string
    name: string
    value: number
    createdAt?: Date | string
    createdBy: string
    updatedAt?: Date | string
    updatedBy: string
  }

  export type ChallengePhaseConstraintUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    value?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdBy?: StringFieldUpdateOperationsInput | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedBy?: StringFieldUpdateOperationsInput | string
  }

  export type ChallengePhaseConstraintUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    challengePhaseId?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    value?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdBy?: StringFieldUpdateOperationsInput | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedBy?: StringFieldUpdateOperationsInput | string
  }

  export type ChallengePrizeSetCreateInput = {
    id?: string
    type: $Enums.PrizeSetTypeEnum
    description?: string | null
    createdAt?: Date | string
    createdBy: string
    updatedAt?: Date | string
    updatedBy: string
    prizes?: PrizeCreateNestedManyWithoutPrizeSetInput
    challenge: ChallengeCreateNestedOneWithoutPrizeSetsInput
  }

  export type ChallengePrizeSetUncheckedCreateInput = {
    id?: string
    challengeId: string
    type: $Enums.PrizeSetTypeEnum
    description?: string | null
    createdAt?: Date | string
    createdBy: string
    updatedAt?: Date | string
    updatedBy: string
    prizes?: PrizeUncheckedCreateNestedManyWithoutPrizeSetInput
  }

  export type ChallengePrizeSetUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: EnumPrizeSetTypeEnumFieldUpdateOperationsInput | $Enums.PrizeSetTypeEnum
    description?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdBy?: StringFieldUpdateOperationsInput | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedBy?: StringFieldUpdateOperationsInput | string
    prizes?: PrizeUpdateManyWithoutPrizeSetNestedInput
    challenge?: ChallengeUpdateOneRequiredWithoutPrizeSetsNestedInput
  }

  export type ChallengePrizeSetUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    challengeId?: StringFieldUpdateOperationsInput | string
    type?: EnumPrizeSetTypeEnumFieldUpdateOperationsInput | $Enums.PrizeSetTypeEnum
    description?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdBy?: StringFieldUpdateOperationsInput | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedBy?: StringFieldUpdateOperationsInput | string
    prizes?: PrizeUncheckedUpdateManyWithoutPrizeSetNestedInput
  }

  export type ChallengePrizeSetCreateManyInput = {
    id?: string
    challengeId: string
    type: $Enums.PrizeSetTypeEnum
    description?: string | null
    createdAt?: Date | string
    createdBy: string
    updatedAt?: Date | string
    updatedBy: string
  }

  export type ChallengePrizeSetUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: EnumPrizeSetTypeEnumFieldUpdateOperationsInput | $Enums.PrizeSetTypeEnum
    description?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdBy?: StringFieldUpdateOperationsInput | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedBy?: StringFieldUpdateOperationsInput | string
  }

  export type ChallengePrizeSetUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    challengeId?: StringFieldUpdateOperationsInput | string
    type?: EnumPrizeSetTypeEnumFieldUpdateOperationsInput | $Enums.PrizeSetTypeEnum
    description?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdBy?: StringFieldUpdateOperationsInput | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedBy?: StringFieldUpdateOperationsInput | string
  }

  export type ChallengeReviewerCreateInput = {
    id?: string
    scorecardId: string
    isMemberReview: boolean
    memberReviewerCount?: number | null
    fixedAmount?: number | null
    baseCoefficient?: number | null
    incrementalCoefficient?: number | null
    type?: $Enums.ReviewOpportunityTypeEnum | null
    aiWorkflowId?: string | null
    shouldOpenOpportunity?: boolean
    createdAt?: Date | string
    createdBy: string
    updatedAt?: Date | string
    updatedBy: string
    challenge: ChallengeCreateNestedOneWithoutReviewersInput
    phase: PhaseCreateNestedOneWithoutChallengeReviewerInput
  }

  export type ChallengeReviewerUncheckedCreateInput = {
    id?: string
    challengeId: string
    scorecardId: string
    isMemberReview: boolean
    memberReviewerCount?: number | null
    phaseId: string
    fixedAmount?: number | null
    baseCoefficient?: number | null
    incrementalCoefficient?: number | null
    type?: $Enums.ReviewOpportunityTypeEnum | null
    aiWorkflowId?: string | null
    shouldOpenOpportunity?: boolean
    createdAt?: Date | string
    createdBy: string
    updatedAt?: Date | string
    updatedBy: string
  }

  export type ChallengeReviewerUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    scorecardId?: StringFieldUpdateOperationsInput | string
    isMemberReview?: BoolFieldUpdateOperationsInput | boolean
    memberReviewerCount?: NullableIntFieldUpdateOperationsInput | number | null
    fixedAmount?: NullableFloatFieldUpdateOperationsInput | number | null
    baseCoefficient?: NullableFloatFieldUpdateOperationsInput | number | null
    incrementalCoefficient?: NullableFloatFieldUpdateOperationsInput | number | null
    type?: NullableEnumReviewOpportunityTypeEnumFieldUpdateOperationsInput | $Enums.ReviewOpportunityTypeEnum | null
    aiWorkflowId?: NullableStringFieldUpdateOperationsInput | string | null
    shouldOpenOpportunity?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdBy?: StringFieldUpdateOperationsInput | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedBy?: StringFieldUpdateOperationsInput | string
    challenge?: ChallengeUpdateOneRequiredWithoutReviewersNestedInput
    phase?: PhaseUpdateOneRequiredWithoutChallengeReviewerNestedInput
  }

  export type ChallengeReviewerUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    challengeId?: StringFieldUpdateOperationsInput | string
    scorecardId?: StringFieldUpdateOperationsInput | string
    isMemberReview?: BoolFieldUpdateOperationsInput | boolean
    memberReviewerCount?: NullableIntFieldUpdateOperationsInput | number | null
    phaseId?: StringFieldUpdateOperationsInput | string
    fixedAmount?: NullableFloatFieldUpdateOperationsInput | number | null
    baseCoefficient?: NullableFloatFieldUpdateOperationsInput | number | null
    incrementalCoefficient?: NullableFloatFieldUpdateOperationsInput | number | null
    type?: NullableEnumReviewOpportunityTypeEnumFieldUpdateOperationsInput | $Enums.ReviewOpportunityTypeEnum | null
    aiWorkflowId?: NullableStringFieldUpdateOperationsInput | string | null
    shouldOpenOpportunity?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdBy?: StringFieldUpdateOperationsInput | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedBy?: StringFieldUpdateOperationsInput | string
  }

  export type ChallengeReviewerCreateManyInput = {
    id?: string
    challengeId: string
    scorecardId: string
    isMemberReview: boolean
    memberReviewerCount?: number | null
    phaseId: string
    fixedAmount?: number | null
    baseCoefficient?: number | null
    incrementalCoefficient?: number | null
    type?: $Enums.ReviewOpportunityTypeEnum | null
    aiWorkflowId?: string | null
    shouldOpenOpportunity?: boolean
    createdAt?: Date | string
    createdBy: string
    updatedAt?: Date | string
    updatedBy: string
  }

  export type ChallengeReviewerUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    scorecardId?: StringFieldUpdateOperationsInput | string
    isMemberReview?: BoolFieldUpdateOperationsInput | boolean
    memberReviewerCount?: NullableIntFieldUpdateOperationsInput | number | null
    fixedAmount?: NullableFloatFieldUpdateOperationsInput | number | null
    baseCoefficient?: NullableFloatFieldUpdateOperationsInput | number | null
    incrementalCoefficient?: NullableFloatFieldUpdateOperationsInput | number | null
    type?: NullableEnumReviewOpportunityTypeEnumFieldUpdateOperationsInput | $Enums.ReviewOpportunityTypeEnum | null
    aiWorkflowId?: NullableStringFieldUpdateOperationsInput | string | null
    shouldOpenOpportunity?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdBy?: StringFieldUpdateOperationsInput | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedBy?: StringFieldUpdateOperationsInput | string
  }

  export type ChallengeReviewerUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    challengeId?: StringFieldUpdateOperationsInput | string
    scorecardId?: StringFieldUpdateOperationsInput | string
    isMemberReview?: BoolFieldUpdateOperationsInput | boolean
    memberReviewerCount?: NullableIntFieldUpdateOperationsInput | number | null
    phaseId?: StringFieldUpdateOperationsInput | string
    fixedAmount?: NullableFloatFieldUpdateOperationsInput | number | null
    baseCoefficient?: NullableFloatFieldUpdateOperationsInput | number | null
    incrementalCoefficient?: NullableFloatFieldUpdateOperationsInput | number | null
    type?: NullableEnumReviewOpportunityTypeEnumFieldUpdateOperationsInput | $Enums.ReviewOpportunityTypeEnum | null
    aiWorkflowId?: NullableStringFieldUpdateOperationsInput | string | null
    shouldOpenOpportunity?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdBy?: StringFieldUpdateOperationsInput | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedBy?: StringFieldUpdateOperationsInput | string
  }

  export type DefaultChallengeReviewerCreateInput = {
    id?: string
    scorecardId?: string | null
    isMemberReview: boolean
    memberReviewerCount?: number | null
    phaseName: string
    fixedAmount?: number | null
    baseCoefficient?: number | null
    incrementalCoefficient?: number | null
    opportunityType?: $Enums.ReviewOpportunityTypeEnum | null
    aiWorkflowId?: string | null
    shouldOpenOpportunity?: boolean
    createdAt?: Date | string
    createdBy: string
    updatedAt?: Date | string
    updatedBy: string
    challengeType: ChallengeTypeCreateNestedOneWithoutDefaultReviewersInput
    challengeTrack: ChallengeTrackCreateNestedOneWithoutDefaultReviewersInput
    timelineTemplate?: TimelineTemplateCreateNestedOneWithoutDefaultChallengeReviewerInput
    phase?: PhaseCreateNestedOneWithoutDefaultChallengeReviewerInput
  }

  export type DefaultChallengeReviewerUncheckedCreateInput = {
    id?: string
    typeId: string
    trackId: string
    timelineTemplateId?: string | null
    scorecardId?: string | null
    isMemberReview: boolean
    memberReviewerCount?: number | null
    phaseName: string
    phaseId?: string | null
    fixedAmount?: number | null
    baseCoefficient?: number | null
    incrementalCoefficient?: number | null
    opportunityType?: $Enums.ReviewOpportunityTypeEnum | null
    aiWorkflowId?: string | null
    shouldOpenOpportunity?: boolean
    createdAt?: Date | string
    createdBy: string
    updatedAt?: Date | string
    updatedBy: string
  }

  export type DefaultChallengeReviewerUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    scorecardId?: NullableStringFieldUpdateOperationsInput | string | null
    isMemberReview?: BoolFieldUpdateOperationsInput | boolean
    memberReviewerCount?: NullableIntFieldUpdateOperationsInput | number | null
    phaseName?: StringFieldUpdateOperationsInput | string
    fixedAmount?: NullableFloatFieldUpdateOperationsInput | number | null
    baseCoefficient?: NullableFloatFieldUpdateOperationsInput | number | null
    incrementalCoefficient?: NullableFloatFieldUpdateOperationsInput | number | null
    opportunityType?: NullableEnumReviewOpportunityTypeEnumFieldUpdateOperationsInput | $Enums.ReviewOpportunityTypeEnum | null
    aiWorkflowId?: NullableStringFieldUpdateOperationsInput | string | null
    shouldOpenOpportunity?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdBy?: StringFieldUpdateOperationsInput | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedBy?: StringFieldUpdateOperationsInput | string
    challengeType?: ChallengeTypeUpdateOneRequiredWithoutDefaultReviewersNestedInput
    challengeTrack?: ChallengeTrackUpdateOneRequiredWithoutDefaultReviewersNestedInput
    timelineTemplate?: TimelineTemplateUpdateOneWithoutDefaultChallengeReviewerNestedInput
    phase?: PhaseUpdateOneWithoutDefaultChallengeReviewerNestedInput
  }

  export type DefaultChallengeReviewerUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    typeId?: StringFieldUpdateOperationsInput | string
    trackId?: StringFieldUpdateOperationsInput | string
    timelineTemplateId?: NullableStringFieldUpdateOperationsInput | string | null
    scorecardId?: NullableStringFieldUpdateOperationsInput | string | null
    isMemberReview?: BoolFieldUpdateOperationsInput | boolean
    memberReviewerCount?: NullableIntFieldUpdateOperationsInput | number | null
    phaseName?: StringFieldUpdateOperationsInput | string
    phaseId?: NullableStringFieldUpdateOperationsInput | string | null
    fixedAmount?: NullableFloatFieldUpdateOperationsInput | number | null
    baseCoefficient?: NullableFloatFieldUpdateOperationsInput | number | null
    incrementalCoefficient?: NullableFloatFieldUpdateOperationsInput | number | null
    opportunityType?: NullableEnumReviewOpportunityTypeEnumFieldUpdateOperationsInput | $Enums.ReviewOpportunityTypeEnum | null
    aiWorkflowId?: NullableStringFieldUpdateOperationsInput | string | null
    shouldOpenOpportunity?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdBy?: StringFieldUpdateOperationsInput | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedBy?: StringFieldUpdateOperationsInput | string
  }

  export type DefaultChallengeReviewerCreateManyInput = {
    id?: string
    typeId: string
    trackId: string
    timelineTemplateId?: string | null
    scorecardId?: string | null
    isMemberReview: boolean
    memberReviewerCount?: number | null
    phaseName: string
    phaseId?: string | null
    fixedAmount?: number | null
    baseCoefficient?: number | null
    incrementalCoefficient?: number | null
    opportunityType?: $Enums.ReviewOpportunityTypeEnum | null
    aiWorkflowId?: string | null
    shouldOpenOpportunity?: boolean
    createdAt?: Date | string
    createdBy: string
    updatedAt?: Date | string
    updatedBy: string
  }

  export type DefaultChallengeReviewerUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    scorecardId?: NullableStringFieldUpdateOperationsInput | string | null
    isMemberReview?: BoolFieldUpdateOperationsInput | boolean
    memberReviewerCount?: NullableIntFieldUpdateOperationsInput | number | null
    phaseName?: StringFieldUpdateOperationsInput | string
    fixedAmount?: NullableFloatFieldUpdateOperationsInput | number | null
    baseCoefficient?: NullableFloatFieldUpdateOperationsInput | number | null
    incrementalCoefficient?: NullableFloatFieldUpdateOperationsInput | number | null
    opportunityType?: NullableEnumReviewOpportunityTypeEnumFieldUpdateOperationsInput | $Enums.ReviewOpportunityTypeEnum | null
    aiWorkflowId?: NullableStringFieldUpdateOperationsInput | string | null
    shouldOpenOpportunity?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdBy?: StringFieldUpdateOperationsInput | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedBy?: StringFieldUpdateOperationsInput | string
  }

  export type DefaultChallengeReviewerUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    typeId?: StringFieldUpdateOperationsInput | string
    trackId?: StringFieldUpdateOperationsInput | string
    timelineTemplateId?: NullableStringFieldUpdateOperationsInput | string | null
    scorecardId?: NullableStringFieldUpdateOperationsInput | string | null
    isMemberReview?: BoolFieldUpdateOperationsInput | boolean
    memberReviewerCount?: NullableIntFieldUpdateOperationsInput | number | null
    phaseName?: StringFieldUpdateOperationsInput | string
    phaseId?: NullableStringFieldUpdateOperationsInput | string | null
    fixedAmount?: NullableFloatFieldUpdateOperationsInput | number | null
    baseCoefficient?: NullableFloatFieldUpdateOperationsInput | number | null
    incrementalCoefficient?: NullableFloatFieldUpdateOperationsInput | number | null
    opportunityType?: NullableEnumReviewOpportunityTypeEnumFieldUpdateOperationsInput | $Enums.ReviewOpportunityTypeEnum | null
    aiWorkflowId?: NullableStringFieldUpdateOperationsInput | string | null
    shouldOpenOpportunity?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdBy?: StringFieldUpdateOperationsInput | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedBy?: StringFieldUpdateOperationsInput | string
  }

  export type TimelineTemplateCreateInput = {
    id?: string
    name: string
    description?: string | null
    isActive?: boolean
    createdAt?: Date | string
    createdBy: string
    updatedAt?: Date | string
    updatedBy: string
    phases?: TimelineTemplatePhaseCreateNestedManyWithoutTimelineTemplateInput
    challengeTimelineTemplates?: ChallengeTimelineTemplateCreateNestedManyWithoutTimelineTemplateInput
    challenges?: ChallengeCreateNestedManyWithoutTimelineTemplateInput
    DefaultChallengeReviewer?: DefaultChallengeReviewerCreateNestedManyWithoutTimelineTemplateInput
  }

  export type TimelineTemplateUncheckedCreateInput = {
    id?: string
    name: string
    description?: string | null
    isActive?: boolean
    createdAt?: Date | string
    createdBy: string
    updatedAt?: Date | string
    updatedBy: string
    phases?: TimelineTemplatePhaseUncheckedCreateNestedManyWithoutTimelineTemplateInput
    challengeTimelineTemplates?: ChallengeTimelineTemplateUncheckedCreateNestedManyWithoutTimelineTemplateInput
    challenges?: ChallengeUncheckedCreateNestedManyWithoutTimelineTemplateInput
    DefaultChallengeReviewer?: DefaultChallengeReviewerUncheckedCreateNestedManyWithoutTimelineTemplateInput
  }

  export type TimelineTemplateUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdBy?: StringFieldUpdateOperationsInput | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedBy?: StringFieldUpdateOperationsInput | string
    phases?: TimelineTemplatePhaseUpdateManyWithoutTimelineTemplateNestedInput
    challengeTimelineTemplates?: ChallengeTimelineTemplateUpdateManyWithoutTimelineTemplateNestedInput
    challenges?: ChallengeUpdateManyWithoutTimelineTemplateNestedInput
    DefaultChallengeReviewer?: DefaultChallengeReviewerUpdateManyWithoutTimelineTemplateNestedInput
  }

  export type TimelineTemplateUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdBy?: StringFieldUpdateOperationsInput | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedBy?: StringFieldUpdateOperationsInput | string
    phases?: TimelineTemplatePhaseUncheckedUpdateManyWithoutTimelineTemplateNestedInput
    challengeTimelineTemplates?: ChallengeTimelineTemplateUncheckedUpdateManyWithoutTimelineTemplateNestedInput
    challenges?: ChallengeUncheckedUpdateManyWithoutTimelineTemplateNestedInput
    DefaultChallengeReviewer?: DefaultChallengeReviewerUncheckedUpdateManyWithoutTimelineTemplateNestedInput
  }

  export type TimelineTemplateCreateManyInput = {
    id?: string
    name: string
    description?: string | null
    isActive?: boolean
    createdAt?: Date | string
    createdBy: string
    updatedAt?: Date | string
    updatedBy: string
  }

  export type TimelineTemplateUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdBy?: StringFieldUpdateOperationsInput | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedBy?: StringFieldUpdateOperationsInput | string
  }

  export type TimelineTemplateUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdBy?: StringFieldUpdateOperationsInput | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedBy?: StringFieldUpdateOperationsInput | string
  }

  export type TimelineTemplatePhaseCreateInput = {
    id?: string
    phaseId: string
    predecessor?: string | null
    defaultDuration: number
    createdAt?: Date | string
    createdBy: string
    updatedAt?: Date | string
    updatedBy: string
    timelineTemplate: TimelineTemplateCreateNestedOneWithoutPhasesInput
  }

  export type TimelineTemplatePhaseUncheckedCreateInput = {
    id?: string
    timelineTemplateId: string
    phaseId: string
    predecessor?: string | null
    defaultDuration: number
    createdAt?: Date | string
    createdBy: string
    updatedAt?: Date | string
    updatedBy: string
  }

  export type TimelineTemplatePhaseUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    phaseId?: StringFieldUpdateOperationsInput | string
    predecessor?: NullableStringFieldUpdateOperationsInput | string | null
    defaultDuration?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdBy?: StringFieldUpdateOperationsInput | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedBy?: StringFieldUpdateOperationsInput | string
    timelineTemplate?: TimelineTemplateUpdateOneRequiredWithoutPhasesNestedInput
  }

  export type TimelineTemplatePhaseUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    timelineTemplateId?: StringFieldUpdateOperationsInput | string
    phaseId?: StringFieldUpdateOperationsInput | string
    predecessor?: NullableStringFieldUpdateOperationsInput | string | null
    defaultDuration?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdBy?: StringFieldUpdateOperationsInput | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedBy?: StringFieldUpdateOperationsInput | string
  }

  export type TimelineTemplatePhaseCreateManyInput = {
    id?: string
    timelineTemplateId: string
    phaseId: string
    predecessor?: string | null
    defaultDuration: number
    createdAt?: Date | string
    createdBy: string
    updatedAt?: Date | string
    updatedBy: string
  }

  export type TimelineTemplatePhaseUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    phaseId?: StringFieldUpdateOperationsInput | string
    predecessor?: NullableStringFieldUpdateOperationsInput | string | null
    defaultDuration?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdBy?: StringFieldUpdateOperationsInput | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedBy?: StringFieldUpdateOperationsInput | string
  }

  export type TimelineTemplatePhaseUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    timelineTemplateId?: StringFieldUpdateOperationsInput | string
    phaseId?: StringFieldUpdateOperationsInput | string
    predecessor?: NullableStringFieldUpdateOperationsInput | string | null
    defaultDuration?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdBy?: StringFieldUpdateOperationsInput | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedBy?: StringFieldUpdateOperationsInput | string
  }

  export type StringFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    search?: string
    mode?: QueryMode
    not?: NestedStringFilter<$PrismaModel> | string
  }

  export type StringNullableFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    search?: string
    mode?: QueryMode
    not?: NestedStringNullableFilter<$PrismaModel> | string | null
  }

  export type IntNullableFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableFilter<$PrismaModel> | number | null
  }

  export type FloatNullableFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel> | null
    in?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatNullableFilter<$PrismaModel> | number | null
  }

  export type IntFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[] | ListIntFieldRefInput<$PrismaModel>
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntFilter<$PrismaModel> | number
  }

  export type StringNullableListFilter<$PrismaModel = never> = {
    equals?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    has?: string | StringFieldRefInput<$PrismaModel> | null
    hasEvery?: string[] | ListStringFieldRefInput<$PrismaModel>
    hasSome?: string[] | ListStringFieldRefInput<$PrismaModel>
    isEmpty?: boolean
  }

  export type BoolFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolFilter<$PrismaModel> | boolean
  }

  export type DateTimeNullableFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableFilter<$PrismaModel> | Date | string | null
  }

  export type EnumChallengeStatusEnumFilter<$PrismaModel = never> = {
    equals?: $Enums.ChallengeStatusEnum | EnumChallengeStatusEnumFieldRefInput<$PrismaModel>
    in?: $Enums.ChallengeStatusEnum[] | ListEnumChallengeStatusEnumFieldRefInput<$PrismaModel>
    notIn?: $Enums.ChallengeStatusEnum[] | ListEnumChallengeStatusEnumFieldRefInput<$PrismaModel>
    not?: NestedEnumChallengeStatusEnumFilter<$PrismaModel> | $Enums.ChallengeStatusEnum
  }

  export type DateTimeFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeFilter<$PrismaModel> | Date | string
  }

  export type ChallengeBillingNullableScalarRelationFilter = {
    is?: ChallengeBillingWhereInput | null
    isNot?: ChallengeBillingWhereInput | null
  }

  export type ChallengeLegacyNullableScalarRelationFilter = {
    is?: ChallengeLegacyWhereInput | null
    isNot?: ChallengeLegacyWhereInput | null
  }

  export type ChallengeConstraintNullableScalarRelationFilter = {
    is?: ChallengeConstraintWhereInput | null
    isNot?: ChallengeConstraintWhereInput | null
  }

  export type ChallengeEventListRelationFilter = {
    every?: ChallengeEventWhereInput
    some?: ChallengeEventWhereInput
    none?: ChallengeEventWhereInput
  }

  export type ChallengeDiscussionListRelationFilter = {
    every?: ChallengeDiscussionWhereInput
    some?: ChallengeDiscussionWhereInput
    none?: ChallengeDiscussionWhereInput
  }

  export type ChallengeMetadataListRelationFilter = {
    every?: ChallengeMetadataWhereInput
    some?: ChallengeMetadataWhereInput
    none?: ChallengeMetadataWhereInput
  }

  export type ChallengePhaseListRelationFilter = {
    every?: ChallengePhaseWhereInput
    some?: ChallengePhaseWhereInput
    none?: ChallengePhaseWhereInput
  }

  export type ChallengePrizeSetListRelationFilter = {
    every?: ChallengePrizeSetWhereInput
    some?: ChallengePrizeSetWhereInput
    none?: ChallengePrizeSetWhereInput
  }

  export type ChallengeReviewerListRelationFilter = {
    every?: ChallengeReviewerWhereInput
    some?: ChallengeReviewerWhereInput
    none?: ChallengeReviewerWhereInput
  }

  export type ChallengeWinnerListRelationFilter = {
    every?: ChallengeWinnerWhereInput
    some?: ChallengeWinnerWhereInput
    none?: ChallengeWinnerWhereInput
  }

  export type AttachmentListRelationFilter = {
    every?: AttachmentWhereInput
    some?: AttachmentWhereInput
    none?: AttachmentWhereInput
  }

  export type ChallengeTermListRelationFilter = {
    every?: ChallengeTermWhereInput
    some?: ChallengeTermWhereInput
    none?: ChallengeTermWhereInput
  }

  export type ChallengeSkillListRelationFilter = {
    every?: ChallengeSkillWhereInput
    some?: ChallengeSkillWhereInput
    none?: ChallengeSkillWhereInput
  }

  export type AuditLogListRelationFilter = {
    every?: AuditLogWhereInput
    some?: AuditLogWhereInput
    none?: AuditLogWhereInput
  }

  export type MemberChallengeAccessListRelationFilter = {
    every?: MemberChallengeAccessWhereInput
    some?: MemberChallengeAccessWhereInput
    none?: MemberChallengeAccessWhereInput
  }

  export type ChallengeTypeScalarRelationFilter = {
    is?: ChallengeTypeWhereInput
    isNot?: ChallengeTypeWhereInput
  }

  export type ChallengeTrackScalarRelationFilter = {
    is?: ChallengeTrackWhereInput
    isNot?: ChallengeTrackWhereInput
  }

  export type TimelineTemplateNullableScalarRelationFilter = {
    is?: TimelineTemplateWhereInput | null
    isNot?: TimelineTemplateWhereInput | null
  }

  export type SortOrderInput = {
    sort: SortOrder
    nulls?: NullsOrder
  }

  export type ChallengeEventOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type ChallengeDiscussionOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type ChallengeMetadataOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type ChallengePhaseOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type ChallengePrizeSetOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type ChallengeReviewerOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type ChallengeWinnerOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type AttachmentOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type ChallengeTermOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type ChallengeSkillOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type AuditLogOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type MemberChallengeAccessOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type ChallengeOrderByRelevanceInput = {
    fields: ChallengeOrderByRelevanceFieldEnum | ChallengeOrderByRelevanceFieldEnum[]
    sort: SortOrder
    search: string
  }

  export type ChallengeCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrder
    privateDescription?: SortOrder
    challengeSource?: SortOrder
    descriptionFormat?: SortOrder
    projectId?: SortOrder
    typeId?: SortOrder
    trackId?: SortOrder
    timelineTemplateId?: SortOrder
    overviewTotalPrizes?: SortOrder
    numOfRegistrants?: SortOrder
    numOfSubmissions?: SortOrder
    numOfCheckpointSubmissions?: SortOrder
    currentPhaseNames?: SortOrder
    wiproAllowed?: SortOrder
    tags?: SortOrder
    groups?: SortOrder
    taskIsTask?: SortOrder
    taskIsAssigned?: SortOrder
    taskMemberId?: SortOrder
    submissionStartDate?: SortOrder
    submissionEndDate?: SortOrder
    registrationStartDate?: SortOrder
    registrationEndDate?: SortOrder
    startDate?: SortOrder
    endDate?: SortOrder
    legacyId?: SortOrder
    status?: SortOrder
    createdAt?: SortOrder
    createdBy?: SortOrder
    updatedAt?: SortOrder
    updatedBy?: SortOrder
  }

  export type ChallengeAvgOrderByAggregateInput = {
    projectId?: SortOrder
    overviewTotalPrizes?: SortOrder
    numOfRegistrants?: SortOrder
    numOfSubmissions?: SortOrder
    numOfCheckpointSubmissions?: SortOrder
    legacyId?: SortOrder
  }

  export type ChallengeMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrder
    privateDescription?: SortOrder
    challengeSource?: SortOrder
    descriptionFormat?: SortOrder
    projectId?: SortOrder
    typeId?: SortOrder
    trackId?: SortOrder
    timelineTemplateId?: SortOrder
    overviewTotalPrizes?: SortOrder
    numOfRegistrants?: SortOrder
    numOfSubmissions?: SortOrder
    numOfCheckpointSubmissions?: SortOrder
    wiproAllowed?: SortOrder
    taskIsTask?: SortOrder
    taskIsAssigned?: SortOrder
    taskMemberId?: SortOrder
    submissionStartDate?: SortOrder
    submissionEndDate?: SortOrder
    registrationStartDate?: SortOrder
    registrationEndDate?: SortOrder
    startDate?: SortOrder
    endDate?: SortOrder
    legacyId?: SortOrder
    status?: SortOrder
    createdAt?: SortOrder
    createdBy?: SortOrder
    updatedAt?: SortOrder
    updatedBy?: SortOrder
  }

  export type ChallengeMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrder
    privateDescription?: SortOrder
    challengeSource?: SortOrder
    descriptionFormat?: SortOrder
    projectId?: SortOrder
    typeId?: SortOrder
    trackId?: SortOrder
    timelineTemplateId?: SortOrder
    overviewTotalPrizes?: SortOrder
    numOfRegistrants?: SortOrder
    numOfSubmissions?: SortOrder
    numOfCheckpointSubmissions?: SortOrder
    wiproAllowed?: SortOrder
    taskIsTask?: SortOrder
    taskIsAssigned?: SortOrder
    taskMemberId?: SortOrder
    submissionStartDate?: SortOrder
    submissionEndDate?: SortOrder
    registrationStartDate?: SortOrder
    registrationEndDate?: SortOrder
    startDate?: SortOrder
    endDate?: SortOrder
    legacyId?: SortOrder
    status?: SortOrder
    createdAt?: SortOrder
    createdBy?: SortOrder
    updatedAt?: SortOrder
    updatedBy?: SortOrder
  }

  export type ChallengeSumOrderByAggregateInput = {
    projectId?: SortOrder
    overviewTotalPrizes?: SortOrder
    numOfRegistrants?: SortOrder
    numOfSubmissions?: SortOrder
    numOfCheckpointSubmissions?: SortOrder
    legacyId?: SortOrder
  }

  export type StringWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    search?: string
    mode?: QueryMode
    not?: NestedStringWithAggregatesFilter<$PrismaModel> | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedStringFilter<$PrismaModel>
    _max?: NestedStringFilter<$PrismaModel>
  }

  export type StringNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    search?: string
    mode?: QueryMode
    not?: NestedStringNullableWithAggregatesFilter<$PrismaModel> | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedStringNullableFilter<$PrismaModel>
    _max?: NestedStringNullableFilter<$PrismaModel>
  }

  export type IntNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableWithAggregatesFilter<$PrismaModel> | number | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedFloatNullableFilter<$PrismaModel>
    _sum?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedIntNullableFilter<$PrismaModel>
    _max?: NestedIntNullableFilter<$PrismaModel>
  }

  export type FloatNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel> | null
    in?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatNullableWithAggregatesFilter<$PrismaModel> | number | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedFloatNullableFilter<$PrismaModel>
    _sum?: NestedFloatNullableFilter<$PrismaModel>
    _min?: NestedFloatNullableFilter<$PrismaModel>
    _max?: NestedFloatNullableFilter<$PrismaModel>
  }

  export type IntWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[] | ListIntFieldRefInput<$PrismaModel>
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntWithAggregatesFilter<$PrismaModel> | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedIntFilter<$PrismaModel>
    _min?: NestedIntFilter<$PrismaModel>
    _max?: NestedIntFilter<$PrismaModel>
  }

  export type BoolWithAggregatesFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolWithAggregatesFilter<$PrismaModel> | boolean
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedBoolFilter<$PrismaModel>
    _max?: NestedBoolFilter<$PrismaModel>
  }

  export type DateTimeNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableWithAggregatesFilter<$PrismaModel> | Date | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedDateTimeNullableFilter<$PrismaModel>
    _max?: NestedDateTimeNullableFilter<$PrismaModel>
  }

  export type EnumChallengeStatusEnumWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.ChallengeStatusEnum | EnumChallengeStatusEnumFieldRefInput<$PrismaModel>
    in?: $Enums.ChallengeStatusEnum[] | ListEnumChallengeStatusEnumFieldRefInput<$PrismaModel>
    notIn?: $Enums.ChallengeStatusEnum[] | ListEnumChallengeStatusEnumFieldRefInput<$PrismaModel>
    not?: NestedEnumChallengeStatusEnumWithAggregatesFilter<$PrismaModel> | $Enums.ChallengeStatusEnum
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumChallengeStatusEnumFilter<$PrismaModel>
    _max?: NestedEnumChallengeStatusEnumFilter<$PrismaModel>
  }

  export type DateTimeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeWithAggregatesFilter<$PrismaModel> | Date | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedDateTimeFilter<$PrismaModel>
    _max?: NestedDateTimeFilter<$PrismaModel>
  }

  export type ChallengeListRelationFilter = {
    every?: ChallengeWhereInput
    some?: ChallengeWhereInput
    none?: ChallengeWhereInput
  }

  export type ChallengeTimelineTemplateListRelationFilter = {
    every?: ChallengeTimelineTemplateWhereInput
    some?: ChallengeTimelineTemplateWhereInput
    none?: ChallengeTimelineTemplateWhereInput
  }

  export type DefaultChallengeReviewerListRelationFilter = {
    every?: DefaultChallengeReviewerWhereInput
    some?: DefaultChallengeReviewerWhereInput
    none?: DefaultChallengeReviewerWhereInput
  }

  export type ChallengeOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type ChallengeTimelineTemplateOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type DefaultChallengeReviewerOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type ChallengeTypeOrderByRelevanceInput = {
    fields: ChallengeTypeOrderByRelevanceFieldEnum | ChallengeTypeOrderByRelevanceFieldEnum[]
    sort: SortOrder
    search: string
  }

  export type ChallengeTypeCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrder
    isActive?: SortOrder
    isTask?: SortOrder
    abbreviation?: SortOrder
    createdAt?: SortOrder
    createdBy?: SortOrder
    updatedAt?: SortOrder
    updatedBy?: SortOrder
  }

  export type ChallengeTypeMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrder
    isActive?: SortOrder
    isTask?: SortOrder
    abbreviation?: SortOrder
    createdAt?: SortOrder
    createdBy?: SortOrder
    updatedAt?: SortOrder
    updatedBy?: SortOrder
  }

  export type ChallengeTypeMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrder
    isActive?: SortOrder
    isTask?: SortOrder
    abbreviation?: SortOrder
    createdAt?: SortOrder
    createdBy?: SortOrder
    updatedAt?: SortOrder
    updatedBy?: SortOrder
  }

  export type EnumChallengeTrackEnumNullableFilter<$PrismaModel = never> = {
    equals?: $Enums.ChallengeTrackEnum | EnumChallengeTrackEnumFieldRefInput<$PrismaModel> | null
    in?: $Enums.ChallengeTrackEnum[] | ListEnumChallengeTrackEnumFieldRefInput<$PrismaModel> | null
    notIn?: $Enums.ChallengeTrackEnum[] | ListEnumChallengeTrackEnumFieldRefInput<$PrismaModel> | null
    not?: NestedEnumChallengeTrackEnumNullableFilter<$PrismaModel> | $Enums.ChallengeTrackEnum | null
  }

  export type ChallengeTrackOrderByRelevanceInput = {
    fields: ChallengeTrackOrderByRelevanceFieldEnum | ChallengeTrackOrderByRelevanceFieldEnum[]
    sort: SortOrder
    search: string
  }

  export type ChallengeTrackCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrder
    isActive?: SortOrder
    abbreviation?: SortOrder
    legacyId?: SortOrder
    track?: SortOrder
    createdAt?: SortOrder
    createdBy?: SortOrder
    updatedAt?: SortOrder
    updatedBy?: SortOrder
  }

  export type ChallengeTrackAvgOrderByAggregateInput = {
    legacyId?: SortOrder
  }

  export type ChallengeTrackMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrder
    isActive?: SortOrder
    abbreviation?: SortOrder
    legacyId?: SortOrder
    track?: SortOrder
    createdAt?: SortOrder
    createdBy?: SortOrder
    updatedAt?: SortOrder
    updatedBy?: SortOrder
  }

  export type ChallengeTrackMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrder
    isActive?: SortOrder
    abbreviation?: SortOrder
    legacyId?: SortOrder
    track?: SortOrder
    createdAt?: SortOrder
    createdBy?: SortOrder
    updatedAt?: SortOrder
    updatedBy?: SortOrder
  }

  export type ChallengeTrackSumOrderByAggregateInput = {
    legacyId?: SortOrder
  }

  export type EnumChallengeTrackEnumNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.ChallengeTrackEnum | EnumChallengeTrackEnumFieldRefInput<$PrismaModel> | null
    in?: $Enums.ChallengeTrackEnum[] | ListEnumChallengeTrackEnumFieldRefInput<$PrismaModel> | null
    notIn?: $Enums.ChallengeTrackEnum[] | ListEnumChallengeTrackEnumFieldRefInput<$PrismaModel> | null
    not?: NestedEnumChallengeTrackEnumNullableWithAggregatesFilter<$PrismaModel> | $Enums.ChallengeTrackEnum | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedEnumChallengeTrackEnumNullableFilter<$PrismaModel>
    _max?: NestedEnumChallengeTrackEnumNullableFilter<$PrismaModel>
  }

  export type TimelineTemplateScalarRelationFilter = {
    is?: TimelineTemplateWhereInput
    isNot?: TimelineTemplateWhereInput
  }

  export type ChallengeTimelineTemplateOrderByRelevanceInput = {
    fields: ChallengeTimelineTemplateOrderByRelevanceFieldEnum | ChallengeTimelineTemplateOrderByRelevanceFieldEnum[]
    sort: SortOrder
    search: string
  }

  export type ChallengeTimelineTemplateCountOrderByAggregateInput = {
    id?: SortOrder
    typeId?: SortOrder
    trackId?: SortOrder
    timelineTemplateId?: SortOrder
    isDefault?: SortOrder
    createdAt?: SortOrder
    createdBy?: SortOrder
    updatedAt?: SortOrder
    updatedBy?: SortOrder
  }

  export type ChallengeTimelineTemplateMaxOrderByAggregateInput = {
    id?: SortOrder
    typeId?: SortOrder
    trackId?: SortOrder
    timelineTemplateId?: SortOrder
    isDefault?: SortOrder
    createdAt?: SortOrder
    createdBy?: SortOrder
    updatedAt?: SortOrder
    updatedBy?: SortOrder
  }

  export type ChallengeTimelineTemplateMinOrderByAggregateInput = {
    id?: SortOrder
    typeId?: SortOrder
    trackId?: SortOrder
    timelineTemplateId?: SortOrder
    isDefault?: SortOrder
    createdAt?: SortOrder
    createdBy?: SortOrder
    updatedAt?: SortOrder
    updatedBy?: SortOrder
  }

  export type ChallengeNullableScalarRelationFilter = {
    is?: ChallengeWhereInput | null
    isNot?: ChallengeWhereInput | null
  }

  export type AuditLogOrderByRelevanceInput = {
    fields: AuditLogOrderByRelevanceFieldEnum | AuditLogOrderByRelevanceFieldEnum[]
    sort: SortOrder
    search: string
  }

  export type AuditLogCountOrderByAggregateInput = {
    id?: SortOrder
    challengeId?: SortOrder
    fieldName?: SortOrder
    oldValue?: SortOrder
    newValue?: SortOrder
    createdAt?: SortOrder
    createdBy?: SortOrder
    memberId?: SortOrder
  }

  export type AuditLogMaxOrderByAggregateInput = {
    id?: SortOrder
    challengeId?: SortOrder
    fieldName?: SortOrder
    oldValue?: SortOrder
    newValue?: SortOrder
    createdAt?: SortOrder
    createdBy?: SortOrder
    memberId?: SortOrder
  }

  export type AuditLogMinOrderByAggregateInput = {
    id?: SortOrder
    challengeId?: SortOrder
    fieldName?: SortOrder
    oldValue?: SortOrder
    newValue?: SortOrder
    createdAt?: SortOrder
    createdBy?: SortOrder
    memberId?: SortOrder
  }

  export type ChallengeScalarRelationFilter = {
    is?: ChallengeWhereInput
    isNot?: ChallengeWhereInput
  }

  export type AttachmentOrderByRelevanceInput = {
    fields: AttachmentOrderByRelevanceFieldEnum | AttachmentOrderByRelevanceFieldEnum[]
    sort: SortOrder
    search: string
  }

  export type AttachmentCountOrderByAggregateInput = {
    id?: SortOrder
    challengeId?: SortOrder
    name?: SortOrder
    fileSize?: SortOrder
    url?: SortOrder
    description?: SortOrder
    createdAt?: SortOrder
    createdBy?: SortOrder
    updatedAt?: SortOrder
    updatedBy?: SortOrder
  }

  export type AttachmentAvgOrderByAggregateInput = {
    fileSize?: SortOrder
  }

  export type AttachmentMaxOrderByAggregateInput = {
    id?: SortOrder
    challengeId?: SortOrder
    name?: SortOrder
    fileSize?: SortOrder
    url?: SortOrder
    description?: SortOrder
    createdAt?: SortOrder
    createdBy?: SortOrder
    updatedAt?: SortOrder
    updatedBy?: SortOrder
  }

  export type AttachmentMinOrderByAggregateInput = {
    id?: SortOrder
    challengeId?: SortOrder
    name?: SortOrder
    fileSize?: SortOrder
    url?: SortOrder
    description?: SortOrder
    createdAt?: SortOrder
    createdBy?: SortOrder
    updatedAt?: SortOrder
    updatedBy?: SortOrder
  }

  export type AttachmentSumOrderByAggregateInput = {
    fileSize?: SortOrder
  }

  export type ChallengeMetadataOrderByRelevanceInput = {
    fields: ChallengeMetadataOrderByRelevanceFieldEnum | ChallengeMetadataOrderByRelevanceFieldEnum[]
    sort: SortOrder
    search: string
  }

  export type ChallengeMetadataCountOrderByAggregateInput = {
    id?: SortOrder
    challengeId?: SortOrder
    name?: SortOrder
    value?: SortOrder
    createdAt?: SortOrder
    createdBy?: SortOrder
    updatedAt?: SortOrder
    updatedBy?: SortOrder
  }

  export type ChallengeMetadataMaxOrderByAggregateInput = {
    id?: SortOrder
    challengeId?: SortOrder
    name?: SortOrder
    value?: SortOrder
    createdAt?: SortOrder
    createdBy?: SortOrder
    updatedAt?: SortOrder
    updatedBy?: SortOrder
  }

  export type ChallengeMetadataMinOrderByAggregateInput = {
    id?: SortOrder
    challengeId?: SortOrder
    name?: SortOrder
    value?: SortOrder
    createdAt?: SortOrder
    createdBy?: SortOrder
    updatedAt?: SortOrder
    updatedBy?: SortOrder
  }

  export type FloatFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel>
    in?: number[] | ListFloatFieldRefInput<$PrismaModel>
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel>
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatFilter<$PrismaModel> | number
  }

  export type ChallengePrizeSetScalarRelationFilter = {
    is?: ChallengePrizeSetWhereInput
    isNot?: ChallengePrizeSetWhereInput
  }

  export type PrizeOrderByRelevanceInput = {
    fields: PrizeOrderByRelevanceFieldEnum | PrizeOrderByRelevanceFieldEnum[]
    sort: SortOrder
    search: string
  }

  export type PrizeCountOrderByAggregateInput = {
    id?: SortOrder
    description?: SortOrder
    prizeSetId?: SortOrder
    type?: SortOrder
    value?: SortOrder
    createdAt?: SortOrder
    createdBy?: SortOrder
    updatedAt?: SortOrder
    updatedBy?: SortOrder
  }

  export type PrizeAvgOrderByAggregateInput = {
    value?: SortOrder
  }

  export type PrizeMaxOrderByAggregateInput = {
    id?: SortOrder
    description?: SortOrder
    prizeSetId?: SortOrder
    type?: SortOrder
    value?: SortOrder
    createdAt?: SortOrder
    createdBy?: SortOrder
    updatedAt?: SortOrder
    updatedBy?: SortOrder
  }

  export type PrizeMinOrderByAggregateInput = {
    id?: SortOrder
    description?: SortOrder
    prizeSetId?: SortOrder
    type?: SortOrder
    value?: SortOrder
    createdAt?: SortOrder
    createdBy?: SortOrder
    updatedAt?: SortOrder
    updatedBy?: SortOrder
  }

  export type PrizeSumOrderByAggregateInput = {
    value?: SortOrder
  }

  export type FloatWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel>
    in?: number[] | ListFloatFieldRefInput<$PrismaModel>
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel>
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatWithAggregatesFilter<$PrismaModel> | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedFloatFilter<$PrismaModel>
    _min?: NestedFloatFilter<$PrismaModel>
    _max?: NestedFloatFilter<$PrismaModel>
  }

  export type EnumPrizeSetTypeEnumFilter<$PrismaModel = never> = {
    equals?: $Enums.PrizeSetTypeEnum | EnumPrizeSetTypeEnumFieldRefInput<$PrismaModel>
    in?: $Enums.PrizeSetTypeEnum[] | ListEnumPrizeSetTypeEnumFieldRefInput<$PrismaModel>
    notIn?: $Enums.PrizeSetTypeEnum[] | ListEnumPrizeSetTypeEnumFieldRefInput<$PrismaModel>
    not?: NestedEnumPrizeSetTypeEnumFilter<$PrismaModel> | $Enums.PrizeSetTypeEnum
  }

  export type ChallengeWinnerOrderByRelevanceInput = {
    fields: ChallengeWinnerOrderByRelevanceFieldEnum | ChallengeWinnerOrderByRelevanceFieldEnum[]
    sort: SortOrder
    search: string
  }

  export type ChallengeWinnerCountOrderByAggregateInput = {
    id?: SortOrder
    challengeId?: SortOrder
    userId?: SortOrder
    handle?: SortOrder
    placement?: SortOrder
    type?: SortOrder
    createdAt?: SortOrder
    createdBy?: SortOrder
    updatedAt?: SortOrder
    updatedBy?: SortOrder
  }

  export type ChallengeWinnerAvgOrderByAggregateInput = {
    userId?: SortOrder
    placement?: SortOrder
  }

  export type ChallengeWinnerMaxOrderByAggregateInput = {
    id?: SortOrder
    challengeId?: SortOrder
    userId?: SortOrder
    handle?: SortOrder
    placement?: SortOrder
    type?: SortOrder
    createdAt?: SortOrder
    createdBy?: SortOrder
    updatedAt?: SortOrder
    updatedBy?: SortOrder
  }

  export type ChallengeWinnerMinOrderByAggregateInput = {
    id?: SortOrder
    challengeId?: SortOrder
    userId?: SortOrder
    handle?: SortOrder
    placement?: SortOrder
    type?: SortOrder
    createdAt?: SortOrder
    createdBy?: SortOrder
    updatedAt?: SortOrder
    updatedBy?: SortOrder
  }

  export type ChallengeWinnerSumOrderByAggregateInput = {
    userId?: SortOrder
    placement?: SortOrder
  }

  export type EnumPrizeSetTypeEnumWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.PrizeSetTypeEnum | EnumPrizeSetTypeEnumFieldRefInput<$PrismaModel>
    in?: $Enums.PrizeSetTypeEnum[] | ListEnumPrizeSetTypeEnumFieldRefInput<$PrismaModel>
    notIn?: $Enums.PrizeSetTypeEnum[] | ListEnumPrizeSetTypeEnumFieldRefInput<$PrismaModel>
    not?: NestedEnumPrizeSetTypeEnumWithAggregatesFilter<$PrismaModel> | $Enums.PrizeSetTypeEnum
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumPrizeSetTypeEnumFilter<$PrismaModel>
    _max?: NestedEnumPrizeSetTypeEnumFilter<$PrismaModel>
  }

  export type ChallengeTermOrderByRelevanceInput = {
    fields: ChallengeTermOrderByRelevanceFieldEnum | ChallengeTermOrderByRelevanceFieldEnum[]
    sort: SortOrder
    search: string
  }

  export type ChallengeTermCountOrderByAggregateInput = {
    id?: SortOrder
    challengeId?: SortOrder
    termId?: SortOrder
    roleId?: SortOrder
    createdAt?: SortOrder
    createdBy?: SortOrder
    updatedAt?: SortOrder
    updatedBy?: SortOrder
  }

  export type ChallengeTermMaxOrderByAggregateInput = {
    id?: SortOrder
    challengeId?: SortOrder
    termId?: SortOrder
    roleId?: SortOrder
    createdAt?: SortOrder
    createdBy?: SortOrder
    updatedAt?: SortOrder
    updatedBy?: SortOrder
  }

  export type ChallengeTermMinOrderByAggregateInput = {
    id?: SortOrder
    challengeId?: SortOrder
    termId?: SortOrder
    roleId?: SortOrder
    createdAt?: SortOrder
    createdBy?: SortOrder
    updatedAt?: SortOrder
    updatedBy?: SortOrder
  }

  export type ChallengeSkillOrderByRelevanceInput = {
    fields: ChallengeSkillOrderByRelevanceFieldEnum | ChallengeSkillOrderByRelevanceFieldEnum[]
    sort: SortOrder
    search: string
  }

  export type ChallengeSkillCountOrderByAggregateInput = {
    id?: SortOrder
    challengeId?: SortOrder
    skillId?: SortOrder
    createdAt?: SortOrder
    createdBy?: SortOrder
    updatedAt?: SortOrder
    updatedBy?: SortOrder
  }

  export type ChallengeSkillMaxOrderByAggregateInput = {
    id?: SortOrder
    challengeId?: SortOrder
    skillId?: SortOrder
    createdAt?: SortOrder
    createdBy?: SortOrder
    updatedAt?: SortOrder
    updatedBy?: SortOrder
  }

  export type ChallengeSkillMinOrderByAggregateInput = {
    id?: SortOrder
    challengeId?: SortOrder
    skillId?: SortOrder
    createdAt?: SortOrder
    createdBy?: SortOrder
    updatedAt?: SortOrder
    updatedBy?: SortOrder
  }

  export type ChallengeBillingOrderByRelevanceInput = {
    fields: ChallengeBillingOrderByRelevanceFieldEnum | ChallengeBillingOrderByRelevanceFieldEnum[]
    sort: SortOrder
    search: string
  }

  export type ChallengeBillingCountOrderByAggregateInput = {
    id?: SortOrder
    billingAccountId?: SortOrder
    markup?: SortOrder
    clientBillingRate?: SortOrder
    challengeId?: SortOrder
    createdAt?: SortOrder
    createdBy?: SortOrder
    updatedAt?: SortOrder
    updatedBy?: SortOrder
  }

  export type ChallengeBillingAvgOrderByAggregateInput = {
    markup?: SortOrder
    clientBillingRate?: SortOrder
  }

  export type ChallengeBillingMaxOrderByAggregateInput = {
    id?: SortOrder
    billingAccountId?: SortOrder
    markup?: SortOrder
    clientBillingRate?: SortOrder
    challengeId?: SortOrder
    createdAt?: SortOrder
    createdBy?: SortOrder
    updatedAt?: SortOrder
    updatedBy?: SortOrder
  }

  export type ChallengeBillingMinOrderByAggregateInput = {
    id?: SortOrder
    billingAccountId?: SortOrder
    markup?: SortOrder
    clientBillingRate?: SortOrder
    challengeId?: SortOrder
    createdAt?: SortOrder
    createdBy?: SortOrder
    updatedAt?: SortOrder
    updatedBy?: SortOrder
  }

  export type ChallengeBillingSumOrderByAggregateInput = {
    markup?: SortOrder
    clientBillingRate?: SortOrder
  }

  export type EnumReviewTypeEnumFilter<$PrismaModel = never> = {
    equals?: $Enums.ReviewTypeEnum | EnumReviewTypeEnumFieldRefInput<$PrismaModel>
    in?: $Enums.ReviewTypeEnum[] | ListEnumReviewTypeEnumFieldRefInput<$PrismaModel>
    notIn?: $Enums.ReviewTypeEnum[] | ListEnumReviewTypeEnumFieldRefInput<$PrismaModel>
    not?: NestedEnumReviewTypeEnumFilter<$PrismaModel> | $Enums.ReviewTypeEnum
  }

  export type ChallengeLegacyOrderByRelevanceInput = {
    fields: ChallengeLegacyOrderByRelevanceFieldEnum | ChallengeLegacyOrderByRelevanceFieldEnum[]
    sort: SortOrder
    search: string
  }

  export type ChallengeLegacyCountOrderByAggregateInput = {
    id?: SortOrder
    reviewType?: SortOrder
    confidentialityType?: SortOrder
    forumId?: SortOrder
    directProjectId?: SortOrder
    screeningScorecardId?: SortOrder
    reviewScorecardId?: SortOrder
    isTask?: SortOrder
    useSchedulingAPI?: SortOrder
    pureV5Task?: SortOrder
    pureV5?: SortOrder
    selfService?: SortOrder
    selfServiceCopilot?: SortOrder
    track?: SortOrder
    subTrack?: SortOrder
    legacySystemId?: SortOrder
    challengeId?: SortOrder
    createdAt?: SortOrder
    createdBy?: SortOrder
    updatedAt?: SortOrder
    updatedBy?: SortOrder
  }

  export type ChallengeLegacyAvgOrderByAggregateInput = {
    forumId?: SortOrder
    directProjectId?: SortOrder
    screeningScorecardId?: SortOrder
    reviewScorecardId?: SortOrder
    legacySystemId?: SortOrder
  }

  export type ChallengeLegacyMaxOrderByAggregateInput = {
    id?: SortOrder
    reviewType?: SortOrder
    confidentialityType?: SortOrder
    forumId?: SortOrder
    directProjectId?: SortOrder
    screeningScorecardId?: SortOrder
    reviewScorecardId?: SortOrder
    isTask?: SortOrder
    useSchedulingAPI?: SortOrder
    pureV5Task?: SortOrder
    pureV5?: SortOrder
    selfService?: SortOrder
    selfServiceCopilot?: SortOrder
    track?: SortOrder
    subTrack?: SortOrder
    legacySystemId?: SortOrder
    challengeId?: SortOrder
    createdAt?: SortOrder
    createdBy?: SortOrder
    updatedAt?: SortOrder
    updatedBy?: SortOrder
  }

  export type ChallengeLegacyMinOrderByAggregateInput = {
    id?: SortOrder
    reviewType?: SortOrder
    confidentialityType?: SortOrder
    forumId?: SortOrder
    directProjectId?: SortOrder
    screeningScorecardId?: SortOrder
    reviewScorecardId?: SortOrder
    isTask?: SortOrder
    useSchedulingAPI?: SortOrder
    pureV5Task?: SortOrder
    pureV5?: SortOrder
    selfService?: SortOrder
    selfServiceCopilot?: SortOrder
    track?: SortOrder
    subTrack?: SortOrder
    legacySystemId?: SortOrder
    challengeId?: SortOrder
    createdAt?: SortOrder
    createdBy?: SortOrder
    updatedAt?: SortOrder
    updatedBy?: SortOrder
  }

  export type ChallengeLegacySumOrderByAggregateInput = {
    forumId?: SortOrder
    directProjectId?: SortOrder
    screeningScorecardId?: SortOrder
    reviewScorecardId?: SortOrder
    legacySystemId?: SortOrder
  }

  export type EnumReviewTypeEnumWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.ReviewTypeEnum | EnumReviewTypeEnumFieldRefInput<$PrismaModel>
    in?: $Enums.ReviewTypeEnum[] | ListEnumReviewTypeEnumFieldRefInput<$PrismaModel>
    notIn?: $Enums.ReviewTypeEnum[] | ListEnumReviewTypeEnumFieldRefInput<$PrismaModel>
    not?: NestedEnumReviewTypeEnumWithAggregatesFilter<$PrismaModel> | $Enums.ReviewTypeEnum
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumReviewTypeEnumFilter<$PrismaModel>
    _max?: NestedEnumReviewTypeEnumFilter<$PrismaModel>
  }

  export type ChallengeEventOrderByRelevanceInput = {
    fields: ChallengeEventOrderByRelevanceFieldEnum | ChallengeEventOrderByRelevanceFieldEnum[]
    sort: SortOrder
    search: string
  }

  export type ChallengeEventCountOrderByAggregateInput = {
    id?: SortOrder
    challengeId?: SortOrder
    eventId?: SortOrder
    name?: SortOrder
    key?: SortOrder
    createdAt?: SortOrder
    createdBy?: SortOrder
    updatedAt?: SortOrder
    updatedBy?: SortOrder
  }

  export type ChallengeEventAvgOrderByAggregateInput = {
    eventId?: SortOrder
  }

  export type ChallengeEventMaxOrderByAggregateInput = {
    id?: SortOrder
    challengeId?: SortOrder
    eventId?: SortOrder
    name?: SortOrder
    key?: SortOrder
    createdAt?: SortOrder
    createdBy?: SortOrder
    updatedAt?: SortOrder
    updatedBy?: SortOrder
  }

  export type ChallengeEventMinOrderByAggregateInput = {
    id?: SortOrder
    challengeId?: SortOrder
    eventId?: SortOrder
    name?: SortOrder
    key?: SortOrder
    createdAt?: SortOrder
    createdBy?: SortOrder
    updatedAt?: SortOrder
    updatedBy?: SortOrder
  }

  export type ChallengeEventSumOrderByAggregateInput = {
    eventId?: SortOrder
  }

  export type EnumDiscussionTypeEnumFilter<$PrismaModel = never> = {
    equals?: $Enums.DiscussionTypeEnum | EnumDiscussionTypeEnumFieldRefInput<$PrismaModel>
    in?: $Enums.DiscussionTypeEnum[] | ListEnumDiscussionTypeEnumFieldRefInput<$PrismaModel>
    notIn?: $Enums.DiscussionTypeEnum[] | ListEnumDiscussionTypeEnumFieldRefInput<$PrismaModel>
    not?: NestedEnumDiscussionTypeEnumFilter<$PrismaModel> | $Enums.DiscussionTypeEnum
  }

  export type ChallengeDiscussionOptionListRelationFilter = {
    every?: ChallengeDiscussionOptionWhereInput
    some?: ChallengeDiscussionOptionWhereInput
    none?: ChallengeDiscussionOptionWhereInput
  }

  export type ChallengeDiscussionOptionOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type ChallengeDiscussionOrderByRelevanceInput = {
    fields: ChallengeDiscussionOrderByRelevanceFieldEnum | ChallengeDiscussionOrderByRelevanceFieldEnum[]
    sort: SortOrder
    search: string
  }

  export type ChallengeDiscussionCountOrderByAggregateInput = {
    id?: SortOrder
    challengeId?: SortOrder
    discussionId?: SortOrder
    name?: SortOrder
    type?: SortOrder
    provider?: SortOrder
    url?: SortOrder
    createdAt?: SortOrder
    createdBy?: SortOrder
    updatedAt?: SortOrder
    updatedBy?: SortOrder
  }

  export type ChallengeDiscussionMaxOrderByAggregateInput = {
    id?: SortOrder
    challengeId?: SortOrder
    discussionId?: SortOrder
    name?: SortOrder
    type?: SortOrder
    provider?: SortOrder
    url?: SortOrder
    createdAt?: SortOrder
    createdBy?: SortOrder
    updatedAt?: SortOrder
    updatedBy?: SortOrder
  }

  export type ChallengeDiscussionMinOrderByAggregateInput = {
    id?: SortOrder
    challengeId?: SortOrder
    discussionId?: SortOrder
    name?: SortOrder
    type?: SortOrder
    provider?: SortOrder
    url?: SortOrder
    createdAt?: SortOrder
    createdBy?: SortOrder
    updatedAt?: SortOrder
    updatedBy?: SortOrder
  }

  export type EnumDiscussionTypeEnumWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.DiscussionTypeEnum | EnumDiscussionTypeEnumFieldRefInput<$PrismaModel>
    in?: $Enums.DiscussionTypeEnum[] | ListEnumDiscussionTypeEnumFieldRefInput<$PrismaModel>
    notIn?: $Enums.DiscussionTypeEnum[] | ListEnumDiscussionTypeEnumFieldRefInput<$PrismaModel>
    not?: NestedEnumDiscussionTypeEnumWithAggregatesFilter<$PrismaModel> | $Enums.DiscussionTypeEnum
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumDiscussionTypeEnumFilter<$PrismaModel>
    _max?: NestedEnumDiscussionTypeEnumFilter<$PrismaModel>
  }

  export type ChallengeDiscussionScalarRelationFilter = {
    is?: ChallengeDiscussionWhereInput
    isNot?: ChallengeDiscussionWhereInput
  }

  export type ChallengeDiscussionOptionOrderByRelevanceInput = {
    fields: ChallengeDiscussionOptionOrderByRelevanceFieldEnum | ChallengeDiscussionOptionOrderByRelevanceFieldEnum[]
    sort: SortOrder
    search: string
  }

  export type ChallengeDiscussionOptionCountOrderByAggregateInput = {
    id?: SortOrder
    discussionId?: SortOrder
    optionKey?: SortOrder
    optionValue?: SortOrder
    createdAt?: SortOrder
    createdBy?: SortOrder
    updatedAt?: SortOrder
    updatedBy?: SortOrder
  }

  export type ChallengeDiscussionOptionMaxOrderByAggregateInput = {
    id?: SortOrder
    discussionId?: SortOrder
    optionKey?: SortOrder
    optionValue?: SortOrder
    createdAt?: SortOrder
    createdBy?: SortOrder
    updatedAt?: SortOrder
    updatedBy?: SortOrder
  }

  export type ChallengeDiscussionOptionMinOrderByAggregateInput = {
    id?: SortOrder
    discussionId?: SortOrder
    optionKey?: SortOrder
    optionValue?: SortOrder
    createdAt?: SortOrder
    createdBy?: SortOrder
    updatedAt?: SortOrder
    updatedBy?: SortOrder
  }

  export type ChallengeConstraintOrderByRelevanceInput = {
    fields: ChallengeConstraintOrderByRelevanceFieldEnum | ChallengeConstraintOrderByRelevanceFieldEnum[]
    sort: SortOrder
    search: string
  }

  export type ChallengeConstraintCountOrderByAggregateInput = {
    id?: SortOrder
    challengeId?: SortOrder
    allowedRegistrants?: SortOrder
    createdAt?: SortOrder
    createdBy?: SortOrder
    updatedAt?: SortOrder
    updatedBy?: SortOrder
  }

  export type ChallengeConstraintMaxOrderByAggregateInput = {
    id?: SortOrder
    challengeId?: SortOrder
    createdAt?: SortOrder
    createdBy?: SortOrder
    updatedAt?: SortOrder
    updatedBy?: SortOrder
  }

  export type ChallengeConstraintMinOrderByAggregateInput = {
    id?: SortOrder
    challengeId?: SortOrder
    createdAt?: SortOrder
    createdBy?: SortOrder
    updatedAt?: SortOrder
    updatedBy?: SortOrder
  }

  export type PhaseOrderByRelevanceInput = {
    fields: PhaseOrderByRelevanceFieldEnum | PhaseOrderByRelevanceFieldEnum[]
    sort: SortOrder
    search: string
  }

  export type PhaseCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrder
    isOpen?: SortOrder
    duration?: SortOrder
    createdAt?: SortOrder
    createdBy?: SortOrder
    updatedAt?: SortOrder
    updatedBy?: SortOrder
  }

  export type PhaseAvgOrderByAggregateInput = {
    duration?: SortOrder
  }

  export type PhaseMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrder
    isOpen?: SortOrder
    duration?: SortOrder
    createdAt?: SortOrder
    createdBy?: SortOrder
    updatedAt?: SortOrder
    updatedBy?: SortOrder
  }

  export type PhaseMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrder
    isOpen?: SortOrder
    duration?: SortOrder
    createdAt?: SortOrder
    createdBy?: SortOrder
    updatedAt?: SortOrder
    updatedBy?: SortOrder
  }

  export type PhaseSumOrderByAggregateInput = {
    duration?: SortOrder
  }

  export type BoolNullableFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel> | null
    not?: NestedBoolNullableFilter<$PrismaModel> | boolean | null
  }

  export type ChallengePhaseConstraintListRelationFilter = {
    every?: ChallengePhaseConstraintWhereInput
    some?: ChallengePhaseConstraintWhereInput
    none?: ChallengePhaseConstraintWhereInput
  }

  export type PhaseScalarRelationFilter = {
    is?: PhaseWhereInput
    isNot?: PhaseWhereInput
  }

  export type ChallengePhaseConstraintOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type ChallengePhaseOrderByRelevanceInput = {
    fields: ChallengePhaseOrderByRelevanceFieldEnum | ChallengePhaseOrderByRelevanceFieldEnum[]
    sort: SortOrder
    search: string
  }

  export type ChallengePhaseCountOrderByAggregateInput = {
    id?: SortOrder
    challengeId?: SortOrder
    phaseId?: SortOrder
    name?: SortOrder
    description?: SortOrder
    isOpen?: SortOrder
    predecessor?: SortOrder
    duration?: SortOrder
    scheduledStartDate?: SortOrder
    scheduledEndDate?: SortOrder
    actualStartDate?: SortOrder
    actualEndDate?: SortOrder
    createdAt?: SortOrder
    createdBy?: SortOrder
    updatedAt?: SortOrder
    updatedBy?: SortOrder
  }

  export type ChallengePhaseAvgOrderByAggregateInput = {
    duration?: SortOrder
  }

  export type ChallengePhaseMaxOrderByAggregateInput = {
    id?: SortOrder
    challengeId?: SortOrder
    phaseId?: SortOrder
    name?: SortOrder
    description?: SortOrder
    isOpen?: SortOrder
    predecessor?: SortOrder
    duration?: SortOrder
    scheduledStartDate?: SortOrder
    scheduledEndDate?: SortOrder
    actualStartDate?: SortOrder
    actualEndDate?: SortOrder
    createdAt?: SortOrder
    createdBy?: SortOrder
    updatedAt?: SortOrder
    updatedBy?: SortOrder
  }

  export type ChallengePhaseMinOrderByAggregateInput = {
    id?: SortOrder
    challengeId?: SortOrder
    phaseId?: SortOrder
    name?: SortOrder
    description?: SortOrder
    isOpen?: SortOrder
    predecessor?: SortOrder
    duration?: SortOrder
    scheduledStartDate?: SortOrder
    scheduledEndDate?: SortOrder
    actualStartDate?: SortOrder
    actualEndDate?: SortOrder
    createdAt?: SortOrder
    createdBy?: SortOrder
    updatedAt?: SortOrder
    updatedBy?: SortOrder
  }

  export type ChallengePhaseSumOrderByAggregateInput = {
    duration?: SortOrder
  }

  export type BoolNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel> | null
    not?: NestedBoolNullableWithAggregatesFilter<$PrismaModel> | boolean | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedBoolNullableFilter<$PrismaModel>
    _max?: NestedBoolNullableFilter<$PrismaModel>
  }

  export type ChallengePhaseScalarRelationFilter = {
    is?: ChallengePhaseWhereInput
    isNot?: ChallengePhaseWhereInput
  }

  export type ChallengePhaseConstraintOrderByRelevanceInput = {
    fields: ChallengePhaseConstraintOrderByRelevanceFieldEnum | ChallengePhaseConstraintOrderByRelevanceFieldEnum[]
    sort: SortOrder
    search: string
  }

  export type ChallengePhaseConstraintCountOrderByAggregateInput = {
    id?: SortOrder
    challengePhaseId?: SortOrder
    name?: SortOrder
    value?: SortOrder
    createdAt?: SortOrder
    createdBy?: SortOrder
    updatedAt?: SortOrder
    updatedBy?: SortOrder
  }

  export type ChallengePhaseConstraintAvgOrderByAggregateInput = {
    value?: SortOrder
  }

  export type ChallengePhaseConstraintMaxOrderByAggregateInput = {
    id?: SortOrder
    challengePhaseId?: SortOrder
    name?: SortOrder
    value?: SortOrder
    createdAt?: SortOrder
    createdBy?: SortOrder
    updatedAt?: SortOrder
    updatedBy?: SortOrder
  }

  export type ChallengePhaseConstraintMinOrderByAggregateInput = {
    id?: SortOrder
    challengePhaseId?: SortOrder
    name?: SortOrder
    value?: SortOrder
    createdAt?: SortOrder
    createdBy?: SortOrder
    updatedAt?: SortOrder
    updatedBy?: SortOrder
  }

  export type ChallengePhaseConstraintSumOrderByAggregateInput = {
    value?: SortOrder
  }

  export type PrizeListRelationFilter = {
    every?: PrizeWhereInput
    some?: PrizeWhereInput
    none?: PrizeWhereInput
  }

  export type PrizeOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type ChallengePrizeSetOrderByRelevanceInput = {
    fields: ChallengePrizeSetOrderByRelevanceFieldEnum | ChallengePrizeSetOrderByRelevanceFieldEnum[]
    sort: SortOrder
    search: string
  }

  export type ChallengePrizeSetCountOrderByAggregateInput = {
    id?: SortOrder
    challengeId?: SortOrder
    type?: SortOrder
    description?: SortOrder
    createdAt?: SortOrder
    createdBy?: SortOrder
    updatedAt?: SortOrder
    updatedBy?: SortOrder
  }

  export type ChallengePrizeSetMaxOrderByAggregateInput = {
    id?: SortOrder
    challengeId?: SortOrder
    type?: SortOrder
    description?: SortOrder
    createdAt?: SortOrder
    createdBy?: SortOrder
    updatedAt?: SortOrder
    updatedBy?: SortOrder
  }

  export type ChallengePrizeSetMinOrderByAggregateInput = {
    id?: SortOrder
    challengeId?: SortOrder
    type?: SortOrder
    description?: SortOrder
    createdAt?: SortOrder
    createdBy?: SortOrder
    updatedAt?: SortOrder
    updatedBy?: SortOrder
  }

  export type EnumReviewOpportunityTypeEnumNullableFilter<$PrismaModel = never> = {
    equals?: $Enums.ReviewOpportunityTypeEnum | EnumReviewOpportunityTypeEnumFieldRefInput<$PrismaModel> | null
    in?: $Enums.ReviewOpportunityTypeEnum[] | ListEnumReviewOpportunityTypeEnumFieldRefInput<$PrismaModel> | null
    notIn?: $Enums.ReviewOpportunityTypeEnum[] | ListEnumReviewOpportunityTypeEnumFieldRefInput<$PrismaModel> | null
    not?: NestedEnumReviewOpportunityTypeEnumNullableFilter<$PrismaModel> | $Enums.ReviewOpportunityTypeEnum | null
  }

  export type ChallengeReviewerOrderByRelevanceInput = {
    fields: ChallengeReviewerOrderByRelevanceFieldEnum | ChallengeReviewerOrderByRelevanceFieldEnum[]
    sort: SortOrder
    search: string
  }

  export type ChallengeReviewerCountOrderByAggregateInput = {
    id?: SortOrder
    challengeId?: SortOrder
    scorecardId?: SortOrder
    isMemberReview?: SortOrder
    memberReviewerCount?: SortOrder
    phaseId?: SortOrder
    fixedAmount?: SortOrder
    baseCoefficient?: SortOrder
    incrementalCoefficient?: SortOrder
    type?: SortOrder
    aiWorkflowId?: SortOrder
    shouldOpenOpportunity?: SortOrder
    createdAt?: SortOrder
    createdBy?: SortOrder
    updatedAt?: SortOrder
    updatedBy?: SortOrder
  }

  export type ChallengeReviewerAvgOrderByAggregateInput = {
    memberReviewerCount?: SortOrder
    fixedAmount?: SortOrder
    baseCoefficient?: SortOrder
    incrementalCoefficient?: SortOrder
  }

  export type ChallengeReviewerMaxOrderByAggregateInput = {
    id?: SortOrder
    challengeId?: SortOrder
    scorecardId?: SortOrder
    isMemberReview?: SortOrder
    memberReviewerCount?: SortOrder
    phaseId?: SortOrder
    fixedAmount?: SortOrder
    baseCoefficient?: SortOrder
    incrementalCoefficient?: SortOrder
    type?: SortOrder
    aiWorkflowId?: SortOrder
    shouldOpenOpportunity?: SortOrder
    createdAt?: SortOrder
    createdBy?: SortOrder
    updatedAt?: SortOrder
    updatedBy?: SortOrder
  }

  export type ChallengeReviewerMinOrderByAggregateInput = {
    id?: SortOrder
    challengeId?: SortOrder
    scorecardId?: SortOrder
    isMemberReview?: SortOrder
    memberReviewerCount?: SortOrder
    phaseId?: SortOrder
    fixedAmount?: SortOrder
    baseCoefficient?: SortOrder
    incrementalCoefficient?: SortOrder
    type?: SortOrder
    aiWorkflowId?: SortOrder
    shouldOpenOpportunity?: SortOrder
    createdAt?: SortOrder
    createdBy?: SortOrder
    updatedAt?: SortOrder
    updatedBy?: SortOrder
  }

  export type ChallengeReviewerSumOrderByAggregateInput = {
    memberReviewerCount?: SortOrder
    fixedAmount?: SortOrder
    baseCoefficient?: SortOrder
    incrementalCoefficient?: SortOrder
  }

  export type EnumReviewOpportunityTypeEnumNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.ReviewOpportunityTypeEnum | EnumReviewOpportunityTypeEnumFieldRefInput<$PrismaModel> | null
    in?: $Enums.ReviewOpportunityTypeEnum[] | ListEnumReviewOpportunityTypeEnumFieldRefInput<$PrismaModel> | null
    notIn?: $Enums.ReviewOpportunityTypeEnum[] | ListEnumReviewOpportunityTypeEnumFieldRefInput<$PrismaModel> | null
    not?: NestedEnumReviewOpportunityTypeEnumNullableWithAggregatesFilter<$PrismaModel> | $Enums.ReviewOpportunityTypeEnum | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedEnumReviewOpportunityTypeEnumNullableFilter<$PrismaModel>
    _max?: NestedEnumReviewOpportunityTypeEnumNullableFilter<$PrismaModel>
  }

  export type PhaseNullableScalarRelationFilter = {
    is?: PhaseWhereInput | null
    isNot?: PhaseWhereInput | null
  }

  export type DefaultChallengeReviewerOrderByRelevanceInput = {
    fields: DefaultChallengeReviewerOrderByRelevanceFieldEnum | DefaultChallengeReviewerOrderByRelevanceFieldEnum[]
    sort: SortOrder
    search: string
  }

  export type DefaultChallengeReviewerCountOrderByAggregateInput = {
    id?: SortOrder
    typeId?: SortOrder
    trackId?: SortOrder
    timelineTemplateId?: SortOrder
    scorecardId?: SortOrder
    isMemberReview?: SortOrder
    memberReviewerCount?: SortOrder
    phaseName?: SortOrder
    phaseId?: SortOrder
    fixedAmount?: SortOrder
    baseCoefficient?: SortOrder
    incrementalCoefficient?: SortOrder
    opportunityType?: SortOrder
    aiWorkflowId?: SortOrder
    shouldOpenOpportunity?: SortOrder
    createdAt?: SortOrder
    createdBy?: SortOrder
    updatedAt?: SortOrder
    updatedBy?: SortOrder
  }

  export type DefaultChallengeReviewerAvgOrderByAggregateInput = {
    memberReviewerCount?: SortOrder
    fixedAmount?: SortOrder
    baseCoefficient?: SortOrder
    incrementalCoefficient?: SortOrder
  }

  export type DefaultChallengeReviewerMaxOrderByAggregateInput = {
    id?: SortOrder
    typeId?: SortOrder
    trackId?: SortOrder
    timelineTemplateId?: SortOrder
    scorecardId?: SortOrder
    isMemberReview?: SortOrder
    memberReviewerCount?: SortOrder
    phaseName?: SortOrder
    phaseId?: SortOrder
    fixedAmount?: SortOrder
    baseCoefficient?: SortOrder
    incrementalCoefficient?: SortOrder
    opportunityType?: SortOrder
    aiWorkflowId?: SortOrder
    shouldOpenOpportunity?: SortOrder
    createdAt?: SortOrder
    createdBy?: SortOrder
    updatedAt?: SortOrder
    updatedBy?: SortOrder
  }

  export type DefaultChallengeReviewerMinOrderByAggregateInput = {
    id?: SortOrder
    typeId?: SortOrder
    trackId?: SortOrder
    timelineTemplateId?: SortOrder
    scorecardId?: SortOrder
    isMemberReview?: SortOrder
    memberReviewerCount?: SortOrder
    phaseName?: SortOrder
    phaseId?: SortOrder
    fixedAmount?: SortOrder
    baseCoefficient?: SortOrder
    incrementalCoefficient?: SortOrder
    opportunityType?: SortOrder
    aiWorkflowId?: SortOrder
    shouldOpenOpportunity?: SortOrder
    createdAt?: SortOrder
    createdBy?: SortOrder
    updatedAt?: SortOrder
    updatedBy?: SortOrder
  }

  export type DefaultChallengeReviewerSumOrderByAggregateInput = {
    memberReviewerCount?: SortOrder
    fixedAmount?: SortOrder
    baseCoefficient?: SortOrder
    incrementalCoefficient?: SortOrder
  }

  export type TimelineTemplatePhaseListRelationFilter = {
    every?: TimelineTemplatePhaseWhereInput
    some?: TimelineTemplatePhaseWhereInput
    none?: TimelineTemplatePhaseWhereInput
  }

  export type TimelineTemplatePhaseOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type TimelineTemplateOrderByRelevanceInput = {
    fields: TimelineTemplateOrderByRelevanceFieldEnum | TimelineTemplateOrderByRelevanceFieldEnum[]
    sort: SortOrder
    search: string
  }

  export type TimelineTemplateCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    createdBy?: SortOrder
    updatedAt?: SortOrder
    updatedBy?: SortOrder
  }

  export type TimelineTemplateMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    createdBy?: SortOrder
    updatedAt?: SortOrder
    updatedBy?: SortOrder
  }

  export type TimelineTemplateMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    createdBy?: SortOrder
    updatedAt?: SortOrder
    updatedBy?: SortOrder
  }

  export type TimelineTemplatePhaseOrderByRelevanceInput = {
    fields: TimelineTemplatePhaseOrderByRelevanceFieldEnum | TimelineTemplatePhaseOrderByRelevanceFieldEnum[]
    sort: SortOrder
    search: string
  }

  export type TimelineTemplatePhaseCountOrderByAggregateInput = {
    id?: SortOrder
    timelineTemplateId?: SortOrder
    phaseId?: SortOrder
    predecessor?: SortOrder
    defaultDuration?: SortOrder
    createdAt?: SortOrder
    createdBy?: SortOrder
    updatedAt?: SortOrder
    updatedBy?: SortOrder
  }

  export type TimelineTemplatePhaseAvgOrderByAggregateInput = {
    defaultDuration?: SortOrder
  }

  export type TimelineTemplatePhaseMaxOrderByAggregateInput = {
    id?: SortOrder
    timelineTemplateId?: SortOrder
    phaseId?: SortOrder
    predecessor?: SortOrder
    defaultDuration?: SortOrder
    createdAt?: SortOrder
    createdBy?: SortOrder
    updatedAt?: SortOrder
    updatedBy?: SortOrder
  }

  export type TimelineTemplatePhaseMinOrderByAggregateInput = {
    id?: SortOrder
    timelineTemplateId?: SortOrder
    phaseId?: SortOrder
    predecessor?: SortOrder
    defaultDuration?: SortOrder
    createdAt?: SortOrder
    createdBy?: SortOrder
    updatedAt?: SortOrder
    updatedBy?: SortOrder
  }

  export type TimelineTemplatePhaseSumOrderByAggregateInput = {
    defaultDuration?: SortOrder
  }

  export type MemberChallengeAccessOrderByRelevanceInput = {
    fields: MemberChallengeAccessOrderByRelevanceFieldEnum | MemberChallengeAccessOrderByRelevanceFieldEnum[]
    sort: SortOrder
    search: string
  }

  export type MemberChallengeAccessCountOrderByAggregateInput = {
    challengeId?: SortOrder
    memberId?: SortOrder
  }

  export type MemberChallengeAccessMaxOrderByAggregateInput = {
    challengeId?: SortOrder
    memberId?: SortOrder
  }

  export type MemberChallengeAccessMinOrderByAggregateInput = {
    challengeId?: SortOrder
    memberId?: SortOrder
  }

  export type ChallengeCreatecurrentPhaseNamesInput = {
    set: string[]
  }

  export type ChallengeCreatetagsInput = {
    set: string[]
  }

  export type ChallengeCreategroupsInput = {
    set: string[]
  }

  export type ChallengeBillingCreateNestedOneWithoutChallengeInput = {
    create?: XOR<ChallengeBillingCreateWithoutChallengeInput, ChallengeBillingUncheckedCreateWithoutChallengeInput>
    connectOrCreate?: ChallengeBillingCreateOrConnectWithoutChallengeInput
    connect?: ChallengeBillingWhereUniqueInput
  }

  export type ChallengeLegacyCreateNestedOneWithoutChallengeInput = {
    create?: XOR<ChallengeLegacyCreateWithoutChallengeInput, ChallengeLegacyUncheckedCreateWithoutChallengeInput>
    connectOrCreate?: ChallengeLegacyCreateOrConnectWithoutChallengeInput
    connect?: ChallengeLegacyWhereUniqueInput
  }

  export type ChallengeConstraintCreateNestedOneWithoutChallengeInput = {
    create?: XOR<ChallengeConstraintCreateWithoutChallengeInput, ChallengeConstraintUncheckedCreateWithoutChallengeInput>
    connectOrCreate?: ChallengeConstraintCreateOrConnectWithoutChallengeInput
    connect?: ChallengeConstraintWhereUniqueInput
  }

  export type ChallengeEventCreateNestedManyWithoutChallengeInput = {
    create?: XOR<ChallengeEventCreateWithoutChallengeInput, ChallengeEventUncheckedCreateWithoutChallengeInput> | ChallengeEventCreateWithoutChallengeInput[] | ChallengeEventUncheckedCreateWithoutChallengeInput[]
    connectOrCreate?: ChallengeEventCreateOrConnectWithoutChallengeInput | ChallengeEventCreateOrConnectWithoutChallengeInput[]
    createMany?: ChallengeEventCreateManyChallengeInputEnvelope
    connect?: ChallengeEventWhereUniqueInput | ChallengeEventWhereUniqueInput[]
  }

  export type ChallengeDiscussionCreateNestedManyWithoutChallengeInput = {
    create?: XOR<ChallengeDiscussionCreateWithoutChallengeInput, ChallengeDiscussionUncheckedCreateWithoutChallengeInput> | ChallengeDiscussionCreateWithoutChallengeInput[] | ChallengeDiscussionUncheckedCreateWithoutChallengeInput[]
    connectOrCreate?: ChallengeDiscussionCreateOrConnectWithoutChallengeInput | ChallengeDiscussionCreateOrConnectWithoutChallengeInput[]
    createMany?: ChallengeDiscussionCreateManyChallengeInputEnvelope
    connect?: ChallengeDiscussionWhereUniqueInput | ChallengeDiscussionWhereUniqueInput[]
  }

  export type ChallengeMetadataCreateNestedManyWithoutChallengeInput = {
    create?: XOR<ChallengeMetadataCreateWithoutChallengeInput, ChallengeMetadataUncheckedCreateWithoutChallengeInput> | ChallengeMetadataCreateWithoutChallengeInput[] | ChallengeMetadataUncheckedCreateWithoutChallengeInput[]
    connectOrCreate?: ChallengeMetadataCreateOrConnectWithoutChallengeInput | ChallengeMetadataCreateOrConnectWithoutChallengeInput[]
    createMany?: ChallengeMetadataCreateManyChallengeInputEnvelope
    connect?: ChallengeMetadataWhereUniqueInput | ChallengeMetadataWhereUniqueInput[]
  }

  export type ChallengePhaseCreateNestedManyWithoutChallengeInput = {
    create?: XOR<ChallengePhaseCreateWithoutChallengeInput, ChallengePhaseUncheckedCreateWithoutChallengeInput> | ChallengePhaseCreateWithoutChallengeInput[] | ChallengePhaseUncheckedCreateWithoutChallengeInput[]
    connectOrCreate?: ChallengePhaseCreateOrConnectWithoutChallengeInput | ChallengePhaseCreateOrConnectWithoutChallengeInput[]
    createMany?: ChallengePhaseCreateManyChallengeInputEnvelope
    connect?: ChallengePhaseWhereUniqueInput | ChallengePhaseWhereUniqueInput[]
  }

  export type ChallengePrizeSetCreateNestedManyWithoutChallengeInput = {
    create?: XOR<ChallengePrizeSetCreateWithoutChallengeInput, ChallengePrizeSetUncheckedCreateWithoutChallengeInput> | ChallengePrizeSetCreateWithoutChallengeInput[] | ChallengePrizeSetUncheckedCreateWithoutChallengeInput[]
    connectOrCreate?: ChallengePrizeSetCreateOrConnectWithoutChallengeInput | ChallengePrizeSetCreateOrConnectWithoutChallengeInput[]
    createMany?: ChallengePrizeSetCreateManyChallengeInputEnvelope
    connect?: ChallengePrizeSetWhereUniqueInput | ChallengePrizeSetWhereUniqueInput[]
  }

  export type ChallengeReviewerCreateNestedManyWithoutChallengeInput = {
    create?: XOR<ChallengeReviewerCreateWithoutChallengeInput, ChallengeReviewerUncheckedCreateWithoutChallengeInput> | ChallengeReviewerCreateWithoutChallengeInput[] | ChallengeReviewerUncheckedCreateWithoutChallengeInput[]
    connectOrCreate?: ChallengeReviewerCreateOrConnectWithoutChallengeInput | ChallengeReviewerCreateOrConnectWithoutChallengeInput[]
    createMany?: ChallengeReviewerCreateManyChallengeInputEnvelope
    connect?: ChallengeReviewerWhereUniqueInput | ChallengeReviewerWhereUniqueInput[]
  }

  export type ChallengeWinnerCreateNestedManyWithoutChallengeInput = {
    create?: XOR<ChallengeWinnerCreateWithoutChallengeInput, ChallengeWinnerUncheckedCreateWithoutChallengeInput> | ChallengeWinnerCreateWithoutChallengeInput[] | ChallengeWinnerUncheckedCreateWithoutChallengeInput[]
    connectOrCreate?: ChallengeWinnerCreateOrConnectWithoutChallengeInput | ChallengeWinnerCreateOrConnectWithoutChallengeInput[]
    createMany?: ChallengeWinnerCreateManyChallengeInputEnvelope
    connect?: ChallengeWinnerWhereUniqueInput | ChallengeWinnerWhereUniqueInput[]
  }

  export type AttachmentCreateNestedManyWithoutChallengeInput = {
    create?: XOR<AttachmentCreateWithoutChallengeInput, AttachmentUncheckedCreateWithoutChallengeInput> | AttachmentCreateWithoutChallengeInput[] | AttachmentUncheckedCreateWithoutChallengeInput[]
    connectOrCreate?: AttachmentCreateOrConnectWithoutChallengeInput | AttachmentCreateOrConnectWithoutChallengeInput[]
    createMany?: AttachmentCreateManyChallengeInputEnvelope
    connect?: AttachmentWhereUniqueInput | AttachmentWhereUniqueInput[]
  }

  export type ChallengeTermCreateNestedManyWithoutChallengeInput = {
    create?: XOR<ChallengeTermCreateWithoutChallengeInput, ChallengeTermUncheckedCreateWithoutChallengeInput> | ChallengeTermCreateWithoutChallengeInput[] | ChallengeTermUncheckedCreateWithoutChallengeInput[]
    connectOrCreate?: ChallengeTermCreateOrConnectWithoutChallengeInput | ChallengeTermCreateOrConnectWithoutChallengeInput[]
    createMany?: ChallengeTermCreateManyChallengeInputEnvelope
    connect?: ChallengeTermWhereUniqueInput | ChallengeTermWhereUniqueInput[]
  }

  export type ChallengeSkillCreateNestedManyWithoutChallengeInput = {
    create?: XOR<ChallengeSkillCreateWithoutChallengeInput, ChallengeSkillUncheckedCreateWithoutChallengeInput> | ChallengeSkillCreateWithoutChallengeInput[] | ChallengeSkillUncheckedCreateWithoutChallengeInput[]
    connectOrCreate?: ChallengeSkillCreateOrConnectWithoutChallengeInput | ChallengeSkillCreateOrConnectWithoutChallengeInput[]
    createMany?: ChallengeSkillCreateManyChallengeInputEnvelope
    connect?: ChallengeSkillWhereUniqueInput | ChallengeSkillWhereUniqueInput[]
  }

  export type AuditLogCreateNestedManyWithoutChallengeInput = {
    create?: XOR<AuditLogCreateWithoutChallengeInput, AuditLogUncheckedCreateWithoutChallengeInput> | AuditLogCreateWithoutChallengeInput[] | AuditLogUncheckedCreateWithoutChallengeInput[]
    connectOrCreate?: AuditLogCreateOrConnectWithoutChallengeInput | AuditLogCreateOrConnectWithoutChallengeInput[]
    createMany?: AuditLogCreateManyChallengeInputEnvelope
    connect?: AuditLogWhereUniqueInput | AuditLogWhereUniqueInput[]
  }

  export type MemberChallengeAccessCreateNestedManyWithoutChallengeInput = {
    connect?: MemberChallengeAccessWhereUniqueInput | MemberChallengeAccessWhereUniqueInput[]
  }

  export type ChallengeTypeCreateNestedOneWithoutChallengesInput = {
    create?: XOR<ChallengeTypeCreateWithoutChallengesInput, ChallengeTypeUncheckedCreateWithoutChallengesInput>
    connectOrCreate?: ChallengeTypeCreateOrConnectWithoutChallengesInput
    connect?: ChallengeTypeWhereUniqueInput
  }

  export type ChallengeTrackCreateNestedOneWithoutChallengesInput = {
    create?: XOR<ChallengeTrackCreateWithoutChallengesInput, ChallengeTrackUncheckedCreateWithoutChallengesInput>
    connectOrCreate?: ChallengeTrackCreateOrConnectWithoutChallengesInput
    connect?: ChallengeTrackWhereUniqueInput
  }

  export type TimelineTemplateCreateNestedOneWithoutChallengesInput = {
    create?: XOR<TimelineTemplateCreateWithoutChallengesInput, TimelineTemplateUncheckedCreateWithoutChallengesInput>
    connectOrCreate?: TimelineTemplateCreateOrConnectWithoutChallengesInput
    connect?: TimelineTemplateWhereUniqueInput
  }

  export type ChallengeBillingUncheckedCreateNestedOneWithoutChallengeInput = {
    create?: XOR<ChallengeBillingCreateWithoutChallengeInput, ChallengeBillingUncheckedCreateWithoutChallengeInput>
    connectOrCreate?: ChallengeBillingCreateOrConnectWithoutChallengeInput
    connect?: ChallengeBillingWhereUniqueInput
  }

  export type ChallengeLegacyUncheckedCreateNestedOneWithoutChallengeInput = {
    create?: XOR<ChallengeLegacyCreateWithoutChallengeInput, ChallengeLegacyUncheckedCreateWithoutChallengeInput>
    connectOrCreate?: ChallengeLegacyCreateOrConnectWithoutChallengeInput
    connect?: ChallengeLegacyWhereUniqueInput
  }

  export type ChallengeConstraintUncheckedCreateNestedOneWithoutChallengeInput = {
    create?: XOR<ChallengeConstraintCreateWithoutChallengeInput, ChallengeConstraintUncheckedCreateWithoutChallengeInput>
    connectOrCreate?: ChallengeConstraintCreateOrConnectWithoutChallengeInput
    connect?: ChallengeConstraintWhereUniqueInput
  }

  export type ChallengeEventUncheckedCreateNestedManyWithoutChallengeInput = {
    create?: XOR<ChallengeEventCreateWithoutChallengeInput, ChallengeEventUncheckedCreateWithoutChallengeInput> | ChallengeEventCreateWithoutChallengeInput[] | ChallengeEventUncheckedCreateWithoutChallengeInput[]
    connectOrCreate?: ChallengeEventCreateOrConnectWithoutChallengeInput | ChallengeEventCreateOrConnectWithoutChallengeInput[]
    createMany?: ChallengeEventCreateManyChallengeInputEnvelope
    connect?: ChallengeEventWhereUniqueInput | ChallengeEventWhereUniqueInput[]
  }

  export type ChallengeDiscussionUncheckedCreateNestedManyWithoutChallengeInput = {
    create?: XOR<ChallengeDiscussionCreateWithoutChallengeInput, ChallengeDiscussionUncheckedCreateWithoutChallengeInput> | ChallengeDiscussionCreateWithoutChallengeInput[] | ChallengeDiscussionUncheckedCreateWithoutChallengeInput[]
    connectOrCreate?: ChallengeDiscussionCreateOrConnectWithoutChallengeInput | ChallengeDiscussionCreateOrConnectWithoutChallengeInput[]
    createMany?: ChallengeDiscussionCreateManyChallengeInputEnvelope
    connect?: ChallengeDiscussionWhereUniqueInput | ChallengeDiscussionWhereUniqueInput[]
  }

  export type ChallengeMetadataUncheckedCreateNestedManyWithoutChallengeInput = {
    create?: XOR<ChallengeMetadataCreateWithoutChallengeInput, ChallengeMetadataUncheckedCreateWithoutChallengeInput> | ChallengeMetadataCreateWithoutChallengeInput[] | ChallengeMetadataUncheckedCreateWithoutChallengeInput[]
    connectOrCreate?: ChallengeMetadataCreateOrConnectWithoutChallengeInput | ChallengeMetadataCreateOrConnectWithoutChallengeInput[]
    createMany?: ChallengeMetadataCreateManyChallengeInputEnvelope
    connect?: ChallengeMetadataWhereUniqueInput | ChallengeMetadataWhereUniqueInput[]
  }

  export type ChallengePhaseUncheckedCreateNestedManyWithoutChallengeInput = {
    create?: XOR<ChallengePhaseCreateWithoutChallengeInput, ChallengePhaseUncheckedCreateWithoutChallengeInput> | ChallengePhaseCreateWithoutChallengeInput[] | ChallengePhaseUncheckedCreateWithoutChallengeInput[]
    connectOrCreate?: ChallengePhaseCreateOrConnectWithoutChallengeInput | ChallengePhaseCreateOrConnectWithoutChallengeInput[]
    createMany?: ChallengePhaseCreateManyChallengeInputEnvelope
    connect?: ChallengePhaseWhereUniqueInput | ChallengePhaseWhereUniqueInput[]
  }

  export type ChallengePrizeSetUncheckedCreateNestedManyWithoutChallengeInput = {
    create?: XOR<ChallengePrizeSetCreateWithoutChallengeInput, ChallengePrizeSetUncheckedCreateWithoutChallengeInput> | ChallengePrizeSetCreateWithoutChallengeInput[] | ChallengePrizeSetUncheckedCreateWithoutChallengeInput[]
    connectOrCreate?: ChallengePrizeSetCreateOrConnectWithoutChallengeInput | ChallengePrizeSetCreateOrConnectWithoutChallengeInput[]
    createMany?: ChallengePrizeSetCreateManyChallengeInputEnvelope
    connect?: ChallengePrizeSetWhereUniqueInput | ChallengePrizeSetWhereUniqueInput[]
  }

  export type ChallengeReviewerUncheckedCreateNestedManyWithoutChallengeInput = {
    create?: XOR<ChallengeReviewerCreateWithoutChallengeInput, ChallengeReviewerUncheckedCreateWithoutChallengeInput> | ChallengeReviewerCreateWithoutChallengeInput[] | ChallengeReviewerUncheckedCreateWithoutChallengeInput[]
    connectOrCreate?: ChallengeReviewerCreateOrConnectWithoutChallengeInput | ChallengeReviewerCreateOrConnectWithoutChallengeInput[]
    createMany?: ChallengeReviewerCreateManyChallengeInputEnvelope
    connect?: ChallengeReviewerWhereUniqueInput | ChallengeReviewerWhereUniqueInput[]
  }

  export type ChallengeWinnerUncheckedCreateNestedManyWithoutChallengeInput = {
    create?: XOR<ChallengeWinnerCreateWithoutChallengeInput, ChallengeWinnerUncheckedCreateWithoutChallengeInput> | ChallengeWinnerCreateWithoutChallengeInput[] | ChallengeWinnerUncheckedCreateWithoutChallengeInput[]
    connectOrCreate?: ChallengeWinnerCreateOrConnectWithoutChallengeInput | ChallengeWinnerCreateOrConnectWithoutChallengeInput[]
    createMany?: ChallengeWinnerCreateManyChallengeInputEnvelope
    connect?: ChallengeWinnerWhereUniqueInput | ChallengeWinnerWhereUniqueInput[]
  }

  export type AttachmentUncheckedCreateNestedManyWithoutChallengeInput = {
    create?: XOR<AttachmentCreateWithoutChallengeInput, AttachmentUncheckedCreateWithoutChallengeInput> | AttachmentCreateWithoutChallengeInput[] | AttachmentUncheckedCreateWithoutChallengeInput[]
    connectOrCreate?: AttachmentCreateOrConnectWithoutChallengeInput | AttachmentCreateOrConnectWithoutChallengeInput[]
    createMany?: AttachmentCreateManyChallengeInputEnvelope
    connect?: AttachmentWhereUniqueInput | AttachmentWhereUniqueInput[]
  }

  export type ChallengeTermUncheckedCreateNestedManyWithoutChallengeInput = {
    create?: XOR<ChallengeTermCreateWithoutChallengeInput, ChallengeTermUncheckedCreateWithoutChallengeInput> | ChallengeTermCreateWithoutChallengeInput[] | ChallengeTermUncheckedCreateWithoutChallengeInput[]
    connectOrCreate?: ChallengeTermCreateOrConnectWithoutChallengeInput | ChallengeTermCreateOrConnectWithoutChallengeInput[]
    createMany?: ChallengeTermCreateManyChallengeInputEnvelope
    connect?: ChallengeTermWhereUniqueInput | ChallengeTermWhereUniqueInput[]
  }

  export type ChallengeSkillUncheckedCreateNestedManyWithoutChallengeInput = {
    create?: XOR<ChallengeSkillCreateWithoutChallengeInput, ChallengeSkillUncheckedCreateWithoutChallengeInput> | ChallengeSkillCreateWithoutChallengeInput[] | ChallengeSkillUncheckedCreateWithoutChallengeInput[]
    connectOrCreate?: ChallengeSkillCreateOrConnectWithoutChallengeInput | ChallengeSkillCreateOrConnectWithoutChallengeInput[]
    createMany?: ChallengeSkillCreateManyChallengeInputEnvelope
    connect?: ChallengeSkillWhereUniqueInput | ChallengeSkillWhereUniqueInput[]
  }

  export type AuditLogUncheckedCreateNestedManyWithoutChallengeInput = {
    create?: XOR<AuditLogCreateWithoutChallengeInput, AuditLogUncheckedCreateWithoutChallengeInput> | AuditLogCreateWithoutChallengeInput[] | AuditLogUncheckedCreateWithoutChallengeInput[]
    connectOrCreate?: AuditLogCreateOrConnectWithoutChallengeInput | AuditLogCreateOrConnectWithoutChallengeInput[]
    createMany?: AuditLogCreateManyChallengeInputEnvelope
    connect?: AuditLogWhereUniqueInput | AuditLogWhereUniqueInput[]
  }

  export type MemberChallengeAccessUncheckedCreateNestedManyWithoutChallengeInput = {
    connect?: MemberChallengeAccessWhereUniqueInput | MemberChallengeAccessWhereUniqueInput[]
  }

  export type StringFieldUpdateOperationsInput = {
    set?: string
  }

  export type NullableStringFieldUpdateOperationsInput = {
    set?: string | null
  }

  export type NullableIntFieldUpdateOperationsInput = {
    set?: number | null
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
  }

  export type NullableFloatFieldUpdateOperationsInput = {
    set?: number | null
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
  }

  export type IntFieldUpdateOperationsInput = {
    set?: number
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
  }

  export type ChallengeUpdatecurrentPhaseNamesInput = {
    set?: string[]
    push?: string | string[]
  }

  export type BoolFieldUpdateOperationsInput = {
    set?: boolean
  }

  export type ChallengeUpdatetagsInput = {
    set?: string[]
    push?: string | string[]
  }

  export type ChallengeUpdategroupsInput = {
    set?: string[]
    push?: string | string[]
  }

  export type NullableDateTimeFieldUpdateOperationsInput = {
    set?: Date | string | null
  }

  export type EnumChallengeStatusEnumFieldUpdateOperationsInput = {
    set?: $Enums.ChallengeStatusEnum
  }

  export type DateTimeFieldUpdateOperationsInput = {
    set?: Date | string
  }

  export type ChallengeBillingUpdateOneWithoutChallengeNestedInput = {
    create?: XOR<ChallengeBillingCreateWithoutChallengeInput, ChallengeBillingUncheckedCreateWithoutChallengeInput>
    connectOrCreate?: ChallengeBillingCreateOrConnectWithoutChallengeInput
    upsert?: ChallengeBillingUpsertWithoutChallengeInput
    disconnect?: ChallengeBillingWhereInput | boolean
    delete?: ChallengeBillingWhereInput | boolean
    connect?: ChallengeBillingWhereUniqueInput
    update?: XOR<XOR<ChallengeBillingUpdateToOneWithWhereWithoutChallengeInput, ChallengeBillingUpdateWithoutChallengeInput>, ChallengeBillingUncheckedUpdateWithoutChallengeInput>
  }

  export type ChallengeLegacyUpdateOneWithoutChallengeNestedInput = {
    create?: XOR<ChallengeLegacyCreateWithoutChallengeInput, ChallengeLegacyUncheckedCreateWithoutChallengeInput>
    connectOrCreate?: ChallengeLegacyCreateOrConnectWithoutChallengeInput
    upsert?: ChallengeLegacyUpsertWithoutChallengeInput
    disconnect?: ChallengeLegacyWhereInput | boolean
    delete?: ChallengeLegacyWhereInput | boolean
    connect?: ChallengeLegacyWhereUniqueInput
    update?: XOR<XOR<ChallengeLegacyUpdateToOneWithWhereWithoutChallengeInput, ChallengeLegacyUpdateWithoutChallengeInput>, ChallengeLegacyUncheckedUpdateWithoutChallengeInput>
  }

  export type ChallengeConstraintUpdateOneWithoutChallengeNestedInput = {
    create?: XOR<ChallengeConstraintCreateWithoutChallengeInput, ChallengeConstraintUncheckedCreateWithoutChallengeInput>
    connectOrCreate?: ChallengeConstraintCreateOrConnectWithoutChallengeInput
    upsert?: ChallengeConstraintUpsertWithoutChallengeInput
    disconnect?: ChallengeConstraintWhereInput | boolean
    delete?: ChallengeConstraintWhereInput | boolean
    connect?: ChallengeConstraintWhereUniqueInput
    update?: XOR<XOR<ChallengeConstraintUpdateToOneWithWhereWithoutChallengeInput, ChallengeConstraintUpdateWithoutChallengeInput>, ChallengeConstraintUncheckedUpdateWithoutChallengeInput>
  }

  export type ChallengeEventUpdateManyWithoutChallengeNestedInput = {
    create?: XOR<ChallengeEventCreateWithoutChallengeInput, ChallengeEventUncheckedCreateWithoutChallengeInput> | ChallengeEventCreateWithoutChallengeInput[] | ChallengeEventUncheckedCreateWithoutChallengeInput[]
    connectOrCreate?: ChallengeEventCreateOrConnectWithoutChallengeInput | ChallengeEventCreateOrConnectWithoutChallengeInput[]
    upsert?: ChallengeEventUpsertWithWhereUniqueWithoutChallengeInput | ChallengeEventUpsertWithWhereUniqueWithoutChallengeInput[]
    createMany?: ChallengeEventCreateManyChallengeInputEnvelope
    set?: ChallengeEventWhereUniqueInput | ChallengeEventWhereUniqueInput[]
    disconnect?: ChallengeEventWhereUniqueInput | ChallengeEventWhereUniqueInput[]
    delete?: ChallengeEventWhereUniqueInput | ChallengeEventWhereUniqueInput[]
    connect?: ChallengeEventWhereUniqueInput | ChallengeEventWhereUniqueInput[]
    update?: ChallengeEventUpdateWithWhereUniqueWithoutChallengeInput | ChallengeEventUpdateWithWhereUniqueWithoutChallengeInput[]
    updateMany?: ChallengeEventUpdateManyWithWhereWithoutChallengeInput | ChallengeEventUpdateManyWithWhereWithoutChallengeInput[]
    deleteMany?: ChallengeEventScalarWhereInput | ChallengeEventScalarWhereInput[]
  }

  export type ChallengeDiscussionUpdateManyWithoutChallengeNestedInput = {
    create?: XOR<ChallengeDiscussionCreateWithoutChallengeInput, ChallengeDiscussionUncheckedCreateWithoutChallengeInput> | ChallengeDiscussionCreateWithoutChallengeInput[] | ChallengeDiscussionUncheckedCreateWithoutChallengeInput[]
    connectOrCreate?: ChallengeDiscussionCreateOrConnectWithoutChallengeInput | ChallengeDiscussionCreateOrConnectWithoutChallengeInput[]
    upsert?: ChallengeDiscussionUpsertWithWhereUniqueWithoutChallengeInput | ChallengeDiscussionUpsertWithWhereUniqueWithoutChallengeInput[]
    createMany?: ChallengeDiscussionCreateManyChallengeInputEnvelope
    set?: ChallengeDiscussionWhereUniqueInput | ChallengeDiscussionWhereUniqueInput[]
    disconnect?: ChallengeDiscussionWhereUniqueInput | ChallengeDiscussionWhereUniqueInput[]
    delete?: ChallengeDiscussionWhereUniqueInput | ChallengeDiscussionWhereUniqueInput[]
    connect?: ChallengeDiscussionWhereUniqueInput | ChallengeDiscussionWhereUniqueInput[]
    update?: ChallengeDiscussionUpdateWithWhereUniqueWithoutChallengeInput | ChallengeDiscussionUpdateWithWhereUniqueWithoutChallengeInput[]
    updateMany?: ChallengeDiscussionUpdateManyWithWhereWithoutChallengeInput | ChallengeDiscussionUpdateManyWithWhereWithoutChallengeInput[]
    deleteMany?: ChallengeDiscussionScalarWhereInput | ChallengeDiscussionScalarWhereInput[]
  }

  export type ChallengeMetadataUpdateManyWithoutChallengeNestedInput = {
    create?: XOR<ChallengeMetadataCreateWithoutChallengeInput, ChallengeMetadataUncheckedCreateWithoutChallengeInput> | ChallengeMetadataCreateWithoutChallengeInput[] | ChallengeMetadataUncheckedCreateWithoutChallengeInput[]
    connectOrCreate?: ChallengeMetadataCreateOrConnectWithoutChallengeInput | ChallengeMetadataCreateOrConnectWithoutChallengeInput[]
    upsert?: ChallengeMetadataUpsertWithWhereUniqueWithoutChallengeInput | ChallengeMetadataUpsertWithWhereUniqueWithoutChallengeInput[]
    createMany?: ChallengeMetadataCreateManyChallengeInputEnvelope
    set?: ChallengeMetadataWhereUniqueInput | ChallengeMetadataWhereUniqueInput[]
    disconnect?: ChallengeMetadataWhereUniqueInput | ChallengeMetadataWhereUniqueInput[]
    delete?: ChallengeMetadataWhereUniqueInput | ChallengeMetadataWhereUniqueInput[]
    connect?: ChallengeMetadataWhereUniqueInput | ChallengeMetadataWhereUniqueInput[]
    update?: ChallengeMetadataUpdateWithWhereUniqueWithoutChallengeInput | ChallengeMetadataUpdateWithWhereUniqueWithoutChallengeInput[]
    updateMany?: ChallengeMetadataUpdateManyWithWhereWithoutChallengeInput | ChallengeMetadataUpdateManyWithWhereWithoutChallengeInput[]
    deleteMany?: ChallengeMetadataScalarWhereInput | ChallengeMetadataScalarWhereInput[]
  }

  export type ChallengePhaseUpdateManyWithoutChallengeNestedInput = {
    create?: XOR<ChallengePhaseCreateWithoutChallengeInput, ChallengePhaseUncheckedCreateWithoutChallengeInput> | ChallengePhaseCreateWithoutChallengeInput[] | ChallengePhaseUncheckedCreateWithoutChallengeInput[]
    connectOrCreate?: ChallengePhaseCreateOrConnectWithoutChallengeInput | ChallengePhaseCreateOrConnectWithoutChallengeInput[]
    upsert?: ChallengePhaseUpsertWithWhereUniqueWithoutChallengeInput | ChallengePhaseUpsertWithWhereUniqueWithoutChallengeInput[]
    createMany?: ChallengePhaseCreateManyChallengeInputEnvelope
    set?: ChallengePhaseWhereUniqueInput | ChallengePhaseWhereUniqueInput[]
    disconnect?: ChallengePhaseWhereUniqueInput | ChallengePhaseWhereUniqueInput[]
    delete?: ChallengePhaseWhereUniqueInput | ChallengePhaseWhereUniqueInput[]
    connect?: ChallengePhaseWhereUniqueInput | ChallengePhaseWhereUniqueInput[]
    update?: ChallengePhaseUpdateWithWhereUniqueWithoutChallengeInput | ChallengePhaseUpdateWithWhereUniqueWithoutChallengeInput[]
    updateMany?: ChallengePhaseUpdateManyWithWhereWithoutChallengeInput | ChallengePhaseUpdateManyWithWhereWithoutChallengeInput[]
    deleteMany?: ChallengePhaseScalarWhereInput | ChallengePhaseScalarWhereInput[]
  }

  export type ChallengePrizeSetUpdateManyWithoutChallengeNestedInput = {
    create?: XOR<ChallengePrizeSetCreateWithoutChallengeInput, ChallengePrizeSetUncheckedCreateWithoutChallengeInput> | ChallengePrizeSetCreateWithoutChallengeInput[] | ChallengePrizeSetUncheckedCreateWithoutChallengeInput[]
    connectOrCreate?: ChallengePrizeSetCreateOrConnectWithoutChallengeInput | ChallengePrizeSetCreateOrConnectWithoutChallengeInput[]
    upsert?: ChallengePrizeSetUpsertWithWhereUniqueWithoutChallengeInput | ChallengePrizeSetUpsertWithWhereUniqueWithoutChallengeInput[]
    createMany?: ChallengePrizeSetCreateManyChallengeInputEnvelope
    set?: ChallengePrizeSetWhereUniqueInput | ChallengePrizeSetWhereUniqueInput[]
    disconnect?: ChallengePrizeSetWhereUniqueInput | ChallengePrizeSetWhereUniqueInput[]
    delete?: ChallengePrizeSetWhereUniqueInput | ChallengePrizeSetWhereUniqueInput[]
    connect?: ChallengePrizeSetWhereUniqueInput | ChallengePrizeSetWhereUniqueInput[]
    update?: ChallengePrizeSetUpdateWithWhereUniqueWithoutChallengeInput | ChallengePrizeSetUpdateWithWhereUniqueWithoutChallengeInput[]
    updateMany?: ChallengePrizeSetUpdateManyWithWhereWithoutChallengeInput | ChallengePrizeSetUpdateManyWithWhereWithoutChallengeInput[]
    deleteMany?: ChallengePrizeSetScalarWhereInput | ChallengePrizeSetScalarWhereInput[]
  }

  export type ChallengeReviewerUpdateManyWithoutChallengeNestedInput = {
    create?: XOR<ChallengeReviewerCreateWithoutChallengeInput, ChallengeReviewerUncheckedCreateWithoutChallengeInput> | ChallengeReviewerCreateWithoutChallengeInput[] | ChallengeReviewerUncheckedCreateWithoutChallengeInput[]
    connectOrCreate?: ChallengeReviewerCreateOrConnectWithoutChallengeInput | ChallengeReviewerCreateOrConnectWithoutChallengeInput[]
    upsert?: ChallengeReviewerUpsertWithWhereUniqueWithoutChallengeInput | ChallengeReviewerUpsertWithWhereUniqueWithoutChallengeInput[]
    createMany?: ChallengeReviewerCreateManyChallengeInputEnvelope
    set?: ChallengeReviewerWhereUniqueInput | ChallengeReviewerWhereUniqueInput[]
    disconnect?: ChallengeReviewerWhereUniqueInput | ChallengeReviewerWhereUniqueInput[]
    delete?: ChallengeReviewerWhereUniqueInput | ChallengeReviewerWhereUniqueInput[]
    connect?: ChallengeReviewerWhereUniqueInput | ChallengeReviewerWhereUniqueInput[]
    update?: ChallengeReviewerUpdateWithWhereUniqueWithoutChallengeInput | ChallengeReviewerUpdateWithWhereUniqueWithoutChallengeInput[]
    updateMany?: ChallengeReviewerUpdateManyWithWhereWithoutChallengeInput | ChallengeReviewerUpdateManyWithWhereWithoutChallengeInput[]
    deleteMany?: ChallengeReviewerScalarWhereInput | ChallengeReviewerScalarWhereInput[]
  }

  export type ChallengeWinnerUpdateManyWithoutChallengeNestedInput = {
    create?: XOR<ChallengeWinnerCreateWithoutChallengeInput, ChallengeWinnerUncheckedCreateWithoutChallengeInput> | ChallengeWinnerCreateWithoutChallengeInput[] | ChallengeWinnerUncheckedCreateWithoutChallengeInput[]
    connectOrCreate?: ChallengeWinnerCreateOrConnectWithoutChallengeInput | ChallengeWinnerCreateOrConnectWithoutChallengeInput[]
    upsert?: ChallengeWinnerUpsertWithWhereUniqueWithoutChallengeInput | ChallengeWinnerUpsertWithWhereUniqueWithoutChallengeInput[]
    createMany?: ChallengeWinnerCreateManyChallengeInputEnvelope
    set?: ChallengeWinnerWhereUniqueInput | ChallengeWinnerWhereUniqueInput[]
    disconnect?: ChallengeWinnerWhereUniqueInput | ChallengeWinnerWhereUniqueInput[]
    delete?: ChallengeWinnerWhereUniqueInput | ChallengeWinnerWhereUniqueInput[]
    connect?: ChallengeWinnerWhereUniqueInput | ChallengeWinnerWhereUniqueInput[]
    update?: ChallengeWinnerUpdateWithWhereUniqueWithoutChallengeInput | ChallengeWinnerUpdateWithWhereUniqueWithoutChallengeInput[]
    updateMany?: ChallengeWinnerUpdateManyWithWhereWithoutChallengeInput | ChallengeWinnerUpdateManyWithWhereWithoutChallengeInput[]
    deleteMany?: ChallengeWinnerScalarWhereInput | ChallengeWinnerScalarWhereInput[]
  }

  export type AttachmentUpdateManyWithoutChallengeNestedInput = {
    create?: XOR<AttachmentCreateWithoutChallengeInput, AttachmentUncheckedCreateWithoutChallengeInput> | AttachmentCreateWithoutChallengeInput[] | AttachmentUncheckedCreateWithoutChallengeInput[]
    connectOrCreate?: AttachmentCreateOrConnectWithoutChallengeInput | AttachmentCreateOrConnectWithoutChallengeInput[]
    upsert?: AttachmentUpsertWithWhereUniqueWithoutChallengeInput | AttachmentUpsertWithWhereUniqueWithoutChallengeInput[]
    createMany?: AttachmentCreateManyChallengeInputEnvelope
    set?: AttachmentWhereUniqueInput | AttachmentWhereUniqueInput[]
    disconnect?: AttachmentWhereUniqueInput | AttachmentWhereUniqueInput[]
    delete?: AttachmentWhereUniqueInput | AttachmentWhereUniqueInput[]
    connect?: AttachmentWhereUniqueInput | AttachmentWhereUniqueInput[]
    update?: AttachmentUpdateWithWhereUniqueWithoutChallengeInput | AttachmentUpdateWithWhereUniqueWithoutChallengeInput[]
    updateMany?: AttachmentUpdateManyWithWhereWithoutChallengeInput | AttachmentUpdateManyWithWhereWithoutChallengeInput[]
    deleteMany?: AttachmentScalarWhereInput | AttachmentScalarWhereInput[]
  }

  export type ChallengeTermUpdateManyWithoutChallengeNestedInput = {
    create?: XOR<ChallengeTermCreateWithoutChallengeInput, ChallengeTermUncheckedCreateWithoutChallengeInput> | ChallengeTermCreateWithoutChallengeInput[] | ChallengeTermUncheckedCreateWithoutChallengeInput[]
    connectOrCreate?: ChallengeTermCreateOrConnectWithoutChallengeInput | ChallengeTermCreateOrConnectWithoutChallengeInput[]
    upsert?: ChallengeTermUpsertWithWhereUniqueWithoutChallengeInput | ChallengeTermUpsertWithWhereUniqueWithoutChallengeInput[]
    createMany?: ChallengeTermCreateManyChallengeInputEnvelope
    set?: ChallengeTermWhereUniqueInput | ChallengeTermWhereUniqueInput[]
    disconnect?: ChallengeTermWhereUniqueInput | ChallengeTermWhereUniqueInput[]
    delete?: ChallengeTermWhereUniqueInput | ChallengeTermWhereUniqueInput[]
    connect?: ChallengeTermWhereUniqueInput | ChallengeTermWhereUniqueInput[]
    update?: ChallengeTermUpdateWithWhereUniqueWithoutChallengeInput | ChallengeTermUpdateWithWhereUniqueWithoutChallengeInput[]
    updateMany?: ChallengeTermUpdateManyWithWhereWithoutChallengeInput | ChallengeTermUpdateManyWithWhereWithoutChallengeInput[]
    deleteMany?: ChallengeTermScalarWhereInput | ChallengeTermScalarWhereInput[]
  }

  export type ChallengeSkillUpdateManyWithoutChallengeNestedInput = {
    create?: XOR<ChallengeSkillCreateWithoutChallengeInput, ChallengeSkillUncheckedCreateWithoutChallengeInput> | ChallengeSkillCreateWithoutChallengeInput[] | ChallengeSkillUncheckedCreateWithoutChallengeInput[]
    connectOrCreate?: ChallengeSkillCreateOrConnectWithoutChallengeInput | ChallengeSkillCreateOrConnectWithoutChallengeInput[]
    upsert?: ChallengeSkillUpsertWithWhereUniqueWithoutChallengeInput | ChallengeSkillUpsertWithWhereUniqueWithoutChallengeInput[]
    createMany?: ChallengeSkillCreateManyChallengeInputEnvelope
    set?: ChallengeSkillWhereUniqueInput | ChallengeSkillWhereUniqueInput[]
    disconnect?: ChallengeSkillWhereUniqueInput | ChallengeSkillWhereUniqueInput[]
    delete?: ChallengeSkillWhereUniqueInput | ChallengeSkillWhereUniqueInput[]
    connect?: ChallengeSkillWhereUniqueInput | ChallengeSkillWhereUniqueInput[]
    update?: ChallengeSkillUpdateWithWhereUniqueWithoutChallengeInput | ChallengeSkillUpdateWithWhereUniqueWithoutChallengeInput[]
    updateMany?: ChallengeSkillUpdateManyWithWhereWithoutChallengeInput | ChallengeSkillUpdateManyWithWhereWithoutChallengeInput[]
    deleteMany?: ChallengeSkillScalarWhereInput | ChallengeSkillScalarWhereInput[]
  }

  export type AuditLogUpdateManyWithoutChallengeNestedInput = {
    create?: XOR<AuditLogCreateWithoutChallengeInput, AuditLogUncheckedCreateWithoutChallengeInput> | AuditLogCreateWithoutChallengeInput[] | AuditLogUncheckedCreateWithoutChallengeInput[]
    connectOrCreate?: AuditLogCreateOrConnectWithoutChallengeInput | AuditLogCreateOrConnectWithoutChallengeInput[]
    upsert?: AuditLogUpsertWithWhereUniqueWithoutChallengeInput | AuditLogUpsertWithWhereUniqueWithoutChallengeInput[]
    createMany?: AuditLogCreateManyChallengeInputEnvelope
    set?: AuditLogWhereUniqueInput | AuditLogWhereUniqueInput[]
    disconnect?: AuditLogWhereUniqueInput | AuditLogWhereUniqueInput[]
    delete?: AuditLogWhereUniqueInput | AuditLogWhereUniqueInput[]
    connect?: AuditLogWhereUniqueInput | AuditLogWhereUniqueInput[]
    update?: AuditLogUpdateWithWhereUniqueWithoutChallengeInput | AuditLogUpdateWithWhereUniqueWithoutChallengeInput[]
    updateMany?: AuditLogUpdateManyWithWhereWithoutChallengeInput | AuditLogUpdateManyWithWhereWithoutChallengeInput[]
    deleteMany?: AuditLogScalarWhereInput | AuditLogScalarWhereInput[]
  }

  export type MemberChallengeAccessUpdateManyWithoutChallengeNestedInput = {
    set?: MemberChallengeAccessWhereUniqueInput | MemberChallengeAccessWhereUniqueInput[]
    disconnect?: MemberChallengeAccessWhereUniqueInput | MemberChallengeAccessWhereUniqueInput[]
    delete?: MemberChallengeAccessWhereUniqueInput | MemberChallengeAccessWhereUniqueInput[]
    connect?: MemberChallengeAccessWhereUniqueInput | MemberChallengeAccessWhereUniqueInput[]
    update?: MemberChallengeAccessUpdateWithWhereUniqueWithoutChallengeInput | MemberChallengeAccessUpdateWithWhereUniqueWithoutChallengeInput[]
    updateMany?: MemberChallengeAccessUpdateManyWithWhereWithoutChallengeInput | MemberChallengeAccessUpdateManyWithWhereWithoutChallengeInput[]
    deleteMany?: MemberChallengeAccessScalarWhereInput | MemberChallengeAccessScalarWhereInput[]
  }

  export type ChallengeTypeUpdateOneRequiredWithoutChallengesNestedInput = {
    create?: XOR<ChallengeTypeCreateWithoutChallengesInput, ChallengeTypeUncheckedCreateWithoutChallengesInput>
    connectOrCreate?: ChallengeTypeCreateOrConnectWithoutChallengesInput
    upsert?: ChallengeTypeUpsertWithoutChallengesInput
    connect?: ChallengeTypeWhereUniqueInput
    update?: XOR<XOR<ChallengeTypeUpdateToOneWithWhereWithoutChallengesInput, ChallengeTypeUpdateWithoutChallengesInput>, ChallengeTypeUncheckedUpdateWithoutChallengesInput>
  }

  export type ChallengeTrackUpdateOneRequiredWithoutChallengesNestedInput = {
    create?: XOR<ChallengeTrackCreateWithoutChallengesInput, ChallengeTrackUncheckedCreateWithoutChallengesInput>
    connectOrCreate?: ChallengeTrackCreateOrConnectWithoutChallengesInput
    upsert?: ChallengeTrackUpsertWithoutChallengesInput
    connect?: ChallengeTrackWhereUniqueInput
    update?: XOR<XOR<ChallengeTrackUpdateToOneWithWhereWithoutChallengesInput, ChallengeTrackUpdateWithoutChallengesInput>, ChallengeTrackUncheckedUpdateWithoutChallengesInput>
  }

  export type TimelineTemplateUpdateOneWithoutChallengesNestedInput = {
    create?: XOR<TimelineTemplateCreateWithoutChallengesInput, TimelineTemplateUncheckedCreateWithoutChallengesInput>
    connectOrCreate?: TimelineTemplateCreateOrConnectWithoutChallengesInput
    upsert?: TimelineTemplateUpsertWithoutChallengesInput
    disconnect?: TimelineTemplateWhereInput | boolean
    delete?: TimelineTemplateWhereInput | boolean
    connect?: TimelineTemplateWhereUniqueInput
    update?: XOR<XOR<TimelineTemplateUpdateToOneWithWhereWithoutChallengesInput, TimelineTemplateUpdateWithoutChallengesInput>, TimelineTemplateUncheckedUpdateWithoutChallengesInput>
  }

  export type ChallengeBillingUncheckedUpdateOneWithoutChallengeNestedInput = {
    create?: XOR<ChallengeBillingCreateWithoutChallengeInput, ChallengeBillingUncheckedCreateWithoutChallengeInput>
    connectOrCreate?: ChallengeBillingCreateOrConnectWithoutChallengeInput
    upsert?: ChallengeBillingUpsertWithoutChallengeInput
    disconnect?: ChallengeBillingWhereInput | boolean
    delete?: ChallengeBillingWhereInput | boolean
    connect?: ChallengeBillingWhereUniqueInput
    update?: XOR<XOR<ChallengeBillingUpdateToOneWithWhereWithoutChallengeInput, ChallengeBillingUpdateWithoutChallengeInput>, ChallengeBillingUncheckedUpdateWithoutChallengeInput>
  }

  export type ChallengeLegacyUncheckedUpdateOneWithoutChallengeNestedInput = {
    create?: XOR<ChallengeLegacyCreateWithoutChallengeInput, ChallengeLegacyUncheckedCreateWithoutChallengeInput>
    connectOrCreate?: ChallengeLegacyCreateOrConnectWithoutChallengeInput
    upsert?: ChallengeLegacyUpsertWithoutChallengeInput
    disconnect?: ChallengeLegacyWhereInput | boolean
    delete?: ChallengeLegacyWhereInput | boolean
    connect?: ChallengeLegacyWhereUniqueInput
    update?: XOR<XOR<ChallengeLegacyUpdateToOneWithWhereWithoutChallengeInput, ChallengeLegacyUpdateWithoutChallengeInput>, ChallengeLegacyUncheckedUpdateWithoutChallengeInput>
  }

  export type ChallengeConstraintUncheckedUpdateOneWithoutChallengeNestedInput = {
    create?: XOR<ChallengeConstraintCreateWithoutChallengeInput, ChallengeConstraintUncheckedCreateWithoutChallengeInput>
    connectOrCreate?: ChallengeConstraintCreateOrConnectWithoutChallengeInput
    upsert?: ChallengeConstraintUpsertWithoutChallengeInput
    disconnect?: ChallengeConstraintWhereInput | boolean
    delete?: ChallengeConstraintWhereInput | boolean
    connect?: ChallengeConstraintWhereUniqueInput
    update?: XOR<XOR<ChallengeConstraintUpdateToOneWithWhereWithoutChallengeInput, ChallengeConstraintUpdateWithoutChallengeInput>, ChallengeConstraintUncheckedUpdateWithoutChallengeInput>
  }

  export type ChallengeEventUncheckedUpdateManyWithoutChallengeNestedInput = {
    create?: XOR<ChallengeEventCreateWithoutChallengeInput, ChallengeEventUncheckedCreateWithoutChallengeInput> | ChallengeEventCreateWithoutChallengeInput[] | ChallengeEventUncheckedCreateWithoutChallengeInput[]
    connectOrCreate?: ChallengeEventCreateOrConnectWithoutChallengeInput | ChallengeEventCreateOrConnectWithoutChallengeInput[]
    upsert?: ChallengeEventUpsertWithWhereUniqueWithoutChallengeInput | ChallengeEventUpsertWithWhereUniqueWithoutChallengeInput[]
    createMany?: ChallengeEventCreateManyChallengeInputEnvelope
    set?: ChallengeEventWhereUniqueInput | ChallengeEventWhereUniqueInput[]
    disconnect?: ChallengeEventWhereUniqueInput | ChallengeEventWhereUniqueInput[]
    delete?: ChallengeEventWhereUniqueInput | ChallengeEventWhereUniqueInput[]
    connect?: ChallengeEventWhereUniqueInput | ChallengeEventWhereUniqueInput[]
    update?: ChallengeEventUpdateWithWhereUniqueWithoutChallengeInput | ChallengeEventUpdateWithWhereUniqueWithoutChallengeInput[]
    updateMany?: ChallengeEventUpdateManyWithWhereWithoutChallengeInput | ChallengeEventUpdateManyWithWhereWithoutChallengeInput[]
    deleteMany?: ChallengeEventScalarWhereInput | ChallengeEventScalarWhereInput[]
  }

  export type ChallengeDiscussionUncheckedUpdateManyWithoutChallengeNestedInput = {
    create?: XOR<ChallengeDiscussionCreateWithoutChallengeInput, ChallengeDiscussionUncheckedCreateWithoutChallengeInput> | ChallengeDiscussionCreateWithoutChallengeInput[] | ChallengeDiscussionUncheckedCreateWithoutChallengeInput[]
    connectOrCreate?: ChallengeDiscussionCreateOrConnectWithoutChallengeInput | ChallengeDiscussionCreateOrConnectWithoutChallengeInput[]
    upsert?: ChallengeDiscussionUpsertWithWhereUniqueWithoutChallengeInput | ChallengeDiscussionUpsertWithWhereUniqueWithoutChallengeInput[]
    createMany?: ChallengeDiscussionCreateManyChallengeInputEnvelope
    set?: ChallengeDiscussionWhereUniqueInput | ChallengeDiscussionWhereUniqueInput[]
    disconnect?: ChallengeDiscussionWhereUniqueInput | ChallengeDiscussionWhereUniqueInput[]
    delete?: ChallengeDiscussionWhereUniqueInput | ChallengeDiscussionWhereUniqueInput[]
    connect?: ChallengeDiscussionWhereUniqueInput | ChallengeDiscussionWhereUniqueInput[]
    update?: ChallengeDiscussionUpdateWithWhereUniqueWithoutChallengeInput | ChallengeDiscussionUpdateWithWhereUniqueWithoutChallengeInput[]
    updateMany?: ChallengeDiscussionUpdateManyWithWhereWithoutChallengeInput | ChallengeDiscussionUpdateManyWithWhereWithoutChallengeInput[]
    deleteMany?: ChallengeDiscussionScalarWhereInput | ChallengeDiscussionScalarWhereInput[]
  }

  export type ChallengeMetadataUncheckedUpdateManyWithoutChallengeNestedInput = {
    create?: XOR<ChallengeMetadataCreateWithoutChallengeInput, ChallengeMetadataUncheckedCreateWithoutChallengeInput> | ChallengeMetadataCreateWithoutChallengeInput[] | ChallengeMetadataUncheckedCreateWithoutChallengeInput[]
    connectOrCreate?: ChallengeMetadataCreateOrConnectWithoutChallengeInput | ChallengeMetadataCreateOrConnectWithoutChallengeInput[]
    upsert?: ChallengeMetadataUpsertWithWhereUniqueWithoutChallengeInput | ChallengeMetadataUpsertWithWhereUniqueWithoutChallengeInput[]
    createMany?: ChallengeMetadataCreateManyChallengeInputEnvelope
    set?: ChallengeMetadataWhereUniqueInput | ChallengeMetadataWhereUniqueInput[]
    disconnect?: ChallengeMetadataWhereUniqueInput | ChallengeMetadataWhereUniqueInput[]
    delete?: ChallengeMetadataWhereUniqueInput | ChallengeMetadataWhereUniqueInput[]
    connect?: ChallengeMetadataWhereUniqueInput | ChallengeMetadataWhereUniqueInput[]
    update?: ChallengeMetadataUpdateWithWhereUniqueWithoutChallengeInput | ChallengeMetadataUpdateWithWhereUniqueWithoutChallengeInput[]
    updateMany?: ChallengeMetadataUpdateManyWithWhereWithoutChallengeInput | ChallengeMetadataUpdateManyWithWhereWithoutChallengeInput[]
    deleteMany?: ChallengeMetadataScalarWhereInput | ChallengeMetadataScalarWhereInput[]
  }

  export type ChallengePhaseUncheckedUpdateManyWithoutChallengeNestedInput = {
    create?: XOR<ChallengePhaseCreateWithoutChallengeInput, ChallengePhaseUncheckedCreateWithoutChallengeInput> | ChallengePhaseCreateWithoutChallengeInput[] | ChallengePhaseUncheckedCreateWithoutChallengeInput[]
    connectOrCreate?: ChallengePhaseCreateOrConnectWithoutChallengeInput | ChallengePhaseCreateOrConnectWithoutChallengeInput[]
    upsert?: ChallengePhaseUpsertWithWhereUniqueWithoutChallengeInput | ChallengePhaseUpsertWithWhereUniqueWithoutChallengeInput[]
    createMany?: ChallengePhaseCreateManyChallengeInputEnvelope
    set?: ChallengePhaseWhereUniqueInput | ChallengePhaseWhereUniqueInput[]
    disconnect?: ChallengePhaseWhereUniqueInput | ChallengePhaseWhereUniqueInput[]
    delete?: ChallengePhaseWhereUniqueInput | ChallengePhaseWhereUniqueInput[]
    connect?: ChallengePhaseWhereUniqueInput | ChallengePhaseWhereUniqueInput[]
    update?: ChallengePhaseUpdateWithWhereUniqueWithoutChallengeInput | ChallengePhaseUpdateWithWhereUniqueWithoutChallengeInput[]
    updateMany?: ChallengePhaseUpdateManyWithWhereWithoutChallengeInput | ChallengePhaseUpdateManyWithWhereWithoutChallengeInput[]
    deleteMany?: ChallengePhaseScalarWhereInput | ChallengePhaseScalarWhereInput[]
  }

  export type ChallengePrizeSetUncheckedUpdateManyWithoutChallengeNestedInput = {
    create?: XOR<ChallengePrizeSetCreateWithoutChallengeInput, ChallengePrizeSetUncheckedCreateWithoutChallengeInput> | ChallengePrizeSetCreateWithoutChallengeInput[] | ChallengePrizeSetUncheckedCreateWithoutChallengeInput[]
    connectOrCreate?: ChallengePrizeSetCreateOrConnectWithoutChallengeInput | ChallengePrizeSetCreateOrConnectWithoutChallengeInput[]
    upsert?: ChallengePrizeSetUpsertWithWhereUniqueWithoutChallengeInput | ChallengePrizeSetUpsertWithWhereUniqueWithoutChallengeInput[]
    createMany?: ChallengePrizeSetCreateManyChallengeInputEnvelope
    set?: ChallengePrizeSetWhereUniqueInput | ChallengePrizeSetWhereUniqueInput[]
    disconnect?: ChallengePrizeSetWhereUniqueInput | ChallengePrizeSetWhereUniqueInput[]
    delete?: ChallengePrizeSetWhereUniqueInput | ChallengePrizeSetWhereUniqueInput[]
    connect?: ChallengePrizeSetWhereUniqueInput | ChallengePrizeSetWhereUniqueInput[]
    update?: ChallengePrizeSetUpdateWithWhereUniqueWithoutChallengeInput | ChallengePrizeSetUpdateWithWhereUniqueWithoutChallengeInput[]
    updateMany?: ChallengePrizeSetUpdateManyWithWhereWithoutChallengeInput | ChallengePrizeSetUpdateManyWithWhereWithoutChallengeInput[]
    deleteMany?: ChallengePrizeSetScalarWhereInput | ChallengePrizeSetScalarWhereInput[]
  }

  export type ChallengeReviewerUncheckedUpdateManyWithoutChallengeNestedInput = {
    create?: XOR<ChallengeReviewerCreateWithoutChallengeInput, ChallengeReviewerUncheckedCreateWithoutChallengeInput> | ChallengeReviewerCreateWithoutChallengeInput[] | ChallengeReviewerUncheckedCreateWithoutChallengeInput[]
    connectOrCreate?: ChallengeReviewerCreateOrConnectWithoutChallengeInput | ChallengeReviewerCreateOrConnectWithoutChallengeInput[]
    upsert?: ChallengeReviewerUpsertWithWhereUniqueWithoutChallengeInput | ChallengeReviewerUpsertWithWhereUniqueWithoutChallengeInput[]
    createMany?: ChallengeReviewerCreateManyChallengeInputEnvelope
    set?: ChallengeReviewerWhereUniqueInput | ChallengeReviewerWhereUniqueInput[]
    disconnect?: ChallengeReviewerWhereUniqueInput | ChallengeReviewerWhereUniqueInput[]
    delete?: ChallengeReviewerWhereUniqueInput | ChallengeReviewerWhereUniqueInput[]
    connect?: ChallengeReviewerWhereUniqueInput | ChallengeReviewerWhereUniqueInput[]
    update?: ChallengeReviewerUpdateWithWhereUniqueWithoutChallengeInput | ChallengeReviewerUpdateWithWhereUniqueWithoutChallengeInput[]
    updateMany?: ChallengeReviewerUpdateManyWithWhereWithoutChallengeInput | ChallengeReviewerUpdateManyWithWhereWithoutChallengeInput[]
    deleteMany?: ChallengeReviewerScalarWhereInput | ChallengeReviewerScalarWhereInput[]
  }

  export type ChallengeWinnerUncheckedUpdateManyWithoutChallengeNestedInput = {
    create?: XOR<ChallengeWinnerCreateWithoutChallengeInput, ChallengeWinnerUncheckedCreateWithoutChallengeInput> | ChallengeWinnerCreateWithoutChallengeInput[] | ChallengeWinnerUncheckedCreateWithoutChallengeInput[]
    connectOrCreate?: ChallengeWinnerCreateOrConnectWithoutChallengeInput | ChallengeWinnerCreateOrConnectWithoutChallengeInput[]
    upsert?: ChallengeWinnerUpsertWithWhereUniqueWithoutChallengeInput | ChallengeWinnerUpsertWithWhereUniqueWithoutChallengeInput[]
    createMany?: ChallengeWinnerCreateManyChallengeInputEnvelope
    set?: ChallengeWinnerWhereUniqueInput | ChallengeWinnerWhereUniqueInput[]
    disconnect?: ChallengeWinnerWhereUniqueInput | ChallengeWinnerWhereUniqueInput[]
    delete?: ChallengeWinnerWhereUniqueInput | ChallengeWinnerWhereUniqueInput[]
    connect?: ChallengeWinnerWhereUniqueInput | ChallengeWinnerWhereUniqueInput[]
    update?: ChallengeWinnerUpdateWithWhereUniqueWithoutChallengeInput | ChallengeWinnerUpdateWithWhereUniqueWithoutChallengeInput[]
    updateMany?: ChallengeWinnerUpdateManyWithWhereWithoutChallengeInput | ChallengeWinnerUpdateManyWithWhereWithoutChallengeInput[]
    deleteMany?: ChallengeWinnerScalarWhereInput | ChallengeWinnerScalarWhereInput[]
  }

  export type AttachmentUncheckedUpdateManyWithoutChallengeNestedInput = {
    create?: XOR<AttachmentCreateWithoutChallengeInput, AttachmentUncheckedCreateWithoutChallengeInput> | AttachmentCreateWithoutChallengeInput[] | AttachmentUncheckedCreateWithoutChallengeInput[]
    connectOrCreate?: AttachmentCreateOrConnectWithoutChallengeInput | AttachmentCreateOrConnectWithoutChallengeInput[]
    upsert?: AttachmentUpsertWithWhereUniqueWithoutChallengeInput | AttachmentUpsertWithWhereUniqueWithoutChallengeInput[]
    createMany?: AttachmentCreateManyChallengeInputEnvelope
    set?: AttachmentWhereUniqueInput | AttachmentWhereUniqueInput[]
    disconnect?: AttachmentWhereUniqueInput | AttachmentWhereUniqueInput[]
    delete?: AttachmentWhereUniqueInput | AttachmentWhereUniqueInput[]
    connect?: AttachmentWhereUniqueInput | AttachmentWhereUniqueInput[]
    update?: AttachmentUpdateWithWhereUniqueWithoutChallengeInput | AttachmentUpdateWithWhereUniqueWithoutChallengeInput[]
    updateMany?: AttachmentUpdateManyWithWhereWithoutChallengeInput | AttachmentUpdateManyWithWhereWithoutChallengeInput[]
    deleteMany?: AttachmentScalarWhereInput | AttachmentScalarWhereInput[]
  }

  export type ChallengeTermUncheckedUpdateManyWithoutChallengeNestedInput = {
    create?: XOR<ChallengeTermCreateWithoutChallengeInput, ChallengeTermUncheckedCreateWithoutChallengeInput> | ChallengeTermCreateWithoutChallengeInput[] | ChallengeTermUncheckedCreateWithoutChallengeInput[]
    connectOrCreate?: ChallengeTermCreateOrConnectWithoutChallengeInput | ChallengeTermCreateOrConnectWithoutChallengeInput[]
    upsert?: ChallengeTermUpsertWithWhereUniqueWithoutChallengeInput | ChallengeTermUpsertWithWhereUniqueWithoutChallengeInput[]
    createMany?: ChallengeTermCreateManyChallengeInputEnvelope
    set?: ChallengeTermWhereUniqueInput | ChallengeTermWhereUniqueInput[]
    disconnect?: ChallengeTermWhereUniqueInput | ChallengeTermWhereUniqueInput[]
    delete?: ChallengeTermWhereUniqueInput | ChallengeTermWhereUniqueInput[]
    connect?: ChallengeTermWhereUniqueInput | ChallengeTermWhereUniqueInput[]
    update?: ChallengeTermUpdateWithWhereUniqueWithoutChallengeInput | ChallengeTermUpdateWithWhereUniqueWithoutChallengeInput[]
    updateMany?: ChallengeTermUpdateManyWithWhereWithoutChallengeInput | ChallengeTermUpdateManyWithWhereWithoutChallengeInput[]
    deleteMany?: ChallengeTermScalarWhereInput | ChallengeTermScalarWhereInput[]
  }

  export type ChallengeSkillUncheckedUpdateManyWithoutChallengeNestedInput = {
    create?: XOR<ChallengeSkillCreateWithoutChallengeInput, ChallengeSkillUncheckedCreateWithoutChallengeInput> | ChallengeSkillCreateWithoutChallengeInput[] | ChallengeSkillUncheckedCreateWithoutChallengeInput[]
    connectOrCreate?: ChallengeSkillCreateOrConnectWithoutChallengeInput | ChallengeSkillCreateOrConnectWithoutChallengeInput[]
    upsert?: ChallengeSkillUpsertWithWhereUniqueWithoutChallengeInput | ChallengeSkillUpsertWithWhereUniqueWithoutChallengeInput[]
    createMany?: ChallengeSkillCreateManyChallengeInputEnvelope
    set?: ChallengeSkillWhereUniqueInput | ChallengeSkillWhereUniqueInput[]
    disconnect?: ChallengeSkillWhereUniqueInput | ChallengeSkillWhereUniqueInput[]
    delete?: ChallengeSkillWhereUniqueInput | ChallengeSkillWhereUniqueInput[]
    connect?: ChallengeSkillWhereUniqueInput | ChallengeSkillWhereUniqueInput[]
    update?: ChallengeSkillUpdateWithWhereUniqueWithoutChallengeInput | ChallengeSkillUpdateWithWhereUniqueWithoutChallengeInput[]
    updateMany?: ChallengeSkillUpdateManyWithWhereWithoutChallengeInput | ChallengeSkillUpdateManyWithWhereWithoutChallengeInput[]
    deleteMany?: ChallengeSkillScalarWhereInput | ChallengeSkillScalarWhereInput[]
  }

  export type AuditLogUncheckedUpdateManyWithoutChallengeNestedInput = {
    create?: XOR<AuditLogCreateWithoutChallengeInput, AuditLogUncheckedCreateWithoutChallengeInput> | AuditLogCreateWithoutChallengeInput[] | AuditLogUncheckedCreateWithoutChallengeInput[]
    connectOrCreate?: AuditLogCreateOrConnectWithoutChallengeInput | AuditLogCreateOrConnectWithoutChallengeInput[]
    upsert?: AuditLogUpsertWithWhereUniqueWithoutChallengeInput | AuditLogUpsertWithWhereUniqueWithoutChallengeInput[]
    createMany?: AuditLogCreateManyChallengeInputEnvelope
    set?: AuditLogWhereUniqueInput | AuditLogWhereUniqueInput[]
    disconnect?: AuditLogWhereUniqueInput | AuditLogWhereUniqueInput[]
    delete?: AuditLogWhereUniqueInput | AuditLogWhereUniqueInput[]
    connect?: AuditLogWhereUniqueInput | AuditLogWhereUniqueInput[]
    update?: AuditLogUpdateWithWhereUniqueWithoutChallengeInput | AuditLogUpdateWithWhereUniqueWithoutChallengeInput[]
    updateMany?: AuditLogUpdateManyWithWhereWithoutChallengeInput | AuditLogUpdateManyWithWhereWithoutChallengeInput[]
    deleteMany?: AuditLogScalarWhereInput | AuditLogScalarWhereInput[]
  }

  export type MemberChallengeAccessUncheckedUpdateManyWithoutChallengeNestedInput = {
    set?: MemberChallengeAccessWhereUniqueInput | MemberChallengeAccessWhereUniqueInput[]
    disconnect?: MemberChallengeAccessWhereUniqueInput | MemberChallengeAccessWhereUniqueInput[]
    delete?: MemberChallengeAccessWhereUniqueInput | MemberChallengeAccessWhereUniqueInput[]
    connect?: MemberChallengeAccessWhereUniqueInput | MemberChallengeAccessWhereUniqueInput[]
    update?: MemberChallengeAccessUpdateWithWhereUniqueWithoutChallengeInput | MemberChallengeAccessUpdateWithWhereUniqueWithoutChallengeInput[]
    updateMany?: MemberChallengeAccessUpdateManyWithWhereWithoutChallengeInput | MemberChallengeAccessUpdateManyWithWhereWithoutChallengeInput[]
    deleteMany?: MemberChallengeAccessScalarWhereInput | MemberChallengeAccessScalarWhereInput[]
  }

  export type ChallengeCreateNestedManyWithoutTypeInput = {
    create?: XOR<ChallengeCreateWithoutTypeInput, ChallengeUncheckedCreateWithoutTypeInput> | ChallengeCreateWithoutTypeInput[] | ChallengeUncheckedCreateWithoutTypeInput[]
    connectOrCreate?: ChallengeCreateOrConnectWithoutTypeInput | ChallengeCreateOrConnectWithoutTypeInput[]
    createMany?: ChallengeCreateManyTypeInputEnvelope
    connect?: ChallengeWhereUniqueInput | ChallengeWhereUniqueInput[]
  }

  export type ChallengeTimelineTemplateCreateNestedManyWithoutTypeInput = {
    create?: XOR<ChallengeTimelineTemplateCreateWithoutTypeInput, ChallengeTimelineTemplateUncheckedCreateWithoutTypeInput> | ChallengeTimelineTemplateCreateWithoutTypeInput[] | ChallengeTimelineTemplateUncheckedCreateWithoutTypeInput[]
    connectOrCreate?: ChallengeTimelineTemplateCreateOrConnectWithoutTypeInput | ChallengeTimelineTemplateCreateOrConnectWithoutTypeInput[]
    createMany?: ChallengeTimelineTemplateCreateManyTypeInputEnvelope
    connect?: ChallengeTimelineTemplateWhereUniqueInput | ChallengeTimelineTemplateWhereUniqueInput[]
  }

  export type DefaultChallengeReviewerCreateNestedManyWithoutChallengeTypeInput = {
    create?: XOR<DefaultChallengeReviewerCreateWithoutChallengeTypeInput, DefaultChallengeReviewerUncheckedCreateWithoutChallengeTypeInput> | DefaultChallengeReviewerCreateWithoutChallengeTypeInput[] | DefaultChallengeReviewerUncheckedCreateWithoutChallengeTypeInput[]
    connectOrCreate?: DefaultChallengeReviewerCreateOrConnectWithoutChallengeTypeInput | DefaultChallengeReviewerCreateOrConnectWithoutChallengeTypeInput[]
    createMany?: DefaultChallengeReviewerCreateManyChallengeTypeInputEnvelope
    connect?: DefaultChallengeReviewerWhereUniqueInput | DefaultChallengeReviewerWhereUniqueInput[]
  }

  export type ChallengeUncheckedCreateNestedManyWithoutTypeInput = {
    create?: XOR<ChallengeCreateWithoutTypeInput, ChallengeUncheckedCreateWithoutTypeInput> | ChallengeCreateWithoutTypeInput[] | ChallengeUncheckedCreateWithoutTypeInput[]
    connectOrCreate?: ChallengeCreateOrConnectWithoutTypeInput | ChallengeCreateOrConnectWithoutTypeInput[]
    createMany?: ChallengeCreateManyTypeInputEnvelope
    connect?: ChallengeWhereUniqueInput | ChallengeWhereUniqueInput[]
  }

  export type ChallengeTimelineTemplateUncheckedCreateNestedManyWithoutTypeInput = {
    create?: XOR<ChallengeTimelineTemplateCreateWithoutTypeInput, ChallengeTimelineTemplateUncheckedCreateWithoutTypeInput> | ChallengeTimelineTemplateCreateWithoutTypeInput[] | ChallengeTimelineTemplateUncheckedCreateWithoutTypeInput[]
    connectOrCreate?: ChallengeTimelineTemplateCreateOrConnectWithoutTypeInput | ChallengeTimelineTemplateCreateOrConnectWithoutTypeInput[]
    createMany?: ChallengeTimelineTemplateCreateManyTypeInputEnvelope
    connect?: ChallengeTimelineTemplateWhereUniqueInput | ChallengeTimelineTemplateWhereUniqueInput[]
  }

  export type DefaultChallengeReviewerUncheckedCreateNestedManyWithoutChallengeTypeInput = {
    create?: XOR<DefaultChallengeReviewerCreateWithoutChallengeTypeInput, DefaultChallengeReviewerUncheckedCreateWithoutChallengeTypeInput> | DefaultChallengeReviewerCreateWithoutChallengeTypeInput[] | DefaultChallengeReviewerUncheckedCreateWithoutChallengeTypeInput[]
    connectOrCreate?: DefaultChallengeReviewerCreateOrConnectWithoutChallengeTypeInput | DefaultChallengeReviewerCreateOrConnectWithoutChallengeTypeInput[]
    createMany?: DefaultChallengeReviewerCreateManyChallengeTypeInputEnvelope
    connect?: DefaultChallengeReviewerWhereUniqueInput | DefaultChallengeReviewerWhereUniqueInput[]
  }

  export type ChallengeUpdateManyWithoutTypeNestedInput = {
    create?: XOR<ChallengeCreateWithoutTypeInput, ChallengeUncheckedCreateWithoutTypeInput> | ChallengeCreateWithoutTypeInput[] | ChallengeUncheckedCreateWithoutTypeInput[]
    connectOrCreate?: ChallengeCreateOrConnectWithoutTypeInput | ChallengeCreateOrConnectWithoutTypeInput[]
    upsert?: ChallengeUpsertWithWhereUniqueWithoutTypeInput | ChallengeUpsertWithWhereUniqueWithoutTypeInput[]
    createMany?: ChallengeCreateManyTypeInputEnvelope
    set?: ChallengeWhereUniqueInput | ChallengeWhereUniqueInput[]
    disconnect?: ChallengeWhereUniqueInput | ChallengeWhereUniqueInput[]
    delete?: ChallengeWhereUniqueInput | ChallengeWhereUniqueInput[]
    connect?: ChallengeWhereUniqueInput | ChallengeWhereUniqueInput[]
    update?: ChallengeUpdateWithWhereUniqueWithoutTypeInput | ChallengeUpdateWithWhereUniqueWithoutTypeInput[]
    updateMany?: ChallengeUpdateManyWithWhereWithoutTypeInput | ChallengeUpdateManyWithWhereWithoutTypeInput[]
    deleteMany?: ChallengeScalarWhereInput | ChallengeScalarWhereInput[]
  }

  export type ChallengeTimelineTemplateUpdateManyWithoutTypeNestedInput = {
    create?: XOR<ChallengeTimelineTemplateCreateWithoutTypeInput, ChallengeTimelineTemplateUncheckedCreateWithoutTypeInput> | ChallengeTimelineTemplateCreateWithoutTypeInput[] | ChallengeTimelineTemplateUncheckedCreateWithoutTypeInput[]
    connectOrCreate?: ChallengeTimelineTemplateCreateOrConnectWithoutTypeInput | ChallengeTimelineTemplateCreateOrConnectWithoutTypeInput[]
    upsert?: ChallengeTimelineTemplateUpsertWithWhereUniqueWithoutTypeInput | ChallengeTimelineTemplateUpsertWithWhereUniqueWithoutTypeInput[]
    createMany?: ChallengeTimelineTemplateCreateManyTypeInputEnvelope
    set?: ChallengeTimelineTemplateWhereUniqueInput | ChallengeTimelineTemplateWhereUniqueInput[]
    disconnect?: ChallengeTimelineTemplateWhereUniqueInput | ChallengeTimelineTemplateWhereUniqueInput[]
    delete?: ChallengeTimelineTemplateWhereUniqueInput | ChallengeTimelineTemplateWhereUniqueInput[]
    connect?: ChallengeTimelineTemplateWhereUniqueInput | ChallengeTimelineTemplateWhereUniqueInput[]
    update?: ChallengeTimelineTemplateUpdateWithWhereUniqueWithoutTypeInput | ChallengeTimelineTemplateUpdateWithWhereUniqueWithoutTypeInput[]
    updateMany?: ChallengeTimelineTemplateUpdateManyWithWhereWithoutTypeInput | ChallengeTimelineTemplateUpdateManyWithWhereWithoutTypeInput[]
    deleteMany?: ChallengeTimelineTemplateScalarWhereInput | ChallengeTimelineTemplateScalarWhereInput[]
  }

  export type DefaultChallengeReviewerUpdateManyWithoutChallengeTypeNestedInput = {
    create?: XOR<DefaultChallengeReviewerCreateWithoutChallengeTypeInput, DefaultChallengeReviewerUncheckedCreateWithoutChallengeTypeInput> | DefaultChallengeReviewerCreateWithoutChallengeTypeInput[] | DefaultChallengeReviewerUncheckedCreateWithoutChallengeTypeInput[]
    connectOrCreate?: DefaultChallengeReviewerCreateOrConnectWithoutChallengeTypeInput | DefaultChallengeReviewerCreateOrConnectWithoutChallengeTypeInput[]
    upsert?: DefaultChallengeReviewerUpsertWithWhereUniqueWithoutChallengeTypeInput | DefaultChallengeReviewerUpsertWithWhereUniqueWithoutChallengeTypeInput[]
    createMany?: DefaultChallengeReviewerCreateManyChallengeTypeInputEnvelope
    set?: DefaultChallengeReviewerWhereUniqueInput | DefaultChallengeReviewerWhereUniqueInput[]
    disconnect?: DefaultChallengeReviewerWhereUniqueInput | DefaultChallengeReviewerWhereUniqueInput[]
    delete?: DefaultChallengeReviewerWhereUniqueInput | DefaultChallengeReviewerWhereUniqueInput[]
    connect?: DefaultChallengeReviewerWhereUniqueInput | DefaultChallengeReviewerWhereUniqueInput[]
    update?: DefaultChallengeReviewerUpdateWithWhereUniqueWithoutChallengeTypeInput | DefaultChallengeReviewerUpdateWithWhereUniqueWithoutChallengeTypeInput[]
    updateMany?: DefaultChallengeReviewerUpdateManyWithWhereWithoutChallengeTypeInput | DefaultChallengeReviewerUpdateManyWithWhereWithoutChallengeTypeInput[]
    deleteMany?: DefaultChallengeReviewerScalarWhereInput | DefaultChallengeReviewerScalarWhereInput[]
  }

  export type ChallengeUncheckedUpdateManyWithoutTypeNestedInput = {
    create?: XOR<ChallengeCreateWithoutTypeInput, ChallengeUncheckedCreateWithoutTypeInput> | ChallengeCreateWithoutTypeInput[] | ChallengeUncheckedCreateWithoutTypeInput[]
    connectOrCreate?: ChallengeCreateOrConnectWithoutTypeInput | ChallengeCreateOrConnectWithoutTypeInput[]
    upsert?: ChallengeUpsertWithWhereUniqueWithoutTypeInput | ChallengeUpsertWithWhereUniqueWithoutTypeInput[]
    createMany?: ChallengeCreateManyTypeInputEnvelope
    set?: ChallengeWhereUniqueInput | ChallengeWhereUniqueInput[]
    disconnect?: ChallengeWhereUniqueInput | ChallengeWhereUniqueInput[]
    delete?: ChallengeWhereUniqueInput | ChallengeWhereUniqueInput[]
    connect?: ChallengeWhereUniqueInput | ChallengeWhereUniqueInput[]
    update?: ChallengeUpdateWithWhereUniqueWithoutTypeInput | ChallengeUpdateWithWhereUniqueWithoutTypeInput[]
    updateMany?: ChallengeUpdateManyWithWhereWithoutTypeInput | ChallengeUpdateManyWithWhereWithoutTypeInput[]
    deleteMany?: ChallengeScalarWhereInput | ChallengeScalarWhereInput[]
  }

  export type ChallengeTimelineTemplateUncheckedUpdateManyWithoutTypeNestedInput = {
    create?: XOR<ChallengeTimelineTemplateCreateWithoutTypeInput, ChallengeTimelineTemplateUncheckedCreateWithoutTypeInput> | ChallengeTimelineTemplateCreateWithoutTypeInput[] | ChallengeTimelineTemplateUncheckedCreateWithoutTypeInput[]
    connectOrCreate?: ChallengeTimelineTemplateCreateOrConnectWithoutTypeInput | ChallengeTimelineTemplateCreateOrConnectWithoutTypeInput[]
    upsert?: ChallengeTimelineTemplateUpsertWithWhereUniqueWithoutTypeInput | ChallengeTimelineTemplateUpsertWithWhereUniqueWithoutTypeInput[]
    createMany?: ChallengeTimelineTemplateCreateManyTypeInputEnvelope
    set?: ChallengeTimelineTemplateWhereUniqueInput | ChallengeTimelineTemplateWhereUniqueInput[]
    disconnect?: ChallengeTimelineTemplateWhereUniqueInput | ChallengeTimelineTemplateWhereUniqueInput[]
    delete?: ChallengeTimelineTemplateWhereUniqueInput | ChallengeTimelineTemplateWhereUniqueInput[]
    connect?: ChallengeTimelineTemplateWhereUniqueInput | ChallengeTimelineTemplateWhereUniqueInput[]
    update?: ChallengeTimelineTemplateUpdateWithWhereUniqueWithoutTypeInput | ChallengeTimelineTemplateUpdateWithWhereUniqueWithoutTypeInput[]
    updateMany?: ChallengeTimelineTemplateUpdateManyWithWhereWithoutTypeInput | ChallengeTimelineTemplateUpdateManyWithWhereWithoutTypeInput[]
    deleteMany?: ChallengeTimelineTemplateScalarWhereInput | ChallengeTimelineTemplateScalarWhereInput[]
  }

  export type DefaultChallengeReviewerUncheckedUpdateManyWithoutChallengeTypeNestedInput = {
    create?: XOR<DefaultChallengeReviewerCreateWithoutChallengeTypeInput, DefaultChallengeReviewerUncheckedCreateWithoutChallengeTypeInput> | DefaultChallengeReviewerCreateWithoutChallengeTypeInput[] | DefaultChallengeReviewerUncheckedCreateWithoutChallengeTypeInput[]
    connectOrCreate?: DefaultChallengeReviewerCreateOrConnectWithoutChallengeTypeInput | DefaultChallengeReviewerCreateOrConnectWithoutChallengeTypeInput[]
    upsert?: DefaultChallengeReviewerUpsertWithWhereUniqueWithoutChallengeTypeInput | DefaultChallengeReviewerUpsertWithWhereUniqueWithoutChallengeTypeInput[]
    createMany?: DefaultChallengeReviewerCreateManyChallengeTypeInputEnvelope
    set?: DefaultChallengeReviewerWhereUniqueInput | DefaultChallengeReviewerWhereUniqueInput[]
    disconnect?: DefaultChallengeReviewerWhereUniqueInput | DefaultChallengeReviewerWhereUniqueInput[]
    delete?: DefaultChallengeReviewerWhereUniqueInput | DefaultChallengeReviewerWhereUniqueInput[]
    connect?: DefaultChallengeReviewerWhereUniqueInput | DefaultChallengeReviewerWhereUniqueInput[]
    update?: DefaultChallengeReviewerUpdateWithWhereUniqueWithoutChallengeTypeInput | DefaultChallengeReviewerUpdateWithWhereUniqueWithoutChallengeTypeInput[]
    updateMany?: DefaultChallengeReviewerUpdateManyWithWhereWithoutChallengeTypeInput | DefaultChallengeReviewerUpdateManyWithWhereWithoutChallengeTypeInput[]
    deleteMany?: DefaultChallengeReviewerScalarWhereInput | DefaultChallengeReviewerScalarWhereInput[]
  }

  export type ChallengeCreateNestedManyWithoutTrackInput = {
    create?: XOR<ChallengeCreateWithoutTrackInput, ChallengeUncheckedCreateWithoutTrackInput> | ChallengeCreateWithoutTrackInput[] | ChallengeUncheckedCreateWithoutTrackInput[]
    connectOrCreate?: ChallengeCreateOrConnectWithoutTrackInput | ChallengeCreateOrConnectWithoutTrackInput[]
    createMany?: ChallengeCreateManyTrackInputEnvelope
    connect?: ChallengeWhereUniqueInput | ChallengeWhereUniqueInput[]
  }

  export type ChallengeTimelineTemplateCreateNestedManyWithoutTrackInput = {
    create?: XOR<ChallengeTimelineTemplateCreateWithoutTrackInput, ChallengeTimelineTemplateUncheckedCreateWithoutTrackInput> | ChallengeTimelineTemplateCreateWithoutTrackInput[] | ChallengeTimelineTemplateUncheckedCreateWithoutTrackInput[]
    connectOrCreate?: ChallengeTimelineTemplateCreateOrConnectWithoutTrackInput | ChallengeTimelineTemplateCreateOrConnectWithoutTrackInput[]
    createMany?: ChallengeTimelineTemplateCreateManyTrackInputEnvelope
    connect?: ChallengeTimelineTemplateWhereUniqueInput | ChallengeTimelineTemplateWhereUniqueInput[]
  }

  export type DefaultChallengeReviewerCreateNestedManyWithoutChallengeTrackInput = {
    create?: XOR<DefaultChallengeReviewerCreateWithoutChallengeTrackInput, DefaultChallengeReviewerUncheckedCreateWithoutChallengeTrackInput> | DefaultChallengeReviewerCreateWithoutChallengeTrackInput[] | DefaultChallengeReviewerUncheckedCreateWithoutChallengeTrackInput[]
    connectOrCreate?: DefaultChallengeReviewerCreateOrConnectWithoutChallengeTrackInput | DefaultChallengeReviewerCreateOrConnectWithoutChallengeTrackInput[]
    createMany?: DefaultChallengeReviewerCreateManyChallengeTrackInputEnvelope
    connect?: DefaultChallengeReviewerWhereUniqueInput | DefaultChallengeReviewerWhereUniqueInput[]
  }

  export type ChallengeUncheckedCreateNestedManyWithoutTrackInput = {
    create?: XOR<ChallengeCreateWithoutTrackInput, ChallengeUncheckedCreateWithoutTrackInput> | ChallengeCreateWithoutTrackInput[] | ChallengeUncheckedCreateWithoutTrackInput[]
    connectOrCreate?: ChallengeCreateOrConnectWithoutTrackInput | ChallengeCreateOrConnectWithoutTrackInput[]
    createMany?: ChallengeCreateManyTrackInputEnvelope
    connect?: ChallengeWhereUniqueInput | ChallengeWhereUniqueInput[]
  }

  export type ChallengeTimelineTemplateUncheckedCreateNestedManyWithoutTrackInput = {
    create?: XOR<ChallengeTimelineTemplateCreateWithoutTrackInput, ChallengeTimelineTemplateUncheckedCreateWithoutTrackInput> | ChallengeTimelineTemplateCreateWithoutTrackInput[] | ChallengeTimelineTemplateUncheckedCreateWithoutTrackInput[]
    connectOrCreate?: ChallengeTimelineTemplateCreateOrConnectWithoutTrackInput | ChallengeTimelineTemplateCreateOrConnectWithoutTrackInput[]
    createMany?: ChallengeTimelineTemplateCreateManyTrackInputEnvelope
    connect?: ChallengeTimelineTemplateWhereUniqueInput | ChallengeTimelineTemplateWhereUniqueInput[]
  }

  export type DefaultChallengeReviewerUncheckedCreateNestedManyWithoutChallengeTrackInput = {
    create?: XOR<DefaultChallengeReviewerCreateWithoutChallengeTrackInput, DefaultChallengeReviewerUncheckedCreateWithoutChallengeTrackInput> | DefaultChallengeReviewerCreateWithoutChallengeTrackInput[] | DefaultChallengeReviewerUncheckedCreateWithoutChallengeTrackInput[]
    connectOrCreate?: DefaultChallengeReviewerCreateOrConnectWithoutChallengeTrackInput | DefaultChallengeReviewerCreateOrConnectWithoutChallengeTrackInput[]
    createMany?: DefaultChallengeReviewerCreateManyChallengeTrackInputEnvelope
    connect?: DefaultChallengeReviewerWhereUniqueInput | DefaultChallengeReviewerWhereUniqueInput[]
  }

  export type NullableEnumChallengeTrackEnumFieldUpdateOperationsInput = {
    set?: $Enums.ChallengeTrackEnum | null
  }

  export type ChallengeUpdateManyWithoutTrackNestedInput = {
    create?: XOR<ChallengeCreateWithoutTrackInput, ChallengeUncheckedCreateWithoutTrackInput> | ChallengeCreateWithoutTrackInput[] | ChallengeUncheckedCreateWithoutTrackInput[]
    connectOrCreate?: ChallengeCreateOrConnectWithoutTrackInput | ChallengeCreateOrConnectWithoutTrackInput[]
    upsert?: ChallengeUpsertWithWhereUniqueWithoutTrackInput | ChallengeUpsertWithWhereUniqueWithoutTrackInput[]
    createMany?: ChallengeCreateManyTrackInputEnvelope
    set?: ChallengeWhereUniqueInput | ChallengeWhereUniqueInput[]
    disconnect?: ChallengeWhereUniqueInput | ChallengeWhereUniqueInput[]
    delete?: ChallengeWhereUniqueInput | ChallengeWhereUniqueInput[]
    connect?: ChallengeWhereUniqueInput | ChallengeWhereUniqueInput[]
    update?: ChallengeUpdateWithWhereUniqueWithoutTrackInput | ChallengeUpdateWithWhereUniqueWithoutTrackInput[]
    updateMany?: ChallengeUpdateManyWithWhereWithoutTrackInput | ChallengeUpdateManyWithWhereWithoutTrackInput[]
    deleteMany?: ChallengeScalarWhereInput | ChallengeScalarWhereInput[]
  }

  export type ChallengeTimelineTemplateUpdateManyWithoutTrackNestedInput = {
    create?: XOR<ChallengeTimelineTemplateCreateWithoutTrackInput, ChallengeTimelineTemplateUncheckedCreateWithoutTrackInput> | ChallengeTimelineTemplateCreateWithoutTrackInput[] | ChallengeTimelineTemplateUncheckedCreateWithoutTrackInput[]
    connectOrCreate?: ChallengeTimelineTemplateCreateOrConnectWithoutTrackInput | ChallengeTimelineTemplateCreateOrConnectWithoutTrackInput[]
    upsert?: ChallengeTimelineTemplateUpsertWithWhereUniqueWithoutTrackInput | ChallengeTimelineTemplateUpsertWithWhereUniqueWithoutTrackInput[]
    createMany?: ChallengeTimelineTemplateCreateManyTrackInputEnvelope
    set?: ChallengeTimelineTemplateWhereUniqueInput | ChallengeTimelineTemplateWhereUniqueInput[]
    disconnect?: ChallengeTimelineTemplateWhereUniqueInput | ChallengeTimelineTemplateWhereUniqueInput[]
    delete?: ChallengeTimelineTemplateWhereUniqueInput | ChallengeTimelineTemplateWhereUniqueInput[]
    connect?: ChallengeTimelineTemplateWhereUniqueInput | ChallengeTimelineTemplateWhereUniqueInput[]
    update?: ChallengeTimelineTemplateUpdateWithWhereUniqueWithoutTrackInput | ChallengeTimelineTemplateUpdateWithWhereUniqueWithoutTrackInput[]
    updateMany?: ChallengeTimelineTemplateUpdateManyWithWhereWithoutTrackInput | ChallengeTimelineTemplateUpdateManyWithWhereWithoutTrackInput[]
    deleteMany?: ChallengeTimelineTemplateScalarWhereInput | ChallengeTimelineTemplateScalarWhereInput[]
  }

  export type DefaultChallengeReviewerUpdateManyWithoutChallengeTrackNestedInput = {
    create?: XOR<DefaultChallengeReviewerCreateWithoutChallengeTrackInput, DefaultChallengeReviewerUncheckedCreateWithoutChallengeTrackInput> | DefaultChallengeReviewerCreateWithoutChallengeTrackInput[] | DefaultChallengeReviewerUncheckedCreateWithoutChallengeTrackInput[]
    connectOrCreate?: DefaultChallengeReviewerCreateOrConnectWithoutChallengeTrackInput | DefaultChallengeReviewerCreateOrConnectWithoutChallengeTrackInput[]
    upsert?: DefaultChallengeReviewerUpsertWithWhereUniqueWithoutChallengeTrackInput | DefaultChallengeReviewerUpsertWithWhereUniqueWithoutChallengeTrackInput[]
    createMany?: DefaultChallengeReviewerCreateManyChallengeTrackInputEnvelope
    set?: DefaultChallengeReviewerWhereUniqueInput | DefaultChallengeReviewerWhereUniqueInput[]
    disconnect?: DefaultChallengeReviewerWhereUniqueInput | DefaultChallengeReviewerWhereUniqueInput[]
    delete?: DefaultChallengeReviewerWhereUniqueInput | DefaultChallengeReviewerWhereUniqueInput[]
    connect?: DefaultChallengeReviewerWhereUniqueInput | DefaultChallengeReviewerWhereUniqueInput[]
    update?: DefaultChallengeReviewerUpdateWithWhereUniqueWithoutChallengeTrackInput | DefaultChallengeReviewerUpdateWithWhereUniqueWithoutChallengeTrackInput[]
    updateMany?: DefaultChallengeReviewerUpdateManyWithWhereWithoutChallengeTrackInput | DefaultChallengeReviewerUpdateManyWithWhereWithoutChallengeTrackInput[]
    deleteMany?: DefaultChallengeReviewerScalarWhereInput | DefaultChallengeReviewerScalarWhereInput[]
  }

  export type ChallengeUncheckedUpdateManyWithoutTrackNestedInput = {
    create?: XOR<ChallengeCreateWithoutTrackInput, ChallengeUncheckedCreateWithoutTrackInput> | ChallengeCreateWithoutTrackInput[] | ChallengeUncheckedCreateWithoutTrackInput[]
    connectOrCreate?: ChallengeCreateOrConnectWithoutTrackInput | ChallengeCreateOrConnectWithoutTrackInput[]
    upsert?: ChallengeUpsertWithWhereUniqueWithoutTrackInput | ChallengeUpsertWithWhereUniqueWithoutTrackInput[]
    createMany?: ChallengeCreateManyTrackInputEnvelope
    set?: ChallengeWhereUniqueInput | ChallengeWhereUniqueInput[]
    disconnect?: ChallengeWhereUniqueInput | ChallengeWhereUniqueInput[]
    delete?: ChallengeWhereUniqueInput | ChallengeWhereUniqueInput[]
    connect?: ChallengeWhereUniqueInput | ChallengeWhereUniqueInput[]
    update?: ChallengeUpdateWithWhereUniqueWithoutTrackInput | ChallengeUpdateWithWhereUniqueWithoutTrackInput[]
    updateMany?: ChallengeUpdateManyWithWhereWithoutTrackInput | ChallengeUpdateManyWithWhereWithoutTrackInput[]
    deleteMany?: ChallengeScalarWhereInput | ChallengeScalarWhereInput[]
  }

  export type ChallengeTimelineTemplateUncheckedUpdateManyWithoutTrackNestedInput = {
    create?: XOR<ChallengeTimelineTemplateCreateWithoutTrackInput, ChallengeTimelineTemplateUncheckedCreateWithoutTrackInput> | ChallengeTimelineTemplateCreateWithoutTrackInput[] | ChallengeTimelineTemplateUncheckedCreateWithoutTrackInput[]
    connectOrCreate?: ChallengeTimelineTemplateCreateOrConnectWithoutTrackInput | ChallengeTimelineTemplateCreateOrConnectWithoutTrackInput[]
    upsert?: ChallengeTimelineTemplateUpsertWithWhereUniqueWithoutTrackInput | ChallengeTimelineTemplateUpsertWithWhereUniqueWithoutTrackInput[]
    createMany?: ChallengeTimelineTemplateCreateManyTrackInputEnvelope
    set?: ChallengeTimelineTemplateWhereUniqueInput | ChallengeTimelineTemplateWhereUniqueInput[]
    disconnect?: ChallengeTimelineTemplateWhereUniqueInput | ChallengeTimelineTemplateWhereUniqueInput[]
    delete?: ChallengeTimelineTemplateWhereUniqueInput | ChallengeTimelineTemplateWhereUniqueInput[]
    connect?: ChallengeTimelineTemplateWhereUniqueInput | ChallengeTimelineTemplateWhereUniqueInput[]
    update?: ChallengeTimelineTemplateUpdateWithWhereUniqueWithoutTrackInput | ChallengeTimelineTemplateUpdateWithWhereUniqueWithoutTrackInput[]
    updateMany?: ChallengeTimelineTemplateUpdateManyWithWhereWithoutTrackInput | ChallengeTimelineTemplateUpdateManyWithWhereWithoutTrackInput[]
    deleteMany?: ChallengeTimelineTemplateScalarWhereInput | ChallengeTimelineTemplateScalarWhereInput[]
  }

  export type DefaultChallengeReviewerUncheckedUpdateManyWithoutChallengeTrackNestedInput = {
    create?: XOR<DefaultChallengeReviewerCreateWithoutChallengeTrackInput, DefaultChallengeReviewerUncheckedCreateWithoutChallengeTrackInput> | DefaultChallengeReviewerCreateWithoutChallengeTrackInput[] | DefaultChallengeReviewerUncheckedCreateWithoutChallengeTrackInput[]
    connectOrCreate?: DefaultChallengeReviewerCreateOrConnectWithoutChallengeTrackInput | DefaultChallengeReviewerCreateOrConnectWithoutChallengeTrackInput[]
    upsert?: DefaultChallengeReviewerUpsertWithWhereUniqueWithoutChallengeTrackInput | DefaultChallengeReviewerUpsertWithWhereUniqueWithoutChallengeTrackInput[]
    createMany?: DefaultChallengeReviewerCreateManyChallengeTrackInputEnvelope
    set?: DefaultChallengeReviewerWhereUniqueInput | DefaultChallengeReviewerWhereUniqueInput[]
    disconnect?: DefaultChallengeReviewerWhereUniqueInput | DefaultChallengeReviewerWhereUniqueInput[]
    delete?: DefaultChallengeReviewerWhereUniqueInput | DefaultChallengeReviewerWhereUniqueInput[]
    connect?: DefaultChallengeReviewerWhereUniqueInput | DefaultChallengeReviewerWhereUniqueInput[]
    update?: DefaultChallengeReviewerUpdateWithWhereUniqueWithoutChallengeTrackInput | DefaultChallengeReviewerUpdateWithWhereUniqueWithoutChallengeTrackInput[]
    updateMany?: DefaultChallengeReviewerUpdateManyWithWhereWithoutChallengeTrackInput | DefaultChallengeReviewerUpdateManyWithWhereWithoutChallengeTrackInput[]
    deleteMany?: DefaultChallengeReviewerScalarWhereInput | DefaultChallengeReviewerScalarWhereInput[]
  }

  export type TimelineTemplateCreateNestedOneWithoutChallengeTimelineTemplatesInput = {
    create?: XOR<TimelineTemplateCreateWithoutChallengeTimelineTemplatesInput, TimelineTemplateUncheckedCreateWithoutChallengeTimelineTemplatesInput>
    connectOrCreate?: TimelineTemplateCreateOrConnectWithoutChallengeTimelineTemplatesInput
    connect?: TimelineTemplateWhereUniqueInput
  }

  export type ChallengeTrackCreateNestedOneWithoutTimelineTemplatesInput = {
    create?: XOR<ChallengeTrackCreateWithoutTimelineTemplatesInput, ChallengeTrackUncheckedCreateWithoutTimelineTemplatesInput>
    connectOrCreate?: ChallengeTrackCreateOrConnectWithoutTimelineTemplatesInput
    connect?: ChallengeTrackWhereUniqueInput
  }

  export type ChallengeTypeCreateNestedOneWithoutTimelineTemplatesInput = {
    create?: XOR<ChallengeTypeCreateWithoutTimelineTemplatesInput, ChallengeTypeUncheckedCreateWithoutTimelineTemplatesInput>
    connectOrCreate?: ChallengeTypeCreateOrConnectWithoutTimelineTemplatesInput
    connect?: ChallengeTypeWhereUniqueInput
  }

  export type TimelineTemplateUpdateOneRequiredWithoutChallengeTimelineTemplatesNestedInput = {
    create?: XOR<TimelineTemplateCreateWithoutChallengeTimelineTemplatesInput, TimelineTemplateUncheckedCreateWithoutChallengeTimelineTemplatesInput>
    connectOrCreate?: TimelineTemplateCreateOrConnectWithoutChallengeTimelineTemplatesInput
    upsert?: TimelineTemplateUpsertWithoutChallengeTimelineTemplatesInput
    connect?: TimelineTemplateWhereUniqueInput
    update?: XOR<XOR<TimelineTemplateUpdateToOneWithWhereWithoutChallengeTimelineTemplatesInput, TimelineTemplateUpdateWithoutChallengeTimelineTemplatesInput>, TimelineTemplateUncheckedUpdateWithoutChallengeTimelineTemplatesInput>
  }

  export type ChallengeTrackUpdateOneRequiredWithoutTimelineTemplatesNestedInput = {
    create?: XOR<ChallengeTrackCreateWithoutTimelineTemplatesInput, ChallengeTrackUncheckedCreateWithoutTimelineTemplatesInput>
    connectOrCreate?: ChallengeTrackCreateOrConnectWithoutTimelineTemplatesInput
    upsert?: ChallengeTrackUpsertWithoutTimelineTemplatesInput
    connect?: ChallengeTrackWhereUniqueInput
    update?: XOR<XOR<ChallengeTrackUpdateToOneWithWhereWithoutTimelineTemplatesInput, ChallengeTrackUpdateWithoutTimelineTemplatesInput>, ChallengeTrackUncheckedUpdateWithoutTimelineTemplatesInput>
  }

  export type ChallengeTypeUpdateOneRequiredWithoutTimelineTemplatesNestedInput = {
    create?: XOR<ChallengeTypeCreateWithoutTimelineTemplatesInput, ChallengeTypeUncheckedCreateWithoutTimelineTemplatesInput>
    connectOrCreate?: ChallengeTypeCreateOrConnectWithoutTimelineTemplatesInput
    upsert?: ChallengeTypeUpsertWithoutTimelineTemplatesInput
    connect?: ChallengeTypeWhereUniqueInput
    update?: XOR<XOR<ChallengeTypeUpdateToOneWithWhereWithoutTimelineTemplatesInput, ChallengeTypeUpdateWithoutTimelineTemplatesInput>, ChallengeTypeUncheckedUpdateWithoutTimelineTemplatesInput>
  }

  export type ChallengeCreateNestedOneWithoutAuditLogsInput = {
    create?: XOR<ChallengeCreateWithoutAuditLogsInput, ChallengeUncheckedCreateWithoutAuditLogsInput>
    connectOrCreate?: ChallengeCreateOrConnectWithoutAuditLogsInput
    connect?: ChallengeWhereUniqueInput
  }

  export type ChallengeUpdateOneWithoutAuditLogsNestedInput = {
    create?: XOR<ChallengeCreateWithoutAuditLogsInput, ChallengeUncheckedCreateWithoutAuditLogsInput>
    connectOrCreate?: ChallengeCreateOrConnectWithoutAuditLogsInput
    upsert?: ChallengeUpsertWithoutAuditLogsInput
    disconnect?: ChallengeWhereInput | boolean
    delete?: ChallengeWhereInput | boolean
    connect?: ChallengeWhereUniqueInput
    update?: XOR<XOR<ChallengeUpdateToOneWithWhereWithoutAuditLogsInput, ChallengeUpdateWithoutAuditLogsInput>, ChallengeUncheckedUpdateWithoutAuditLogsInput>
  }

  export type ChallengeCreateNestedOneWithoutAttachmentsInput = {
    create?: XOR<ChallengeCreateWithoutAttachmentsInput, ChallengeUncheckedCreateWithoutAttachmentsInput>
    connectOrCreate?: ChallengeCreateOrConnectWithoutAttachmentsInput
    connect?: ChallengeWhereUniqueInput
  }

  export type ChallengeUpdateOneRequiredWithoutAttachmentsNestedInput = {
    create?: XOR<ChallengeCreateWithoutAttachmentsInput, ChallengeUncheckedCreateWithoutAttachmentsInput>
    connectOrCreate?: ChallengeCreateOrConnectWithoutAttachmentsInput
    upsert?: ChallengeUpsertWithoutAttachmentsInput
    connect?: ChallengeWhereUniqueInput
    update?: XOR<XOR<ChallengeUpdateToOneWithWhereWithoutAttachmentsInput, ChallengeUpdateWithoutAttachmentsInput>, ChallengeUncheckedUpdateWithoutAttachmentsInput>
  }

  export type ChallengeCreateNestedOneWithoutMetadataInput = {
    create?: XOR<ChallengeCreateWithoutMetadataInput, ChallengeUncheckedCreateWithoutMetadataInput>
    connectOrCreate?: ChallengeCreateOrConnectWithoutMetadataInput
    connect?: ChallengeWhereUniqueInput
  }

  export type ChallengeUpdateOneRequiredWithoutMetadataNestedInput = {
    create?: XOR<ChallengeCreateWithoutMetadataInput, ChallengeUncheckedCreateWithoutMetadataInput>
    connectOrCreate?: ChallengeCreateOrConnectWithoutMetadataInput
    upsert?: ChallengeUpsertWithoutMetadataInput
    connect?: ChallengeWhereUniqueInput
    update?: XOR<XOR<ChallengeUpdateToOneWithWhereWithoutMetadataInput, ChallengeUpdateWithoutMetadataInput>, ChallengeUncheckedUpdateWithoutMetadataInput>
  }

  export type ChallengePrizeSetCreateNestedOneWithoutPrizesInput = {
    create?: XOR<ChallengePrizeSetCreateWithoutPrizesInput, ChallengePrizeSetUncheckedCreateWithoutPrizesInput>
    connectOrCreate?: ChallengePrizeSetCreateOrConnectWithoutPrizesInput
    connect?: ChallengePrizeSetWhereUniqueInput
  }

  export type FloatFieldUpdateOperationsInput = {
    set?: number
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
  }

  export type ChallengePrizeSetUpdateOneRequiredWithoutPrizesNestedInput = {
    create?: XOR<ChallengePrizeSetCreateWithoutPrizesInput, ChallengePrizeSetUncheckedCreateWithoutPrizesInput>
    connectOrCreate?: ChallengePrizeSetCreateOrConnectWithoutPrizesInput
    upsert?: ChallengePrizeSetUpsertWithoutPrizesInput
    connect?: ChallengePrizeSetWhereUniqueInput
    update?: XOR<XOR<ChallengePrizeSetUpdateToOneWithWhereWithoutPrizesInput, ChallengePrizeSetUpdateWithoutPrizesInput>, ChallengePrizeSetUncheckedUpdateWithoutPrizesInput>
  }

  export type ChallengeCreateNestedOneWithoutWinnersInput = {
    create?: XOR<ChallengeCreateWithoutWinnersInput, ChallengeUncheckedCreateWithoutWinnersInput>
    connectOrCreate?: ChallengeCreateOrConnectWithoutWinnersInput
    connect?: ChallengeWhereUniqueInput
  }

  export type EnumPrizeSetTypeEnumFieldUpdateOperationsInput = {
    set?: $Enums.PrizeSetTypeEnum
  }

  export type ChallengeUpdateOneRequiredWithoutWinnersNestedInput = {
    create?: XOR<ChallengeCreateWithoutWinnersInput, ChallengeUncheckedCreateWithoutWinnersInput>
    connectOrCreate?: ChallengeCreateOrConnectWithoutWinnersInput
    upsert?: ChallengeUpsertWithoutWinnersInput
    connect?: ChallengeWhereUniqueInput
    update?: XOR<XOR<ChallengeUpdateToOneWithWhereWithoutWinnersInput, ChallengeUpdateWithoutWinnersInput>, ChallengeUncheckedUpdateWithoutWinnersInput>
  }

  export type ChallengeCreateNestedOneWithoutTermsInput = {
    create?: XOR<ChallengeCreateWithoutTermsInput, ChallengeUncheckedCreateWithoutTermsInput>
    connectOrCreate?: ChallengeCreateOrConnectWithoutTermsInput
    connect?: ChallengeWhereUniqueInput
  }

  export type ChallengeUpdateOneRequiredWithoutTermsNestedInput = {
    create?: XOR<ChallengeCreateWithoutTermsInput, ChallengeUncheckedCreateWithoutTermsInput>
    connectOrCreate?: ChallengeCreateOrConnectWithoutTermsInput
    upsert?: ChallengeUpsertWithoutTermsInput
    connect?: ChallengeWhereUniqueInput
    update?: XOR<XOR<ChallengeUpdateToOneWithWhereWithoutTermsInput, ChallengeUpdateWithoutTermsInput>, ChallengeUncheckedUpdateWithoutTermsInput>
  }

  export type ChallengeCreateNestedOneWithoutSkillsInput = {
    create?: XOR<ChallengeCreateWithoutSkillsInput, ChallengeUncheckedCreateWithoutSkillsInput>
    connectOrCreate?: ChallengeCreateOrConnectWithoutSkillsInput
    connect?: ChallengeWhereUniqueInput
  }

  export type ChallengeUpdateOneRequiredWithoutSkillsNestedInput = {
    create?: XOR<ChallengeCreateWithoutSkillsInput, ChallengeUncheckedCreateWithoutSkillsInput>
    connectOrCreate?: ChallengeCreateOrConnectWithoutSkillsInput
    upsert?: ChallengeUpsertWithoutSkillsInput
    connect?: ChallengeWhereUniqueInput
    update?: XOR<XOR<ChallengeUpdateToOneWithWhereWithoutSkillsInput, ChallengeUpdateWithoutSkillsInput>, ChallengeUncheckedUpdateWithoutSkillsInput>
  }

  export type ChallengeCreateNestedOneWithoutBillingRecordInput = {
    create?: XOR<ChallengeCreateWithoutBillingRecordInput, ChallengeUncheckedCreateWithoutBillingRecordInput>
    connectOrCreate?: ChallengeCreateOrConnectWithoutBillingRecordInput
    connect?: ChallengeWhereUniqueInput
  }

  export type ChallengeUpdateOneRequiredWithoutBillingRecordNestedInput = {
    create?: XOR<ChallengeCreateWithoutBillingRecordInput, ChallengeUncheckedCreateWithoutBillingRecordInput>
    connectOrCreate?: ChallengeCreateOrConnectWithoutBillingRecordInput
    upsert?: ChallengeUpsertWithoutBillingRecordInput
    connect?: ChallengeWhereUniqueInput
    update?: XOR<XOR<ChallengeUpdateToOneWithWhereWithoutBillingRecordInput, ChallengeUpdateWithoutBillingRecordInput>, ChallengeUncheckedUpdateWithoutBillingRecordInput>
  }

  export type ChallengeCreateNestedOneWithoutLegacyRecordInput = {
    create?: XOR<ChallengeCreateWithoutLegacyRecordInput, ChallengeUncheckedCreateWithoutLegacyRecordInput>
    connectOrCreate?: ChallengeCreateOrConnectWithoutLegacyRecordInput
    connect?: ChallengeWhereUniqueInput
  }

  export type EnumReviewTypeEnumFieldUpdateOperationsInput = {
    set?: $Enums.ReviewTypeEnum
  }

  export type ChallengeUpdateOneRequiredWithoutLegacyRecordNestedInput = {
    create?: XOR<ChallengeCreateWithoutLegacyRecordInput, ChallengeUncheckedCreateWithoutLegacyRecordInput>
    connectOrCreate?: ChallengeCreateOrConnectWithoutLegacyRecordInput
    upsert?: ChallengeUpsertWithoutLegacyRecordInput
    connect?: ChallengeWhereUniqueInput
    update?: XOR<XOR<ChallengeUpdateToOneWithWhereWithoutLegacyRecordInput, ChallengeUpdateWithoutLegacyRecordInput>, ChallengeUncheckedUpdateWithoutLegacyRecordInput>
  }

  export type ChallengeCreateNestedOneWithoutEventsInput = {
    create?: XOR<ChallengeCreateWithoutEventsInput, ChallengeUncheckedCreateWithoutEventsInput>
    connectOrCreate?: ChallengeCreateOrConnectWithoutEventsInput
    connect?: ChallengeWhereUniqueInput
  }

  export type ChallengeUpdateOneRequiredWithoutEventsNestedInput = {
    create?: XOR<ChallengeCreateWithoutEventsInput, ChallengeUncheckedCreateWithoutEventsInput>
    connectOrCreate?: ChallengeCreateOrConnectWithoutEventsInput
    upsert?: ChallengeUpsertWithoutEventsInput
    connect?: ChallengeWhereUniqueInput
    update?: XOR<XOR<ChallengeUpdateToOneWithWhereWithoutEventsInput, ChallengeUpdateWithoutEventsInput>, ChallengeUncheckedUpdateWithoutEventsInput>
  }

  export type ChallengeCreateNestedOneWithoutDiscussionsInput = {
    create?: XOR<ChallengeCreateWithoutDiscussionsInput, ChallengeUncheckedCreateWithoutDiscussionsInput>
    connectOrCreate?: ChallengeCreateOrConnectWithoutDiscussionsInput
    connect?: ChallengeWhereUniqueInput
  }

  export type ChallengeDiscussionOptionCreateNestedManyWithoutDiscussionInput = {
    create?: XOR<ChallengeDiscussionOptionCreateWithoutDiscussionInput, ChallengeDiscussionOptionUncheckedCreateWithoutDiscussionInput> | ChallengeDiscussionOptionCreateWithoutDiscussionInput[] | ChallengeDiscussionOptionUncheckedCreateWithoutDiscussionInput[]
    connectOrCreate?: ChallengeDiscussionOptionCreateOrConnectWithoutDiscussionInput | ChallengeDiscussionOptionCreateOrConnectWithoutDiscussionInput[]
    createMany?: ChallengeDiscussionOptionCreateManyDiscussionInputEnvelope
    connect?: ChallengeDiscussionOptionWhereUniqueInput | ChallengeDiscussionOptionWhereUniqueInput[]
  }

  export type ChallengeDiscussionOptionUncheckedCreateNestedManyWithoutDiscussionInput = {
    create?: XOR<ChallengeDiscussionOptionCreateWithoutDiscussionInput, ChallengeDiscussionOptionUncheckedCreateWithoutDiscussionInput> | ChallengeDiscussionOptionCreateWithoutDiscussionInput[] | ChallengeDiscussionOptionUncheckedCreateWithoutDiscussionInput[]
    connectOrCreate?: ChallengeDiscussionOptionCreateOrConnectWithoutDiscussionInput | ChallengeDiscussionOptionCreateOrConnectWithoutDiscussionInput[]
    createMany?: ChallengeDiscussionOptionCreateManyDiscussionInputEnvelope
    connect?: ChallengeDiscussionOptionWhereUniqueInput | ChallengeDiscussionOptionWhereUniqueInput[]
  }

  export type EnumDiscussionTypeEnumFieldUpdateOperationsInput = {
    set?: $Enums.DiscussionTypeEnum
  }

  export type ChallengeUpdateOneRequiredWithoutDiscussionsNestedInput = {
    create?: XOR<ChallengeCreateWithoutDiscussionsInput, ChallengeUncheckedCreateWithoutDiscussionsInput>
    connectOrCreate?: ChallengeCreateOrConnectWithoutDiscussionsInput
    upsert?: ChallengeUpsertWithoutDiscussionsInput
    connect?: ChallengeWhereUniqueInput
    update?: XOR<XOR<ChallengeUpdateToOneWithWhereWithoutDiscussionsInput, ChallengeUpdateWithoutDiscussionsInput>, ChallengeUncheckedUpdateWithoutDiscussionsInput>
  }

  export type ChallengeDiscussionOptionUpdateManyWithoutDiscussionNestedInput = {
    create?: XOR<ChallengeDiscussionOptionCreateWithoutDiscussionInput, ChallengeDiscussionOptionUncheckedCreateWithoutDiscussionInput> | ChallengeDiscussionOptionCreateWithoutDiscussionInput[] | ChallengeDiscussionOptionUncheckedCreateWithoutDiscussionInput[]
    connectOrCreate?: ChallengeDiscussionOptionCreateOrConnectWithoutDiscussionInput | ChallengeDiscussionOptionCreateOrConnectWithoutDiscussionInput[]
    upsert?: ChallengeDiscussionOptionUpsertWithWhereUniqueWithoutDiscussionInput | ChallengeDiscussionOptionUpsertWithWhereUniqueWithoutDiscussionInput[]
    createMany?: ChallengeDiscussionOptionCreateManyDiscussionInputEnvelope
    set?: ChallengeDiscussionOptionWhereUniqueInput | ChallengeDiscussionOptionWhereUniqueInput[]
    disconnect?: ChallengeDiscussionOptionWhereUniqueInput | ChallengeDiscussionOptionWhereUniqueInput[]
    delete?: ChallengeDiscussionOptionWhereUniqueInput | ChallengeDiscussionOptionWhereUniqueInput[]
    connect?: ChallengeDiscussionOptionWhereUniqueInput | ChallengeDiscussionOptionWhereUniqueInput[]
    update?: ChallengeDiscussionOptionUpdateWithWhereUniqueWithoutDiscussionInput | ChallengeDiscussionOptionUpdateWithWhereUniqueWithoutDiscussionInput[]
    updateMany?: ChallengeDiscussionOptionUpdateManyWithWhereWithoutDiscussionInput | ChallengeDiscussionOptionUpdateManyWithWhereWithoutDiscussionInput[]
    deleteMany?: ChallengeDiscussionOptionScalarWhereInput | ChallengeDiscussionOptionScalarWhereInput[]
  }

  export type ChallengeDiscussionOptionUncheckedUpdateManyWithoutDiscussionNestedInput = {
    create?: XOR<ChallengeDiscussionOptionCreateWithoutDiscussionInput, ChallengeDiscussionOptionUncheckedCreateWithoutDiscussionInput> | ChallengeDiscussionOptionCreateWithoutDiscussionInput[] | ChallengeDiscussionOptionUncheckedCreateWithoutDiscussionInput[]
    connectOrCreate?: ChallengeDiscussionOptionCreateOrConnectWithoutDiscussionInput | ChallengeDiscussionOptionCreateOrConnectWithoutDiscussionInput[]
    upsert?: ChallengeDiscussionOptionUpsertWithWhereUniqueWithoutDiscussionInput | ChallengeDiscussionOptionUpsertWithWhereUniqueWithoutDiscussionInput[]
    createMany?: ChallengeDiscussionOptionCreateManyDiscussionInputEnvelope
    set?: ChallengeDiscussionOptionWhereUniqueInput | ChallengeDiscussionOptionWhereUniqueInput[]
    disconnect?: ChallengeDiscussionOptionWhereUniqueInput | ChallengeDiscussionOptionWhereUniqueInput[]
    delete?: ChallengeDiscussionOptionWhereUniqueInput | ChallengeDiscussionOptionWhereUniqueInput[]
    connect?: ChallengeDiscussionOptionWhereUniqueInput | ChallengeDiscussionOptionWhereUniqueInput[]
    update?: ChallengeDiscussionOptionUpdateWithWhereUniqueWithoutDiscussionInput | ChallengeDiscussionOptionUpdateWithWhereUniqueWithoutDiscussionInput[]
    updateMany?: ChallengeDiscussionOptionUpdateManyWithWhereWithoutDiscussionInput | ChallengeDiscussionOptionUpdateManyWithWhereWithoutDiscussionInput[]
    deleteMany?: ChallengeDiscussionOptionScalarWhereInput | ChallengeDiscussionOptionScalarWhereInput[]
  }

  export type ChallengeDiscussionCreateNestedOneWithoutOptionsInput = {
    create?: XOR<ChallengeDiscussionCreateWithoutOptionsInput, ChallengeDiscussionUncheckedCreateWithoutOptionsInput>
    connectOrCreate?: ChallengeDiscussionCreateOrConnectWithoutOptionsInput
    connect?: ChallengeDiscussionWhereUniqueInput
  }

  export type ChallengeDiscussionUpdateOneRequiredWithoutOptionsNestedInput = {
    create?: XOR<ChallengeDiscussionCreateWithoutOptionsInput, ChallengeDiscussionUncheckedCreateWithoutOptionsInput>
    connectOrCreate?: ChallengeDiscussionCreateOrConnectWithoutOptionsInput
    upsert?: ChallengeDiscussionUpsertWithoutOptionsInput
    connect?: ChallengeDiscussionWhereUniqueInput
    update?: XOR<XOR<ChallengeDiscussionUpdateToOneWithWhereWithoutOptionsInput, ChallengeDiscussionUpdateWithoutOptionsInput>, ChallengeDiscussionUncheckedUpdateWithoutOptionsInput>
  }

  export type ChallengeConstraintCreateallowedRegistrantsInput = {
    set: string[]
  }

  export type ChallengeCreateNestedOneWithoutConstraintRecordInput = {
    create?: XOR<ChallengeCreateWithoutConstraintRecordInput, ChallengeUncheckedCreateWithoutConstraintRecordInput>
    connectOrCreate?: ChallengeCreateOrConnectWithoutConstraintRecordInput
    connect?: ChallengeWhereUniqueInput
  }

  export type ChallengeConstraintUpdateallowedRegistrantsInput = {
    set?: string[]
    push?: string | string[]
  }

  export type ChallengeUpdateOneRequiredWithoutConstraintRecordNestedInput = {
    create?: XOR<ChallengeCreateWithoutConstraintRecordInput, ChallengeUncheckedCreateWithoutConstraintRecordInput>
    connectOrCreate?: ChallengeCreateOrConnectWithoutConstraintRecordInput
    upsert?: ChallengeUpsertWithoutConstraintRecordInput
    connect?: ChallengeWhereUniqueInput
    update?: XOR<XOR<ChallengeUpdateToOneWithWhereWithoutConstraintRecordInput, ChallengeUpdateWithoutConstraintRecordInput>, ChallengeUncheckedUpdateWithoutConstraintRecordInput>
  }

  export type ChallengePhaseCreateNestedManyWithoutPhaseInput = {
    create?: XOR<ChallengePhaseCreateWithoutPhaseInput, ChallengePhaseUncheckedCreateWithoutPhaseInput> | ChallengePhaseCreateWithoutPhaseInput[] | ChallengePhaseUncheckedCreateWithoutPhaseInput[]
    connectOrCreate?: ChallengePhaseCreateOrConnectWithoutPhaseInput | ChallengePhaseCreateOrConnectWithoutPhaseInput[]
    createMany?: ChallengePhaseCreateManyPhaseInputEnvelope
    connect?: ChallengePhaseWhereUniqueInput | ChallengePhaseWhereUniqueInput[]
  }

  export type ChallengeReviewerCreateNestedManyWithoutPhaseInput = {
    create?: XOR<ChallengeReviewerCreateWithoutPhaseInput, ChallengeReviewerUncheckedCreateWithoutPhaseInput> | ChallengeReviewerCreateWithoutPhaseInput[] | ChallengeReviewerUncheckedCreateWithoutPhaseInput[]
    connectOrCreate?: ChallengeReviewerCreateOrConnectWithoutPhaseInput | ChallengeReviewerCreateOrConnectWithoutPhaseInput[]
    createMany?: ChallengeReviewerCreateManyPhaseInputEnvelope
    connect?: ChallengeReviewerWhereUniqueInput | ChallengeReviewerWhereUniqueInput[]
  }

  export type DefaultChallengeReviewerCreateNestedManyWithoutPhaseInput = {
    create?: XOR<DefaultChallengeReviewerCreateWithoutPhaseInput, DefaultChallengeReviewerUncheckedCreateWithoutPhaseInput> | DefaultChallengeReviewerCreateWithoutPhaseInput[] | DefaultChallengeReviewerUncheckedCreateWithoutPhaseInput[]
    connectOrCreate?: DefaultChallengeReviewerCreateOrConnectWithoutPhaseInput | DefaultChallengeReviewerCreateOrConnectWithoutPhaseInput[]
    createMany?: DefaultChallengeReviewerCreateManyPhaseInputEnvelope
    connect?: DefaultChallengeReviewerWhereUniqueInput | DefaultChallengeReviewerWhereUniqueInput[]
  }

  export type ChallengePhaseUncheckedCreateNestedManyWithoutPhaseInput = {
    create?: XOR<ChallengePhaseCreateWithoutPhaseInput, ChallengePhaseUncheckedCreateWithoutPhaseInput> | ChallengePhaseCreateWithoutPhaseInput[] | ChallengePhaseUncheckedCreateWithoutPhaseInput[]
    connectOrCreate?: ChallengePhaseCreateOrConnectWithoutPhaseInput | ChallengePhaseCreateOrConnectWithoutPhaseInput[]
    createMany?: ChallengePhaseCreateManyPhaseInputEnvelope
    connect?: ChallengePhaseWhereUniqueInput | ChallengePhaseWhereUniqueInput[]
  }

  export type ChallengeReviewerUncheckedCreateNestedManyWithoutPhaseInput = {
    create?: XOR<ChallengeReviewerCreateWithoutPhaseInput, ChallengeReviewerUncheckedCreateWithoutPhaseInput> | ChallengeReviewerCreateWithoutPhaseInput[] | ChallengeReviewerUncheckedCreateWithoutPhaseInput[]
    connectOrCreate?: ChallengeReviewerCreateOrConnectWithoutPhaseInput | ChallengeReviewerCreateOrConnectWithoutPhaseInput[]
    createMany?: ChallengeReviewerCreateManyPhaseInputEnvelope
    connect?: ChallengeReviewerWhereUniqueInput | ChallengeReviewerWhereUniqueInput[]
  }

  export type DefaultChallengeReviewerUncheckedCreateNestedManyWithoutPhaseInput = {
    create?: XOR<DefaultChallengeReviewerCreateWithoutPhaseInput, DefaultChallengeReviewerUncheckedCreateWithoutPhaseInput> | DefaultChallengeReviewerCreateWithoutPhaseInput[] | DefaultChallengeReviewerUncheckedCreateWithoutPhaseInput[]
    connectOrCreate?: DefaultChallengeReviewerCreateOrConnectWithoutPhaseInput | DefaultChallengeReviewerCreateOrConnectWithoutPhaseInput[]
    createMany?: DefaultChallengeReviewerCreateManyPhaseInputEnvelope
    connect?: DefaultChallengeReviewerWhereUniqueInput | DefaultChallengeReviewerWhereUniqueInput[]
  }

  export type ChallengePhaseUpdateManyWithoutPhaseNestedInput = {
    create?: XOR<ChallengePhaseCreateWithoutPhaseInput, ChallengePhaseUncheckedCreateWithoutPhaseInput> | ChallengePhaseCreateWithoutPhaseInput[] | ChallengePhaseUncheckedCreateWithoutPhaseInput[]
    connectOrCreate?: ChallengePhaseCreateOrConnectWithoutPhaseInput | ChallengePhaseCreateOrConnectWithoutPhaseInput[]
    upsert?: ChallengePhaseUpsertWithWhereUniqueWithoutPhaseInput | ChallengePhaseUpsertWithWhereUniqueWithoutPhaseInput[]
    createMany?: ChallengePhaseCreateManyPhaseInputEnvelope
    set?: ChallengePhaseWhereUniqueInput | ChallengePhaseWhereUniqueInput[]
    disconnect?: ChallengePhaseWhereUniqueInput | ChallengePhaseWhereUniqueInput[]
    delete?: ChallengePhaseWhereUniqueInput | ChallengePhaseWhereUniqueInput[]
    connect?: ChallengePhaseWhereUniqueInput | ChallengePhaseWhereUniqueInput[]
    update?: ChallengePhaseUpdateWithWhereUniqueWithoutPhaseInput | ChallengePhaseUpdateWithWhereUniqueWithoutPhaseInput[]
    updateMany?: ChallengePhaseUpdateManyWithWhereWithoutPhaseInput | ChallengePhaseUpdateManyWithWhereWithoutPhaseInput[]
    deleteMany?: ChallengePhaseScalarWhereInput | ChallengePhaseScalarWhereInput[]
  }

  export type ChallengeReviewerUpdateManyWithoutPhaseNestedInput = {
    create?: XOR<ChallengeReviewerCreateWithoutPhaseInput, ChallengeReviewerUncheckedCreateWithoutPhaseInput> | ChallengeReviewerCreateWithoutPhaseInput[] | ChallengeReviewerUncheckedCreateWithoutPhaseInput[]
    connectOrCreate?: ChallengeReviewerCreateOrConnectWithoutPhaseInput | ChallengeReviewerCreateOrConnectWithoutPhaseInput[]
    upsert?: ChallengeReviewerUpsertWithWhereUniqueWithoutPhaseInput | ChallengeReviewerUpsertWithWhereUniqueWithoutPhaseInput[]
    createMany?: ChallengeReviewerCreateManyPhaseInputEnvelope
    set?: ChallengeReviewerWhereUniqueInput | ChallengeReviewerWhereUniqueInput[]
    disconnect?: ChallengeReviewerWhereUniqueInput | ChallengeReviewerWhereUniqueInput[]
    delete?: ChallengeReviewerWhereUniqueInput | ChallengeReviewerWhereUniqueInput[]
    connect?: ChallengeReviewerWhereUniqueInput | ChallengeReviewerWhereUniqueInput[]
    update?: ChallengeReviewerUpdateWithWhereUniqueWithoutPhaseInput | ChallengeReviewerUpdateWithWhereUniqueWithoutPhaseInput[]
    updateMany?: ChallengeReviewerUpdateManyWithWhereWithoutPhaseInput | ChallengeReviewerUpdateManyWithWhereWithoutPhaseInput[]
    deleteMany?: ChallengeReviewerScalarWhereInput | ChallengeReviewerScalarWhereInput[]
  }

  export type DefaultChallengeReviewerUpdateManyWithoutPhaseNestedInput = {
    create?: XOR<DefaultChallengeReviewerCreateWithoutPhaseInput, DefaultChallengeReviewerUncheckedCreateWithoutPhaseInput> | DefaultChallengeReviewerCreateWithoutPhaseInput[] | DefaultChallengeReviewerUncheckedCreateWithoutPhaseInput[]
    connectOrCreate?: DefaultChallengeReviewerCreateOrConnectWithoutPhaseInput | DefaultChallengeReviewerCreateOrConnectWithoutPhaseInput[]
    upsert?: DefaultChallengeReviewerUpsertWithWhereUniqueWithoutPhaseInput | DefaultChallengeReviewerUpsertWithWhereUniqueWithoutPhaseInput[]
    createMany?: DefaultChallengeReviewerCreateManyPhaseInputEnvelope
    set?: DefaultChallengeReviewerWhereUniqueInput | DefaultChallengeReviewerWhereUniqueInput[]
    disconnect?: DefaultChallengeReviewerWhereUniqueInput | DefaultChallengeReviewerWhereUniqueInput[]
    delete?: DefaultChallengeReviewerWhereUniqueInput | DefaultChallengeReviewerWhereUniqueInput[]
    connect?: DefaultChallengeReviewerWhereUniqueInput | DefaultChallengeReviewerWhereUniqueInput[]
    update?: DefaultChallengeReviewerUpdateWithWhereUniqueWithoutPhaseInput | DefaultChallengeReviewerUpdateWithWhereUniqueWithoutPhaseInput[]
    updateMany?: DefaultChallengeReviewerUpdateManyWithWhereWithoutPhaseInput | DefaultChallengeReviewerUpdateManyWithWhereWithoutPhaseInput[]
    deleteMany?: DefaultChallengeReviewerScalarWhereInput | DefaultChallengeReviewerScalarWhereInput[]
  }

  export type ChallengePhaseUncheckedUpdateManyWithoutPhaseNestedInput = {
    create?: XOR<ChallengePhaseCreateWithoutPhaseInput, ChallengePhaseUncheckedCreateWithoutPhaseInput> | ChallengePhaseCreateWithoutPhaseInput[] | ChallengePhaseUncheckedCreateWithoutPhaseInput[]
    connectOrCreate?: ChallengePhaseCreateOrConnectWithoutPhaseInput | ChallengePhaseCreateOrConnectWithoutPhaseInput[]
    upsert?: ChallengePhaseUpsertWithWhereUniqueWithoutPhaseInput | ChallengePhaseUpsertWithWhereUniqueWithoutPhaseInput[]
    createMany?: ChallengePhaseCreateManyPhaseInputEnvelope
    set?: ChallengePhaseWhereUniqueInput | ChallengePhaseWhereUniqueInput[]
    disconnect?: ChallengePhaseWhereUniqueInput | ChallengePhaseWhereUniqueInput[]
    delete?: ChallengePhaseWhereUniqueInput | ChallengePhaseWhereUniqueInput[]
    connect?: ChallengePhaseWhereUniqueInput | ChallengePhaseWhereUniqueInput[]
    update?: ChallengePhaseUpdateWithWhereUniqueWithoutPhaseInput | ChallengePhaseUpdateWithWhereUniqueWithoutPhaseInput[]
    updateMany?: ChallengePhaseUpdateManyWithWhereWithoutPhaseInput | ChallengePhaseUpdateManyWithWhereWithoutPhaseInput[]
    deleteMany?: ChallengePhaseScalarWhereInput | ChallengePhaseScalarWhereInput[]
  }

  export type ChallengeReviewerUncheckedUpdateManyWithoutPhaseNestedInput = {
    create?: XOR<ChallengeReviewerCreateWithoutPhaseInput, ChallengeReviewerUncheckedCreateWithoutPhaseInput> | ChallengeReviewerCreateWithoutPhaseInput[] | ChallengeReviewerUncheckedCreateWithoutPhaseInput[]
    connectOrCreate?: ChallengeReviewerCreateOrConnectWithoutPhaseInput | ChallengeReviewerCreateOrConnectWithoutPhaseInput[]
    upsert?: ChallengeReviewerUpsertWithWhereUniqueWithoutPhaseInput | ChallengeReviewerUpsertWithWhereUniqueWithoutPhaseInput[]
    createMany?: ChallengeReviewerCreateManyPhaseInputEnvelope
    set?: ChallengeReviewerWhereUniqueInput | ChallengeReviewerWhereUniqueInput[]
    disconnect?: ChallengeReviewerWhereUniqueInput | ChallengeReviewerWhereUniqueInput[]
    delete?: ChallengeReviewerWhereUniqueInput | ChallengeReviewerWhereUniqueInput[]
    connect?: ChallengeReviewerWhereUniqueInput | ChallengeReviewerWhereUniqueInput[]
    update?: ChallengeReviewerUpdateWithWhereUniqueWithoutPhaseInput | ChallengeReviewerUpdateWithWhereUniqueWithoutPhaseInput[]
    updateMany?: ChallengeReviewerUpdateManyWithWhereWithoutPhaseInput | ChallengeReviewerUpdateManyWithWhereWithoutPhaseInput[]
    deleteMany?: ChallengeReviewerScalarWhereInput | ChallengeReviewerScalarWhereInput[]
  }

  export type DefaultChallengeReviewerUncheckedUpdateManyWithoutPhaseNestedInput = {
    create?: XOR<DefaultChallengeReviewerCreateWithoutPhaseInput, DefaultChallengeReviewerUncheckedCreateWithoutPhaseInput> | DefaultChallengeReviewerCreateWithoutPhaseInput[] | DefaultChallengeReviewerUncheckedCreateWithoutPhaseInput[]
    connectOrCreate?: DefaultChallengeReviewerCreateOrConnectWithoutPhaseInput | DefaultChallengeReviewerCreateOrConnectWithoutPhaseInput[]
    upsert?: DefaultChallengeReviewerUpsertWithWhereUniqueWithoutPhaseInput | DefaultChallengeReviewerUpsertWithWhereUniqueWithoutPhaseInput[]
    createMany?: DefaultChallengeReviewerCreateManyPhaseInputEnvelope
    set?: DefaultChallengeReviewerWhereUniqueInput | DefaultChallengeReviewerWhereUniqueInput[]
    disconnect?: DefaultChallengeReviewerWhereUniqueInput | DefaultChallengeReviewerWhereUniqueInput[]
    delete?: DefaultChallengeReviewerWhereUniqueInput | DefaultChallengeReviewerWhereUniqueInput[]
    connect?: DefaultChallengeReviewerWhereUniqueInput | DefaultChallengeReviewerWhereUniqueInput[]
    update?: DefaultChallengeReviewerUpdateWithWhereUniqueWithoutPhaseInput | DefaultChallengeReviewerUpdateWithWhereUniqueWithoutPhaseInput[]
    updateMany?: DefaultChallengeReviewerUpdateManyWithWhereWithoutPhaseInput | DefaultChallengeReviewerUpdateManyWithWhereWithoutPhaseInput[]
    deleteMany?: DefaultChallengeReviewerScalarWhereInput | DefaultChallengeReviewerScalarWhereInput[]
  }

  export type ChallengePhaseConstraintCreateNestedManyWithoutChallengePhaseInput = {
    create?: XOR<ChallengePhaseConstraintCreateWithoutChallengePhaseInput, ChallengePhaseConstraintUncheckedCreateWithoutChallengePhaseInput> | ChallengePhaseConstraintCreateWithoutChallengePhaseInput[] | ChallengePhaseConstraintUncheckedCreateWithoutChallengePhaseInput[]
    connectOrCreate?: ChallengePhaseConstraintCreateOrConnectWithoutChallengePhaseInput | ChallengePhaseConstraintCreateOrConnectWithoutChallengePhaseInput[]
    createMany?: ChallengePhaseConstraintCreateManyChallengePhaseInputEnvelope
    connect?: ChallengePhaseConstraintWhereUniqueInput | ChallengePhaseConstraintWhereUniqueInput[]
  }

  export type ChallengeCreateNestedOneWithoutPhasesInput = {
    create?: XOR<ChallengeCreateWithoutPhasesInput, ChallengeUncheckedCreateWithoutPhasesInput>
    connectOrCreate?: ChallengeCreateOrConnectWithoutPhasesInput
    connect?: ChallengeWhereUniqueInput
  }

  export type PhaseCreateNestedOneWithoutChallengePhasesInput = {
    create?: XOR<PhaseCreateWithoutChallengePhasesInput, PhaseUncheckedCreateWithoutChallengePhasesInput>
    connectOrCreate?: PhaseCreateOrConnectWithoutChallengePhasesInput
    connect?: PhaseWhereUniqueInput
  }

  export type ChallengePhaseConstraintUncheckedCreateNestedManyWithoutChallengePhaseInput = {
    create?: XOR<ChallengePhaseConstraintCreateWithoutChallengePhaseInput, ChallengePhaseConstraintUncheckedCreateWithoutChallengePhaseInput> | ChallengePhaseConstraintCreateWithoutChallengePhaseInput[] | ChallengePhaseConstraintUncheckedCreateWithoutChallengePhaseInput[]
    connectOrCreate?: ChallengePhaseConstraintCreateOrConnectWithoutChallengePhaseInput | ChallengePhaseConstraintCreateOrConnectWithoutChallengePhaseInput[]
    createMany?: ChallengePhaseConstraintCreateManyChallengePhaseInputEnvelope
    connect?: ChallengePhaseConstraintWhereUniqueInput | ChallengePhaseConstraintWhereUniqueInput[]
  }

  export type NullableBoolFieldUpdateOperationsInput = {
    set?: boolean | null
  }

  export type ChallengePhaseConstraintUpdateManyWithoutChallengePhaseNestedInput = {
    create?: XOR<ChallengePhaseConstraintCreateWithoutChallengePhaseInput, ChallengePhaseConstraintUncheckedCreateWithoutChallengePhaseInput> | ChallengePhaseConstraintCreateWithoutChallengePhaseInput[] | ChallengePhaseConstraintUncheckedCreateWithoutChallengePhaseInput[]
    connectOrCreate?: ChallengePhaseConstraintCreateOrConnectWithoutChallengePhaseInput | ChallengePhaseConstraintCreateOrConnectWithoutChallengePhaseInput[]
    upsert?: ChallengePhaseConstraintUpsertWithWhereUniqueWithoutChallengePhaseInput | ChallengePhaseConstraintUpsertWithWhereUniqueWithoutChallengePhaseInput[]
    createMany?: ChallengePhaseConstraintCreateManyChallengePhaseInputEnvelope
    set?: ChallengePhaseConstraintWhereUniqueInput | ChallengePhaseConstraintWhereUniqueInput[]
    disconnect?: ChallengePhaseConstraintWhereUniqueInput | ChallengePhaseConstraintWhereUniqueInput[]
    delete?: ChallengePhaseConstraintWhereUniqueInput | ChallengePhaseConstraintWhereUniqueInput[]
    connect?: ChallengePhaseConstraintWhereUniqueInput | ChallengePhaseConstraintWhereUniqueInput[]
    update?: ChallengePhaseConstraintUpdateWithWhereUniqueWithoutChallengePhaseInput | ChallengePhaseConstraintUpdateWithWhereUniqueWithoutChallengePhaseInput[]
    updateMany?: ChallengePhaseConstraintUpdateManyWithWhereWithoutChallengePhaseInput | ChallengePhaseConstraintUpdateManyWithWhereWithoutChallengePhaseInput[]
    deleteMany?: ChallengePhaseConstraintScalarWhereInput | ChallengePhaseConstraintScalarWhereInput[]
  }

  export type ChallengeUpdateOneRequiredWithoutPhasesNestedInput = {
    create?: XOR<ChallengeCreateWithoutPhasesInput, ChallengeUncheckedCreateWithoutPhasesInput>
    connectOrCreate?: ChallengeCreateOrConnectWithoutPhasesInput
    upsert?: ChallengeUpsertWithoutPhasesInput
    connect?: ChallengeWhereUniqueInput
    update?: XOR<XOR<ChallengeUpdateToOneWithWhereWithoutPhasesInput, ChallengeUpdateWithoutPhasesInput>, ChallengeUncheckedUpdateWithoutPhasesInput>
  }

  export type PhaseUpdateOneRequiredWithoutChallengePhasesNestedInput = {
    create?: XOR<PhaseCreateWithoutChallengePhasesInput, PhaseUncheckedCreateWithoutChallengePhasesInput>
    connectOrCreate?: PhaseCreateOrConnectWithoutChallengePhasesInput
    upsert?: PhaseUpsertWithoutChallengePhasesInput
    connect?: PhaseWhereUniqueInput
    update?: XOR<XOR<PhaseUpdateToOneWithWhereWithoutChallengePhasesInput, PhaseUpdateWithoutChallengePhasesInput>, PhaseUncheckedUpdateWithoutChallengePhasesInput>
  }

  export type ChallengePhaseConstraintUncheckedUpdateManyWithoutChallengePhaseNestedInput = {
    create?: XOR<ChallengePhaseConstraintCreateWithoutChallengePhaseInput, ChallengePhaseConstraintUncheckedCreateWithoutChallengePhaseInput> | ChallengePhaseConstraintCreateWithoutChallengePhaseInput[] | ChallengePhaseConstraintUncheckedCreateWithoutChallengePhaseInput[]
    connectOrCreate?: ChallengePhaseConstraintCreateOrConnectWithoutChallengePhaseInput | ChallengePhaseConstraintCreateOrConnectWithoutChallengePhaseInput[]
    upsert?: ChallengePhaseConstraintUpsertWithWhereUniqueWithoutChallengePhaseInput | ChallengePhaseConstraintUpsertWithWhereUniqueWithoutChallengePhaseInput[]
    createMany?: ChallengePhaseConstraintCreateManyChallengePhaseInputEnvelope
    set?: ChallengePhaseConstraintWhereUniqueInput | ChallengePhaseConstraintWhereUniqueInput[]
    disconnect?: ChallengePhaseConstraintWhereUniqueInput | ChallengePhaseConstraintWhereUniqueInput[]
    delete?: ChallengePhaseConstraintWhereUniqueInput | ChallengePhaseConstraintWhereUniqueInput[]
    connect?: ChallengePhaseConstraintWhereUniqueInput | ChallengePhaseConstraintWhereUniqueInput[]
    update?: ChallengePhaseConstraintUpdateWithWhereUniqueWithoutChallengePhaseInput | ChallengePhaseConstraintUpdateWithWhereUniqueWithoutChallengePhaseInput[]
    updateMany?: ChallengePhaseConstraintUpdateManyWithWhereWithoutChallengePhaseInput | ChallengePhaseConstraintUpdateManyWithWhereWithoutChallengePhaseInput[]
    deleteMany?: ChallengePhaseConstraintScalarWhereInput | ChallengePhaseConstraintScalarWhereInput[]
  }

  export type ChallengePhaseCreateNestedOneWithoutConstraintsInput = {
    create?: XOR<ChallengePhaseCreateWithoutConstraintsInput, ChallengePhaseUncheckedCreateWithoutConstraintsInput>
    connectOrCreate?: ChallengePhaseCreateOrConnectWithoutConstraintsInput
    connect?: ChallengePhaseWhereUniqueInput
  }

  export type ChallengePhaseUpdateOneRequiredWithoutConstraintsNestedInput = {
    create?: XOR<ChallengePhaseCreateWithoutConstraintsInput, ChallengePhaseUncheckedCreateWithoutConstraintsInput>
    connectOrCreate?: ChallengePhaseCreateOrConnectWithoutConstraintsInput
    upsert?: ChallengePhaseUpsertWithoutConstraintsInput
    connect?: ChallengePhaseWhereUniqueInput
    update?: XOR<XOR<ChallengePhaseUpdateToOneWithWhereWithoutConstraintsInput, ChallengePhaseUpdateWithoutConstraintsInput>, ChallengePhaseUncheckedUpdateWithoutConstraintsInput>
  }

  export type PrizeCreateNestedManyWithoutPrizeSetInput = {
    create?: XOR<PrizeCreateWithoutPrizeSetInput, PrizeUncheckedCreateWithoutPrizeSetInput> | PrizeCreateWithoutPrizeSetInput[] | PrizeUncheckedCreateWithoutPrizeSetInput[]
    connectOrCreate?: PrizeCreateOrConnectWithoutPrizeSetInput | PrizeCreateOrConnectWithoutPrizeSetInput[]
    createMany?: PrizeCreateManyPrizeSetInputEnvelope
    connect?: PrizeWhereUniqueInput | PrizeWhereUniqueInput[]
  }

  export type ChallengeCreateNestedOneWithoutPrizeSetsInput = {
    create?: XOR<ChallengeCreateWithoutPrizeSetsInput, ChallengeUncheckedCreateWithoutPrizeSetsInput>
    connectOrCreate?: ChallengeCreateOrConnectWithoutPrizeSetsInput
    connect?: ChallengeWhereUniqueInput
  }

  export type PrizeUncheckedCreateNestedManyWithoutPrizeSetInput = {
    create?: XOR<PrizeCreateWithoutPrizeSetInput, PrizeUncheckedCreateWithoutPrizeSetInput> | PrizeCreateWithoutPrizeSetInput[] | PrizeUncheckedCreateWithoutPrizeSetInput[]
    connectOrCreate?: PrizeCreateOrConnectWithoutPrizeSetInput | PrizeCreateOrConnectWithoutPrizeSetInput[]
    createMany?: PrizeCreateManyPrizeSetInputEnvelope
    connect?: PrizeWhereUniqueInput | PrizeWhereUniqueInput[]
  }

  export type PrizeUpdateManyWithoutPrizeSetNestedInput = {
    create?: XOR<PrizeCreateWithoutPrizeSetInput, PrizeUncheckedCreateWithoutPrizeSetInput> | PrizeCreateWithoutPrizeSetInput[] | PrizeUncheckedCreateWithoutPrizeSetInput[]
    connectOrCreate?: PrizeCreateOrConnectWithoutPrizeSetInput | PrizeCreateOrConnectWithoutPrizeSetInput[]
    upsert?: PrizeUpsertWithWhereUniqueWithoutPrizeSetInput | PrizeUpsertWithWhereUniqueWithoutPrizeSetInput[]
    createMany?: PrizeCreateManyPrizeSetInputEnvelope
    set?: PrizeWhereUniqueInput | PrizeWhereUniqueInput[]
    disconnect?: PrizeWhereUniqueInput | PrizeWhereUniqueInput[]
    delete?: PrizeWhereUniqueInput | PrizeWhereUniqueInput[]
    connect?: PrizeWhereUniqueInput | PrizeWhereUniqueInput[]
    update?: PrizeUpdateWithWhereUniqueWithoutPrizeSetInput | PrizeUpdateWithWhereUniqueWithoutPrizeSetInput[]
    updateMany?: PrizeUpdateManyWithWhereWithoutPrizeSetInput | PrizeUpdateManyWithWhereWithoutPrizeSetInput[]
    deleteMany?: PrizeScalarWhereInput | PrizeScalarWhereInput[]
  }

  export type ChallengeUpdateOneRequiredWithoutPrizeSetsNestedInput = {
    create?: XOR<ChallengeCreateWithoutPrizeSetsInput, ChallengeUncheckedCreateWithoutPrizeSetsInput>
    connectOrCreate?: ChallengeCreateOrConnectWithoutPrizeSetsInput
    upsert?: ChallengeUpsertWithoutPrizeSetsInput
    connect?: ChallengeWhereUniqueInput
    update?: XOR<XOR<ChallengeUpdateToOneWithWhereWithoutPrizeSetsInput, ChallengeUpdateWithoutPrizeSetsInput>, ChallengeUncheckedUpdateWithoutPrizeSetsInput>
  }

  export type PrizeUncheckedUpdateManyWithoutPrizeSetNestedInput = {
    create?: XOR<PrizeCreateWithoutPrizeSetInput, PrizeUncheckedCreateWithoutPrizeSetInput> | PrizeCreateWithoutPrizeSetInput[] | PrizeUncheckedCreateWithoutPrizeSetInput[]
    connectOrCreate?: PrizeCreateOrConnectWithoutPrizeSetInput | PrizeCreateOrConnectWithoutPrizeSetInput[]
    upsert?: PrizeUpsertWithWhereUniqueWithoutPrizeSetInput | PrizeUpsertWithWhereUniqueWithoutPrizeSetInput[]
    createMany?: PrizeCreateManyPrizeSetInputEnvelope
    set?: PrizeWhereUniqueInput | PrizeWhereUniqueInput[]
    disconnect?: PrizeWhereUniqueInput | PrizeWhereUniqueInput[]
    delete?: PrizeWhereUniqueInput | PrizeWhereUniqueInput[]
    connect?: PrizeWhereUniqueInput | PrizeWhereUniqueInput[]
    update?: PrizeUpdateWithWhereUniqueWithoutPrizeSetInput | PrizeUpdateWithWhereUniqueWithoutPrizeSetInput[]
    updateMany?: PrizeUpdateManyWithWhereWithoutPrizeSetInput | PrizeUpdateManyWithWhereWithoutPrizeSetInput[]
    deleteMany?: PrizeScalarWhereInput | PrizeScalarWhereInput[]
  }

  export type ChallengeCreateNestedOneWithoutReviewersInput = {
    create?: XOR<ChallengeCreateWithoutReviewersInput, ChallengeUncheckedCreateWithoutReviewersInput>
    connectOrCreate?: ChallengeCreateOrConnectWithoutReviewersInput
    connect?: ChallengeWhereUniqueInput
  }

  export type PhaseCreateNestedOneWithoutChallengeReviewerInput = {
    create?: XOR<PhaseCreateWithoutChallengeReviewerInput, PhaseUncheckedCreateWithoutChallengeReviewerInput>
    connectOrCreate?: PhaseCreateOrConnectWithoutChallengeReviewerInput
    connect?: PhaseWhereUniqueInput
  }

  export type NullableEnumReviewOpportunityTypeEnumFieldUpdateOperationsInput = {
    set?: $Enums.ReviewOpportunityTypeEnum | null
  }

  export type ChallengeUpdateOneRequiredWithoutReviewersNestedInput = {
    create?: XOR<ChallengeCreateWithoutReviewersInput, ChallengeUncheckedCreateWithoutReviewersInput>
    connectOrCreate?: ChallengeCreateOrConnectWithoutReviewersInput
    upsert?: ChallengeUpsertWithoutReviewersInput
    connect?: ChallengeWhereUniqueInput
    update?: XOR<XOR<ChallengeUpdateToOneWithWhereWithoutReviewersInput, ChallengeUpdateWithoutReviewersInput>, ChallengeUncheckedUpdateWithoutReviewersInput>
  }

  export type PhaseUpdateOneRequiredWithoutChallengeReviewerNestedInput = {
    create?: XOR<PhaseCreateWithoutChallengeReviewerInput, PhaseUncheckedCreateWithoutChallengeReviewerInput>
    connectOrCreate?: PhaseCreateOrConnectWithoutChallengeReviewerInput
    upsert?: PhaseUpsertWithoutChallengeReviewerInput
    connect?: PhaseWhereUniqueInput
    update?: XOR<XOR<PhaseUpdateToOneWithWhereWithoutChallengeReviewerInput, PhaseUpdateWithoutChallengeReviewerInput>, PhaseUncheckedUpdateWithoutChallengeReviewerInput>
  }

  export type ChallengeTypeCreateNestedOneWithoutDefaultReviewersInput = {
    create?: XOR<ChallengeTypeCreateWithoutDefaultReviewersInput, ChallengeTypeUncheckedCreateWithoutDefaultReviewersInput>
    connectOrCreate?: ChallengeTypeCreateOrConnectWithoutDefaultReviewersInput
    connect?: ChallengeTypeWhereUniqueInput
  }

  export type ChallengeTrackCreateNestedOneWithoutDefaultReviewersInput = {
    create?: XOR<ChallengeTrackCreateWithoutDefaultReviewersInput, ChallengeTrackUncheckedCreateWithoutDefaultReviewersInput>
    connectOrCreate?: ChallengeTrackCreateOrConnectWithoutDefaultReviewersInput
    connect?: ChallengeTrackWhereUniqueInput
  }

  export type TimelineTemplateCreateNestedOneWithoutDefaultChallengeReviewerInput = {
    create?: XOR<TimelineTemplateCreateWithoutDefaultChallengeReviewerInput, TimelineTemplateUncheckedCreateWithoutDefaultChallengeReviewerInput>
    connectOrCreate?: TimelineTemplateCreateOrConnectWithoutDefaultChallengeReviewerInput
    connect?: TimelineTemplateWhereUniqueInput
  }

  export type PhaseCreateNestedOneWithoutDefaultChallengeReviewerInput = {
    create?: XOR<PhaseCreateWithoutDefaultChallengeReviewerInput, PhaseUncheckedCreateWithoutDefaultChallengeReviewerInput>
    connectOrCreate?: PhaseCreateOrConnectWithoutDefaultChallengeReviewerInput
    connect?: PhaseWhereUniqueInput
  }

  export type ChallengeTypeUpdateOneRequiredWithoutDefaultReviewersNestedInput = {
    create?: XOR<ChallengeTypeCreateWithoutDefaultReviewersInput, ChallengeTypeUncheckedCreateWithoutDefaultReviewersInput>
    connectOrCreate?: ChallengeTypeCreateOrConnectWithoutDefaultReviewersInput
    upsert?: ChallengeTypeUpsertWithoutDefaultReviewersInput
    connect?: ChallengeTypeWhereUniqueInput
    update?: XOR<XOR<ChallengeTypeUpdateToOneWithWhereWithoutDefaultReviewersInput, ChallengeTypeUpdateWithoutDefaultReviewersInput>, ChallengeTypeUncheckedUpdateWithoutDefaultReviewersInput>
  }

  export type ChallengeTrackUpdateOneRequiredWithoutDefaultReviewersNestedInput = {
    create?: XOR<ChallengeTrackCreateWithoutDefaultReviewersInput, ChallengeTrackUncheckedCreateWithoutDefaultReviewersInput>
    connectOrCreate?: ChallengeTrackCreateOrConnectWithoutDefaultReviewersInput
    upsert?: ChallengeTrackUpsertWithoutDefaultReviewersInput
    connect?: ChallengeTrackWhereUniqueInput
    update?: XOR<XOR<ChallengeTrackUpdateToOneWithWhereWithoutDefaultReviewersInput, ChallengeTrackUpdateWithoutDefaultReviewersInput>, ChallengeTrackUncheckedUpdateWithoutDefaultReviewersInput>
  }

  export type TimelineTemplateUpdateOneWithoutDefaultChallengeReviewerNestedInput = {
    create?: XOR<TimelineTemplateCreateWithoutDefaultChallengeReviewerInput, TimelineTemplateUncheckedCreateWithoutDefaultChallengeReviewerInput>
    connectOrCreate?: TimelineTemplateCreateOrConnectWithoutDefaultChallengeReviewerInput
    upsert?: TimelineTemplateUpsertWithoutDefaultChallengeReviewerInput
    disconnect?: TimelineTemplateWhereInput | boolean
    delete?: TimelineTemplateWhereInput | boolean
    connect?: TimelineTemplateWhereUniqueInput
    update?: XOR<XOR<TimelineTemplateUpdateToOneWithWhereWithoutDefaultChallengeReviewerInput, TimelineTemplateUpdateWithoutDefaultChallengeReviewerInput>, TimelineTemplateUncheckedUpdateWithoutDefaultChallengeReviewerInput>
  }

  export type PhaseUpdateOneWithoutDefaultChallengeReviewerNestedInput = {
    create?: XOR<PhaseCreateWithoutDefaultChallengeReviewerInput, PhaseUncheckedCreateWithoutDefaultChallengeReviewerInput>
    connectOrCreate?: PhaseCreateOrConnectWithoutDefaultChallengeReviewerInput
    upsert?: PhaseUpsertWithoutDefaultChallengeReviewerInput
    disconnect?: PhaseWhereInput | boolean
    delete?: PhaseWhereInput | boolean
    connect?: PhaseWhereUniqueInput
    update?: XOR<XOR<PhaseUpdateToOneWithWhereWithoutDefaultChallengeReviewerInput, PhaseUpdateWithoutDefaultChallengeReviewerInput>, PhaseUncheckedUpdateWithoutDefaultChallengeReviewerInput>
  }

  export type TimelineTemplatePhaseCreateNestedManyWithoutTimelineTemplateInput = {
    create?: XOR<TimelineTemplatePhaseCreateWithoutTimelineTemplateInput, TimelineTemplatePhaseUncheckedCreateWithoutTimelineTemplateInput> | TimelineTemplatePhaseCreateWithoutTimelineTemplateInput[] | TimelineTemplatePhaseUncheckedCreateWithoutTimelineTemplateInput[]
    connectOrCreate?: TimelineTemplatePhaseCreateOrConnectWithoutTimelineTemplateInput | TimelineTemplatePhaseCreateOrConnectWithoutTimelineTemplateInput[]
    createMany?: TimelineTemplatePhaseCreateManyTimelineTemplateInputEnvelope
    connect?: TimelineTemplatePhaseWhereUniqueInput | TimelineTemplatePhaseWhereUniqueInput[]
  }

  export type ChallengeTimelineTemplateCreateNestedManyWithoutTimelineTemplateInput = {
    create?: XOR<ChallengeTimelineTemplateCreateWithoutTimelineTemplateInput, ChallengeTimelineTemplateUncheckedCreateWithoutTimelineTemplateInput> | ChallengeTimelineTemplateCreateWithoutTimelineTemplateInput[] | ChallengeTimelineTemplateUncheckedCreateWithoutTimelineTemplateInput[]
    connectOrCreate?: ChallengeTimelineTemplateCreateOrConnectWithoutTimelineTemplateInput | ChallengeTimelineTemplateCreateOrConnectWithoutTimelineTemplateInput[]
    createMany?: ChallengeTimelineTemplateCreateManyTimelineTemplateInputEnvelope
    connect?: ChallengeTimelineTemplateWhereUniqueInput | ChallengeTimelineTemplateWhereUniqueInput[]
  }

  export type ChallengeCreateNestedManyWithoutTimelineTemplateInput = {
    create?: XOR<ChallengeCreateWithoutTimelineTemplateInput, ChallengeUncheckedCreateWithoutTimelineTemplateInput> | ChallengeCreateWithoutTimelineTemplateInput[] | ChallengeUncheckedCreateWithoutTimelineTemplateInput[]
    connectOrCreate?: ChallengeCreateOrConnectWithoutTimelineTemplateInput | ChallengeCreateOrConnectWithoutTimelineTemplateInput[]
    createMany?: ChallengeCreateManyTimelineTemplateInputEnvelope
    connect?: ChallengeWhereUniqueInput | ChallengeWhereUniqueInput[]
  }

  export type DefaultChallengeReviewerCreateNestedManyWithoutTimelineTemplateInput = {
    create?: XOR<DefaultChallengeReviewerCreateWithoutTimelineTemplateInput, DefaultChallengeReviewerUncheckedCreateWithoutTimelineTemplateInput> | DefaultChallengeReviewerCreateWithoutTimelineTemplateInput[] | DefaultChallengeReviewerUncheckedCreateWithoutTimelineTemplateInput[]
    connectOrCreate?: DefaultChallengeReviewerCreateOrConnectWithoutTimelineTemplateInput | DefaultChallengeReviewerCreateOrConnectWithoutTimelineTemplateInput[]
    createMany?: DefaultChallengeReviewerCreateManyTimelineTemplateInputEnvelope
    connect?: DefaultChallengeReviewerWhereUniqueInput | DefaultChallengeReviewerWhereUniqueInput[]
  }

  export type TimelineTemplatePhaseUncheckedCreateNestedManyWithoutTimelineTemplateInput = {
    create?: XOR<TimelineTemplatePhaseCreateWithoutTimelineTemplateInput, TimelineTemplatePhaseUncheckedCreateWithoutTimelineTemplateInput> | TimelineTemplatePhaseCreateWithoutTimelineTemplateInput[] | TimelineTemplatePhaseUncheckedCreateWithoutTimelineTemplateInput[]
    connectOrCreate?: TimelineTemplatePhaseCreateOrConnectWithoutTimelineTemplateInput | TimelineTemplatePhaseCreateOrConnectWithoutTimelineTemplateInput[]
    createMany?: TimelineTemplatePhaseCreateManyTimelineTemplateInputEnvelope
    connect?: TimelineTemplatePhaseWhereUniqueInput | TimelineTemplatePhaseWhereUniqueInput[]
  }

  export type ChallengeTimelineTemplateUncheckedCreateNestedManyWithoutTimelineTemplateInput = {
    create?: XOR<ChallengeTimelineTemplateCreateWithoutTimelineTemplateInput, ChallengeTimelineTemplateUncheckedCreateWithoutTimelineTemplateInput> | ChallengeTimelineTemplateCreateWithoutTimelineTemplateInput[] | ChallengeTimelineTemplateUncheckedCreateWithoutTimelineTemplateInput[]
    connectOrCreate?: ChallengeTimelineTemplateCreateOrConnectWithoutTimelineTemplateInput | ChallengeTimelineTemplateCreateOrConnectWithoutTimelineTemplateInput[]
    createMany?: ChallengeTimelineTemplateCreateManyTimelineTemplateInputEnvelope
    connect?: ChallengeTimelineTemplateWhereUniqueInput | ChallengeTimelineTemplateWhereUniqueInput[]
  }

  export type ChallengeUncheckedCreateNestedManyWithoutTimelineTemplateInput = {
    create?: XOR<ChallengeCreateWithoutTimelineTemplateInput, ChallengeUncheckedCreateWithoutTimelineTemplateInput> | ChallengeCreateWithoutTimelineTemplateInput[] | ChallengeUncheckedCreateWithoutTimelineTemplateInput[]
    connectOrCreate?: ChallengeCreateOrConnectWithoutTimelineTemplateInput | ChallengeCreateOrConnectWithoutTimelineTemplateInput[]
    createMany?: ChallengeCreateManyTimelineTemplateInputEnvelope
    connect?: ChallengeWhereUniqueInput | ChallengeWhereUniqueInput[]
  }

  export type DefaultChallengeReviewerUncheckedCreateNestedManyWithoutTimelineTemplateInput = {
    create?: XOR<DefaultChallengeReviewerCreateWithoutTimelineTemplateInput, DefaultChallengeReviewerUncheckedCreateWithoutTimelineTemplateInput> | DefaultChallengeReviewerCreateWithoutTimelineTemplateInput[] | DefaultChallengeReviewerUncheckedCreateWithoutTimelineTemplateInput[]
    connectOrCreate?: DefaultChallengeReviewerCreateOrConnectWithoutTimelineTemplateInput | DefaultChallengeReviewerCreateOrConnectWithoutTimelineTemplateInput[]
    createMany?: DefaultChallengeReviewerCreateManyTimelineTemplateInputEnvelope
    connect?: DefaultChallengeReviewerWhereUniqueInput | DefaultChallengeReviewerWhereUniqueInput[]
  }

  export type TimelineTemplatePhaseUpdateManyWithoutTimelineTemplateNestedInput = {
    create?: XOR<TimelineTemplatePhaseCreateWithoutTimelineTemplateInput, TimelineTemplatePhaseUncheckedCreateWithoutTimelineTemplateInput> | TimelineTemplatePhaseCreateWithoutTimelineTemplateInput[] | TimelineTemplatePhaseUncheckedCreateWithoutTimelineTemplateInput[]
    connectOrCreate?: TimelineTemplatePhaseCreateOrConnectWithoutTimelineTemplateInput | TimelineTemplatePhaseCreateOrConnectWithoutTimelineTemplateInput[]
    upsert?: TimelineTemplatePhaseUpsertWithWhereUniqueWithoutTimelineTemplateInput | TimelineTemplatePhaseUpsertWithWhereUniqueWithoutTimelineTemplateInput[]
    createMany?: TimelineTemplatePhaseCreateManyTimelineTemplateInputEnvelope
    set?: TimelineTemplatePhaseWhereUniqueInput | TimelineTemplatePhaseWhereUniqueInput[]
    disconnect?: TimelineTemplatePhaseWhereUniqueInput | TimelineTemplatePhaseWhereUniqueInput[]
    delete?: TimelineTemplatePhaseWhereUniqueInput | TimelineTemplatePhaseWhereUniqueInput[]
    connect?: TimelineTemplatePhaseWhereUniqueInput | TimelineTemplatePhaseWhereUniqueInput[]
    update?: TimelineTemplatePhaseUpdateWithWhereUniqueWithoutTimelineTemplateInput | TimelineTemplatePhaseUpdateWithWhereUniqueWithoutTimelineTemplateInput[]
    updateMany?: TimelineTemplatePhaseUpdateManyWithWhereWithoutTimelineTemplateInput | TimelineTemplatePhaseUpdateManyWithWhereWithoutTimelineTemplateInput[]
    deleteMany?: TimelineTemplatePhaseScalarWhereInput | TimelineTemplatePhaseScalarWhereInput[]
  }

  export type ChallengeTimelineTemplateUpdateManyWithoutTimelineTemplateNestedInput = {
    create?: XOR<ChallengeTimelineTemplateCreateWithoutTimelineTemplateInput, ChallengeTimelineTemplateUncheckedCreateWithoutTimelineTemplateInput> | ChallengeTimelineTemplateCreateWithoutTimelineTemplateInput[] | ChallengeTimelineTemplateUncheckedCreateWithoutTimelineTemplateInput[]
    connectOrCreate?: ChallengeTimelineTemplateCreateOrConnectWithoutTimelineTemplateInput | ChallengeTimelineTemplateCreateOrConnectWithoutTimelineTemplateInput[]
    upsert?: ChallengeTimelineTemplateUpsertWithWhereUniqueWithoutTimelineTemplateInput | ChallengeTimelineTemplateUpsertWithWhereUniqueWithoutTimelineTemplateInput[]
    createMany?: ChallengeTimelineTemplateCreateManyTimelineTemplateInputEnvelope
    set?: ChallengeTimelineTemplateWhereUniqueInput | ChallengeTimelineTemplateWhereUniqueInput[]
    disconnect?: ChallengeTimelineTemplateWhereUniqueInput | ChallengeTimelineTemplateWhereUniqueInput[]
    delete?: ChallengeTimelineTemplateWhereUniqueInput | ChallengeTimelineTemplateWhereUniqueInput[]
    connect?: ChallengeTimelineTemplateWhereUniqueInput | ChallengeTimelineTemplateWhereUniqueInput[]
    update?: ChallengeTimelineTemplateUpdateWithWhereUniqueWithoutTimelineTemplateInput | ChallengeTimelineTemplateUpdateWithWhereUniqueWithoutTimelineTemplateInput[]
    updateMany?: ChallengeTimelineTemplateUpdateManyWithWhereWithoutTimelineTemplateInput | ChallengeTimelineTemplateUpdateManyWithWhereWithoutTimelineTemplateInput[]
    deleteMany?: ChallengeTimelineTemplateScalarWhereInput | ChallengeTimelineTemplateScalarWhereInput[]
  }

  export type ChallengeUpdateManyWithoutTimelineTemplateNestedInput = {
    create?: XOR<ChallengeCreateWithoutTimelineTemplateInput, ChallengeUncheckedCreateWithoutTimelineTemplateInput> | ChallengeCreateWithoutTimelineTemplateInput[] | ChallengeUncheckedCreateWithoutTimelineTemplateInput[]
    connectOrCreate?: ChallengeCreateOrConnectWithoutTimelineTemplateInput | ChallengeCreateOrConnectWithoutTimelineTemplateInput[]
    upsert?: ChallengeUpsertWithWhereUniqueWithoutTimelineTemplateInput | ChallengeUpsertWithWhereUniqueWithoutTimelineTemplateInput[]
    createMany?: ChallengeCreateManyTimelineTemplateInputEnvelope
    set?: ChallengeWhereUniqueInput | ChallengeWhereUniqueInput[]
    disconnect?: ChallengeWhereUniqueInput | ChallengeWhereUniqueInput[]
    delete?: ChallengeWhereUniqueInput | ChallengeWhereUniqueInput[]
    connect?: ChallengeWhereUniqueInput | ChallengeWhereUniqueInput[]
    update?: ChallengeUpdateWithWhereUniqueWithoutTimelineTemplateInput | ChallengeUpdateWithWhereUniqueWithoutTimelineTemplateInput[]
    updateMany?: ChallengeUpdateManyWithWhereWithoutTimelineTemplateInput | ChallengeUpdateManyWithWhereWithoutTimelineTemplateInput[]
    deleteMany?: ChallengeScalarWhereInput | ChallengeScalarWhereInput[]
  }

  export type DefaultChallengeReviewerUpdateManyWithoutTimelineTemplateNestedInput = {
    create?: XOR<DefaultChallengeReviewerCreateWithoutTimelineTemplateInput, DefaultChallengeReviewerUncheckedCreateWithoutTimelineTemplateInput> | DefaultChallengeReviewerCreateWithoutTimelineTemplateInput[] | DefaultChallengeReviewerUncheckedCreateWithoutTimelineTemplateInput[]
    connectOrCreate?: DefaultChallengeReviewerCreateOrConnectWithoutTimelineTemplateInput | DefaultChallengeReviewerCreateOrConnectWithoutTimelineTemplateInput[]
    upsert?: DefaultChallengeReviewerUpsertWithWhereUniqueWithoutTimelineTemplateInput | DefaultChallengeReviewerUpsertWithWhereUniqueWithoutTimelineTemplateInput[]
    createMany?: DefaultChallengeReviewerCreateManyTimelineTemplateInputEnvelope
    set?: DefaultChallengeReviewerWhereUniqueInput | DefaultChallengeReviewerWhereUniqueInput[]
    disconnect?: DefaultChallengeReviewerWhereUniqueInput | DefaultChallengeReviewerWhereUniqueInput[]
    delete?: DefaultChallengeReviewerWhereUniqueInput | DefaultChallengeReviewerWhereUniqueInput[]
    connect?: DefaultChallengeReviewerWhereUniqueInput | DefaultChallengeReviewerWhereUniqueInput[]
    update?: DefaultChallengeReviewerUpdateWithWhereUniqueWithoutTimelineTemplateInput | DefaultChallengeReviewerUpdateWithWhereUniqueWithoutTimelineTemplateInput[]
    updateMany?: DefaultChallengeReviewerUpdateManyWithWhereWithoutTimelineTemplateInput | DefaultChallengeReviewerUpdateManyWithWhereWithoutTimelineTemplateInput[]
    deleteMany?: DefaultChallengeReviewerScalarWhereInput | DefaultChallengeReviewerScalarWhereInput[]
  }

  export type TimelineTemplatePhaseUncheckedUpdateManyWithoutTimelineTemplateNestedInput = {
    create?: XOR<TimelineTemplatePhaseCreateWithoutTimelineTemplateInput, TimelineTemplatePhaseUncheckedCreateWithoutTimelineTemplateInput> | TimelineTemplatePhaseCreateWithoutTimelineTemplateInput[] | TimelineTemplatePhaseUncheckedCreateWithoutTimelineTemplateInput[]
    connectOrCreate?: TimelineTemplatePhaseCreateOrConnectWithoutTimelineTemplateInput | TimelineTemplatePhaseCreateOrConnectWithoutTimelineTemplateInput[]
    upsert?: TimelineTemplatePhaseUpsertWithWhereUniqueWithoutTimelineTemplateInput | TimelineTemplatePhaseUpsertWithWhereUniqueWithoutTimelineTemplateInput[]
    createMany?: TimelineTemplatePhaseCreateManyTimelineTemplateInputEnvelope
    set?: TimelineTemplatePhaseWhereUniqueInput | TimelineTemplatePhaseWhereUniqueInput[]
    disconnect?: TimelineTemplatePhaseWhereUniqueInput | TimelineTemplatePhaseWhereUniqueInput[]
    delete?: TimelineTemplatePhaseWhereUniqueInput | TimelineTemplatePhaseWhereUniqueInput[]
    connect?: TimelineTemplatePhaseWhereUniqueInput | TimelineTemplatePhaseWhereUniqueInput[]
    update?: TimelineTemplatePhaseUpdateWithWhereUniqueWithoutTimelineTemplateInput | TimelineTemplatePhaseUpdateWithWhereUniqueWithoutTimelineTemplateInput[]
    updateMany?: TimelineTemplatePhaseUpdateManyWithWhereWithoutTimelineTemplateInput | TimelineTemplatePhaseUpdateManyWithWhereWithoutTimelineTemplateInput[]
    deleteMany?: TimelineTemplatePhaseScalarWhereInput | TimelineTemplatePhaseScalarWhereInput[]
  }

  export type ChallengeTimelineTemplateUncheckedUpdateManyWithoutTimelineTemplateNestedInput = {
    create?: XOR<ChallengeTimelineTemplateCreateWithoutTimelineTemplateInput, ChallengeTimelineTemplateUncheckedCreateWithoutTimelineTemplateInput> | ChallengeTimelineTemplateCreateWithoutTimelineTemplateInput[] | ChallengeTimelineTemplateUncheckedCreateWithoutTimelineTemplateInput[]
    connectOrCreate?: ChallengeTimelineTemplateCreateOrConnectWithoutTimelineTemplateInput | ChallengeTimelineTemplateCreateOrConnectWithoutTimelineTemplateInput[]
    upsert?: ChallengeTimelineTemplateUpsertWithWhereUniqueWithoutTimelineTemplateInput | ChallengeTimelineTemplateUpsertWithWhereUniqueWithoutTimelineTemplateInput[]
    createMany?: ChallengeTimelineTemplateCreateManyTimelineTemplateInputEnvelope
    set?: ChallengeTimelineTemplateWhereUniqueInput | ChallengeTimelineTemplateWhereUniqueInput[]
    disconnect?: ChallengeTimelineTemplateWhereUniqueInput | ChallengeTimelineTemplateWhereUniqueInput[]
    delete?: ChallengeTimelineTemplateWhereUniqueInput | ChallengeTimelineTemplateWhereUniqueInput[]
    connect?: ChallengeTimelineTemplateWhereUniqueInput | ChallengeTimelineTemplateWhereUniqueInput[]
    update?: ChallengeTimelineTemplateUpdateWithWhereUniqueWithoutTimelineTemplateInput | ChallengeTimelineTemplateUpdateWithWhereUniqueWithoutTimelineTemplateInput[]
    updateMany?: ChallengeTimelineTemplateUpdateManyWithWhereWithoutTimelineTemplateInput | ChallengeTimelineTemplateUpdateManyWithWhereWithoutTimelineTemplateInput[]
    deleteMany?: ChallengeTimelineTemplateScalarWhereInput | ChallengeTimelineTemplateScalarWhereInput[]
  }

  export type ChallengeUncheckedUpdateManyWithoutTimelineTemplateNestedInput = {
    create?: XOR<ChallengeCreateWithoutTimelineTemplateInput, ChallengeUncheckedCreateWithoutTimelineTemplateInput> | ChallengeCreateWithoutTimelineTemplateInput[] | ChallengeUncheckedCreateWithoutTimelineTemplateInput[]
    connectOrCreate?: ChallengeCreateOrConnectWithoutTimelineTemplateInput | ChallengeCreateOrConnectWithoutTimelineTemplateInput[]
    upsert?: ChallengeUpsertWithWhereUniqueWithoutTimelineTemplateInput | ChallengeUpsertWithWhereUniqueWithoutTimelineTemplateInput[]
    createMany?: ChallengeCreateManyTimelineTemplateInputEnvelope
    set?: ChallengeWhereUniqueInput | ChallengeWhereUniqueInput[]
    disconnect?: ChallengeWhereUniqueInput | ChallengeWhereUniqueInput[]
    delete?: ChallengeWhereUniqueInput | ChallengeWhereUniqueInput[]
    connect?: ChallengeWhereUniqueInput | ChallengeWhereUniqueInput[]
    update?: ChallengeUpdateWithWhereUniqueWithoutTimelineTemplateInput | ChallengeUpdateWithWhereUniqueWithoutTimelineTemplateInput[]
    updateMany?: ChallengeUpdateManyWithWhereWithoutTimelineTemplateInput | ChallengeUpdateManyWithWhereWithoutTimelineTemplateInput[]
    deleteMany?: ChallengeScalarWhereInput | ChallengeScalarWhereInput[]
  }

  export type DefaultChallengeReviewerUncheckedUpdateManyWithoutTimelineTemplateNestedInput = {
    create?: XOR<DefaultChallengeReviewerCreateWithoutTimelineTemplateInput, DefaultChallengeReviewerUncheckedCreateWithoutTimelineTemplateInput> | DefaultChallengeReviewerCreateWithoutTimelineTemplateInput[] | DefaultChallengeReviewerUncheckedCreateWithoutTimelineTemplateInput[]
    connectOrCreate?: DefaultChallengeReviewerCreateOrConnectWithoutTimelineTemplateInput | DefaultChallengeReviewerCreateOrConnectWithoutTimelineTemplateInput[]
    upsert?: DefaultChallengeReviewerUpsertWithWhereUniqueWithoutTimelineTemplateInput | DefaultChallengeReviewerUpsertWithWhereUniqueWithoutTimelineTemplateInput[]
    createMany?: DefaultChallengeReviewerCreateManyTimelineTemplateInputEnvelope
    set?: DefaultChallengeReviewerWhereUniqueInput | DefaultChallengeReviewerWhereUniqueInput[]
    disconnect?: DefaultChallengeReviewerWhereUniqueInput | DefaultChallengeReviewerWhereUniqueInput[]
    delete?: DefaultChallengeReviewerWhereUniqueInput | DefaultChallengeReviewerWhereUniqueInput[]
    connect?: DefaultChallengeReviewerWhereUniqueInput | DefaultChallengeReviewerWhereUniqueInput[]
    update?: DefaultChallengeReviewerUpdateWithWhereUniqueWithoutTimelineTemplateInput | DefaultChallengeReviewerUpdateWithWhereUniqueWithoutTimelineTemplateInput[]
    updateMany?: DefaultChallengeReviewerUpdateManyWithWhereWithoutTimelineTemplateInput | DefaultChallengeReviewerUpdateManyWithWhereWithoutTimelineTemplateInput[]
    deleteMany?: DefaultChallengeReviewerScalarWhereInput | DefaultChallengeReviewerScalarWhereInput[]
  }

  export type TimelineTemplateCreateNestedOneWithoutPhasesInput = {
    create?: XOR<TimelineTemplateCreateWithoutPhasesInput, TimelineTemplateUncheckedCreateWithoutPhasesInput>
    connectOrCreate?: TimelineTemplateCreateOrConnectWithoutPhasesInput
    connect?: TimelineTemplateWhereUniqueInput
  }

  export type TimelineTemplateUpdateOneRequiredWithoutPhasesNestedInput = {
    create?: XOR<TimelineTemplateCreateWithoutPhasesInput, TimelineTemplateUncheckedCreateWithoutPhasesInput>
    connectOrCreate?: TimelineTemplateCreateOrConnectWithoutPhasesInput
    upsert?: TimelineTemplateUpsertWithoutPhasesInput
    connect?: TimelineTemplateWhereUniqueInput
    update?: XOR<XOR<TimelineTemplateUpdateToOneWithWhereWithoutPhasesInput, TimelineTemplateUpdateWithoutPhasesInput>, TimelineTemplateUncheckedUpdateWithoutPhasesInput>
  }

  export type NestedStringFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    search?: string
    not?: NestedStringFilter<$PrismaModel> | string
  }

  export type NestedStringNullableFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    search?: string
    not?: NestedStringNullableFilter<$PrismaModel> | string | null
  }

  export type NestedIntNullableFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableFilter<$PrismaModel> | number | null
  }

  export type NestedFloatNullableFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel> | null
    in?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatNullableFilter<$PrismaModel> | number | null
  }

  export type NestedIntFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[] | ListIntFieldRefInput<$PrismaModel>
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntFilter<$PrismaModel> | number
  }

  export type NestedBoolFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolFilter<$PrismaModel> | boolean
  }

  export type NestedDateTimeNullableFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableFilter<$PrismaModel> | Date | string | null
  }

  export type NestedEnumChallengeStatusEnumFilter<$PrismaModel = never> = {
    equals?: $Enums.ChallengeStatusEnum | EnumChallengeStatusEnumFieldRefInput<$PrismaModel>
    in?: $Enums.ChallengeStatusEnum[] | ListEnumChallengeStatusEnumFieldRefInput<$PrismaModel>
    notIn?: $Enums.ChallengeStatusEnum[] | ListEnumChallengeStatusEnumFieldRefInput<$PrismaModel>
    not?: NestedEnumChallengeStatusEnumFilter<$PrismaModel> | $Enums.ChallengeStatusEnum
  }

  export type NestedDateTimeFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeFilter<$PrismaModel> | Date | string
  }

  export type NestedStringWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    search?: string
    not?: NestedStringWithAggregatesFilter<$PrismaModel> | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedStringFilter<$PrismaModel>
    _max?: NestedStringFilter<$PrismaModel>
  }

  export type NestedStringNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    search?: string
    not?: NestedStringNullableWithAggregatesFilter<$PrismaModel> | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedStringNullableFilter<$PrismaModel>
    _max?: NestedStringNullableFilter<$PrismaModel>
  }

  export type NestedIntNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableWithAggregatesFilter<$PrismaModel> | number | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedFloatNullableFilter<$PrismaModel>
    _sum?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedIntNullableFilter<$PrismaModel>
    _max?: NestedIntNullableFilter<$PrismaModel>
  }

  export type NestedFloatNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel> | null
    in?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatNullableWithAggregatesFilter<$PrismaModel> | number | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedFloatNullableFilter<$PrismaModel>
    _sum?: NestedFloatNullableFilter<$PrismaModel>
    _min?: NestedFloatNullableFilter<$PrismaModel>
    _max?: NestedFloatNullableFilter<$PrismaModel>
  }

  export type NestedIntWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[] | ListIntFieldRefInput<$PrismaModel>
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntWithAggregatesFilter<$PrismaModel> | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedIntFilter<$PrismaModel>
    _min?: NestedIntFilter<$PrismaModel>
    _max?: NestedIntFilter<$PrismaModel>
  }

  export type NestedFloatFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel>
    in?: number[] | ListFloatFieldRefInput<$PrismaModel>
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel>
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatFilter<$PrismaModel> | number
  }

  export type NestedBoolWithAggregatesFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolWithAggregatesFilter<$PrismaModel> | boolean
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedBoolFilter<$PrismaModel>
    _max?: NestedBoolFilter<$PrismaModel>
  }

  export type NestedDateTimeNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableWithAggregatesFilter<$PrismaModel> | Date | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedDateTimeNullableFilter<$PrismaModel>
    _max?: NestedDateTimeNullableFilter<$PrismaModel>
  }

  export type NestedEnumChallengeStatusEnumWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.ChallengeStatusEnum | EnumChallengeStatusEnumFieldRefInput<$PrismaModel>
    in?: $Enums.ChallengeStatusEnum[] | ListEnumChallengeStatusEnumFieldRefInput<$PrismaModel>
    notIn?: $Enums.ChallengeStatusEnum[] | ListEnumChallengeStatusEnumFieldRefInput<$PrismaModel>
    not?: NestedEnumChallengeStatusEnumWithAggregatesFilter<$PrismaModel> | $Enums.ChallengeStatusEnum
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumChallengeStatusEnumFilter<$PrismaModel>
    _max?: NestedEnumChallengeStatusEnumFilter<$PrismaModel>
  }

  export type NestedDateTimeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeWithAggregatesFilter<$PrismaModel> | Date | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedDateTimeFilter<$PrismaModel>
    _max?: NestedDateTimeFilter<$PrismaModel>
  }

  export type NestedEnumChallengeTrackEnumNullableFilter<$PrismaModel = never> = {
    equals?: $Enums.ChallengeTrackEnum | EnumChallengeTrackEnumFieldRefInput<$PrismaModel> | null
    in?: $Enums.ChallengeTrackEnum[] | ListEnumChallengeTrackEnumFieldRefInput<$PrismaModel> | null
    notIn?: $Enums.ChallengeTrackEnum[] | ListEnumChallengeTrackEnumFieldRefInput<$PrismaModel> | null
    not?: NestedEnumChallengeTrackEnumNullableFilter<$PrismaModel> | $Enums.ChallengeTrackEnum | null
  }

  export type NestedEnumChallengeTrackEnumNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.ChallengeTrackEnum | EnumChallengeTrackEnumFieldRefInput<$PrismaModel> | null
    in?: $Enums.ChallengeTrackEnum[] | ListEnumChallengeTrackEnumFieldRefInput<$PrismaModel> | null
    notIn?: $Enums.ChallengeTrackEnum[] | ListEnumChallengeTrackEnumFieldRefInput<$PrismaModel> | null
    not?: NestedEnumChallengeTrackEnumNullableWithAggregatesFilter<$PrismaModel> | $Enums.ChallengeTrackEnum | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedEnumChallengeTrackEnumNullableFilter<$PrismaModel>
    _max?: NestedEnumChallengeTrackEnumNullableFilter<$PrismaModel>
  }

  export type NestedFloatWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel>
    in?: number[] | ListFloatFieldRefInput<$PrismaModel>
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel>
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatWithAggregatesFilter<$PrismaModel> | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedFloatFilter<$PrismaModel>
    _min?: NestedFloatFilter<$PrismaModel>
    _max?: NestedFloatFilter<$PrismaModel>
  }

  export type NestedEnumPrizeSetTypeEnumFilter<$PrismaModel = never> = {
    equals?: $Enums.PrizeSetTypeEnum | EnumPrizeSetTypeEnumFieldRefInput<$PrismaModel>
    in?: $Enums.PrizeSetTypeEnum[] | ListEnumPrizeSetTypeEnumFieldRefInput<$PrismaModel>
    notIn?: $Enums.PrizeSetTypeEnum[] | ListEnumPrizeSetTypeEnumFieldRefInput<$PrismaModel>
    not?: NestedEnumPrizeSetTypeEnumFilter<$PrismaModel> | $Enums.PrizeSetTypeEnum
  }

  export type NestedEnumPrizeSetTypeEnumWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.PrizeSetTypeEnum | EnumPrizeSetTypeEnumFieldRefInput<$PrismaModel>
    in?: $Enums.PrizeSetTypeEnum[] | ListEnumPrizeSetTypeEnumFieldRefInput<$PrismaModel>
    notIn?: $Enums.PrizeSetTypeEnum[] | ListEnumPrizeSetTypeEnumFieldRefInput<$PrismaModel>
    not?: NestedEnumPrizeSetTypeEnumWithAggregatesFilter<$PrismaModel> | $Enums.PrizeSetTypeEnum
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumPrizeSetTypeEnumFilter<$PrismaModel>
    _max?: NestedEnumPrizeSetTypeEnumFilter<$PrismaModel>
  }

  export type NestedEnumReviewTypeEnumFilter<$PrismaModel = never> = {
    equals?: $Enums.ReviewTypeEnum | EnumReviewTypeEnumFieldRefInput<$PrismaModel>
    in?: $Enums.ReviewTypeEnum[] | ListEnumReviewTypeEnumFieldRefInput<$PrismaModel>
    notIn?: $Enums.ReviewTypeEnum[] | ListEnumReviewTypeEnumFieldRefInput<$PrismaModel>
    not?: NestedEnumReviewTypeEnumFilter<$PrismaModel> | $Enums.ReviewTypeEnum
  }

  export type NestedEnumReviewTypeEnumWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.ReviewTypeEnum | EnumReviewTypeEnumFieldRefInput<$PrismaModel>
    in?: $Enums.ReviewTypeEnum[] | ListEnumReviewTypeEnumFieldRefInput<$PrismaModel>
    notIn?: $Enums.ReviewTypeEnum[] | ListEnumReviewTypeEnumFieldRefInput<$PrismaModel>
    not?: NestedEnumReviewTypeEnumWithAggregatesFilter<$PrismaModel> | $Enums.ReviewTypeEnum
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumReviewTypeEnumFilter<$PrismaModel>
    _max?: NestedEnumReviewTypeEnumFilter<$PrismaModel>
  }

  export type NestedEnumDiscussionTypeEnumFilter<$PrismaModel = never> = {
    equals?: $Enums.DiscussionTypeEnum | EnumDiscussionTypeEnumFieldRefInput<$PrismaModel>
    in?: $Enums.DiscussionTypeEnum[] | ListEnumDiscussionTypeEnumFieldRefInput<$PrismaModel>
    notIn?: $Enums.DiscussionTypeEnum[] | ListEnumDiscussionTypeEnumFieldRefInput<$PrismaModel>
    not?: NestedEnumDiscussionTypeEnumFilter<$PrismaModel> | $Enums.DiscussionTypeEnum
  }

  export type NestedEnumDiscussionTypeEnumWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.DiscussionTypeEnum | EnumDiscussionTypeEnumFieldRefInput<$PrismaModel>
    in?: $Enums.DiscussionTypeEnum[] | ListEnumDiscussionTypeEnumFieldRefInput<$PrismaModel>
    notIn?: $Enums.DiscussionTypeEnum[] | ListEnumDiscussionTypeEnumFieldRefInput<$PrismaModel>
    not?: NestedEnumDiscussionTypeEnumWithAggregatesFilter<$PrismaModel> | $Enums.DiscussionTypeEnum
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumDiscussionTypeEnumFilter<$PrismaModel>
    _max?: NestedEnumDiscussionTypeEnumFilter<$PrismaModel>
  }

  export type NestedBoolNullableFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel> | null
    not?: NestedBoolNullableFilter<$PrismaModel> | boolean | null
  }

  export type NestedBoolNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel> | null
    not?: NestedBoolNullableWithAggregatesFilter<$PrismaModel> | boolean | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedBoolNullableFilter<$PrismaModel>
    _max?: NestedBoolNullableFilter<$PrismaModel>
  }

  export type NestedEnumReviewOpportunityTypeEnumNullableFilter<$PrismaModel = never> = {
    equals?: $Enums.ReviewOpportunityTypeEnum | EnumReviewOpportunityTypeEnumFieldRefInput<$PrismaModel> | null
    in?: $Enums.ReviewOpportunityTypeEnum[] | ListEnumReviewOpportunityTypeEnumFieldRefInput<$PrismaModel> | null
    notIn?: $Enums.ReviewOpportunityTypeEnum[] | ListEnumReviewOpportunityTypeEnumFieldRefInput<$PrismaModel> | null
    not?: NestedEnumReviewOpportunityTypeEnumNullableFilter<$PrismaModel> | $Enums.ReviewOpportunityTypeEnum | null
  }

  export type NestedEnumReviewOpportunityTypeEnumNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.ReviewOpportunityTypeEnum | EnumReviewOpportunityTypeEnumFieldRefInput<$PrismaModel> | null
    in?: $Enums.ReviewOpportunityTypeEnum[] | ListEnumReviewOpportunityTypeEnumFieldRefInput<$PrismaModel> | null
    notIn?: $Enums.ReviewOpportunityTypeEnum[] | ListEnumReviewOpportunityTypeEnumFieldRefInput<$PrismaModel> | null
    not?: NestedEnumReviewOpportunityTypeEnumNullableWithAggregatesFilter<$PrismaModel> | $Enums.ReviewOpportunityTypeEnum | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedEnumReviewOpportunityTypeEnumNullableFilter<$PrismaModel>
    _max?: NestedEnumReviewOpportunityTypeEnumNullableFilter<$PrismaModel>
  }

  export type ChallengeBillingCreateWithoutChallengeInput = {
    id?: string
    billingAccountId?: string | null
    markup?: number | null
    clientBillingRate?: number | null
    createdAt?: Date | string
    createdBy: string
    updatedAt?: Date | string
    updatedBy: string
  }

  export type ChallengeBillingUncheckedCreateWithoutChallengeInput = {
    id?: string
    billingAccountId?: string | null
    markup?: number | null
    clientBillingRate?: number | null
    createdAt?: Date | string
    createdBy: string
    updatedAt?: Date | string
    updatedBy: string
  }

  export type ChallengeBillingCreateOrConnectWithoutChallengeInput = {
    where: ChallengeBillingWhereUniqueInput
    create: XOR<ChallengeBillingCreateWithoutChallengeInput, ChallengeBillingUncheckedCreateWithoutChallengeInput>
  }

  export type ChallengeLegacyCreateWithoutChallengeInput = {
    id?: string
    reviewType?: $Enums.ReviewTypeEnum
    confidentialityType?: string
    forumId?: number | null
    directProjectId?: number | null
    screeningScorecardId?: number | null
    reviewScorecardId?: number | null
    isTask?: boolean
    useSchedulingAPI?: boolean
    pureV5Task?: boolean
    pureV5?: boolean
    selfService?: boolean
    selfServiceCopilot?: string | null
    track?: string | null
    subTrack?: string | null
    legacySystemId?: number | null
    createdAt?: Date | string
    createdBy: string
    updatedAt?: Date | string
    updatedBy: string
  }

  export type ChallengeLegacyUncheckedCreateWithoutChallengeInput = {
    id?: string
    reviewType?: $Enums.ReviewTypeEnum
    confidentialityType?: string
    forumId?: number | null
    directProjectId?: number | null
    screeningScorecardId?: number | null
    reviewScorecardId?: number | null
    isTask?: boolean
    useSchedulingAPI?: boolean
    pureV5Task?: boolean
    pureV5?: boolean
    selfService?: boolean
    selfServiceCopilot?: string | null
    track?: string | null
    subTrack?: string | null
    legacySystemId?: number | null
    createdAt?: Date | string
    createdBy: string
    updatedAt?: Date | string
    updatedBy: string
  }

  export type ChallengeLegacyCreateOrConnectWithoutChallengeInput = {
    where: ChallengeLegacyWhereUniqueInput
    create: XOR<ChallengeLegacyCreateWithoutChallengeInput, ChallengeLegacyUncheckedCreateWithoutChallengeInput>
  }

  export type ChallengeConstraintCreateWithoutChallengeInput = {
    id?: string
    allowedRegistrants?: ChallengeConstraintCreateallowedRegistrantsInput | string[]
    createdAt?: Date | string
    createdBy: string
    updatedAt?: Date | string
    updatedBy: string
  }

  export type ChallengeConstraintUncheckedCreateWithoutChallengeInput = {
    id?: string
    allowedRegistrants?: ChallengeConstraintCreateallowedRegistrantsInput | string[]
    createdAt?: Date | string
    createdBy: string
    updatedAt?: Date | string
    updatedBy: string
  }

  export type ChallengeConstraintCreateOrConnectWithoutChallengeInput = {
    where: ChallengeConstraintWhereUniqueInput
    create: XOR<ChallengeConstraintCreateWithoutChallengeInput, ChallengeConstraintUncheckedCreateWithoutChallengeInput>
  }

  export type ChallengeEventCreateWithoutChallengeInput = {
    id?: string
    eventId: number
    name?: string | null
    key?: string | null
    createdAt?: Date | string
    createdBy: string
    updatedAt?: Date | string
    updatedBy: string
  }

  export type ChallengeEventUncheckedCreateWithoutChallengeInput = {
    id?: string
    eventId: number
    name?: string | null
    key?: string | null
    createdAt?: Date | string
    createdBy: string
    updatedAt?: Date | string
    updatedBy: string
  }

  export type ChallengeEventCreateOrConnectWithoutChallengeInput = {
    where: ChallengeEventWhereUniqueInput
    create: XOR<ChallengeEventCreateWithoutChallengeInput, ChallengeEventUncheckedCreateWithoutChallengeInput>
  }

  export type ChallengeEventCreateManyChallengeInputEnvelope = {
    data: ChallengeEventCreateManyChallengeInput | ChallengeEventCreateManyChallengeInput[]
    skipDuplicates?: boolean
  }

  export type ChallengeDiscussionCreateWithoutChallengeInput = {
    id?: string
    discussionId?: string | null
    name: string
    type: $Enums.DiscussionTypeEnum
    provider: string
    url?: string | null
    createdAt?: Date | string
    createdBy: string
    updatedAt?: Date | string
    updatedBy: string
    options?: ChallengeDiscussionOptionCreateNestedManyWithoutDiscussionInput
  }

  export type ChallengeDiscussionUncheckedCreateWithoutChallengeInput = {
    id?: string
    discussionId?: string | null
    name: string
    type: $Enums.DiscussionTypeEnum
    provider: string
    url?: string | null
    createdAt?: Date | string
    createdBy: string
    updatedAt?: Date | string
    updatedBy: string
    options?: ChallengeDiscussionOptionUncheckedCreateNestedManyWithoutDiscussionInput
  }

  export type ChallengeDiscussionCreateOrConnectWithoutChallengeInput = {
    where: ChallengeDiscussionWhereUniqueInput
    create: XOR<ChallengeDiscussionCreateWithoutChallengeInput, ChallengeDiscussionUncheckedCreateWithoutChallengeInput>
  }

  export type ChallengeDiscussionCreateManyChallengeInputEnvelope = {
    data: ChallengeDiscussionCreateManyChallengeInput | ChallengeDiscussionCreateManyChallengeInput[]
    skipDuplicates?: boolean
  }

  export type ChallengeMetadataCreateWithoutChallengeInput = {
    id?: string
    name: string
    value: string
    createdAt?: Date | string
    createdBy: string
    updatedAt?: Date | string
    updatedBy: string
  }

  export type ChallengeMetadataUncheckedCreateWithoutChallengeInput = {
    id?: string
    name: string
    value: string
    createdAt?: Date | string
    createdBy: string
    updatedAt?: Date | string
    updatedBy: string
  }

  export type ChallengeMetadataCreateOrConnectWithoutChallengeInput = {
    where: ChallengeMetadataWhereUniqueInput
    create: XOR<ChallengeMetadataCreateWithoutChallengeInput, ChallengeMetadataUncheckedCreateWithoutChallengeInput>
  }

  export type ChallengeMetadataCreateManyChallengeInputEnvelope = {
    data: ChallengeMetadataCreateManyChallengeInput | ChallengeMetadataCreateManyChallengeInput[]
    skipDuplicates?: boolean
  }

  export type ChallengePhaseCreateWithoutChallengeInput = {
    id?: string
    name: string
    description?: string | null
    isOpen?: boolean | null
    predecessor?: string | null
    duration?: number | null
    scheduledStartDate?: Date | string | null
    scheduledEndDate?: Date | string | null
    actualStartDate?: Date | string | null
    actualEndDate?: Date | string | null
    createdAt?: Date | string
    createdBy: string
    updatedAt?: Date | string
    updatedBy: string
    constraints?: ChallengePhaseConstraintCreateNestedManyWithoutChallengePhaseInput
    phase: PhaseCreateNestedOneWithoutChallengePhasesInput
  }

  export type ChallengePhaseUncheckedCreateWithoutChallengeInput = {
    id?: string
    phaseId: string
    name: string
    description?: string | null
    isOpen?: boolean | null
    predecessor?: string | null
    duration?: number | null
    scheduledStartDate?: Date | string | null
    scheduledEndDate?: Date | string | null
    actualStartDate?: Date | string | null
    actualEndDate?: Date | string | null
    createdAt?: Date | string
    createdBy: string
    updatedAt?: Date | string
    updatedBy: string
    constraints?: ChallengePhaseConstraintUncheckedCreateNestedManyWithoutChallengePhaseInput
  }

  export type ChallengePhaseCreateOrConnectWithoutChallengeInput = {
    where: ChallengePhaseWhereUniqueInput
    create: XOR<ChallengePhaseCreateWithoutChallengeInput, ChallengePhaseUncheckedCreateWithoutChallengeInput>
  }

  export type ChallengePhaseCreateManyChallengeInputEnvelope = {
    data: ChallengePhaseCreateManyChallengeInput | ChallengePhaseCreateManyChallengeInput[]
    skipDuplicates?: boolean
  }

  export type ChallengePrizeSetCreateWithoutChallengeInput = {
    id?: string
    type: $Enums.PrizeSetTypeEnum
    description?: string | null
    createdAt?: Date | string
    createdBy: string
    updatedAt?: Date | string
    updatedBy: string
    prizes?: PrizeCreateNestedManyWithoutPrizeSetInput
  }

  export type ChallengePrizeSetUncheckedCreateWithoutChallengeInput = {
    id?: string
    type: $Enums.PrizeSetTypeEnum
    description?: string | null
    createdAt?: Date | string
    createdBy: string
    updatedAt?: Date | string
    updatedBy: string
    prizes?: PrizeUncheckedCreateNestedManyWithoutPrizeSetInput
  }

  export type ChallengePrizeSetCreateOrConnectWithoutChallengeInput = {
    where: ChallengePrizeSetWhereUniqueInput
    create: XOR<ChallengePrizeSetCreateWithoutChallengeInput, ChallengePrizeSetUncheckedCreateWithoutChallengeInput>
  }

  export type ChallengePrizeSetCreateManyChallengeInputEnvelope = {
    data: ChallengePrizeSetCreateManyChallengeInput | ChallengePrizeSetCreateManyChallengeInput[]
    skipDuplicates?: boolean
  }

  export type ChallengeReviewerCreateWithoutChallengeInput = {
    id?: string
    scorecardId: string
    isMemberReview: boolean
    memberReviewerCount?: number | null
    fixedAmount?: number | null
    baseCoefficient?: number | null
    incrementalCoefficient?: number | null
    type?: $Enums.ReviewOpportunityTypeEnum | null
    aiWorkflowId?: string | null
    shouldOpenOpportunity?: boolean
    createdAt?: Date | string
    createdBy: string
    updatedAt?: Date | string
    updatedBy: string
    phase: PhaseCreateNestedOneWithoutChallengeReviewerInput
  }

  export type ChallengeReviewerUncheckedCreateWithoutChallengeInput = {
    id?: string
    scorecardId: string
    isMemberReview: boolean
    memberReviewerCount?: number | null
    phaseId: string
    fixedAmount?: number | null
    baseCoefficient?: number | null
    incrementalCoefficient?: number | null
    type?: $Enums.ReviewOpportunityTypeEnum | null
    aiWorkflowId?: string | null
    shouldOpenOpportunity?: boolean
    createdAt?: Date | string
    createdBy: string
    updatedAt?: Date | string
    updatedBy: string
  }

  export type ChallengeReviewerCreateOrConnectWithoutChallengeInput = {
    where: ChallengeReviewerWhereUniqueInput
    create: XOR<ChallengeReviewerCreateWithoutChallengeInput, ChallengeReviewerUncheckedCreateWithoutChallengeInput>
  }

  export type ChallengeReviewerCreateManyChallengeInputEnvelope = {
    data: ChallengeReviewerCreateManyChallengeInput | ChallengeReviewerCreateManyChallengeInput[]
    skipDuplicates?: boolean
  }

  export type ChallengeWinnerCreateWithoutChallengeInput = {
    id?: string
    userId: number
    handle: string
    placement: number
    type: $Enums.PrizeSetTypeEnum
    createdAt?: Date | string
    createdBy: string
    updatedAt?: Date | string
    updatedBy: string
  }

  export type ChallengeWinnerUncheckedCreateWithoutChallengeInput = {
    id?: string
    userId: number
    handle: string
    placement: number
    type: $Enums.PrizeSetTypeEnum
    createdAt?: Date | string
    createdBy: string
    updatedAt?: Date | string
    updatedBy: string
  }

  export type ChallengeWinnerCreateOrConnectWithoutChallengeInput = {
    where: ChallengeWinnerWhereUniqueInput
    create: XOR<ChallengeWinnerCreateWithoutChallengeInput, ChallengeWinnerUncheckedCreateWithoutChallengeInput>
  }

  export type ChallengeWinnerCreateManyChallengeInputEnvelope = {
    data: ChallengeWinnerCreateManyChallengeInput | ChallengeWinnerCreateManyChallengeInput[]
    skipDuplicates?: boolean
  }

  export type AttachmentCreateWithoutChallengeInput = {
    id?: string
    name: string
    fileSize: number
    url: string
    description?: string | null
    createdAt?: Date | string
    createdBy: string
    updatedAt?: Date | string
    updatedBy: string
  }

  export type AttachmentUncheckedCreateWithoutChallengeInput = {
    id?: string
    name: string
    fileSize: number
    url: string
    description?: string | null
    createdAt?: Date | string
    createdBy: string
    updatedAt?: Date | string
    updatedBy: string
  }

  export type AttachmentCreateOrConnectWithoutChallengeInput = {
    where: AttachmentWhereUniqueInput
    create: XOR<AttachmentCreateWithoutChallengeInput, AttachmentUncheckedCreateWithoutChallengeInput>
  }

  export type AttachmentCreateManyChallengeInputEnvelope = {
    data: AttachmentCreateManyChallengeInput | AttachmentCreateManyChallengeInput[]
    skipDuplicates?: boolean
  }

  export type ChallengeTermCreateWithoutChallengeInput = {
    id?: string
    termId: string
    roleId: string
    createdAt?: Date | string
    createdBy: string
    updatedAt?: Date | string
    updatedBy: string
  }

  export type ChallengeTermUncheckedCreateWithoutChallengeInput = {
    id?: string
    termId: string
    roleId: string
    createdAt?: Date | string
    createdBy: string
    updatedAt?: Date | string
    updatedBy: string
  }

  export type ChallengeTermCreateOrConnectWithoutChallengeInput = {
    where: ChallengeTermWhereUniqueInput
    create: XOR<ChallengeTermCreateWithoutChallengeInput, ChallengeTermUncheckedCreateWithoutChallengeInput>
  }

  export type ChallengeTermCreateManyChallengeInputEnvelope = {
    data: ChallengeTermCreateManyChallengeInput | ChallengeTermCreateManyChallengeInput[]
    skipDuplicates?: boolean
  }

  export type ChallengeSkillCreateWithoutChallengeInput = {
    id?: string
    skillId: string
    createdAt?: Date | string
    createdBy: string
    updatedAt?: Date | string
    updatedBy: string
  }

  export type ChallengeSkillUncheckedCreateWithoutChallengeInput = {
    id?: string
    skillId: string
    createdAt?: Date | string
    createdBy: string
    updatedAt?: Date | string
    updatedBy: string
  }

  export type ChallengeSkillCreateOrConnectWithoutChallengeInput = {
    where: ChallengeSkillWhereUniqueInput
    create: XOR<ChallengeSkillCreateWithoutChallengeInput, ChallengeSkillUncheckedCreateWithoutChallengeInput>
  }

  export type ChallengeSkillCreateManyChallengeInputEnvelope = {
    data: ChallengeSkillCreateManyChallengeInput | ChallengeSkillCreateManyChallengeInput[]
    skipDuplicates?: boolean
  }

  export type AuditLogCreateWithoutChallengeInput = {
    id?: string
    fieldName: string
    oldValue?: string | null
    newValue?: string | null
    createdAt?: Date | string
    createdBy: string
    memberId?: string | null
  }

  export type AuditLogUncheckedCreateWithoutChallengeInput = {
    id?: string
    fieldName: string
    oldValue?: string | null
    newValue?: string | null
    createdAt?: Date | string
    createdBy: string
    memberId?: string | null
  }

  export type AuditLogCreateOrConnectWithoutChallengeInput = {
    where: AuditLogWhereUniqueInput
    create: XOR<AuditLogCreateWithoutChallengeInput, AuditLogUncheckedCreateWithoutChallengeInput>
  }

  export type AuditLogCreateManyChallengeInputEnvelope = {
    data: AuditLogCreateManyChallengeInput | AuditLogCreateManyChallengeInput[]
    skipDuplicates?: boolean
  }

  export type MemberChallengeAccessWhereUniqueInput = {
    AND?: MemberChallengeAccessWhereInput | MemberChallengeAccessWhereInput[]
    OR?: MemberChallengeAccessWhereInput[]
    NOT?: MemberChallengeAccessWhereInput | MemberChallengeAccessWhereInput[]
    challengeId?: StringFilter<"MemberChallengeAccess"> | string
    memberId?: StringFilter<"MemberChallengeAccess"> | string
    challenge?: XOR<ChallengeScalarRelationFilter, ChallengeWhereInput>
  }

  export type ChallengeTypeCreateWithoutChallengesInput = {
    id?: string
    name: string
    description?: string | null
    isActive?: boolean
    isTask?: boolean
    abbreviation: string
    createdAt?: Date | string
    createdBy: string
    updatedAt?: Date | string
    updatedBy: string
    timelineTemplates?: ChallengeTimelineTemplateCreateNestedManyWithoutTypeInput
    defaultReviewers?: DefaultChallengeReviewerCreateNestedManyWithoutChallengeTypeInput
  }

  export type ChallengeTypeUncheckedCreateWithoutChallengesInput = {
    id?: string
    name: string
    description?: string | null
    isActive?: boolean
    isTask?: boolean
    abbreviation: string
    createdAt?: Date | string
    createdBy: string
    updatedAt?: Date | string
    updatedBy: string
    timelineTemplates?: ChallengeTimelineTemplateUncheckedCreateNestedManyWithoutTypeInput
    defaultReviewers?: DefaultChallengeReviewerUncheckedCreateNestedManyWithoutChallengeTypeInput
  }

  export type ChallengeTypeCreateOrConnectWithoutChallengesInput = {
    where: ChallengeTypeWhereUniqueInput
    create: XOR<ChallengeTypeCreateWithoutChallengesInput, ChallengeTypeUncheckedCreateWithoutChallengesInput>
  }

  export type ChallengeTrackCreateWithoutChallengesInput = {
    id?: string
    name: string
    description?: string | null
    isActive: boolean
    abbreviation: string
    legacyId?: number | null
    track?: $Enums.ChallengeTrackEnum | null
    createdAt?: Date | string
    createdBy: string
    updatedAt?: Date | string
    updatedBy: string
    timelineTemplates?: ChallengeTimelineTemplateCreateNestedManyWithoutTrackInput
    defaultReviewers?: DefaultChallengeReviewerCreateNestedManyWithoutChallengeTrackInput
  }

  export type ChallengeTrackUncheckedCreateWithoutChallengesInput = {
    id?: string
    name: string
    description?: string | null
    isActive: boolean
    abbreviation: string
    legacyId?: number | null
    track?: $Enums.ChallengeTrackEnum | null
    createdAt?: Date | string
    createdBy: string
    updatedAt?: Date | string
    updatedBy: string
    timelineTemplates?: ChallengeTimelineTemplateUncheckedCreateNestedManyWithoutTrackInput
    defaultReviewers?: DefaultChallengeReviewerUncheckedCreateNestedManyWithoutChallengeTrackInput
  }

  export type ChallengeTrackCreateOrConnectWithoutChallengesInput = {
    where: ChallengeTrackWhereUniqueInput
    create: XOR<ChallengeTrackCreateWithoutChallengesInput, ChallengeTrackUncheckedCreateWithoutChallengesInput>
  }

  export type TimelineTemplateCreateWithoutChallengesInput = {
    id?: string
    name: string
    description?: string | null
    isActive?: boolean
    createdAt?: Date | string
    createdBy: string
    updatedAt?: Date | string
    updatedBy: string
    phases?: TimelineTemplatePhaseCreateNestedManyWithoutTimelineTemplateInput
    challengeTimelineTemplates?: ChallengeTimelineTemplateCreateNestedManyWithoutTimelineTemplateInput
    DefaultChallengeReviewer?: DefaultChallengeReviewerCreateNestedManyWithoutTimelineTemplateInput
  }

  export type TimelineTemplateUncheckedCreateWithoutChallengesInput = {
    id?: string
    name: string
    description?: string | null
    isActive?: boolean
    createdAt?: Date | string
    createdBy: string
    updatedAt?: Date | string
    updatedBy: string
    phases?: TimelineTemplatePhaseUncheckedCreateNestedManyWithoutTimelineTemplateInput
    challengeTimelineTemplates?: ChallengeTimelineTemplateUncheckedCreateNestedManyWithoutTimelineTemplateInput
    DefaultChallengeReviewer?: DefaultChallengeReviewerUncheckedCreateNestedManyWithoutTimelineTemplateInput
  }

  export type TimelineTemplateCreateOrConnectWithoutChallengesInput = {
    where: TimelineTemplateWhereUniqueInput
    create: XOR<TimelineTemplateCreateWithoutChallengesInput, TimelineTemplateUncheckedCreateWithoutChallengesInput>
  }

  export type ChallengeBillingUpsertWithoutChallengeInput = {
    update: XOR<ChallengeBillingUpdateWithoutChallengeInput, ChallengeBillingUncheckedUpdateWithoutChallengeInput>
    create: XOR<ChallengeBillingCreateWithoutChallengeInput, ChallengeBillingUncheckedCreateWithoutChallengeInput>
    where?: ChallengeBillingWhereInput
  }

  export type ChallengeBillingUpdateToOneWithWhereWithoutChallengeInput = {
    where?: ChallengeBillingWhereInput
    data: XOR<ChallengeBillingUpdateWithoutChallengeInput, ChallengeBillingUncheckedUpdateWithoutChallengeInput>
  }

  export type ChallengeBillingUpdateWithoutChallengeInput = {
    id?: StringFieldUpdateOperationsInput | string
    billingAccountId?: NullableStringFieldUpdateOperationsInput | string | null
    markup?: NullableFloatFieldUpdateOperationsInput | number | null
    clientBillingRate?: NullableFloatFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdBy?: StringFieldUpdateOperationsInput | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedBy?: StringFieldUpdateOperationsInput | string
  }

  export type ChallengeBillingUncheckedUpdateWithoutChallengeInput = {
    id?: StringFieldUpdateOperationsInput | string
    billingAccountId?: NullableStringFieldUpdateOperationsInput | string | null
    markup?: NullableFloatFieldUpdateOperationsInput | number | null
    clientBillingRate?: NullableFloatFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdBy?: StringFieldUpdateOperationsInput | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedBy?: StringFieldUpdateOperationsInput | string
  }

  export type ChallengeLegacyUpsertWithoutChallengeInput = {
    update: XOR<ChallengeLegacyUpdateWithoutChallengeInput, ChallengeLegacyUncheckedUpdateWithoutChallengeInput>
    create: XOR<ChallengeLegacyCreateWithoutChallengeInput, ChallengeLegacyUncheckedCreateWithoutChallengeInput>
    where?: ChallengeLegacyWhereInput
  }

  export type ChallengeLegacyUpdateToOneWithWhereWithoutChallengeInput = {
    where?: ChallengeLegacyWhereInput
    data: XOR<ChallengeLegacyUpdateWithoutChallengeInput, ChallengeLegacyUncheckedUpdateWithoutChallengeInput>
  }

  export type ChallengeLegacyUpdateWithoutChallengeInput = {
    id?: StringFieldUpdateOperationsInput | string
    reviewType?: EnumReviewTypeEnumFieldUpdateOperationsInput | $Enums.ReviewTypeEnum
    confidentialityType?: StringFieldUpdateOperationsInput | string
    forumId?: NullableIntFieldUpdateOperationsInput | number | null
    directProjectId?: NullableIntFieldUpdateOperationsInput | number | null
    screeningScorecardId?: NullableIntFieldUpdateOperationsInput | number | null
    reviewScorecardId?: NullableIntFieldUpdateOperationsInput | number | null
    isTask?: BoolFieldUpdateOperationsInput | boolean
    useSchedulingAPI?: BoolFieldUpdateOperationsInput | boolean
    pureV5Task?: BoolFieldUpdateOperationsInput | boolean
    pureV5?: BoolFieldUpdateOperationsInput | boolean
    selfService?: BoolFieldUpdateOperationsInput | boolean
    selfServiceCopilot?: NullableStringFieldUpdateOperationsInput | string | null
    track?: NullableStringFieldUpdateOperationsInput | string | null
    subTrack?: NullableStringFieldUpdateOperationsInput | string | null
    legacySystemId?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdBy?: StringFieldUpdateOperationsInput | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedBy?: StringFieldUpdateOperationsInput | string
  }

  export type ChallengeLegacyUncheckedUpdateWithoutChallengeInput = {
    id?: StringFieldUpdateOperationsInput | string
    reviewType?: EnumReviewTypeEnumFieldUpdateOperationsInput | $Enums.ReviewTypeEnum
    confidentialityType?: StringFieldUpdateOperationsInput | string
    forumId?: NullableIntFieldUpdateOperationsInput | number | null
    directProjectId?: NullableIntFieldUpdateOperationsInput | number | null
    screeningScorecardId?: NullableIntFieldUpdateOperationsInput | number | null
    reviewScorecardId?: NullableIntFieldUpdateOperationsInput | number | null
    isTask?: BoolFieldUpdateOperationsInput | boolean
    useSchedulingAPI?: BoolFieldUpdateOperationsInput | boolean
    pureV5Task?: BoolFieldUpdateOperationsInput | boolean
    pureV5?: BoolFieldUpdateOperationsInput | boolean
    selfService?: BoolFieldUpdateOperationsInput | boolean
    selfServiceCopilot?: NullableStringFieldUpdateOperationsInput | string | null
    track?: NullableStringFieldUpdateOperationsInput | string | null
    subTrack?: NullableStringFieldUpdateOperationsInput | string | null
    legacySystemId?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdBy?: StringFieldUpdateOperationsInput | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedBy?: StringFieldUpdateOperationsInput | string
  }

  export type ChallengeConstraintUpsertWithoutChallengeInput = {
    update: XOR<ChallengeConstraintUpdateWithoutChallengeInput, ChallengeConstraintUncheckedUpdateWithoutChallengeInput>
    create: XOR<ChallengeConstraintCreateWithoutChallengeInput, ChallengeConstraintUncheckedCreateWithoutChallengeInput>
    where?: ChallengeConstraintWhereInput
  }

  export type ChallengeConstraintUpdateToOneWithWhereWithoutChallengeInput = {
    where?: ChallengeConstraintWhereInput
    data: XOR<ChallengeConstraintUpdateWithoutChallengeInput, ChallengeConstraintUncheckedUpdateWithoutChallengeInput>
  }

  export type ChallengeConstraintUpdateWithoutChallengeInput = {
    id?: StringFieldUpdateOperationsInput | string
    allowedRegistrants?: ChallengeConstraintUpdateallowedRegistrantsInput | string[]
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdBy?: StringFieldUpdateOperationsInput | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedBy?: StringFieldUpdateOperationsInput | string
  }

  export type ChallengeConstraintUncheckedUpdateWithoutChallengeInput = {
    id?: StringFieldUpdateOperationsInput | string
    allowedRegistrants?: ChallengeConstraintUpdateallowedRegistrantsInput | string[]
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdBy?: StringFieldUpdateOperationsInput | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedBy?: StringFieldUpdateOperationsInput | string
  }

  export type ChallengeEventUpsertWithWhereUniqueWithoutChallengeInput = {
    where: ChallengeEventWhereUniqueInput
    update: XOR<ChallengeEventUpdateWithoutChallengeInput, ChallengeEventUncheckedUpdateWithoutChallengeInput>
    create: XOR<ChallengeEventCreateWithoutChallengeInput, ChallengeEventUncheckedCreateWithoutChallengeInput>
  }

  export type ChallengeEventUpdateWithWhereUniqueWithoutChallengeInput = {
    where: ChallengeEventWhereUniqueInput
    data: XOR<ChallengeEventUpdateWithoutChallengeInput, ChallengeEventUncheckedUpdateWithoutChallengeInput>
  }

  export type ChallengeEventUpdateManyWithWhereWithoutChallengeInput = {
    where: ChallengeEventScalarWhereInput
    data: XOR<ChallengeEventUpdateManyMutationInput, ChallengeEventUncheckedUpdateManyWithoutChallengeInput>
  }

  export type ChallengeEventScalarWhereInput = {
    AND?: ChallengeEventScalarWhereInput | ChallengeEventScalarWhereInput[]
    OR?: ChallengeEventScalarWhereInput[]
    NOT?: ChallengeEventScalarWhereInput | ChallengeEventScalarWhereInput[]
    id?: StringFilter<"ChallengeEvent"> | string
    challengeId?: StringFilter<"ChallengeEvent"> | string
    eventId?: IntFilter<"ChallengeEvent"> | number
    name?: StringNullableFilter<"ChallengeEvent"> | string | null
    key?: StringNullableFilter<"ChallengeEvent"> | string | null
    createdAt?: DateTimeFilter<"ChallengeEvent"> | Date | string
    createdBy?: StringFilter<"ChallengeEvent"> | string
    updatedAt?: DateTimeFilter<"ChallengeEvent"> | Date | string
    updatedBy?: StringFilter<"ChallengeEvent"> | string
  }

  export type ChallengeDiscussionUpsertWithWhereUniqueWithoutChallengeInput = {
    where: ChallengeDiscussionWhereUniqueInput
    update: XOR<ChallengeDiscussionUpdateWithoutChallengeInput, ChallengeDiscussionUncheckedUpdateWithoutChallengeInput>
    create: XOR<ChallengeDiscussionCreateWithoutChallengeInput, ChallengeDiscussionUncheckedCreateWithoutChallengeInput>
  }

  export type ChallengeDiscussionUpdateWithWhereUniqueWithoutChallengeInput = {
    where: ChallengeDiscussionWhereUniqueInput
    data: XOR<ChallengeDiscussionUpdateWithoutChallengeInput, ChallengeDiscussionUncheckedUpdateWithoutChallengeInput>
  }

  export type ChallengeDiscussionUpdateManyWithWhereWithoutChallengeInput = {
    where: ChallengeDiscussionScalarWhereInput
    data: XOR<ChallengeDiscussionUpdateManyMutationInput, ChallengeDiscussionUncheckedUpdateManyWithoutChallengeInput>
  }

  export type ChallengeDiscussionScalarWhereInput = {
    AND?: ChallengeDiscussionScalarWhereInput | ChallengeDiscussionScalarWhereInput[]
    OR?: ChallengeDiscussionScalarWhereInput[]
    NOT?: ChallengeDiscussionScalarWhereInput | ChallengeDiscussionScalarWhereInput[]
    id?: StringFilter<"ChallengeDiscussion"> | string
    challengeId?: StringFilter<"ChallengeDiscussion"> | string
    discussionId?: StringNullableFilter<"ChallengeDiscussion"> | string | null
    name?: StringFilter<"ChallengeDiscussion"> | string
    type?: EnumDiscussionTypeEnumFilter<"ChallengeDiscussion"> | $Enums.DiscussionTypeEnum
    provider?: StringFilter<"ChallengeDiscussion"> | string
    url?: StringNullableFilter<"ChallengeDiscussion"> | string | null
    createdAt?: DateTimeFilter<"ChallengeDiscussion"> | Date | string
    createdBy?: StringFilter<"ChallengeDiscussion"> | string
    updatedAt?: DateTimeFilter<"ChallengeDiscussion"> | Date | string
    updatedBy?: StringFilter<"ChallengeDiscussion"> | string
  }

  export type ChallengeMetadataUpsertWithWhereUniqueWithoutChallengeInput = {
    where: ChallengeMetadataWhereUniqueInput
    update: XOR<ChallengeMetadataUpdateWithoutChallengeInput, ChallengeMetadataUncheckedUpdateWithoutChallengeInput>
    create: XOR<ChallengeMetadataCreateWithoutChallengeInput, ChallengeMetadataUncheckedCreateWithoutChallengeInput>
  }

  export type ChallengeMetadataUpdateWithWhereUniqueWithoutChallengeInput = {
    where: ChallengeMetadataWhereUniqueInput
    data: XOR<ChallengeMetadataUpdateWithoutChallengeInput, ChallengeMetadataUncheckedUpdateWithoutChallengeInput>
  }

  export type ChallengeMetadataUpdateManyWithWhereWithoutChallengeInput = {
    where: ChallengeMetadataScalarWhereInput
    data: XOR<ChallengeMetadataUpdateManyMutationInput, ChallengeMetadataUncheckedUpdateManyWithoutChallengeInput>
  }

  export type ChallengeMetadataScalarWhereInput = {
    AND?: ChallengeMetadataScalarWhereInput | ChallengeMetadataScalarWhereInput[]
    OR?: ChallengeMetadataScalarWhereInput[]
    NOT?: ChallengeMetadataScalarWhereInput | ChallengeMetadataScalarWhereInput[]
    id?: StringFilter<"ChallengeMetadata"> | string
    challengeId?: StringFilter<"ChallengeMetadata"> | string
    name?: StringFilter<"ChallengeMetadata"> | string
    value?: StringFilter<"ChallengeMetadata"> | string
    createdAt?: DateTimeFilter<"ChallengeMetadata"> | Date | string
    createdBy?: StringFilter<"ChallengeMetadata"> | string
    updatedAt?: DateTimeFilter<"ChallengeMetadata"> | Date | string
    updatedBy?: StringFilter<"ChallengeMetadata"> | string
  }

  export type ChallengePhaseUpsertWithWhereUniqueWithoutChallengeInput = {
    where: ChallengePhaseWhereUniqueInput
    update: XOR<ChallengePhaseUpdateWithoutChallengeInput, ChallengePhaseUncheckedUpdateWithoutChallengeInput>
    create: XOR<ChallengePhaseCreateWithoutChallengeInput, ChallengePhaseUncheckedCreateWithoutChallengeInput>
  }

  export type ChallengePhaseUpdateWithWhereUniqueWithoutChallengeInput = {
    where: ChallengePhaseWhereUniqueInput
    data: XOR<ChallengePhaseUpdateWithoutChallengeInput, ChallengePhaseUncheckedUpdateWithoutChallengeInput>
  }

  export type ChallengePhaseUpdateManyWithWhereWithoutChallengeInput = {
    where: ChallengePhaseScalarWhereInput
    data: XOR<ChallengePhaseUpdateManyMutationInput, ChallengePhaseUncheckedUpdateManyWithoutChallengeInput>
  }

  export type ChallengePhaseScalarWhereInput = {
    AND?: ChallengePhaseScalarWhereInput | ChallengePhaseScalarWhereInput[]
    OR?: ChallengePhaseScalarWhereInput[]
    NOT?: ChallengePhaseScalarWhereInput | ChallengePhaseScalarWhereInput[]
    id?: StringFilter<"ChallengePhase"> | string
    challengeId?: StringFilter<"ChallengePhase"> | string
    phaseId?: StringFilter<"ChallengePhase"> | string
    name?: StringFilter<"ChallengePhase"> | string
    description?: StringNullableFilter<"ChallengePhase"> | string | null
    isOpen?: BoolNullableFilter<"ChallengePhase"> | boolean | null
    predecessor?: StringNullableFilter<"ChallengePhase"> | string | null
    duration?: IntNullableFilter<"ChallengePhase"> | number | null
    scheduledStartDate?: DateTimeNullableFilter<"ChallengePhase"> | Date | string | null
    scheduledEndDate?: DateTimeNullableFilter<"ChallengePhase"> | Date | string | null
    actualStartDate?: DateTimeNullableFilter<"ChallengePhase"> | Date | string | null
    actualEndDate?: DateTimeNullableFilter<"ChallengePhase"> | Date | string | null
    createdAt?: DateTimeFilter<"ChallengePhase"> | Date | string
    createdBy?: StringFilter<"ChallengePhase"> | string
    updatedAt?: DateTimeFilter<"ChallengePhase"> | Date | string
    updatedBy?: StringFilter<"ChallengePhase"> | string
  }

  export type ChallengePrizeSetUpsertWithWhereUniqueWithoutChallengeInput = {
    where: ChallengePrizeSetWhereUniqueInput
    update: XOR<ChallengePrizeSetUpdateWithoutChallengeInput, ChallengePrizeSetUncheckedUpdateWithoutChallengeInput>
    create: XOR<ChallengePrizeSetCreateWithoutChallengeInput, ChallengePrizeSetUncheckedCreateWithoutChallengeInput>
  }

  export type ChallengePrizeSetUpdateWithWhereUniqueWithoutChallengeInput = {
    where: ChallengePrizeSetWhereUniqueInput
    data: XOR<ChallengePrizeSetUpdateWithoutChallengeInput, ChallengePrizeSetUncheckedUpdateWithoutChallengeInput>
  }

  export type ChallengePrizeSetUpdateManyWithWhereWithoutChallengeInput = {
    where: ChallengePrizeSetScalarWhereInput
    data: XOR<ChallengePrizeSetUpdateManyMutationInput, ChallengePrizeSetUncheckedUpdateManyWithoutChallengeInput>
  }

  export type ChallengePrizeSetScalarWhereInput = {
    AND?: ChallengePrizeSetScalarWhereInput | ChallengePrizeSetScalarWhereInput[]
    OR?: ChallengePrizeSetScalarWhereInput[]
    NOT?: ChallengePrizeSetScalarWhereInput | ChallengePrizeSetScalarWhereInput[]
    id?: StringFilter<"ChallengePrizeSet"> | string
    challengeId?: StringFilter<"ChallengePrizeSet"> | string
    type?: EnumPrizeSetTypeEnumFilter<"ChallengePrizeSet"> | $Enums.PrizeSetTypeEnum
    description?: StringNullableFilter<"ChallengePrizeSet"> | string | null
    createdAt?: DateTimeFilter<"ChallengePrizeSet"> | Date | string
    createdBy?: StringFilter<"ChallengePrizeSet"> | string
    updatedAt?: DateTimeFilter<"ChallengePrizeSet"> | Date | string
    updatedBy?: StringFilter<"ChallengePrizeSet"> | string
  }

  export type ChallengeReviewerUpsertWithWhereUniqueWithoutChallengeInput = {
    where: ChallengeReviewerWhereUniqueInput
    update: XOR<ChallengeReviewerUpdateWithoutChallengeInput, ChallengeReviewerUncheckedUpdateWithoutChallengeInput>
    create: XOR<ChallengeReviewerCreateWithoutChallengeInput, ChallengeReviewerUncheckedCreateWithoutChallengeInput>
  }

  export type ChallengeReviewerUpdateWithWhereUniqueWithoutChallengeInput = {
    where: ChallengeReviewerWhereUniqueInput
    data: XOR<ChallengeReviewerUpdateWithoutChallengeInput, ChallengeReviewerUncheckedUpdateWithoutChallengeInput>
  }

  export type ChallengeReviewerUpdateManyWithWhereWithoutChallengeInput = {
    where: ChallengeReviewerScalarWhereInput
    data: XOR<ChallengeReviewerUpdateManyMutationInput, ChallengeReviewerUncheckedUpdateManyWithoutChallengeInput>
  }

  export type ChallengeReviewerScalarWhereInput = {
    AND?: ChallengeReviewerScalarWhereInput | ChallengeReviewerScalarWhereInput[]
    OR?: ChallengeReviewerScalarWhereInput[]
    NOT?: ChallengeReviewerScalarWhereInput | ChallengeReviewerScalarWhereInput[]
    id?: StringFilter<"ChallengeReviewer"> | string
    challengeId?: StringFilter<"ChallengeReviewer"> | string
    scorecardId?: StringFilter<"ChallengeReviewer"> | string
    isMemberReview?: BoolFilter<"ChallengeReviewer"> | boolean
    memberReviewerCount?: IntNullableFilter<"ChallengeReviewer"> | number | null
    phaseId?: StringFilter<"ChallengeReviewer"> | string
    fixedAmount?: FloatNullableFilter<"ChallengeReviewer"> | number | null
    baseCoefficient?: FloatNullableFilter<"ChallengeReviewer"> | number | null
    incrementalCoefficient?: FloatNullableFilter<"ChallengeReviewer"> | number | null
    type?: EnumReviewOpportunityTypeEnumNullableFilter<"ChallengeReviewer"> | $Enums.ReviewOpportunityTypeEnum | null
    aiWorkflowId?: StringNullableFilter<"ChallengeReviewer"> | string | null
    shouldOpenOpportunity?: BoolFilter<"ChallengeReviewer"> | boolean
    createdAt?: DateTimeFilter<"ChallengeReviewer"> | Date | string
    createdBy?: StringFilter<"ChallengeReviewer"> | string
    updatedAt?: DateTimeFilter<"ChallengeReviewer"> | Date | string
    updatedBy?: StringFilter<"ChallengeReviewer"> | string
  }

  export type ChallengeWinnerUpsertWithWhereUniqueWithoutChallengeInput = {
    where: ChallengeWinnerWhereUniqueInput
    update: XOR<ChallengeWinnerUpdateWithoutChallengeInput, ChallengeWinnerUncheckedUpdateWithoutChallengeInput>
    create: XOR<ChallengeWinnerCreateWithoutChallengeInput, ChallengeWinnerUncheckedCreateWithoutChallengeInput>
  }

  export type ChallengeWinnerUpdateWithWhereUniqueWithoutChallengeInput = {
    where: ChallengeWinnerWhereUniqueInput
    data: XOR<ChallengeWinnerUpdateWithoutChallengeInput, ChallengeWinnerUncheckedUpdateWithoutChallengeInput>
  }

  export type ChallengeWinnerUpdateManyWithWhereWithoutChallengeInput = {
    where: ChallengeWinnerScalarWhereInput
    data: XOR<ChallengeWinnerUpdateManyMutationInput, ChallengeWinnerUncheckedUpdateManyWithoutChallengeInput>
  }

  export type ChallengeWinnerScalarWhereInput = {
    AND?: ChallengeWinnerScalarWhereInput | ChallengeWinnerScalarWhereInput[]
    OR?: ChallengeWinnerScalarWhereInput[]
    NOT?: ChallengeWinnerScalarWhereInput | ChallengeWinnerScalarWhereInput[]
    id?: StringFilter<"ChallengeWinner"> | string
    challengeId?: StringFilter<"ChallengeWinner"> | string
    userId?: IntFilter<"ChallengeWinner"> | number
    handle?: StringFilter<"ChallengeWinner"> | string
    placement?: IntFilter<"ChallengeWinner"> | number
    type?: EnumPrizeSetTypeEnumFilter<"ChallengeWinner"> | $Enums.PrizeSetTypeEnum
    createdAt?: DateTimeFilter<"ChallengeWinner"> | Date | string
    createdBy?: StringFilter<"ChallengeWinner"> | string
    updatedAt?: DateTimeFilter<"ChallengeWinner"> | Date | string
    updatedBy?: StringFilter<"ChallengeWinner"> | string
  }

  export type AttachmentUpsertWithWhereUniqueWithoutChallengeInput = {
    where: AttachmentWhereUniqueInput
    update: XOR<AttachmentUpdateWithoutChallengeInput, AttachmentUncheckedUpdateWithoutChallengeInput>
    create: XOR<AttachmentCreateWithoutChallengeInput, AttachmentUncheckedCreateWithoutChallengeInput>
  }

  export type AttachmentUpdateWithWhereUniqueWithoutChallengeInput = {
    where: AttachmentWhereUniqueInput
    data: XOR<AttachmentUpdateWithoutChallengeInput, AttachmentUncheckedUpdateWithoutChallengeInput>
  }

  export type AttachmentUpdateManyWithWhereWithoutChallengeInput = {
    where: AttachmentScalarWhereInput
    data: XOR<AttachmentUpdateManyMutationInput, AttachmentUncheckedUpdateManyWithoutChallengeInput>
  }

  export type AttachmentScalarWhereInput = {
    AND?: AttachmentScalarWhereInput | AttachmentScalarWhereInput[]
    OR?: AttachmentScalarWhereInput[]
    NOT?: AttachmentScalarWhereInput | AttachmentScalarWhereInput[]
    id?: StringFilter<"Attachment"> | string
    challengeId?: StringFilter<"Attachment"> | string
    name?: StringFilter<"Attachment"> | string
    fileSize?: IntFilter<"Attachment"> | number
    url?: StringFilter<"Attachment"> | string
    description?: StringNullableFilter<"Attachment"> | string | null
    createdAt?: DateTimeFilter<"Attachment"> | Date | string
    createdBy?: StringFilter<"Attachment"> | string
    updatedAt?: DateTimeFilter<"Attachment"> | Date | string
    updatedBy?: StringFilter<"Attachment"> | string
  }

  export type ChallengeTermUpsertWithWhereUniqueWithoutChallengeInput = {
    where: ChallengeTermWhereUniqueInput
    update: XOR<ChallengeTermUpdateWithoutChallengeInput, ChallengeTermUncheckedUpdateWithoutChallengeInput>
    create: XOR<ChallengeTermCreateWithoutChallengeInput, ChallengeTermUncheckedCreateWithoutChallengeInput>
  }

  export type ChallengeTermUpdateWithWhereUniqueWithoutChallengeInput = {
    where: ChallengeTermWhereUniqueInput
    data: XOR<ChallengeTermUpdateWithoutChallengeInput, ChallengeTermUncheckedUpdateWithoutChallengeInput>
  }

  export type ChallengeTermUpdateManyWithWhereWithoutChallengeInput = {
    where: ChallengeTermScalarWhereInput
    data: XOR<ChallengeTermUpdateManyMutationInput, ChallengeTermUncheckedUpdateManyWithoutChallengeInput>
  }

  export type ChallengeTermScalarWhereInput = {
    AND?: ChallengeTermScalarWhereInput | ChallengeTermScalarWhereInput[]
    OR?: ChallengeTermScalarWhereInput[]
    NOT?: ChallengeTermScalarWhereInput | ChallengeTermScalarWhereInput[]
    id?: StringFilter<"ChallengeTerm"> | string
    challengeId?: StringFilter<"ChallengeTerm"> | string
    termId?: StringFilter<"ChallengeTerm"> | string
    roleId?: StringFilter<"ChallengeTerm"> | string
    createdAt?: DateTimeFilter<"ChallengeTerm"> | Date | string
    createdBy?: StringFilter<"ChallengeTerm"> | string
    updatedAt?: DateTimeFilter<"ChallengeTerm"> | Date | string
    updatedBy?: StringFilter<"ChallengeTerm"> | string
  }

  export type ChallengeSkillUpsertWithWhereUniqueWithoutChallengeInput = {
    where: ChallengeSkillWhereUniqueInput
    update: XOR<ChallengeSkillUpdateWithoutChallengeInput, ChallengeSkillUncheckedUpdateWithoutChallengeInput>
    create: XOR<ChallengeSkillCreateWithoutChallengeInput, ChallengeSkillUncheckedCreateWithoutChallengeInput>
  }

  export type ChallengeSkillUpdateWithWhereUniqueWithoutChallengeInput = {
    where: ChallengeSkillWhereUniqueInput
    data: XOR<ChallengeSkillUpdateWithoutChallengeInput, ChallengeSkillUncheckedUpdateWithoutChallengeInput>
  }

  export type ChallengeSkillUpdateManyWithWhereWithoutChallengeInput = {
    where: ChallengeSkillScalarWhereInput
    data: XOR<ChallengeSkillUpdateManyMutationInput, ChallengeSkillUncheckedUpdateManyWithoutChallengeInput>
  }

  export type ChallengeSkillScalarWhereInput = {
    AND?: ChallengeSkillScalarWhereInput | ChallengeSkillScalarWhereInput[]
    OR?: ChallengeSkillScalarWhereInput[]
    NOT?: ChallengeSkillScalarWhereInput | ChallengeSkillScalarWhereInput[]
    id?: StringFilter<"ChallengeSkill"> | string
    challengeId?: StringFilter<"ChallengeSkill"> | string
    skillId?: StringFilter<"ChallengeSkill"> | string
    createdAt?: DateTimeFilter<"ChallengeSkill"> | Date | string
    createdBy?: StringFilter<"ChallengeSkill"> | string
    updatedAt?: DateTimeFilter<"ChallengeSkill"> | Date | string
    updatedBy?: StringFilter<"ChallengeSkill"> | string
  }

  export type AuditLogUpsertWithWhereUniqueWithoutChallengeInput = {
    where: AuditLogWhereUniqueInput
    update: XOR<AuditLogUpdateWithoutChallengeInput, AuditLogUncheckedUpdateWithoutChallengeInput>
    create: XOR<AuditLogCreateWithoutChallengeInput, AuditLogUncheckedCreateWithoutChallengeInput>
  }

  export type AuditLogUpdateWithWhereUniqueWithoutChallengeInput = {
    where: AuditLogWhereUniqueInput
    data: XOR<AuditLogUpdateWithoutChallengeInput, AuditLogUncheckedUpdateWithoutChallengeInput>
  }

  export type AuditLogUpdateManyWithWhereWithoutChallengeInput = {
    where: AuditLogScalarWhereInput
    data: XOR<AuditLogUpdateManyMutationInput, AuditLogUncheckedUpdateManyWithoutChallengeInput>
  }

  export type AuditLogScalarWhereInput = {
    AND?: AuditLogScalarWhereInput | AuditLogScalarWhereInput[]
    OR?: AuditLogScalarWhereInput[]
    NOT?: AuditLogScalarWhereInput | AuditLogScalarWhereInput[]
    id?: StringFilter<"AuditLog"> | string
    challengeId?: StringNullableFilter<"AuditLog"> | string | null
    fieldName?: StringFilter<"AuditLog"> | string
    oldValue?: StringNullableFilter<"AuditLog"> | string | null
    newValue?: StringNullableFilter<"AuditLog"> | string | null
    createdAt?: DateTimeFilter<"AuditLog"> | Date | string
    createdBy?: StringFilter<"AuditLog"> | string
    memberId?: StringNullableFilter<"AuditLog"> | string | null
  }

  export type MemberChallengeAccessUpdateWithWhereUniqueWithoutChallengeInput = {
    where: MemberChallengeAccessWhereUniqueInput
    data: XOR<MemberChallengeAccessUpdateWithoutChallengeInput, MemberChallengeAccessUncheckedUpdateWithoutChallengeInput>
  }

  export type MemberChallengeAccessUpdateManyWithWhereWithoutChallengeInput = {
    where: MemberChallengeAccessScalarWhereInput
    data: XOR<MemberChallengeAccessUpdateManyMutationInput, MemberChallengeAccessUncheckedUpdateManyWithoutChallengeInput>
  }

  export type MemberChallengeAccessScalarWhereInput = {
    AND?: MemberChallengeAccessScalarWhereInput | MemberChallengeAccessScalarWhereInput[]
    OR?: MemberChallengeAccessScalarWhereInput[]
    NOT?: MemberChallengeAccessScalarWhereInput | MemberChallengeAccessScalarWhereInput[]
    challengeId?: StringFilter<"MemberChallengeAccess"> | string
    memberId?: StringFilter<"MemberChallengeAccess"> | string
  }

  export type ChallengeTypeUpsertWithoutChallengesInput = {
    update: XOR<ChallengeTypeUpdateWithoutChallengesInput, ChallengeTypeUncheckedUpdateWithoutChallengesInput>
    create: XOR<ChallengeTypeCreateWithoutChallengesInput, ChallengeTypeUncheckedCreateWithoutChallengesInput>
    where?: ChallengeTypeWhereInput
  }

  export type ChallengeTypeUpdateToOneWithWhereWithoutChallengesInput = {
    where?: ChallengeTypeWhereInput
    data: XOR<ChallengeTypeUpdateWithoutChallengesInput, ChallengeTypeUncheckedUpdateWithoutChallengesInput>
  }

  export type ChallengeTypeUpdateWithoutChallengesInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    isTask?: BoolFieldUpdateOperationsInput | boolean
    abbreviation?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdBy?: StringFieldUpdateOperationsInput | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedBy?: StringFieldUpdateOperationsInput | string
    timelineTemplates?: ChallengeTimelineTemplateUpdateManyWithoutTypeNestedInput
    defaultReviewers?: DefaultChallengeReviewerUpdateManyWithoutChallengeTypeNestedInput
  }

  export type ChallengeTypeUncheckedUpdateWithoutChallengesInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    isTask?: BoolFieldUpdateOperationsInput | boolean
    abbreviation?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdBy?: StringFieldUpdateOperationsInput | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedBy?: StringFieldUpdateOperationsInput | string
    timelineTemplates?: ChallengeTimelineTemplateUncheckedUpdateManyWithoutTypeNestedInput
    defaultReviewers?: DefaultChallengeReviewerUncheckedUpdateManyWithoutChallengeTypeNestedInput
  }

  export type ChallengeTrackUpsertWithoutChallengesInput = {
    update: XOR<ChallengeTrackUpdateWithoutChallengesInput, ChallengeTrackUncheckedUpdateWithoutChallengesInput>
    create: XOR<ChallengeTrackCreateWithoutChallengesInput, ChallengeTrackUncheckedCreateWithoutChallengesInput>
    where?: ChallengeTrackWhereInput
  }

  export type ChallengeTrackUpdateToOneWithWhereWithoutChallengesInput = {
    where?: ChallengeTrackWhereInput
    data: XOR<ChallengeTrackUpdateWithoutChallengesInput, ChallengeTrackUncheckedUpdateWithoutChallengesInput>
  }

  export type ChallengeTrackUpdateWithoutChallengesInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    abbreviation?: StringFieldUpdateOperationsInput | string
    legacyId?: NullableIntFieldUpdateOperationsInput | number | null
    track?: NullableEnumChallengeTrackEnumFieldUpdateOperationsInput | $Enums.ChallengeTrackEnum | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdBy?: StringFieldUpdateOperationsInput | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedBy?: StringFieldUpdateOperationsInput | string
    timelineTemplates?: ChallengeTimelineTemplateUpdateManyWithoutTrackNestedInput
    defaultReviewers?: DefaultChallengeReviewerUpdateManyWithoutChallengeTrackNestedInput
  }

  export type ChallengeTrackUncheckedUpdateWithoutChallengesInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    abbreviation?: StringFieldUpdateOperationsInput | string
    legacyId?: NullableIntFieldUpdateOperationsInput | number | null
    track?: NullableEnumChallengeTrackEnumFieldUpdateOperationsInput | $Enums.ChallengeTrackEnum | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdBy?: StringFieldUpdateOperationsInput | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedBy?: StringFieldUpdateOperationsInput | string
    timelineTemplates?: ChallengeTimelineTemplateUncheckedUpdateManyWithoutTrackNestedInput
    defaultReviewers?: DefaultChallengeReviewerUncheckedUpdateManyWithoutChallengeTrackNestedInput
  }

  export type TimelineTemplateUpsertWithoutChallengesInput = {
    update: XOR<TimelineTemplateUpdateWithoutChallengesInput, TimelineTemplateUncheckedUpdateWithoutChallengesInput>
    create: XOR<TimelineTemplateCreateWithoutChallengesInput, TimelineTemplateUncheckedCreateWithoutChallengesInput>
    where?: TimelineTemplateWhereInput
  }

  export type TimelineTemplateUpdateToOneWithWhereWithoutChallengesInput = {
    where?: TimelineTemplateWhereInput
    data: XOR<TimelineTemplateUpdateWithoutChallengesInput, TimelineTemplateUncheckedUpdateWithoutChallengesInput>
  }

  export type TimelineTemplateUpdateWithoutChallengesInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdBy?: StringFieldUpdateOperationsInput | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedBy?: StringFieldUpdateOperationsInput | string
    phases?: TimelineTemplatePhaseUpdateManyWithoutTimelineTemplateNestedInput
    challengeTimelineTemplates?: ChallengeTimelineTemplateUpdateManyWithoutTimelineTemplateNestedInput
    DefaultChallengeReviewer?: DefaultChallengeReviewerUpdateManyWithoutTimelineTemplateNestedInput
  }

  export type TimelineTemplateUncheckedUpdateWithoutChallengesInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdBy?: StringFieldUpdateOperationsInput | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedBy?: StringFieldUpdateOperationsInput | string
    phases?: TimelineTemplatePhaseUncheckedUpdateManyWithoutTimelineTemplateNestedInput
    challengeTimelineTemplates?: ChallengeTimelineTemplateUncheckedUpdateManyWithoutTimelineTemplateNestedInput
    DefaultChallengeReviewer?: DefaultChallengeReviewerUncheckedUpdateManyWithoutTimelineTemplateNestedInput
  }

  export type ChallengeCreateWithoutTypeInput = {
    id?: string
    name: string
    description?: string | null
    privateDescription?: string | null
    challengeSource?: string | null
    descriptionFormat?: string | null
    projectId?: number | null
    overviewTotalPrizes?: number | null
    numOfRegistrants?: number
    numOfSubmissions?: number
    numOfCheckpointSubmissions?: number
    currentPhaseNames?: ChallengeCreatecurrentPhaseNamesInput | string[]
    wiproAllowed?: boolean
    tags?: ChallengeCreatetagsInput | string[]
    groups?: ChallengeCreategroupsInput | string[]
    taskIsTask?: boolean
    taskIsAssigned?: boolean
    taskMemberId?: string | null
    submissionStartDate?: Date | string | null
    submissionEndDate?: Date | string | null
    registrationStartDate?: Date | string | null
    registrationEndDate?: Date | string | null
    startDate?: Date | string | null
    endDate?: Date | string | null
    legacyId?: number | null
    status?: $Enums.ChallengeStatusEnum
    createdAt?: Date | string
    createdBy: string
    updatedAt?: Date | string
    updatedBy: string
    billingRecord?: ChallengeBillingCreateNestedOneWithoutChallengeInput
    legacyRecord?: ChallengeLegacyCreateNestedOneWithoutChallengeInput
    constraintRecord?: ChallengeConstraintCreateNestedOneWithoutChallengeInput
    events?: ChallengeEventCreateNestedManyWithoutChallengeInput
    discussions?: ChallengeDiscussionCreateNestedManyWithoutChallengeInput
    metadata?: ChallengeMetadataCreateNestedManyWithoutChallengeInput
    phases?: ChallengePhaseCreateNestedManyWithoutChallengeInput
    prizeSets?: ChallengePrizeSetCreateNestedManyWithoutChallengeInput
    reviewers?: ChallengeReviewerCreateNestedManyWithoutChallengeInput
    winners?: ChallengeWinnerCreateNestedManyWithoutChallengeInput
    attachments?: AttachmentCreateNestedManyWithoutChallengeInput
    terms?: ChallengeTermCreateNestedManyWithoutChallengeInput
    skills?: ChallengeSkillCreateNestedManyWithoutChallengeInput
    auditLogs?: AuditLogCreateNestedManyWithoutChallengeInput
    memberAccesses?: MemberChallengeAccessCreateNestedManyWithoutChallengeInput
    track: ChallengeTrackCreateNestedOneWithoutChallengesInput
    timelineTemplate?: TimelineTemplateCreateNestedOneWithoutChallengesInput
  }

  export type ChallengeUncheckedCreateWithoutTypeInput = {
    id?: string
    name: string
    description?: string | null
    privateDescription?: string | null
    challengeSource?: string | null
    descriptionFormat?: string | null
    projectId?: number | null
    trackId: string
    timelineTemplateId?: string | null
    overviewTotalPrizes?: number | null
    numOfRegistrants?: number
    numOfSubmissions?: number
    numOfCheckpointSubmissions?: number
    currentPhaseNames?: ChallengeCreatecurrentPhaseNamesInput | string[]
    wiproAllowed?: boolean
    tags?: ChallengeCreatetagsInput | string[]
    groups?: ChallengeCreategroupsInput | string[]
    taskIsTask?: boolean
    taskIsAssigned?: boolean
    taskMemberId?: string | null
    submissionStartDate?: Date | string | null
    submissionEndDate?: Date | string | null
    registrationStartDate?: Date | string | null
    registrationEndDate?: Date | string | null
    startDate?: Date | string | null
    endDate?: Date | string | null
    legacyId?: number | null
    status?: $Enums.ChallengeStatusEnum
    createdAt?: Date | string
    createdBy: string
    updatedAt?: Date | string
    updatedBy: string
    billingRecord?: ChallengeBillingUncheckedCreateNestedOneWithoutChallengeInput
    legacyRecord?: ChallengeLegacyUncheckedCreateNestedOneWithoutChallengeInput
    constraintRecord?: ChallengeConstraintUncheckedCreateNestedOneWithoutChallengeInput
    events?: ChallengeEventUncheckedCreateNestedManyWithoutChallengeInput
    discussions?: ChallengeDiscussionUncheckedCreateNestedManyWithoutChallengeInput
    metadata?: ChallengeMetadataUncheckedCreateNestedManyWithoutChallengeInput
    phases?: ChallengePhaseUncheckedCreateNestedManyWithoutChallengeInput
    prizeSets?: ChallengePrizeSetUncheckedCreateNestedManyWithoutChallengeInput
    reviewers?: ChallengeReviewerUncheckedCreateNestedManyWithoutChallengeInput
    winners?: ChallengeWinnerUncheckedCreateNestedManyWithoutChallengeInput
    attachments?: AttachmentUncheckedCreateNestedManyWithoutChallengeInput
    terms?: ChallengeTermUncheckedCreateNestedManyWithoutChallengeInput
    skills?: ChallengeSkillUncheckedCreateNestedManyWithoutChallengeInput
    auditLogs?: AuditLogUncheckedCreateNestedManyWithoutChallengeInput
    memberAccesses?: MemberChallengeAccessUncheckedCreateNestedManyWithoutChallengeInput
  }

  export type ChallengeCreateOrConnectWithoutTypeInput = {
    where: ChallengeWhereUniqueInput
    create: XOR<ChallengeCreateWithoutTypeInput, ChallengeUncheckedCreateWithoutTypeInput>
  }

  export type ChallengeCreateManyTypeInputEnvelope = {
    data: ChallengeCreateManyTypeInput | ChallengeCreateManyTypeInput[]
    skipDuplicates?: boolean
  }

  export type ChallengeTimelineTemplateCreateWithoutTypeInput = {
    id?: string
    isDefault?: boolean
    createdAt?: Date | string
    createdBy: string
    updatedAt?: Date | string
    updatedBy: string
    timelineTemplate: TimelineTemplateCreateNestedOneWithoutChallengeTimelineTemplatesInput
    track: ChallengeTrackCreateNestedOneWithoutTimelineTemplatesInput
  }

  export type ChallengeTimelineTemplateUncheckedCreateWithoutTypeInput = {
    id?: string
    trackId: string
    timelineTemplateId: string
    isDefault?: boolean
    createdAt?: Date | string
    createdBy: string
    updatedAt?: Date | string
    updatedBy: string
  }

  export type ChallengeTimelineTemplateCreateOrConnectWithoutTypeInput = {
    where: ChallengeTimelineTemplateWhereUniqueInput
    create: XOR<ChallengeTimelineTemplateCreateWithoutTypeInput, ChallengeTimelineTemplateUncheckedCreateWithoutTypeInput>
  }

  export type ChallengeTimelineTemplateCreateManyTypeInputEnvelope = {
    data: ChallengeTimelineTemplateCreateManyTypeInput | ChallengeTimelineTemplateCreateManyTypeInput[]
    skipDuplicates?: boolean
  }

  export type DefaultChallengeReviewerCreateWithoutChallengeTypeInput = {
    id?: string
    scorecardId?: string | null
    isMemberReview: boolean
    memberReviewerCount?: number | null
    phaseName: string
    fixedAmount?: number | null
    baseCoefficient?: number | null
    incrementalCoefficient?: number | null
    opportunityType?: $Enums.ReviewOpportunityTypeEnum | null
    aiWorkflowId?: string | null
    shouldOpenOpportunity?: boolean
    createdAt?: Date | string
    createdBy: string
    updatedAt?: Date | string
    updatedBy: string
    challengeTrack: ChallengeTrackCreateNestedOneWithoutDefaultReviewersInput
    timelineTemplate?: TimelineTemplateCreateNestedOneWithoutDefaultChallengeReviewerInput
    phase?: PhaseCreateNestedOneWithoutDefaultChallengeReviewerInput
  }

  export type DefaultChallengeReviewerUncheckedCreateWithoutChallengeTypeInput = {
    id?: string
    trackId: string
    timelineTemplateId?: string | null
    scorecardId?: string | null
    isMemberReview: boolean
    memberReviewerCount?: number | null
    phaseName: string
    phaseId?: string | null
    fixedAmount?: number | null
    baseCoefficient?: number | null
    incrementalCoefficient?: number | null
    opportunityType?: $Enums.ReviewOpportunityTypeEnum | null
    aiWorkflowId?: string | null
    shouldOpenOpportunity?: boolean
    createdAt?: Date | string
    createdBy: string
    updatedAt?: Date | string
    updatedBy: string
  }

  export type DefaultChallengeReviewerCreateOrConnectWithoutChallengeTypeInput = {
    where: DefaultChallengeReviewerWhereUniqueInput
    create: XOR<DefaultChallengeReviewerCreateWithoutChallengeTypeInput, DefaultChallengeReviewerUncheckedCreateWithoutChallengeTypeInput>
  }

  export type DefaultChallengeReviewerCreateManyChallengeTypeInputEnvelope = {
    data: DefaultChallengeReviewerCreateManyChallengeTypeInput | DefaultChallengeReviewerCreateManyChallengeTypeInput[]
    skipDuplicates?: boolean
  }

  export type ChallengeUpsertWithWhereUniqueWithoutTypeInput = {
    where: ChallengeWhereUniqueInput
    update: XOR<ChallengeUpdateWithoutTypeInput, ChallengeUncheckedUpdateWithoutTypeInput>
    create: XOR<ChallengeCreateWithoutTypeInput, ChallengeUncheckedCreateWithoutTypeInput>
  }

  export type ChallengeUpdateWithWhereUniqueWithoutTypeInput = {
    where: ChallengeWhereUniqueInput
    data: XOR<ChallengeUpdateWithoutTypeInput, ChallengeUncheckedUpdateWithoutTypeInput>
  }

  export type ChallengeUpdateManyWithWhereWithoutTypeInput = {
    where: ChallengeScalarWhereInput
    data: XOR<ChallengeUpdateManyMutationInput, ChallengeUncheckedUpdateManyWithoutTypeInput>
  }

  export type ChallengeScalarWhereInput = {
    AND?: ChallengeScalarWhereInput | ChallengeScalarWhereInput[]
    OR?: ChallengeScalarWhereInput[]
    NOT?: ChallengeScalarWhereInput | ChallengeScalarWhereInput[]
    id?: StringFilter<"Challenge"> | string
    name?: StringFilter<"Challenge"> | string
    description?: StringNullableFilter<"Challenge"> | string | null
    privateDescription?: StringNullableFilter<"Challenge"> | string | null
    challengeSource?: StringNullableFilter<"Challenge"> | string | null
    descriptionFormat?: StringNullableFilter<"Challenge"> | string | null
    projectId?: IntNullableFilter<"Challenge"> | number | null
    typeId?: StringFilter<"Challenge"> | string
    trackId?: StringFilter<"Challenge"> | string
    timelineTemplateId?: StringNullableFilter<"Challenge"> | string | null
    overviewTotalPrizes?: FloatNullableFilter<"Challenge"> | number | null
    numOfRegistrants?: IntFilter<"Challenge"> | number
    numOfSubmissions?: IntFilter<"Challenge"> | number
    numOfCheckpointSubmissions?: IntFilter<"Challenge"> | number
    currentPhaseNames?: StringNullableListFilter<"Challenge">
    wiproAllowed?: BoolFilter<"Challenge"> | boolean
    tags?: StringNullableListFilter<"Challenge">
    groups?: StringNullableListFilter<"Challenge">
    taskIsTask?: BoolFilter<"Challenge"> | boolean
    taskIsAssigned?: BoolFilter<"Challenge"> | boolean
    taskMemberId?: StringNullableFilter<"Challenge"> | string | null
    submissionStartDate?: DateTimeNullableFilter<"Challenge"> | Date | string | null
    submissionEndDate?: DateTimeNullableFilter<"Challenge"> | Date | string | null
    registrationStartDate?: DateTimeNullableFilter<"Challenge"> | Date | string | null
    registrationEndDate?: DateTimeNullableFilter<"Challenge"> | Date | string | null
    startDate?: DateTimeNullableFilter<"Challenge"> | Date | string | null
    endDate?: DateTimeNullableFilter<"Challenge"> | Date | string | null
    legacyId?: IntNullableFilter<"Challenge"> | number | null
    status?: EnumChallengeStatusEnumFilter<"Challenge"> | $Enums.ChallengeStatusEnum
    createdAt?: DateTimeFilter<"Challenge"> | Date | string
    createdBy?: StringFilter<"Challenge"> | string
    updatedAt?: DateTimeFilter<"Challenge"> | Date | string
    updatedBy?: StringFilter<"Challenge"> | string
  }

  export type ChallengeTimelineTemplateUpsertWithWhereUniqueWithoutTypeInput = {
    where: ChallengeTimelineTemplateWhereUniqueInput
    update: XOR<ChallengeTimelineTemplateUpdateWithoutTypeInput, ChallengeTimelineTemplateUncheckedUpdateWithoutTypeInput>
    create: XOR<ChallengeTimelineTemplateCreateWithoutTypeInput, ChallengeTimelineTemplateUncheckedCreateWithoutTypeInput>
  }

  export type ChallengeTimelineTemplateUpdateWithWhereUniqueWithoutTypeInput = {
    where: ChallengeTimelineTemplateWhereUniqueInput
    data: XOR<ChallengeTimelineTemplateUpdateWithoutTypeInput, ChallengeTimelineTemplateUncheckedUpdateWithoutTypeInput>
  }

  export type ChallengeTimelineTemplateUpdateManyWithWhereWithoutTypeInput = {
    where: ChallengeTimelineTemplateScalarWhereInput
    data: XOR<ChallengeTimelineTemplateUpdateManyMutationInput, ChallengeTimelineTemplateUncheckedUpdateManyWithoutTypeInput>
  }

  export type ChallengeTimelineTemplateScalarWhereInput = {
    AND?: ChallengeTimelineTemplateScalarWhereInput | ChallengeTimelineTemplateScalarWhereInput[]
    OR?: ChallengeTimelineTemplateScalarWhereInput[]
    NOT?: ChallengeTimelineTemplateScalarWhereInput | ChallengeTimelineTemplateScalarWhereInput[]
    id?: StringFilter<"ChallengeTimelineTemplate"> | string
    typeId?: StringFilter<"ChallengeTimelineTemplate"> | string
    trackId?: StringFilter<"ChallengeTimelineTemplate"> | string
    timelineTemplateId?: StringFilter<"ChallengeTimelineTemplate"> | string
    isDefault?: BoolFilter<"ChallengeTimelineTemplate"> | boolean
    createdAt?: DateTimeFilter<"ChallengeTimelineTemplate"> | Date | string
    createdBy?: StringFilter<"ChallengeTimelineTemplate"> | string
    updatedAt?: DateTimeFilter<"ChallengeTimelineTemplate"> | Date | string
    updatedBy?: StringFilter<"ChallengeTimelineTemplate"> | string
  }

  export type DefaultChallengeReviewerUpsertWithWhereUniqueWithoutChallengeTypeInput = {
    where: DefaultChallengeReviewerWhereUniqueInput
    update: XOR<DefaultChallengeReviewerUpdateWithoutChallengeTypeInput, DefaultChallengeReviewerUncheckedUpdateWithoutChallengeTypeInput>
    create: XOR<DefaultChallengeReviewerCreateWithoutChallengeTypeInput, DefaultChallengeReviewerUncheckedCreateWithoutChallengeTypeInput>
  }

  export type DefaultChallengeReviewerUpdateWithWhereUniqueWithoutChallengeTypeInput = {
    where: DefaultChallengeReviewerWhereUniqueInput
    data: XOR<DefaultChallengeReviewerUpdateWithoutChallengeTypeInput, DefaultChallengeReviewerUncheckedUpdateWithoutChallengeTypeInput>
  }

  export type DefaultChallengeReviewerUpdateManyWithWhereWithoutChallengeTypeInput = {
    where: DefaultChallengeReviewerScalarWhereInput
    data: XOR<DefaultChallengeReviewerUpdateManyMutationInput, DefaultChallengeReviewerUncheckedUpdateManyWithoutChallengeTypeInput>
  }

  export type DefaultChallengeReviewerScalarWhereInput = {
    AND?: DefaultChallengeReviewerScalarWhereInput | DefaultChallengeReviewerScalarWhereInput[]
    OR?: DefaultChallengeReviewerScalarWhereInput[]
    NOT?: DefaultChallengeReviewerScalarWhereInput | DefaultChallengeReviewerScalarWhereInput[]
    id?: StringFilter<"DefaultChallengeReviewer"> | string
    typeId?: StringFilter<"DefaultChallengeReviewer"> | string
    trackId?: StringFilter<"DefaultChallengeReviewer"> | string
    timelineTemplateId?: StringNullableFilter<"DefaultChallengeReviewer"> | string | null
    scorecardId?: StringNullableFilter<"DefaultChallengeReviewer"> | string | null
    isMemberReview?: BoolFilter<"DefaultChallengeReviewer"> | boolean
    memberReviewerCount?: IntNullableFilter<"DefaultChallengeReviewer"> | number | null
    phaseName?: StringFilter<"DefaultChallengeReviewer"> | string
    phaseId?: StringNullableFilter<"DefaultChallengeReviewer"> | string | null
    fixedAmount?: FloatNullableFilter<"DefaultChallengeReviewer"> | number | null
    baseCoefficient?: FloatNullableFilter<"DefaultChallengeReviewer"> | number | null
    incrementalCoefficient?: FloatNullableFilter<"DefaultChallengeReviewer"> | number | null
    opportunityType?: EnumReviewOpportunityTypeEnumNullableFilter<"DefaultChallengeReviewer"> | $Enums.ReviewOpportunityTypeEnum | null
    aiWorkflowId?: StringNullableFilter<"DefaultChallengeReviewer"> | string | null
    shouldOpenOpportunity?: BoolFilter<"DefaultChallengeReviewer"> | boolean
    createdAt?: DateTimeFilter<"DefaultChallengeReviewer"> | Date | string
    createdBy?: StringFilter<"DefaultChallengeReviewer"> | string
    updatedAt?: DateTimeFilter<"DefaultChallengeReviewer"> | Date | string
    updatedBy?: StringFilter<"DefaultChallengeReviewer"> | string
  }

  export type ChallengeCreateWithoutTrackInput = {
    id?: string
    name: string
    description?: string | null
    privateDescription?: string | null
    challengeSource?: string | null
    descriptionFormat?: string | null
    projectId?: number | null
    overviewTotalPrizes?: number | null
    numOfRegistrants?: number
    numOfSubmissions?: number
    numOfCheckpointSubmissions?: number
    currentPhaseNames?: ChallengeCreatecurrentPhaseNamesInput | string[]
    wiproAllowed?: boolean
    tags?: ChallengeCreatetagsInput | string[]
    groups?: ChallengeCreategroupsInput | string[]
    taskIsTask?: boolean
    taskIsAssigned?: boolean
    taskMemberId?: string | null
    submissionStartDate?: Date | string | null
    submissionEndDate?: Date | string | null
    registrationStartDate?: Date | string | null
    registrationEndDate?: Date | string | null
    startDate?: Date | string | null
    endDate?: Date | string | null
    legacyId?: number | null
    status?: $Enums.ChallengeStatusEnum
    createdAt?: Date | string
    createdBy: string
    updatedAt?: Date | string
    updatedBy: string
    billingRecord?: ChallengeBillingCreateNestedOneWithoutChallengeInput
    legacyRecord?: ChallengeLegacyCreateNestedOneWithoutChallengeInput
    constraintRecord?: ChallengeConstraintCreateNestedOneWithoutChallengeInput
    events?: ChallengeEventCreateNestedManyWithoutChallengeInput
    discussions?: ChallengeDiscussionCreateNestedManyWithoutChallengeInput
    metadata?: ChallengeMetadataCreateNestedManyWithoutChallengeInput
    phases?: ChallengePhaseCreateNestedManyWithoutChallengeInput
    prizeSets?: ChallengePrizeSetCreateNestedManyWithoutChallengeInput
    reviewers?: ChallengeReviewerCreateNestedManyWithoutChallengeInput
    winners?: ChallengeWinnerCreateNestedManyWithoutChallengeInput
    attachments?: AttachmentCreateNestedManyWithoutChallengeInput
    terms?: ChallengeTermCreateNestedManyWithoutChallengeInput
    skills?: ChallengeSkillCreateNestedManyWithoutChallengeInput
    auditLogs?: AuditLogCreateNestedManyWithoutChallengeInput
    memberAccesses?: MemberChallengeAccessCreateNestedManyWithoutChallengeInput
    type: ChallengeTypeCreateNestedOneWithoutChallengesInput
    timelineTemplate?: TimelineTemplateCreateNestedOneWithoutChallengesInput
  }

  export type ChallengeUncheckedCreateWithoutTrackInput = {
    id?: string
    name: string
    description?: string | null
    privateDescription?: string | null
    challengeSource?: string | null
    descriptionFormat?: string | null
    projectId?: number | null
    typeId: string
    timelineTemplateId?: string | null
    overviewTotalPrizes?: number | null
    numOfRegistrants?: number
    numOfSubmissions?: number
    numOfCheckpointSubmissions?: number
    currentPhaseNames?: ChallengeCreatecurrentPhaseNamesInput | string[]
    wiproAllowed?: boolean
    tags?: ChallengeCreatetagsInput | string[]
    groups?: ChallengeCreategroupsInput | string[]
    taskIsTask?: boolean
    taskIsAssigned?: boolean
    taskMemberId?: string | null
    submissionStartDate?: Date | string | null
    submissionEndDate?: Date | string | null
    registrationStartDate?: Date | string | null
    registrationEndDate?: Date | string | null
    startDate?: Date | string | null
    endDate?: Date | string | null
    legacyId?: number | null
    status?: $Enums.ChallengeStatusEnum
    createdAt?: Date | string
    createdBy: string
    updatedAt?: Date | string
    updatedBy: string
    billingRecord?: ChallengeBillingUncheckedCreateNestedOneWithoutChallengeInput
    legacyRecord?: ChallengeLegacyUncheckedCreateNestedOneWithoutChallengeInput
    constraintRecord?: ChallengeConstraintUncheckedCreateNestedOneWithoutChallengeInput
    events?: ChallengeEventUncheckedCreateNestedManyWithoutChallengeInput
    discussions?: ChallengeDiscussionUncheckedCreateNestedManyWithoutChallengeInput
    metadata?: ChallengeMetadataUncheckedCreateNestedManyWithoutChallengeInput
    phases?: ChallengePhaseUncheckedCreateNestedManyWithoutChallengeInput
    prizeSets?: ChallengePrizeSetUncheckedCreateNestedManyWithoutChallengeInput
    reviewers?: ChallengeReviewerUncheckedCreateNestedManyWithoutChallengeInput
    winners?: ChallengeWinnerUncheckedCreateNestedManyWithoutChallengeInput
    attachments?: AttachmentUncheckedCreateNestedManyWithoutChallengeInput
    terms?: ChallengeTermUncheckedCreateNestedManyWithoutChallengeInput
    skills?: ChallengeSkillUncheckedCreateNestedManyWithoutChallengeInput
    auditLogs?: AuditLogUncheckedCreateNestedManyWithoutChallengeInput
    memberAccesses?: MemberChallengeAccessUncheckedCreateNestedManyWithoutChallengeInput
  }

  export type ChallengeCreateOrConnectWithoutTrackInput = {
    where: ChallengeWhereUniqueInput
    create: XOR<ChallengeCreateWithoutTrackInput, ChallengeUncheckedCreateWithoutTrackInput>
  }

  export type ChallengeCreateManyTrackInputEnvelope = {
    data: ChallengeCreateManyTrackInput | ChallengeCreateManyTrackInput[]
    skipDuplicates?: boolean
  }

  export type ChallengeTimelineTemplateCreateWithoutTrackInput = {
    id?: string
    isDefault?: boolean
    createdAt?: Date | string
    createdBy: string
    updatedAt?: Date | string
    updatedBy: string
    timelineTemplate: TimelineTemplateCreateNestedOneWithoutChallengeTimelineTemplatesInput
    type: ChallengeTypeCreateNestedOneWithoutTimelineTemplatesInput
  }

  export type ChallengeTimelineTemplateUncheckedCreateWithoutTrackInput = {
    id?: string
    typeId: string
    timelineTemplateId: string
    isDefault?: boolean
    createdAt?: Date | string
    createdBy: string
    updatedAt?: Date | string
    updatedBy: string
  }

  export type ChallengeTimelineTemplateCreateOrConnectWithoutTrackInput = {
    where: ChallengeTimelineTemplateWhereUniqueInput
    create: XOR<ChallengeTimelineTemplateCreateWithoutTrackInput, ChallengeTimelineTemplateUncheckedCreateWithoutTrackInput>
  }

  export type ChallengeTimelineTemplateCreateManyTrackInputEnvelope = {
    data: ChallengeTimelineTemplateCreateManyTrackInput | ChallengeTimelineTemplateCreateManyTrackInput[]
    skipDuplicates?: boolean
  }

  export type DefaultChallengeReviewerCreateWithoutChallengeTrackInput = {
    id?: string
    scorecardId?: string | null
    isMemberReview: boolean
    memberReviewerCount?: number | null
    phaseName: string
    fixedAmount?: number | null
    baseCoefficient?: number | null
    incrementalCoefficient?: number | null
    opportunityType?: $Enums.ReviewOpportunityTypeEnum | null
    aiWorkflowId?: string | null
    shouldOpenOpportunity?: boolean
    createdAt?: Date | string
    createdBy: string
    updatedAt?: Date | string
    updatedBy: string
    challengeType: ChallengeTypeCreateNestedOneWithoutDefaultReviewersInput
    timelineTemplate?: TimelineTemplateCreateNestedOneWithoutDefaultChallengeReviewerInput
    phase?: PhaseCreateNestedOneWithoutDefaultChallengeReviewerInput
  }

  export type DefaultChallengeReviewerUncheckedCreateWithoutChallengeTrackInput = {
    id?: string
    typeId: string
    timelineTemplateId?: string | null
    scorecardId?: string | null
    isMemberReview: boolean
    memberReviewerCount?: number | null
    phaseName: string
    phaseId?: string | null
    fixedAmount?: number | null
    baseCoefficient?: number | null
    incrementalCoefficient?: number | null
    opportunityType?: $Enums.ReviewOpportunityTypeEnum | null
    aiWorkflowId?: string | null
    shouldOpenOpportunity?: boolean
    createdAt?: Date | string
    createdBy: string
    updatedAt?: Date | string
    updatedBy: string
  }

  export type DefaultChallengeReviewerCreateOrConnectWithoutChallengeTrackInput = {
    where: DefaultChallengeReviewerWhereUniqueInput
    create: XOR<DefaultChallengeReviewerCreateWithoutChallengeTrackInput, DefaultChallengeReviewerUncheckedCreateWithoutChallengeTrackInput>
  }

  export type DefaultChallengeReviewerCreateManyChallengeTrackInputEnvelope = {
    data: DefaultChallengeReviewerCreateManyChallengeTrackInput | DefaultChallengeReviewerCreateManyChallengeTrackInput[]
    skipDuplicates?: boolean
  }

  export type ChallengeUpsertWithWhereUniqueWithoutTrackInput = {
    where: ChallengeWhereUniqueInput
    update: XOR<ChallengeUpdateWithoutTrackInput, ChallengeUncheckedUpdateWithoutTrackInput>
    create: XOR<ChallengeCreateWithoutTrackInput, ChallengeUncheckedCreateWithoutTrackInput>
  }

  export type ChallengeUpdateWithWhereUniqueWithoutTrackInput = {
    where: ChallengeWhereUniqueInput
    data: XOR<ChallengeUpdateWithoutTrackInput, ChallengeUncheckedUpdateWithoutTrackInput>
  }

  export type ChallengeUpdateManyWithWhereWithoutTrackInput = {
    where: ChallengeScalarWhereInput
    data: XOR<ChallengeUpdateManyMutationInput, ChallengeUncheckedUpdateManyWithoutTrackInput>
  }

  export type ChallengeTimelineTemplateUpsertWithWhereUniqueWithoutTrackInput = {
    where: ChallengeTimelineTemplateWhereUniqueInput
    update: XOR<ChallengeTimelineTemplateUpdateWithoutTrackInput, ChallengeTimelineTemplateUncheckedUpdateWithoutTrackInput>
    create: XOR<ChallengeTimelineTemplateCreateWithoutTrackInput, ChallengeTimelineTemplateUncheckedCreateWithoutTrackInput>
  }

  export type ChallengeTimelineTemplateUpdateWithWhereUniqueWithoutTrackInput = {
    where: ChallengeTimelineTemplateWhereUniqueInput
    data: XOR<ChallengeTimelineTemplateUpdateWithoutTrackInput, ChallengeTimelineTemplateUncheckedUpdateWithoutTrackInput>
  }

  export type ChallengeTimelineTemplateUpdateManyWithWhereWithoutTrackInput = {
    where: ChallengeTimelineTemplateScalarWhereInput
    data: XOR<ChallengeTimelineTemplateUpdateManyMutationInput, ChallengeTimelineTemplateUncheckedUpdateManyWithoutTrackInput>
  }

  export type DefaultChallengeReviewerUpsertWithWhereUniqueWithoutChallengeTrackInput = {
    where: DefaultChallengeReviewerWhereUniqueInput
    update: XOR<DefaultChallengeReviewerUpdateWithoutChallengeTrackInput, DefaultChallengeReviewerUncheckedUpdateWithoutChallengeTrackInput>
    create: XOR<DefaultChallengeReviewerCreateWithoutChallengeTrackInput, DefaultChallengeReviewerUncheckedCreateWithoutChallengeTrackInput>
  }

  export type DefaultChallengeReviewerUpdateWithWhereUniqueWithoutChallengeTrackInput = {
    where: DefaultChallengeReviewerWhereUniqueInput
    data: XOR<DefaultChallengeReviewerUpdateWithoutChallengeTrackInput, DefaultChallengeReviewerUncheckedUpdateWithoutChallengeTrackInput>
  }

  export type DefaultChallengeReviewerUpdateManyWithWhereWithoutChallengeTrackInput = {
    where: DefaultChallengeReviewerScalarWhereInput
    data: XOR<DefaultChallengeReviewerUpdateManyMutationInput, DefaultChallengeReviewerUncheckedUpdateManyWithoutChallengeTrackInput>
  }

  export type TimelineTemplateCreateWithoutChallengeTimelineTemplatesInput = {
    id?: string
    name: string
    description?: string | null
    isActive?: boolean
    createdAt?: Date | string
    createdBy: string
    updatedAt?: Date | string
    updatedBy: string
    phases?: TimelineTemplatePhaseCreateNestedManyWithoutTimelineTemplateInput
    challenges?: ChallengeCreateNestedManyWithoutTimelineTemplateInput
    DefaultChallengeReviewer?: DefaultChallengeReviewerCreateNestedManyWithoutTimelineTemplateInput
  }

  export type TimelineTemplateUncheckedCreateWithoutChallengeTimelineTemplatesInput = {
    id?: string
    name: string
    description?: string | null
    isActive?: boolean
    createdAt?: Date | string
    createdBy: string
    updatedAt?: Date | string
    updatedBy: string
    phases?: TimelineTemplatePhaseUncheckedCreateNestedManyWithoutTimelineTemplateInput
    challenges?: ChallengeUncheckedCreateNestedManyWithoutTimelineTemplateInput
    DefaultChallengeReviewer?: DefaultChallengeReviewerUncheckedCreateNestedManyWithoutTimelineTemplateInput
  }

  export type TimelineTemplateCreateOrConnectWithoutChallengeTimelineTemplatesInput = {
    where: TimelineTemplateWhereUniqueInput
    create: XOR<TimelineTemplateCreateWithoutChallengeTimelineTemplatesInput, TimelineTemplateUncheckedCreateWithoutChallengeTimelineTemplatesInput>
  }

  export type ChallengeTrackCreateWithoutTimelineTemplatesInput = {
    id?: string
    name: string
    description?: string | null
    isActive: boolean
    abbreviation: string
    legacyId?: number | null
    track?: $Enums.ChallengeTrackEnum | null
    createdAt?: Date | string
    createdBy: string
    updatedAt?: Date | string
    updatedBy: string
    challenges?: ChallengeCreateNestedManyWithoutTrackInput
    defaultReviewers?: DefaultChallengeReviewerCreateNestedManyWithoutChallengeTrackInput
  }

  export type ChallengeTrackUncheckedCreateWithoutTimelineTemplatesInput = {
    id?: string
    name: string
    description?: string | null
    isActive: boolean
    abbreviation: string
    legacyId?: number | null
    track?: $Enums.ChallengeTrackEnum | null
    createdAt?: Date | string
    createdBy: string
    updatedAt?: Date | string
    updatedBy: string
    challenges?: ChallengeUncheckedCreateNestedManyWithoutTrackInput
    defaultReviewers?: DefaultChallengeReviewerUncheckedCreateNestedManyWithoutChallengeTrackInput
  }

  export type ChallengeTrackCreateOrConnectWithoutTimelineTemplatesInput = {
    where: ChallengeTrackWhereUniqueInput
    create: XOR<ChallengeTrackCreateWithoutTimelineTemplatesInput, ChallengeTrackUncheckedCreateWithoutTimelineTemplatesInput>
  }

  export type ChallengeTypeCreateWithoutTimelineTemplatesInput = {
    id?: string
    name: string
    description?: string | null
    isActive?: boolean
    isTask?: boolean
    abbreviation: string
    createdAt?: Date | string
    createdBy: string
    updatedAt?: Date | string
    updatedBy: string
    challenges?: ChallengeCreateNestedManyWithoutTypeInput
    defaultReviewers?: DefaultChallengeReviewerCreateNestedManyWithoutChallengeTypeInput
  }

  export type ChallengeTypeUncheckedCreateWithoutTimelineTemplatesInput = {
    id?: string
    name: string
    description?: string | null
    isActive?: boolean
    isTask?: boolean
    abbreviation: string
    createdAt?: Date | string
    createdBy: string
    updatedAt?: Date | string
    updatedBy: string
    challenges?: ChallengeUncheckedCreateNestedManyWithoutTypeInput
    defaultReviewers?: DefaultChallengeReviewerUncheckedCreateNestedManyWithoutChallengeTypeInput
  }

  export type ChallengeTypeCreateOrConnectWithoutTimelineTemplatesInput = {
    where: ChallengeTypeWhereUniqueInput
    create: XOR<ChallengeTypeCreateWithoutTimelineTemplatesInput, ChallengeTypeUncheckedCreateWithoutTimelineTemplatesInput>
  }

  export type TimelineTemplateUpsertWithoutChallengeTimelineTemplatesInput = {
    update: XOR<TimelineTemplateUpdateWithoutChallengeTimelineTemplatesInput, TimelineTemplateUncheckedUpdateWithoutChallengeTimelineTemplatesInput>
    create: XOR<TimelineTemplateCreateWithoutChallengeTimelineTemplatesInput, TimelineTemplateUncheckedCreateWithoutChallengeTimelineTemplatesInput>
    where?: TimelineTemplateWhereInput
  }

  export type TimelineTemplateUpdateToOneWithWhereWithoutChallengeTimelineTemplatesInput = {
    where?: TimelineTemplateWhereInput
    data: XOR<TimelineTemplateUpdateWithoutChallengeTimelineTemplatesInput, TimelineTemplateUncheckedUpdateWithoutChallengeTimelineTemplatesInput>
  }

  export type TimelineTemplateUpdateWithoutChallengeTimelineTemplatesInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdBy?: StringFieldUpdateOperationsInput | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedBy?: StringFieldUpdateOperationsInput | string
    phases?: TimelineTemplatePhaseUpdateManyWithoutTimelineTemplateNestedInput
    challenges?: ChallengeUpdateManyWithoutTimelineTemplateNestedInput
    DefaultChallengeReviewer?: DefaultChallengeReviewerUpdateManyWithoutTimelineTemplateNestedInput
  }

  export type TimelineTemplateUncheckedUpdateWithoutChallengeTimelineTemplatesInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdBy?: StringFieldUpdateOperationsInput | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedBy?: StringFieldUpdateOperationsInput | string
    phases?: TimelineTemplatePhaseUncheckedUpdateManyWithoutTimelineTemplateNestedInput
    challenges?: ChallengeUncheckedUpdateManyWithoutTimelineTemplateNestedInput
    DefaultChallengeReviewer?: DefaultChallengeReviewerUncheckedUpdateManyWithoutTimelineTemplateNestedInput
  }

  export type ChallengeTrackUpsertWithoutTimelineTemplatesInput = {
    update: XOR<ChallengeTrackUpdateWithoutTimelineTemplatesInput, ChallengeTrackUncheckedUpdateWithoutTimelineTemplatesInput>
    create: XOR<ChallengeTrackCreateWithoutTimelineTemplatesInput, ChallengeTrackUncheckedCreateWithoutTimelineTemplatesInput>
    where?: ChallengeTrackWhereInput
  }

  export type ChallengeTrackUpdateToOneWithWhereWithoutTimelineTemplatesInput = {
    where?: ChallengeTrackWhereInput
    data: XOR<ChallengeTrackUpdateWithoutTimelineTemplatesInput, ChallengeTrackUncheckedUpdateWithoutTimelineTemplatesInput>
  }

  export type ChallengeTrackUpdateWithoutTimelineTemplatesInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    abbreviation?: StringFieldUpdateOperationsInput | string
    legacyId?: NullableIntFieldUpdateOperationsInput | number | null
    track?: NullableEnumChallengeTrackEnumFieldUpdateOperationsInput | $Enums.ChallengeTrackEnum | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdBy?: StringFieldUpdateOperationsInput | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedBy?: StringFieldUpdateOperationsInput | string
    challenges?: ChallengeUpdateManyWithoutTrackNestedInput
    defaultReviewers?: DefaultChallengeReviewerUpdateManyWithoutChallengeTrackNestedInput
  }

  export type ChallengeTrackUncheckedUpdateWithoutTimelineTemplatesInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    abbreviation?: StringFieldUpdateOperationsInput | string
    legacyId?: NullableIntFieldUpdateOperationsInput | number | null
    track?: NullableEnumChallengeTrackEnumFieldUpdateOperationsInput | $Enums.ChallengeTrackEnum | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdBy?: StringFieldUpdateOperationsInput | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedBy?: StringFieldUpdateOperationsInput | string
    challenges?: ChallengeUncheckedUpdateManyWithoutTrackNestedInput
    defaultReviewers?: DefaultChallengeReviewerUncheckedUpdateManyWithoutChallengeTrackNestedInput
  }

  export type ChallengeTypeUpsertWithoutTimelineTemplatesInput = {
    update: XOR<ChallengeTypeUpdateWithoutTimelineTemplatesInput, ChallengeTypeUncheckedUpdateWithoutTimelineTemplatesInput>
    create: XOR<ChallengeTypeCreateWithoutTimelineTemplatesInput, ChallengeTypeUncheckedCreateWithoutTimelineTemplatesInput>
    where?: ChallengeTypeWhereInput
  }

  export type ChallengeTypeUpdateToOneWithWhereWithoutTimelineTemplatesInput = {
    where?: ChallengeTypeWhereInput
    data: XOR<ChallengeTypeUpdateWithoutTimelineTemplatesInput, ChallengeTypeUncheckedUpdateWithoutTimelineTemplatesInput>
  }

  export type ChallengeTypeUpdateWithoutTimelineTemplatesInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    isTask?: BoolFieldUpdateOperationsInput | boolean
    abbreviation?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdBy?: StringFieldUpdateOperationsInput | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedBy?: StringFieldUpdateOperationsInput | string
    challenges?: ChallengeUpdateManyWithoutTypeNestedInput
    defaultReviewers?: DefaultChallengeReviewerUpdateManyWithoutChallengeTypeNestedInput
  }

  export type ChallengeTypeUncheckedUpdateWithoutTimelineTemplatesInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    isTask?: BoolFieldUpdateOperationsInput | boolean
    abbreviation?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdBy?: StringFieldUpdateOperationsInput | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedBy?: StringFieldUpdateOperationsInput | string
    challenges?: ChallengeUncheckedUpdateManyWithoutTypeNestedInput
    defaultReviewers?: DefaultChallengeReviewerUncheckedUpdateManyWithoutChallengeTypeNestedInput
  }

  export type ChallengeCreateWithoutAuditLogsInput = {
    id?: string
    name: string
    description?: string | null
    privateDescription?: string | null
    challengeSource?: string | null
    descriptionFormat?: string | null
    projectId?: number | null
    overviewTotalPrizes?: number | null
    numOfRegistrants?: number
    numOfSubmissions?: number
    numOfCheckpointSubmissions?: number
    currentPhaseNames?: ChallengeCreatecurrentPhaseNamesInput | string[]
    wiproAllowed?: boolean
    tags?: ChallengeCreatetagsInput | string[]
    groups?: ChallengeCreategroupsInput | string[]
    taskIsTask?: boolean
    taskIsAssigned?: boolean
    taskMemberId?: string | null
    submissionStartDate?: Date | string | null
    submissionEndDate?: Date | string | null
    registrationStartDate?: Date | string | null
    registrationEndDate?: Date | string | null
    startDate?: Date | string | null
    endDate?: Date | string | null
    legacyId?: number | null
    status?: $Enums.ChallengeStatusEnum
    createdAt?: Date | string
    createdBy: string
    updatedAt?: Date | string
    updatedBy: string
    billingRecord?: ChallengeBillingCreateNestedOneWithoutChallengeInput
    legacyRecord?: ChallengeLegacyCreateNestedOneWithoutChallengeInput
    constraintRecord?: ChallengeConstraintCreateNestedOneWithoutChallengeInput
    events?: ChallengeEventCreateNestedManyWithoutChallengeInput
    discussions?: ChallengeDiscussionCreateNestedManyWithoutChallengeInput
    metadata?: ChallengeMetadataCreateNestedManyWithoutChallengeInput
    phases?: ChallengePhaseCreateNestedManyWithoutChallengeInput
    prizeSets?: ChallengePrizeSetCreateNestedManyWithoutChallengeInput
    reviewers?: ChallengeReviewerCreateNestedManyWithoutChallengeInput
    winners?: ChallengeWinnerCreateNestedManyWithoutChallengeInput
    attachments?: AttachmentCreateNestedManyWithoutChallengeInput
    terms?: ChallengeTermCreateNestedManyWithoutChallengeInput
    skills?: ChallengeSkillCreateNestedManyWithoutChallengeInput
    memberAccesses?: MemberChallengeAccessCreateNestedManyWithoutChallengeInput
    type: ChallengeTypeCreateNestedOneWithoutChallengesInput
    track: ChallengeTrackCreateNestedOneWithoutChallengesInput
    timelineTemplate?: TimelineTemplateCreateNestedOneWithoutChallengesInput
  }

  export type ChallengeUncheckedCreateWithoutAuditLogsInput = {
    id?: string
    name: string
    description?: string | null
    privateDescription?: string | null
    challengeSource?: string | null
    descriptionFormat?: string | null
    projectId?: number | null
    typeId: string
    trackId: string
    timelineTemplateId?: string | null
    overviewTotalPrizes?: number | null
    numOfRegistrants?: number
    numOfSubmissions?: number
    numOfCheckpointSubmissions?: number
    currentPhaseNames?: ChallengeCreatecurrentPhaseNamesInput | string[]
    wiproAllowed?: boolean
    tags?: ChallengeCreatetagsInput | string[]
    groups?: ChallengeCreategroupsInput | string[]
    taskIsTask?: boolean
    taskIsAssigned?: boolean
    taskMemberId?: string | null
    submissionStartDate?: Date | string | null
    submissionEndDate?: Date | string | null
    registrationStartDate?: Date | string | null
    registrationEndDate?: Date | string | null
    startDate?: Date | string | null
    endDate?: Date | string | null
    legacyId?: number | null
    status?: $Enums.ChallengeStatusEnum
    createdAt?: Date | string
    createdBy: string
    updatedAt?: Date | string
    updatedBy: string
    billingRecord?: ChallengeBillingUncheckedCreateNestedOneWithoutChallengeInput
    legacyRecord?: ChallengeLegacyUncheckedCreateNestedOneWithoutChallengeInput
    constraintRecord?: ChallengeConstraintUncheckedCreateNestedOneWithoutChallengeInput
    events?: ChallengeEventUncheckedCreateNestedManyWithoutChallengeInput
    discussions?: ChallengeDiscussionUncheckedCreateNestedManyWithoutChallengeInput
    metadata?: ChallengeMetadataUncheckedCreateNestedManyWithoutChallengeInput
    phases?: ChallengePhaseUncheckedCreateNestedManyWithoutChallengeInput
    prizeSets?: ChallengePrizeSetUncheckedCreateNestedManyWithoutChallengeInput
    reviewers?: ChallengeReviewerUncheckedCreateNestedManyWithoutChallengeInput
    winners?: ChallengeWinnerUncheckedCreateNestedManyWithoutChallengeInput
    attachments?: AttachmentUncheckedCreateNestedManyWithoutChallengeInput
    terms?: ChallengeTermUncheckedCreateNestedManyWithoutChallengeInput
    skills?: ChallengeSkillUncheckedCreateNestedManyWithoutChallengeInput
    memberAccesses?: MemberChallengeAccessUncheckedCreateNestedManyWithoutChallengeInput
  }

  export type ChallengeCreateOrConnectWithoutAuditLogsInput = {
    where: ChallengeWhereUniqueInput
    create: XOR<ChallengeCreateWithoutAuditLogsInput, ChallengeUncheckedCreateWithoutAuditLogsInput>
  }

  export type ChallengeUpsertWithoutAuditLogsInput = {
    update: XOR<ChallengeUpdateWithoutAuditLogsInput, ChallengeUncheckedUpdateWithoutAuditLogsInput>
    create: XOR<ChallengeCreateWithoutAuditLogsInput, ChallengeUncheckedCreateWithoutAuditLogsInput>
    where?: ChallengeWhereInput
  }

  export type ChallengeUpdateToOneWithWhereWithoutAuditLogsInput = {
    where?: ChallengeWhereInput
    data: XOR<ChallengeUpdateWithoutAuditLogsInput, ChallengeUncheckedUpdateWithoutAuditLogsInput>
  }

  export type ChallengeUpdateWithoutAuditLogsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    privateDescription?: NullableStringFieldUpdateOperationsInput | string | null
    challengeSource?: NullableStringFieldUpdateOperationsInput | string | null
    descriptionFormat?: NullableStringFieldUpdateOperationsInput | string | null
    projectId?: NullableIntFieldUpdateOperationsInput | number | null
    overviewTotalPrizes?: NullableFloatFieldUpdateOperationsInput | number | null
    numOfRegistrants?: IntFieldUpdateOperationsInput | number
    numOfSubmissions?: IntFieldUpdateOperationsInput | number
    numOfCheckpointSubmissions?: IntFieldUpdateOperationsInput | number
    currentPhaseNames?: ChallengeUpdatecurrentPhaseNamesInput | string[]
    wiproAllowed?: BoolFieldUpdateOperationsInput | boolean
    tags?: ChallengeUpdatetagsInput | string[]
    groups?: ChallengeUpdategroupsInput | string[]
    taskIsTask?: BoolFieldUpdateOperationsInput | boolean
    taskIsAssigned?: BoolFieldUpdateOperationsInput | boolean
    taskMemberId?: NullableStringFieldUpdateOperationsInput | string | null
    submissionStartDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    submissionEndDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    registrationStartDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    registrationEndDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    startDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    endDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    legacyId?: NullableIntFieldUpdateOperationsInput | number | null
    status?: EnumChallengeStatusEnumFieldUpdateOperationsInput | $Enums.ChallengeStatusEnum
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdBy?: StringFieldUpdateOperationsInput | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedBy?: StringFieldUpdateOperationsInput | string
    billingRecord?: ChallengeBillingUpdateOneWithoutChallengeNestedInput
    legacyRecord?: ChallengeLegacyUpdateOneWithoutChallengeNestedInput
    constraintRecord?: ChallengeConstraintUpdateOneWithoutChallengeNestedInput
    events?: ChallengeEventUpdateManyWithoutChallengeNestedInput
    discussions?: ChallengeDiscussionUpdateManyWithoutChallengeNestedInput
    metadata?: ChallengeMetadataUpdateManyWithoutChallengeNestedInput
    phases?: ChallengePhaseUpdateManyWithoutChallengeNestedInput
    prizeSets?: ChallengePrizeSetUpdateManyWithoutChallengeNestedInput
    reviewers?: ChallengeReviewerUpdateManyWithoutChallengeNestedInput
    winners?: ChallengeWinnerUpdateManyWithoutChallengeNestedInput
    attachments?: AttachmentUpdateManyWithoutChallengeNestedInput
    terms?: ChallengeTermUpdateManyWithoutChallengeNestedInput
    skills?: ChallengeSkillUpdateManyWithoutChallengeNestedInput
    memberAccesses?: MemberChallengeAccessUpdateManyWithoutChallengeNestedInput
    type?: ChallengeTypeUpdateOneRequiredWithoutChallengesNestedInput
    track?: ChallengeTrackUpdateOneRequiredWithoutChallengesNestedInput
    timelineTemplate?: TimelineTemplateUpdateOneWithoutChallengesNestedInput
  }

  export type ChallengeUncheckedUpdateWithoutAuditLogsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    privateDescription?: NullableStringFieldUpdateOperationsInput | string | null
    challengeSource?: NullableStringFieldUpdateOperationsInput | string | null
    descriptionFormat?: NullableStringFieldUpdateOperationsInput | string | null
    projectId?: NullableIntFieldUpdateOperationsInput | number | null
    typeId?: StringFieldUpdateOperationsInput | string
    trackId?: StringFieldUpdateOperationsInput | string
    timelineTemplateId?: NullableStringFieldUpdateOperationsInput | string | null
    overviewTotalPrizes?: NullableFloatFieldUpdateOperationsInput | number | null
    numOfRegistrants?: IntFieldUpdateOperationsInput | number
    numOfSubmissions?: IntFieldUpdateOperationsInput | number
    numOfCheckpointSubmissions?: IntFieldUpdateOperationsInput | number
    currentPhaseNames?: ChallengeUpdatecurrentPhaseNamesInput | string[]
    wiproAllowed?: BoolFieldUpdateOperationsInput | boolean
    tags?: ChallengeUpdatetagsInput | string[]
    groups?: ChallengeUpdategroupsInput | string[]
    taskIsTask?: BoolFieldUpdateOperationsInput | boolean
    taskIsAssigned?: BoolFieldUpdateOperationsInput | boolean
    taskMemberId?: NullableStringFieldUpdateOperationsInput | string | null
    submissionStartDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    submissionEndDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    registrationStartDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    registrationEndDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    startDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    endDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    legacyId?: NullableIntFieldUpdateOperationsInput | number | null
    status?: EnumChallengeStatusEnumFieldUpdateOperationsInput | $Enums.ChallengeStatusEnum
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdBy?: StringFieldUpdateOperationsInput | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedBy?: StringFieldUpdateOperationsInput | string
    billingRecord?: ChallengeBillingUncheckedUpdateOneWithoutChallengeNestedInput
    legacyRecord?: ChallengeLegacyUncheckedUpdateOneWithoutChallengeNestedInput
    constraintRecord?: ChallengeConstraintUncheckedUpdateOneWithoutChallengeNestedInput
    events?: ChallengeEventUncheckedUpdateManyWithoutChallengeNestedInput
    discussions?: ChallengeDiscussionUncheckedUpdateManyWithoutChallengeNestedInput
    metadata?: ChallengeMetadataUncheckedUpdateManyWithoutChallengeNestedInput
    phases?: ChallengePhaseUncheckedUpdateManyWithoutChallengeNestedInput
    prizeSets?: ChallengePrizeSetUncheckedUpdateManyWithoutChallengeNestedInput
    reviewers?: ChallengeReviewerUncheckedUpdateManyWithoutChallengeNestedInput
    winners?: ChallengeWinnerUncheckedUpdateManyWithoutChallengeNestedInput
    attachments?: AttachmentUncheckedUpdateManyWithoutChallengeNestedInput
    terms?: ChallengeTermUncheckedUpdateManyWithoutChallengeNestedInput
    skills?: ChallengeSkillUncheckedUpdateManyWithoutChallengeNestedInput
    memberAccesses?: MemberChallengeAccessUncheckedUpdateManyWithoutChallengeNestedInput
  }

  export type ChallengeCreateWithoutAttachmentsInput = {
    id?: string
    name: string
    description?: string | null
    privateDescription?: string | null
    challengeSource?: string | null
    descriptionFormat?: string | null
    projectId?: number | null
    overviewTotalPrizes?: number | null
    numOfRegistrants?: number
    numOfSubmissions?: number
    numOfCheckpointSubmissions?: number
    currentPhaseNames?: ChallengeCreatecurrentPhaseNamesInput | string[]
    wiproAllowed?: boolean
    tags?: ChallengeCreatetagsInput | string[]
    groups?: ChallengeCreategroupsInput | string[]
    taskIsTask?: boolean
    taskIsAssigned?: boolean
    taskMemberId?: string | null
    submissionStartDate?: Date | string | null
    submissionEndDate?: Date | string | null
    registrationStartDate?: Date | string | null
    registrationEndDate?: Date | string | null
    startDate?: Date | string | null
    endDate?: Date | string | null
    legacyId?: number | null
    status?: $Enums.ChallengeStatusEnum
    createdAt?: Date | string
    createdBy: string
    updatedAt?: Date | string
    updatedBy: string
    billingRecord?: ChallengeBillingCreateNestedOneWithoutChallengeInput
    legacyRecord?: ChallengeLegacyCreateNestedOneWithoutChallengeInput
    constraintRecord?: ChallengeConstraintCreateNestedOneWithoutChallengeInput
    events?: ChallengeEventCreateNestedManyWithoutChallengeInput
    discussions?: ChallengeDiscussionCreateNestedManyWithoutChallengeInput
    metadata?: ChallengeMetadataCreateNestedManyWithoutChallengeInput
    phases?: ChallengePhaseCreateNestedManyWithoutChallengeInput
    prizeSets?: ChallengePrizeSetCreateNestedManyWithoutChallengeInput
    reviewers?: ChallengeReviewerCreateNestedManyWithoutChallengeInput
    winners?: ChallengeWinnerCreateNestedManyWithoutChallengeInput
    terms?: ChallengeTermCreateNestedManyWithoutChallengeInput
    skills?: ChallengeSkillCreateNestedManyWithoutChallengeInput
    auditLogs?: AuditLogCreateNestedManyWithoutChallengeInput
    memberAccesses?: MemberChallengeAccessCreateNestedManyWithoutChallengeInput
    type: ChallengeTypeCreateNestedOneWithoutChallengesInput
    track: ChallengeTrackCreateNestedOneWithoutChallengesInput
    timelineTemplate?: TimelineTemplateCreateNestedOneWithoutChallengesInput
  }

  export type ChallengeUncheckedCreateWithoutAttachmentsInput = {
    id?: string
    name: string
    description?: string | null
    privateDescription?: string | null
    challengeSource?: string | null
    descriptionFormat?: string | null
    projectId?: number | null
    typeId: string
    trackId: string
    timelineTemplateId?: string | null
    overviewTotalPrizes?: number | null
    numOfRegistrants?: number
    numOfSubmissions?: number
    numOfCheckpointSubmissions?: number
    currentPhaseNames?: ChallengeCreatecurrentPhaseNamesInput | string[]
    wiproAllowed?: boolean
    tags?: ChallengeCreatetagsInput | string[]
    groups?: ChallengeCreategroupsInput | string[]
    taskIsTask?: boolean
    taskIsAssigned?: boolean
    taskMemberId?: string | null
    submissionStartDate?: Date | string | null
    submissionEndDate?: Date | string | null
    registrationStartDate?: Date | string | null
    registrationEndDate?: Date | string | null
    startDate?: Date | string | null
    endDate?: Date | string | null
    legacyId?: number | null
    status?: $Enums.ChallengeStatusEnum
    createdAt?: Date | string
    createdBy: string
    updatedAt?: Date | string
    updatedBy: string
    billingRecord?: ChallengeBillingUncheckedCreateNestedOneWithoutChallengeInput
    legacyRecord?: ChallengeLegacyUncheckedCreateNestedOneWithoutChallengeInput
    constraintRecord?: ChallengeConstraintUncheckedCreateNestedOneWithoutChallengeInput
    events?: ChallengeEventUncheckedCreateNestedManyWithoutChallengeInput
    discussions?: ChallengeDiscussionUncheckedCreateNestedManyWithoutChallengeInput
    metadata?: ChallengeMetadataUncheckedCreateNestedManyWithoutChallengeInput
    phases?: ChallengePhaseUncheckedCreateNestedManyWithoutChallengeInput
    prizeSets?: ChallengePrizeSetUncheckedCreateNestedManyWithoutChallengeInput
    reviewers?: ChallengeReviewerUncheckedCreateNestedManyWithoutChallengeInput
    winners?: ChallengeWinnerUncheckedCreateNestedManyWithoutChallengeInput
    terms?: ChallengeTermUncheckedCreateNestedManyWithoutChallengeInput
    skills?: ChallengeSkillUncheckedCreateNestedManyWithoutChallengeInput
    auditLogs?: AuditLogUncheckedCreateNestedManyWithoutChallengeInput
    memberAccesses?: MemberChallengeAccessUncheckedCreateNestedManyWithoutChallengeInput
  }

  export type ChallengeCreateOrConnectWithoutAttachmentsInput = {
    where: ChallengeWhereUniqueInput
    create: XOR<ChallengeCreateWithoutAttachmentsInput, ChallengeUncheckedCreateWithoutAttachmentsInput>
  }

  export type ChallengeUpsertWithoutAttachmentsInput = {
    update: XOR<ChallengeUpdateWithoutAttachmentsInput, ChallengeUncheckedUpdateWithoutAttachmentsInput>
    create: XOR<ChallengeCreateWithoutAttachmentsInput, ChallengeUncheckedCreateWithoutAttachmentsInput>
    where?: ChallengeWhereInput
  }

  export type ChallengeUpdateToOneWithWhereWithoutAttachmentsInput = {
    where?: ChallengeWhereInput
    data: XOR<ChallengeUpdateWithoutAttachmentsInput, ChallengeUncheckedUpdateWithoutAttachmentsInput>
  }

  export type ChallengeUpdateWithoutAttachmentsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    privateDescription?: NullableStringFieldUpdateOperationsInput | string | null
    challengeSource?: NullableStringFieldUpdateOperationsInput | string | null
    descriptionFormat?: NullableStringFieldUpdateOperationsInput | string | null
    projectId?: NullableIntFieldUpdateOperationsInput | number | null
    overviewTotalPrizes?: NullableFloatFieldUpdateOperationsInput | number | null
    numOfRegistrants?: IntFieldUpdateOperationsInput | number
    numOfSubmissions?: IntFieldUpdateOperationsInput | number
    numOfCheckpointSubmissions?: IntFieldUpdateOperationsInput | number
    currentPhaseNames?: ChallengeUpdatecurrentPhaseNamesInput | string[]
    wiproAllowed?: BoolFieldUpdateOperationsInput | boolean
    tags?: ChallengeUpdatetagsInput | string[]
    groups?: ChallengeUpdategroupsInput | string[]
    taskIsTask?: BoolFieldUpdateOperationsInput | boolean
    taskIsAssigned?: BoolFieldUpdateOperationsInput | boolean
    taskMemberId?: NullableStringFieldUpdateOperationsInput | string | null
    submissionStartDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    submissionEndDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    registrationStartDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    registrationEndDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    startDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    endDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    legacyId?: NullableIntFieldUpdateOperationsInput | number | null
    status?: EnumChallengeStatusEnumFieldUpdateOperationsInput | $Enums.ChallengeStatusEnum
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdBy?: StringFieldUpdateOperationsInput | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedBy?: StringFieldUpdateOperationsInput | string
    billingRecord?: ChallengeBillingUpdateOneWithoutChallengeNestedInput
    legacyRecord?: ChallengeLegacyUpdateOneWithoutChallengeNestedInput
    constraintRecord?: ChallengeConstraintUpdateOneWithoutChallengeNestedInput
    events?: ChallengeEventUpdateManyWithoutChallengeNestedInput
    discussions?: ChallengeDiscussionUpdateManyWithoutChallengeNestedInput
    metadata?: ChallengeMetadataUpdateManyWithoutChallengeNestedInput
    phases?: ChallengePhaseUpdateManyWithoutChallengeNestedInput
    prizeSets?: ChallengePrizeSetUpdateManyWithoutChallengeNestedInput
    reviewers?: ChallengeReviewerUpdateManyWithoutChallengeNestedInput
    winners?: ChallengeWinnerUpdateManyWithoutChallengeNestedInput
    terms?: ChallengeTermUpdateManyWithoutChallengeNestedInput
    skills?: ChallengeSkillUpdateManyWithoutChallengeNestedInput
    auditLogs?: AuditLogUpdateManyWithoutChallengeNestedInput
    memberAccesses?: MemberChallengeAccessUpdateManyWithoutChallengeNestedInput
    type?: ChallengeTypeUpdateOneRequiredWithoutChallengesNestedInput
    track?: ChallengeTrackUpdateOneRequiredWithoutChallengesNestedInput
    timelineTemplate?: TimelineTemplateUpdateOneWithoutChallengesNestedInput
  }

  export type ChallengeUncheckedUpdateWithoutAttachmentsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    privateDescription?: NullableStringFieldUpdateOperationsInput | string | null
    challengeSource?: NullableStringFieldUpdateOperationsInput | string | null
    descriptionFormat?: NullableStringFieldUpdateOperationsInput | string | null
    projectId?: NullableIntFieldUpdateOperationsInput | number | null
    typeId?: StringFieldUpdateOperationsInput | string
    trackId?: StringFieldUpdateOperationsInput | string
    timelineTemplateId?: NullableStringFieldUpdateOperationsInput | string | null
    overviewTotalPrizes?: NullableFloatFieldUpdateOperationsInput | number | null
    numOfRegistrants?: IntFieldUpdateOperationsInput | number
    numOfSubmissions?: IntFieldUpdateOperationsInput | number
    numOfCheckpointSubmissions?: IntFieldUpdateOperationsInput | number
    currentPhaseNames?: ChallengeUpdatecurrentPhaseNamesInput | string[]
    wiproAllowed?: BoolFieldUpdateOperationsInput | boolean
    tags?: ChallengeUpdatetagsInput | string[]
    groups?: ChallengeUpdategroupsInput | string[]
    taskIsTask?: BoolFieldUpdateOperationsInput | boolean
    taskIsAssigned?: BoolFieldUpdateOperationsInput | boolean
    taskMemberId?: NullableStringFieldUpdateOperationsInput | string | null
    submissionStartDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    submissionEndDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    registrationStartDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    registrationEndDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    startDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    endDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    legacyId?: NullableIntFieldUpdateOperationsInput | number | null
    status?: EnumChallengeStatusEnumFieldUpdateOperationsInput | $Enums.ChallengeStatusEnum
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdBy?: StringFieldUpdateOperationsInput | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedBy?: StringFieldUpdateOperationsInput | string
    billingRecord?: ChallengeBillingUncheckedUpdateOneWithoutChallengeNestedInput
    legacyRecord?: ChallengeLegacyUncheckedUpdateOneWithoutChallengeNestedInput
    constraintRecord?: ChallengeConstraintUncheckedUpdateOneWithoutChallengeNestedInput
    events?: ChallengeEventUncheckedUpdateManyWithoutChallengeNestedInput
    discussions?: ChallengeDiscussionUncheckedUpdateManyWithoutChallengeNestedInput
    metadata?: ChallengeMetadataUncheckedUpdateManyWithoutChallengeNestedInput
    phases?: ChallengePhaseUncheckedUpdateManyWithoutChallengeNestedInput
    prizeSets?: ChallengePrizeSetUncheckedUpdateManyWithoutChallengeNestedInput
    reviewers?: ChallengeReviewerUncheckedUpdateManyWithoutChallengeNestedInput
    winners?: ChallengeWinnerUncheckedUpdateManyWithoutChallengeNestedInput
    terms?: ChallengeTermUncheckedUpdateManyWithoutChallengeNestedInput
    skills?: ChallengeSkillUncheckedUpdateManyWithoutChallengeNestedInput
    auditLogs?: AuditLogUncheckedUpdateManyWithoutChallengeNestedInput
    memberAccesses?: MemberChallengeAccessUncheckedUpdateManyWithoutChallengeNestedInput
  }

  export type ChallengeCreateWithoutMetadataInput = {
    id?: string
    name: string
    description?: string | null
    privateDescription?: string | null
    challengeSource?: string | null
    descriptionFormat?: string | null
    projectId?: number | null
    overviewTotalPrizes?: number | null
    numOfRegistrants?: number
    numOfSubmissions?: number
    numOfCheckpointSubmissions?: number
    currentPhaseNames?: ChallengeCreatecurrentPhaseNamesInput | string[]
    wiproAllowed?: boolean
    tags?: ChallengeCreatetagsInput | string[]
    groups?: ChallengeCreategroupsInput | string[]
    taskIsTask?: boolean
    taskIsAssigned?: boolean
    taskMemberId?: string | null
    submissionStartDate?: Date | string | null
    submissionEndDate?: Date | string | null
    registrationStartDate?: Date | string | null
    registrationEndDate?: Date | string | null
    startDate?: Date | string | null
    endDate?: Date | string | null
    legacyId?: number | null
    status?: $Enums.ChallengeStatusEnum
    createdAt?: Date | string
    createdBy: string
    updatedAt?: Date | string
    updatedBy: string
    billingRecord?: ChallengeBillingCreateNestedOneWithoutChallengeInput
    legacyRecord?: ChallengeLegacyCreateNestedOneWithoutChallengeInput
    constraintRecord?: ChallengeConstraintCreateNestedOneWithoutChallengeInput
    events?: ChallengeEventCreateNestedManyWithoutChallengeInput
    discussions?: ChallengeDiscussionCreateNestedManyWithoutChallengeInput
    phases?: ChallengePhaseCreateNestedManyWithoutChallengeInput
    prizeSets?: ChallengePrizeSetCreateNestedManyWithoutChallengeInput
    reviewers?: ChallengeReviewerCreateNestedManyWithoutChallengeInput
    winners?: ChallengeWinnerCreateNestedManyWithoutChallengeInput
    attachments?: AttachmentCreateNestedManyWithoutChallengeInput
    terms?: ChallengeTermCreateNestedManyWithoutChallengeInput
    skills?: ChallengeSkillCreateNestedManyWithoutChallengeInput
    auditLogs?: AuditLogCreateNestedManyWithoutChallengeInput
    memberAccesses?: MemberChallengeAccessCreateNestedManyWithoutChallengeInput
    type: ChallengeTypeCreateNestedOneWithoutChallengesInput
    track: ChallengeTrackCreateNestedOneWithoutChallengesInput
    timelineTemplate?: TimelineTemplateCreateNestedOneWithoutChallengesInput
  }

  export type ChallengeUncheckedCreateWithoutMetadataInput = {
    id?: string
    name: string
    description?: string | null
    privateDescription?: string | null
    challengeSource?: string | null
    descriptionFormat?: string | null
    projectId?: number | null
    typeId: string
    trackId: string
    timelineTemplateId?: string | null
    overviewTotalPrizes?: number | null
    numOfRegistrants?: number
    numOfSubmissions?: number
    numOfCheckpointSubmissions?: number
    currentPhaseNames?: ChallengeCreatecurrentPhaseNamesInput | string[]
    wiproAllowed?: boolean
    tags?: ChallengeCreatetagsInput | string[]
    groups?: ChallengeCreategroupsInput | string[]
    taskIsTask?: boolean
    taskIsAssigned?: boolean
    taskMemberId?: string | null
    submissionStartDate?: Date | string | null
    submissionEndDate?: Date | string | null
    registrationStartDate?: Date | string | null
    registrationEndDate?: Date | string | null
    startDate?: Date | string | null
    endDate?: Date | string | null
    legacyId?: number | null
    status?: $Enums.ChallengeStatusEnum
    createdAt?: Date | string
    createdBy: string
    updatedAt?: Date | string
    updatedBy: string
    billingRecord?: ChallengeBillingUncheckedCreateNestedOneWithoutChallengeInput
    legacyRecord?: ChallengeLegacyUncheckedCreateNestedOneWithoutChallengeInput
    constraintRecord?: ChallengeConstraintUncheckedCreateNestedOneWithoutChallengeInput
    events?: ChallengeEventUncheckedCreateNestedManyWithoutChallengeInput
    discussions?: ChallengeDiscussionUncheckedCreateNestedManyWithoutChallengeInput
    phases?: ChallengePhaseUncheckedCreateNestedManyWithoutChallengeInput
    prizeSets?: ChallengePrizeSetUncheckedCreateNestedManyWithoutChallengeInput
    reviewers?: ChallengeReviewerUncheckedCreateNestedManyWithoutChallengeInput
    winners?: ChallengeWinnerUncheckedCreateNestedManyWithoutChallengeInput
    attachments?: AttachmentUncheckedCreateNestedManyWithoutChallengeInput
    terms?: ChallengeTermUncheckedCreateNestedManyWithoutChallengeInput
    skills?: ChallengeSkillUncheckedCreateNestedManyWithoutChallengeInput
    auditLogs?: AuditLogUncheckedCreateNestedManyWithoutChallengeInput
    memberAccesses?: MemberChallengeAccessUncheckedCreateNestedManyWithoutChallengeInput
  }

  export type ChallengeCreateOrConnectWithoutMetadataInput = {
    where: ChallengeWhereUniqueInput
    create: XOR<ChallengeCreateWithoutMetadataInput, ChallengeUncheckedCreateWithoutMetadataInput>
  }

  export type ChallengeUpsertWithoutMetadataInput = {
    update: XOR<ChallengeUpdateWithoutMetadataInput, ChallengeUncheckedUpdateWithoutMetadataInput>
    create: XOR<ChallengeCreateWithoutMetadataInput, ChallengeUncheckedCreateWithoutMetadataInput>
    where?: ChallengeWhereInput
  }

  export type ChallengeUpdateToOneWithWhereWithoutMetadataInput = {
    where?: ChallengeWhereInput
    data: XOR<ChallengeUpdateWithoutMetadataInput, ChallengeUncheckedUpdateWithoutMetadataInput>
  }

  export type ChallengeUpdateWithoutMetadataInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    privateDescription?: NullableStringFieldUpdateOperationsInput | string | null
    challengeSource?: NullableStringFieldUpdateOperationsInput | string | null
    descriptionFormat?: NullableStringFieldUpdateOperationsInput | string | null
    projectId?: NullableIntFieldUpdateOperationsInput | number | null
    overviewTotalPrizes?: NullableFloatFieldUpdateOperationsInput | number | null
    numOfRegistrants?: IntFieldUpdateOperationsInput | number
    numOfSubmissions?: IntFieldUpdateOperationsInput | number
    numOfCheckpointSubmissions?: IntFieldUpdateOperationsInput | number
    currentPhaseNames?: ChallengeUpdatecurrentPhaseNamesInput | string[]
    wiproAllowed?: BoolFieldUpdateOperationsInput | boolean
    tags?: ChallengeUpdatetagsInput | string[]
    groups?: ChallengeUpdategroupsInput | string[]
    taskIsTask?: BoolFieldUpdateOperationsInput | boolean
    taskIsAssigned?: BoolFieldUpdateOperationsInput | boolean
    taskMemberId?: NullableStringFieldUpdateOperationsInput | string | null
    submissionStartDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    submissionEndDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    registrationStartDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    registrationEndDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    startDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    endDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    legacyId?: NullableIntFieldUpdateOperationsInput | number | null
    status?: EnumChallengeStatusEnumFieldUpdateOperationsInput | $Enums.ChallengeStatusEnum
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdBy?: StringFieldUpdateOperationsInput | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedBy?: StringFieldUpdateOperationsInput | string
    billingRecord?: ChallengeBillingUpdateOneWithoutChallengeNestedInput
    legacyRecord?: ChallengeLegacyUpdateOneWithoutChallengeNestedInput
    constraintRecord?: ChallengeConstraintUpdateOneWithoutChallengeNestedInput
    events?: ChallengeEventUpdateManyWithoutChallengeNestedInput
    discussions?: ChallengeDiscussionUpdateManyWithoutChallengeNestedInput
    phases?: ChallengePhaseUpdateManyWithoutChallengeNestedInput
    prizeSets?: ChallengePrizeSetUpdateManyWithoutChallengeNestedInput
    reviewers?: ChallengeReviewerUpdateManyWithoutChallengeNestedInput
    winners?: ChallengeWinnerUpdateManyWithoutChallengeNestedInput
    attachments?: AttachmentUpdateManyWithoutChallengeNestedInput
    terms?: ChallengeTermUpdateManyWithoutChallengeNestedInput
    skills?: ChallengeSkillUpdateManyWithoutChallengeNestedInput
    auditLogs?: AuditLogUpdateManyWithoutChallengeNestedInput
    memberAccesses?: MemberChallengeAccessUpdateManyWithoutChallengeNestedInput
    type?: ChallengeTypeUpdateOneRequiredWithoutChallengesNestedInput
    track?: ChallengeTrackUpdateOneRequiredWithoutChallengesNestedInput
    timelineTemplate?: TimelineTemplateUpdateOneWithoutChallengesNestedInput
  }

  export type ChallengeUncheckedUpdateWithoutMetadataInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    privateDescription?: NullableStringFieldUpdateOperationsInput | string | null
    challengeSource?: NullableStringFieldUpdateOperationsInput | string | null
    descriptionFormat?: NullableStringFieldUpdateOperationsInput | string | null
    projectId?: NullableIntFieldUpdateOperationsInput | number | null
    typeId?: StringFieldUpdateOperationsInput | string
    trackId?: StringFieldUpdateOperationsInput | string
    timelineTemplateId?: NullableStringFieldUpdateOperationsInput | string | null
    overviewTotalPrizes?: NullableFloatFieldUpdateOperationsInput | number | null
    numOfRegistrants?: IntFieldUpdateOperationsInput | number
    numOfSubmissions?: IntFieldUpdateOperationsInput | number
    numOfCheckpointSubmissions?: IntFieldUpdateOperationsInput | number
    currentPhaseNames?: ChallengeUpdatecurrentPhaseNamesInput | string[]
    wiproAllowed?: BoolFieldUpdateOperationsInput | boolean
    tags?: ChallengeUpdatetagsInput | string[]
    groups?: ChallengeUpdategroupsInput | string[]
    taskIsTask?: BoolFieldUpdateOperationsInput | boolean
    taskIsAssigned?: BoolFieldUpdateOperationsInput | boolean
    taskMemberId?: NullableStringFieldUpdateOperationsInput | string | null
    submissionStartDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    submissionEndDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    registrationStartDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    registrationEndDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    startDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    endDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    legacyId?: NullableIntFieldUpdateOperationsInput | number | null
    status?: EnumChallengeStatusEnumFieldUpdateOperationsInput | $Enums.ChallengeStatusEnum
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdBy?: StringFieldUpdateOperationsInput | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedBy?: StringFieldUpdateOperationsInput | string
    billingRecord?: ChallengeBillingUncheckedUpdateOneWithoutChallengeNestedInput
    legacyRecord?: ChallengeLegacyUncheckedUpdateOneWithoutChallengeNestedInput
    constraintRecord?: ChallengeConstraintUncheckedUpdateOneWithoutChallengeNestedInput
    events?: ChallengeEventUncheckedUpdateManyWithoutChallengeNestedInput
    discussions?: ChallengeDiscussionUncheckedUpdateManyWithoutChallengeNestedInput
    phases?: ChallengePhaseUncheckedUpdateManyWithoutChallengeNestedInput
    prizeSets?: ChallengePrizeSetUncheckedUpdateManyWithoutChallengeNestedInput
    reviewers?: ChallengeReviewerUncheckedUpdateManyWithoutChallengeNestedInput
    winners?: ChallengeWinnerUncheckedUpdateManyWithoutChallengeNestedInput
    attachments?: AttachmentUncheckedUpdateManyWithoutChallengeNestedInput
    terms?: ChallengeTermUncheckedUpdateManyWithoutChallengeNestedInput
    skills?: ChallengeSkillUncheckedUpdateManyWithoutChallengeNestedInput
    auditLogs?: AuditLogUncheckedUpdateManyWithoutChallengeNestedInput
    memberAccesses?: MemberChallengeAccessUncheckedUpdateManyWithoutChallengeNestedInput
  }

  export type ChallengePrizeSetCreateWithoutPrizesInput = {
    id?: string
    type: $Enums.PrizeSetTypeEnum
    description?: string | null
    createdAt?: Date | string
    createdBy: string
    updatedAt?: Date | string
    updatedBy: string
    challenge: ChallengeCreateNestedOneWithoutPrizeSetsInput
  }

  export type ChallengePrizeSetUncheckedCreateWithoutPrizesInput = {
    id?: string
    challengeId: string
    type: $Enums.PrizeSetTypeEnum
    description?: string | null
    createdAt?: Date | string
    createdBy: string
    updatedAt?: Date | string
    updatedBy: string
  }

  export type ChallengePrizeSetCreateOrConnectWithoutPrizesInput = {
    where: ChallengePrizeSetWhereUniqueInput
    create: XOR<ChallengePrizeSetCreateWithoutPrizesInput, ChallengePrizeSetUncheckedCreateWithoutPrizesInput>
  }

  export type ChallengePrizeSetUpsertWithoutPrizesInput = {
    update: XOR<ChallengePrizeSetUpdateWithoutPrizesInput, ChallengePrizeSetUncheckedUpdateWithoutPrizesInput>
    create: XOR<ChallengePrizeSetCreateWithoutPrizesInput, ChallengePrizeSetUncheckedCreateWithoutPrizesInput>
    where?: ChallengePrizeSetWhereInput
  }

  export type ChallengePrizeSetUpdateToOneWithWhereWithoutPrizesInput = {
    where?: ChallengePrizeSetWhereInput
    data: XOR<ChallengePrizeSetUpdateWithoutPrizesInput, ChallengePrizeSetUncheckedUpdateWithoutPrizesInput>
  }

  export type ChallengePrizeSetUpdateWithoutPrizesInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: EnumPrizeSetTypeEnumFieldUpdateOperationsInput | $Enums.PrizeSetTypeEnum
    description?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdBy?: StringFieldUpdateOperationsInput | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedBy?: StringFieldUpdateOperationsInput | string
    challenge?: ChallengeUpdateOneRequiredWithoutPrizeSetsNestedInput
  }

  export type ChallengePrizeSetUncheckedUpdateWithoutPrizesInput = {
    id?: StringFieldUpdateOperationsInput | string
    challengeId?: StringFieldUpdateOperationsInput | string
    type?: EnumPrizeSetTypeEnumFieldUpdateOperationsInput | $Enums.PrizeSetTypeEnum
    description?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdBy?: StringFieldUpdateOperationsInput | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedBy?: StringFieldUpdateOperationsInput | string
  }

  export type ChallengeCreateWithoutWinnersInput = {
    id?: string
    name: string
    description?: string | null
    privateDescription?: string | null
    challengeSource?: string | null
    descriptionFormat?: string | null
    projectId?: number | null
    overviewTotalPrizes?: number | null
    numOfRegistrants?: number
    numOfSubmissions?: number
    numOfCheckpointSubmissions?: number
    currentPhaseNames?: ChallengeCreatecurrentPhaseNamesInput | string[]
    wiproAllowed?: boolean
    tags?: ChallengeCreatetagsInput | string[]
    groups?: ChallengeCreategroupsInput | string[]
    taskIsTask?: boolean
    taskIsAssigned?: boolean
    taskMemberId?: string | null
    submissionStartDate?: Date | string | null
    submissionEndDate?: Date | string | null
    registrationStartDate?: Date | string | null
    registrationEndDate?: Date | string | null
    startDate?: Date | string | null
    endDate?: Date | string | null
    legacyId?: number | null
    status?: $Enums.ChallengeStatusEnum
    createdAt?: Date | string
    createdBy: string
    updatedAt?: Date | string
    updatedBy: string
    billingRecord?: ChallengeBillingCreateNestedOneWithoutChallengeInput
    legacyRecord?: ChallengeLegacyCreateNestedOneWithoutChallengeInput
    constraintRecord?: ChallengeConstraintCreateNestedOneWithoutChallengeInput
    events?: ChallengeEventCreateNestedManyWithoutChallengeInput
    discussions?: ChallengeDiscussionCreateNestedManyWithoutChallengeInput
    metadata?: ChallengeMetadataCreateNestedManyWithoutChallengeInput
    phases?: ChallengePhaseCreateNestedManyWithoutChallengeInput
    prizeSets?: ChallengePrizeSetCreateNestedManyWithoutChallengeInput
    reviewers?: ChallengeReviewerCreateNestedManyWithoutChallengeInput
    attachments?: AttachmentCreateNestedManyWithoutChallengeInput
    terms?: ChallengeTermCreateNestedManyWithoutChallengeInput
    skills?: ChallengeSkillCreateNestedManyWithoutChallengeInput
    auditLogs?: AuditLogCreateNestedManyWithoutChallengeInput
    memberAccesses?: MemberChallengeAccessCreateNestedManyWithoutChallengeInput
    type: ChallengeTypeCreateNestedOneWithoutChallengesInput
    track: ChallengeTrackCreateNestedOneWithoutChallengesInput
    timelineTemplate?: TimelineTemplateCreateNestedOneWithoutChallengesInput
  }

  export type ChallengeUncheckedCreateWithoutWinnersInput = {
    id?: string
    name: string
    description?: string | null
    privateDescription?: string | null
    challengeSource?: string | null
    descriptionFormat?: string | null
    projectId?: number | null
    typeId: string
    trackId: string
    timelineTemplateId?: string | null
    overviewTotalPrizes?: number | null
    numOfRegistrants?: number
    numOfSubmissions?: number
    numOfCheckpointSubmissions?: number
    currentPhaseNames?: ChallengeCreatecurrentPhaseNamesInput | string[]
    wiproAllowed?: boolean
    tags?: ChallengeCreatetagsInput | string[]
    groups?: ChallengeCreategroupsInput | string[]
    taskIsTask?: boolean
    taskIsAssigned?: boolean
    taskMemberId?: string | null
    submissionStartDate?: Date | string | null
    submissionEndDate?: Date | string | null
    registrationStartDate?: Date | string | null
    registrationEndDate?: Date | string | null
    startDate?: Date | string | null
    endDate?: Date | string | null
    legacyId?: number | null
    status?: $Enums.ChallengeStatusEnum
    createdAt?: Date | string
    createdBy: string
    updatedAt?: Date | string
    updatedBy: string
    billingRecord?: ChallengeBillingUncheckedCreateNestedOneWithoutChallengeInput
    legacyRecord?: ChallengeLegacyUncheckedCreateNestedOneWithoutChallengeInput
    constraintRecord?: ChallengeConstraintUncheckedCreateNestedOneWithoutChallengeInput
    events?: ChallengeEventUncheckedCreateNestedManyWithoutChallengeInput
    discussions?: ChallengeDiscussionUncheckedCreateNestedManyWithoutChallengeInput
    metadata?: ChallengeMetadataUncheckedCreateNestedManyWithoutChallengeInput
    phases?: ChallengePhaseUncheckedCreateNestedManyWithoutChallengeInput
    prizeSets?: ChallengePrizeSetUncheckedCreateNestedManyWithoutChallengeInput
    reviewers?: ChallengeReviewerUncheckedCreateNestedManyWithoutChallengeInput
    attachments?: AttachmentUncheckedCreateNestedManyWithoutChallengeInput
    terms?: ChallengeTermUncheckedCreateNestedManyWithoutChallengeInput
    skills?: ChallengeSkillUncheckedCreateNestedManyWithoutChallengeInput
    auditLogs?: AuditLogUncheckedCreateNestedManyWithoutChallengeInput
    memberAccesses?: MemberChallengeAccessUncheckedCreateNestedManyWithoutChallengeInput
  }

  export type ChallengeCreateOrConnectWithoutWinnersInput = {
    where: ChallengeWhereUniqueInput
    create: XOR<ChallengeCreateWithoutWinnersInput, ChallengeUncheckedCreateWithoutWinnersInput>
  }

  export type ChallengeUpsertWithoutWinnersInput = {
    update: XOR<ChallengeUpdateWithoutWinnersInput, ChallengeUncheckedUpdateWithoutWinnersInput>
    create: XOR<ChallengeCreateWithoutWinnersInput, ChallengeUncheckedCreateWithoutWinnersInput>
    where?: ChallengeWhereInput
  }

  export type ChallengeUpdateToOneWithWhereWithoutWinnersInput = {
    where?: ChallengeWhereInput
    data: XOR<ChallengeUpdateWithoutWinnersInput, ChallengeUncheckedUpdateWithoutWinnersInput>
  }

  export type ChallengeUpdateWithoutWinnersInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    privateDescription?: NullableStringFieldUpdateOperationsInput | string | null
    challengeSource?: NullableStringFieldUpdateOperationsInput | string | null
    descriptionFormat?: NullableStringFieldUpdateOperationsInput | string | null
    projectId?: NullableIntFieldUpdateOperationsInput | number | null
    overviewTotalPrizes?: NullableFloatFieldUpdateOperationsInput | number | null
    numOfRegistrants?: IntFieldUpdateOperationsInput | number
    numOfSubmissions?: IntFieldUpdateOperationsInput | number
    numOfCheckpointSubmissions?: IntFieldUpdateOperationsInput | number
    currentPhaseNames?: ChallengeUpdatecurrentPhaseNamesInput | string[]
    wiproAllowed?: BoolFieldUpdateOperationsInput | boolean
    tags?: ChallengeUpdatetagsInput | string[]
    groups?: ChallengeUpdategroupsInput | string[]
    taskIsTask?: BoolFieldUpdateOperationsInput | boolean
    taskIsAssigned?: BoolFieldUpdateOperationsInput | boolean
    taskMemberId?: NullableStringFieldUpdateOperationsInput | string | null
    submissionStartDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    submissionEndDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    registrationStartDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    registrationEndDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    startDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    endDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    legacyId?: NullableIntFieldUpdateOperationsInput | number | null
    status?: EnumChallengeStatusEnumFieldUpdateOperationsInput | $Enums.ChallengeStatusEnum
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdBy?: StringFieldUpdateOperationsInput | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedBy?: StringFieldUpdateOperationsInput | string
    billingRecord?: ChallengeBillingUpdateOneWithoutChallengeNestedInput
    legacyRecord?: ChallengeLegacyUpdateOneWithoutChallengeNestedInput
    constraintRecord?: ChallengeConstraintUpdateOneWithoutChallengeNestedInput
    events?: ChallengeEventUpdateManyWithoutChallengeNestedInput
    discussions?: ChallengeDiscussionUpdateManyWithoutChallengeNestedInput
    metadata?: ChallengeMetadataUpdateManyWithoutChallengeNestedInput
    phases?: ChallengePhaseUpdateManyWithoutChallengeNestedInput
    prizeSets?: ChallengePrizeSetUpdateManyWithoutChallengeNestedInput
    reviewers?: ChallengeReviewerUpdateManyWithoutChallengeNestedInput
    attachments?: AttachmentUpdateManyWithoutChallengeNestedInput
    terms?: ChallengeTermUpdateManyWithoutChallengeNestedInput
    skills?: ChallengeSkillUpdateManyWithoutChallengeNestedInput
    auditLogs?: AuditLogUpdateManyWithoutChallengeNestedInput
    memberAccesses?: MemberChallengeAccessUpdateManyWithoutChallengeNestedInput
    type?: ChallengeTypeUpdateOneRequiredWithoutChallengesNestedInput
    track?: ChallengeTrackUpdateOneRequiredWithoutChallengesNestedInput
    timelineTemplate?: TimelineTemplateUpdateOneWithoutChallengesNestedInput
  }

  export type ChallengeUncheckedUpdateWithoutWinnersInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    privateDescription?: NullableStringFieldUpdateOperationsInput | string | null
    challengeSource?: NullableStringFieldUpdateOperationsInput | string | null
    descriptionFormat?: NullableStringFieldUpdateOperationsInput | string | null
    projectId?: NullableIntFieldUpdateOperationsInput | number | null
    typeId?: StringFieldUpdateOperationsInput | string
    trackId?: StringFieldUpdateOperationsInput | string
    timelineTemplateId?: NullableStringFieldUpdateOperationsInput | string | null
    overviewTotalPrizes?: NullableFloatFieldUpdateOperationsInput | number | null
    numOfRegistrants?: IntFieldUpdateOperationsInput | number
    numOfSubmissions?: IntFieldUpdateOperationsInput | number
    numOfCheckpointSubmissions?: IntFieldUpdateOperationsInput | number
    currentPhaseNames?: ChallengeUpdatecurrentPhaseNamesInput | string[]
    wiproAllowed?: BoolFieldUpdateOperationsInput | boolean
    tags?: ChallengeUpdatetagsInput | string[]
    groups?: ChallengeUpdategroupsInput | string[]
    taskIsTask?: BoolFieldUpdateOperationsInput | boolean
    taskIsAssigned?: BoolFieldUpdateOperationsInput | boolean
    taskMemberId?: NullableStringFieldUpdateOperationsInput | string | null
    submissionStartDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    submissionEndDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    registrationStartDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    registrationEndDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    startDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    endDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    legacyId?: NullableIntFieldUpdateOperationsInput | number | null
    status?: EnumChallengeStatusEnumFieldUpdateOperationsInput | $Enums.ChallengeStatusEnum
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdBy?: StringFieldUpdateOperationsInput | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedBy?: StringFieldUpdateOperationsInput | string
    billingRecord?: ChallengeBillingUncheckedUpdateOneWithoutChallengeNestedInput
    legacyRecord?: ChallengeLegacyUncheckedUpdateOneWithoutChallengeNestedInput
    constraintRecord?: ChallengeConstraintUncheckedUpdateOneWithoutChallengeNestedInput
    events?: ChallengeEventUncheckedUpdateManyWithoutChallengeNestedInput
    discussions?: ChallengeDiscussionUncheckedUpdateManyWithoutChallengeNestedInput
    metadata?: ChallengeMetadataUncheckedUpdateManyWithoutChallengeNestedInput
    phases?: ChallengePhaseUncheckedUpdateManyWithoutChallengeNestedInput
    prizeSets?: ChallengePrizeSetUncheckedUpdateManyWithoutChallengeNestedInput
    reviewers?: ChallengeReviewerUncheckedUpdateManyWithoutChallengeNestedInput
    attachments?: AttachmentUncheckedUpdateManyWithoutChallengeNestedInput
    terms?: ChallengeTermUncheckedUpdateManyWithoutChallengeNestedInput
    skills?: ChallengeSkillUncheckedUpdateManyWithoutChallengeNestedInput
    auditLogs?: AuditLogUncheckedUpdateManyWithoutChallengeNestedInput
    memberAccesses?: MemberChallengeAccessUncheckedUpdateManyWithoutChallengeNestedInput
  }

  export type ChallengeCreateWithoutTermsInput = {
    id?: string
    name: string
    description?: string | null
    privateDescription?: string | null
    challengeSource?: string | null
    descriptionFormat?: string | null
    projectId?: number | null
    overviewTotalPrizes?: number | null
    numOfRegistrants?: number
    numOfSubmissions?: number
    numOfCheckpointSubmissions?: number
    currentPhaseNames?: ChallengeCreatecurrentPhaseNamesInput | string[]
    wiproAllowed?: boolean
    tags?: ChallengeCreatetagsInput | string[]
    groups?: ChallengeCreategroupsInput | string[]
    taskIsTask?: boolean
    taskIsAssigned?: boolean
    taskMemberId?: string | null
    submissionStartDate?: Date | string | null
    submissionEndDate?: Date | string | null
    registrationStartDate?: Date | string | null
    registrationEndDate?: Date | string | null
    startDate?: Date | string | null
    endDate?: Date | string | null
    legacyId?: number | null
    status?: $Enums.ChallengeStatusEnum
    createdAt?: Date | string
    createdBy: string
    updatedAt?: Date | string
    updatedBy: string
    billingRecord?: ChallengeBillingCreateNestedOneWithoutChallengeInput
    legacyRecord?: ChallengeLegacyCreateNestedOneWithoutChallengeInput
    constraintRecord?: ChallengeConstraintCreateNestedOneWithoutChallengeInput
    events?: ChallengeEventCreateNestedManyWithoutChallengeInput
    discussions?: ChallengeDiscussionCreateNestedManyWithoutChallengeInput
    metadata?: ChallengeMetadataCreateNestedManyWithoutChallengeInput
    phases?: ChallengePhaseCreateNestedManyWithoutChallengeInput
    prizeSets?: ChallengePrizeSetCreateNestedManyWithoutChallengeInput
    reviewers?: ChallengeReviewerCreateNestedManyWithoutChallengeInput
    winners?: ChallengeWinnerCreateNestedManyWithoutChallengeInput
    attachments?: AttachmentCreateNestedManyWithoutChallengeInput
    skills?: ChallengeSkillCreateNestedManyWithoutChallengeInput
    auditLogs?: AuditLogCreateNestedManyWithoutChallengeInput
    memberAccesses?: MemberChallengeAccessCreateNestedManyWithoutChallengeInput
    type: ChallengeTypeCreateNestedOneWithoutChallengesInput
    track: ChallengeTrackCreateNestedOneWithoutChallengesInput
    timelineTemplate?: TimelineTemplateCreateNestedOneWithoutChallengesInput
  }

  export type ChallengeUncheckedCreateWithoutTermsInput = {
    id?: string
    name: string
    description?: string | null
    privateDescription?: string | null
    challengeSource?: string | null
    descriptionFormat?: string | null
    projectId?: number | null
    typeId: string
    trackId: string
    timelineTemplateId?: string | null
    overviewTotalPrizes?: number | null
    numOfRegistrants?: number
    numOfSubmissions?: number
    numOfCheckpointSubmissions?: number
    currentPhaseNames?: ChallengeCreatecurrentPhaseNamesInput | string[]
    wiproAllowed?: boolean
    tags?: ChallengeCreatetagsInput | string[]
    groups?: ChallengeCreategroupsInput | string[]
    taskIsTask?: boolean
    taskIsAssigned?: boolean
    taskMemberId?: string | null
    submissionStartDate?: Date | string | null
    submissionEndDate?: Date | string | null
    registrationStartDate?: Date | string | null
    registrationEndDate?: Date | string | null
    startDate?: Date | string | null
    endDate?: Date | string | null
    legacyId?: number | null
    status?: $Enums.ChallengeStatusEnum
    createdAt?: Date | string
    createdBy: string
    updatedAt?: Date | string
    updatedBy: string
    billingRecord?: ChallengeBillingUncheckedCreateNestedOneWithoutChallengeInput
    legacyRecord?: ChallengeLegacyUncheckedCreateNestedOneWithoutChallengeInput
    constraintRecord?: ChallengeConstraintUncheckedCreateNestedOneWithoutChallengeInput
    events?: ChallengeEventUncheckedCreateNestedManyWithoutChallengeInput
    discussions?: ChallengeDiscussionUncheckedCreateNestedManyWithoutChallengeInput
    metadata?: ChallengeMetadataUncheckedCreateNestedManyWithoutChallengeInput
    phases?: ChallengePhaseUncheckedCreateNestedManyWithoutChallengeInput
    prizeSets?: ChallengePrizeSetUncheckedCreateNestedManyWithoutChallengeInput
    reviewers?: ChallengeReviewerUncheckedCreateNestedManyWithoutChallengeInput
    winners?: ChallengeWinnerUncheckedCreateNestedManyWithoutChallengeInput
    attachments?: AttachmentUncheckedCreateNestedManyWithoutChallengeInput
    skills?: ChallengeSkillUncheckedCreateNestedManyWithoutChallengeInput
    auditLogs?: AuditLogUncheckedCreateNestedManyWithoutChallengeInput
    memberAccesses?: MemberChallengeAccessUncheckedCreateNestedManyWithoutChallengeInput
  }

  export type ChallengeCreateOrConnectWithoutTermsInput = {
    where: ChallengeWhereUniqueInput
    create: XOR<ChallengeCreateWithoutTermsInput, ChallengeUncheckedCreateWithoutTermsInput>
  }

  export type ChallengeUpsertWithoutTermsInput = {
    update: XOR<ChallengeUpdateWithoutTermsInput, ChallengeUncheckedUpdateWithoutTermsInput>
    create: XOR<ChallengeCreateWithoutTermsInput, ChallengeUncheckedCreateWithoutTermsInput>
    where?: ChallengeWhereInput
  }

  export type ChallengeUpdateToOneWithWhereWithoutTermsInput = {
    where?: ChallengeWhereInput
    data: XOR<ChallengeUpdateWithoutTermsInput, ChallengeUncheckedUpdateWithoutTermsInput>
  }

  export type ChallengeUpdateWithoutTermsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    privateDescription?: NullableStringFieldUpdateOperationsInput | string | null
    challengeSource?: NullableStringFieldUpdateOperationsInput | string | null
    descriptionFormat?: NullableStringFieldUpdateOperationsInput | string | null
    projectId?: NullableIntFieldUpdateOperationsInput | number | null
    overviewTotalPrizes?: NullableFloatFieldUpdateOperationsInput | number | null
    numOfRegistrants?: IntFieldUpdateOperationsInput | number
    numOfSubmissions?: IntFieldUpdateOperationsInput | number
    numOfCheckpointSubmissions?: IntFieldUpdateOperationsInput | number
    currentPhaseNames?: ChallengeUpdatecurrentPhaseNamesInput | string[]
    wiproAllowed?: BoolFieldUpdateOperationsInput | boolean
    tags?: ChallengeUpdatetagsInput | string[]
    groups?: ChallengeUpdategroupsInput | string[]
    taskIsTask?: BoolFieldUpdateOperationsInput | boolean
    taskIsAssigned?: BoolFieldUpdateOperationsInput | boolean
    taskMemberId?: NullableStringFieldUpdateOperationsInput | string | null
    submissionStartDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    submissionEndDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    registrationStartDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    registrationEndDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    startDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    endDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    legacyId?: NullableIntFieldUpdateOperationsInput | number | null
    status?: EnumChallengeStatusEnumFieldUpdateOperationsInput | $Enums.ChallengeStatusEnum
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdBy?: StringFieldUpdateOperationsInput | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedBy?: StringFieldUpdateOperationsInput | string
    billingRecord?: ChallengeBillingUpdateOneWithoutChallengeNestedInput
    legacyRecord?: ChallengeLegacyUpdateOneWithoutChallengeNestedInput
    constraintRecord?: ChallengeConstraintUpdateOneWithoutChallengeNestedInput
    events?: ChallengeEventUpdateManyWithoutChallengeNestedInput
    discussions?: ChallengeDiscussionUpdateManyWithoutChallengeNestedInput
    metadata?: ChallengeMetadataUpdateManyWithoutChallengeNestedInput
    phases?: ChallengePhaseUpdateManyWithoutChallengeNestedInput
    prizeSets?: ChallengePrizeSetUpdateManyWithoutChallengeNestedInput
    reviewers?: ChallengeReviewerUpdateManyWithoutChallengeNestedInput
    winners?: ChallengeWinnerUpdateManyWithoutChallengeNestedInput
    attachments?: AttachmentUpdateManyWithoutChallengeNestedInput
    skills?: ChallengeSkillUpdateManyWithoutChallengeNestedInput
    auditLogs?: AuditLogUpdateManyWithoutChallengeNestedInput
    memberAccesses?: MemberChallengeAccessUpdateManyWithoutChallengeNestedInput
    type?: ChallengeTypeUpdateOneRequiredWithoutChallengesNestedInput
    track?: ChallengeTrackUpdateOneRequiredWithoutChallengesNestedInput
    timelineTemplate?: TimelineTemplateUpdateOneWithoutChallengesNestedInput
  }

  export type ChallengeUncheckedUpdateWithoutTermsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    privateDescription?: NullableStringFieldUpdateOperationsInput | string | null
    challengeSource?: NullableStringFieldUpdateOperationsInput | string | null
    descriptionFormat?: NullableStringFieldUpdateOperationsInput | string | null
    projectId?: NullableIntFieldUpdateOperationsInput | number | null
    typeId?: StringFieldUpdateOperationsInput | string
    trackId?: StringFieldUpdateOperationsInput | string
    timelineTemplateId?: NullableStringFieldUpdateOperationsInput | string | null
    overviewTotalPrizes?: NullableFloatFieldUpdateOperationsInput | number | null
    numOfRegistrants?: IntFieldUpdateOperationsInput | number
    numOfSubmissions?: IntFieldUpdateOperationsInput | number
    numOfCheckpointSubmissions?: IntFieldUpdateOperationsInput | number
    currentPhaseNames?: ChallengeUpdatecurrentPhaseNamesInput | string[]
    wiproAllowed?: BoolFieldUpdateOperationsInput | boolean
    tags?: ChallengeUpdatetagsInput | string[]
    groups?: ChallengeUpdategroupsInput | string[]
    taskIsTask?: BoolFieldUpdateOperationsInput | boolean
    taskIsAssigned?: BoolFieldUpdateOperationsInput | boolean
    taskMemberId?: NullableStringFieldUpdateOperationsInput | string | null
    submissionStartDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    submissionEndDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    registrationStartDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    registrationEndDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    startDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    endDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    legacyId?: NullableIntFieldUpdateOperationsInput | number | null
    status?: EnumChallengeStatusEnumFieldUpdateOperationsInput | $Enums.ChallengeStatusEnum
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdBy?: StringFieldUpdateOperationsInput | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedBy?: StringFieldUpdateOperationsInput | string
    billingRecord?: ChallengeBillingUncheckedUpdateOneWithoutChallengeNestedInput
    legacyRecord?: ChallengeLegacyUncheckedUpdateOneWithoutChallengeNestedInput
    constraintRecord?: ChallengeConstraintUncheckedUpdateOneWithoutChallengeNestedInput
    events?: ChallengeEventUncheckedUpdateManyWithoutChallengeNestedInput
    discussions?: ChallengeDiscussionUncheckedUpdateManyWithoutChallengeNestedInput
    metadata?: ChallengeMetadataUncheckedUpdateManyWithoutChallengeNestedInput
    phases?: ChallengePhaseUncheckedUpdateManyWithoutChallengeNestedInput
    prizeSets?: ChallengePrizeSetUncheckedUpdateManyWithoutChallengeNestedInput
    reviewers?: ChallengeReviewerUncheckedUpdateManyWithoutChallengeNestedInput
    winners?: ChallengeWinnerUncheckedUpdateManyWithoutChallengeNestedInput
    attachments?: AttachmentUncheckedUpdateManyWithoutChallengeNestedInput
    skills?: ChallengeSkillUncheckedUpdateManyWithoutChallengeNestedInput
    auditLogs?: AuditLogUncheckedUpdateManyWithoutChallengeNestedInput
    memberAccesses?: MemberChallengeAccessUncheckedUpdateManyWithoutChallengeNestedInput
  }

  export type ChallengeCreateWithoutSkillsInput = {
    id?: string
    name: string
    description?: string | null
    privateDescription?: string | null
    challengeSource?: string | null
    descriptionFormat?: string | null
    projectId?: number | null
    overviewTotalPrizes?: number | null
    numOfRegistrants?: number
    numOfSubmissions?: number
    numOfCheckpointSubmissions?: number
    currentPhaseNames?: ChallengeCreatecurrentPhaseNamesInput | string[]
    wiproAllowed?: boolean
    tags?: ChallengeCreatetagsInput | string[]
    groups?: ChallengeCreategroupsInput | string[]
    taskIsTask?: boolean
    taskIsAssigned?: boolean
    taskMemberId?: string | null
    submissionStartDate?: Date | string | null
    submissionEndDate?: Date | string | null
    registrationStartDate?: Date | string | null
    registrationEndDate?: Date | string | null
    startDate?: Date | string | null
    endDate?: Date | string | null
    legacyId?: number | null
    status?: $Enums.ChallengeStatusEnum
    createdAt?: Date | string
    createdBy: string
    updatedAt?: Date | string
    updatedBy: string
    billingRecord?: ChallengeBillingCreateNestedOneWithoutChallengeInput
    legacyRecord?: ChallengeLegacyCreateNestedOneWithoutChallengeInput
    constraintRecord?: ChallengeConstraintCreateNestedOneWithoutChallengeInput
    events?: ChallengeEventCreateNestedManyWithoutChallengeInput
    discussions?: ChallengeDiscussionCreateNestedManyWithoutChallengeInput
    metadata?: ChallengeMetadataCreateNestedManyWithoutChallengeInput
    phases?: ChallengePhaseCreateNestedManyWithoutChallengeInput
    prizeSets?: ChallengePrizeSetCreateNestedManyWithoutChallengeInput
    reviewers?: ChallengeReviewerCreateNestedManyWithoutChallengeInput
    winners?: ChallengeWinnerCreateNestedManyWithoutChallengeInput
    attachments?: AttachmentCreateNestedManyWithoutChallengeInput
    terms?: ChallengeTermCreateNestedManyWithoutChallengeInput
    auditLogs?: AuditLogCreateNestedManyWithoutChallengeInput
    memberAccesses?: MemberChallengeAccessCreateNestedManyWithoutChallengeInput
    type: ChallengeTypeCreateNestedOneWithoutChallengesInput
    track: ChallengeTrackCreateNestedOneWithoutChallengesInput
    timelineTemplate?: TimelineTemplateCreateNestedOneWithoutChallengesInput
  }

  export type ChallengeUncheckedCreateWithoutSkillsInput = {
    id?: string
    name: string
    description?: string | null
    privateDescription?: string | null
    challengeSource?: string | null
    descriptionFormat?: string | null
    projectId?: number | null
    typeId: string
    trackId: string
    timelineTemplateId?: string | null
    overviewTotalPrizes?: number | null
    numOfRegistrants?: number
    numOfSubmissions?: number
    numOfCheckpointSubmissions?: number
    currentPhaseNames?: ChallengeCreatecurrentPhaseNamesInput | string[]
    wiproAllowed?: boolean
    tags?: ChallengeCreatetagsInput | string[]
    groups?: ChallengeCreategroupsInput | string[]
    taskIsTask?: boolean
    taskIsAssigned?: boolean
    taskMemberId?: string | null
    submissionStartDate?: Date | string | null
    submissionEndDate?: Date | string | null
    registrationStartDate?: Date | string | null
    registrationEndDate?: Date | string | null
    startDate?: Date | string | null
    endDate?: Date | string | null
    legacyId?: number | null
    status?: $Enums.ChallengeStatusEnum
    createdAt?: Date | string
    createdBy: string
    updatedAt?: Date | string
    updatedBy: string
    billingRecord?: ChallengeBillingUncheckedCreateNestedOneWithoutChallengeInput
    legacyRecord?: ChallengeLegacyUncheckedCreateNestedOneWithoutChallengeInput
    constraintRecord?: ChallengeConstraintUncheckedCreateNestedOneWithoutChallengeInput
    events?: ChallengeEventUncheckedCreateNestedManyWithoutChallengeInput
    discussions?: ChallengeDiscussionUncheckedCreateNestedManyWithoutChallengeInput
    metadata?: ChallengeMetadataUncheckedCreateNestedManyWithoutChallengeInput
    phases?: ChallengePhaseUncheckedCreateNestedManyWithoutChallengeInput
    prizeSets?: ChallengePrizeSetUncheckedCreateNestedManyWithoutChallengeInput
    reviewers?: ChallengeReviewerUncheckedCreateNestedManyWithoutChallengeInput
    winners?: ChallengeWinnerUncheckedCreateNestedManyWithoutChallengeInput
    attachments?: AttachmentUncheckedCreateNestedManyWithoutChallengeInput
    terms?: ChallengeTermUncheckedCreateNestedManyWithoutChallengeInput
    auditLogs?: AuditLogUncheckedCreateNestedManyWithoutChallengeInput
    memberAccesses?: MemberChallengeAccessUncheckedCreateNestedManyWithoutChallengeInput
  }

  export type ChallengeCreateOrConnectWithoutSkillsInput = {
    where: ChallengeWhereUniqueInput
    create: XOR<ChallengeCreateWithoutSkillsInput, ChallengeUncheckedCreateWithoutSkillsInput>
  }

  export type ChallengeUpsertWithoutSkillsInput = {
    update: XOR<ChallengeUpdateWithoutSkillsInput, ChallengeUncheckedUpdateWithoutSkillsInput>
    create: XOR<ChallengeCreateWithoutSkillsInput, ChallengeUncheckedCreateWithoutSkillsInput>
    where?: ChallengeWhereInput
  }

  export type ChallengeUpdateToOneWithWhereWithoutSkillsInput = {
    where?: ChallengeWhereInput
    data: XOR<ChallengeUpdateWithoutSkillsInput, ChallengeUncheckedUpdateWithoutSkillsInput>
  }

  export type ChallengeUpdateWithoutSkillsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    privateDescription?: NullableStringFieldUpdateOperationsInput | string | null
    challengeSource?: NullableStringFieldUpdateOperationsInput | string | null
    descriptionFormat?: NullableStringFieldUpdateOperationsInput | string | null
    projectId?: NullableIntFieldUpdateOperationsInput | number | null
    overviewTotalPrizes?: NullableFloatFieldUpdateOperationsInput | number | null
    numOfRegistrants?: IntFieldUpdateOperationsInput | number
    numOfSubmissions?: IntFieldUpdateOperationsInput | number
    numOfCheckpointSubmissions?: IntFieldUpdateOperationsInput | number
    currentPhaseNames?: ChallengeUpdatecurrentPhaseNamesInput | string[]
    wiproAllowed?: BoolFieldUpdateOperationsInput | boolean
    tags?: ChallengeUpdatetagsInput | string[]
    groups?: ChallengeUpdategroupsInput | string[]
    taskIsTask?: BoolFieldUpdateOperationsInput | boolean
    taskIsAssigned?: BoolFieldUpdateOperationsInput | boolean
    taskMemberId?: NullableStringFieldUpdateOperationsInput | string | null
    submissionStartDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    submissionEndDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    registrationStartDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    registrationEndDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    startDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    endDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    legacyId?: NullableIntFieldUpdateOperationsInput | number | null
    status?: EnumChallengeStatusEnumFieldUpdateOperationsInput | $Enums.ChallengeStatusEnum
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdBy?: StringFieldUpdateOperationsInput | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedBy?: StringFieldUpdateOperationsInput | string
    billingRecord?: ChallengeBillingUpdateOneWithoutChallengeNestedInput
    legacyRecord?: ChallengeLegacyUpdateOneWithoutChallengeNestedInput
    constraintRecord?: ChallengeConstraintUpdateOneWithoutChallengeNestedInput
    events?: ChallengeEventUpdateManyWithoutChallengeNestedInput
    discussions?: ChallengeDiscussionUpdateManyWithoutChallengeNestedInput
    metadata?: ChallengeMetadataUpdateManyWithoutChallengeNestedInput
    phases?: ChallengePhaseUpdateManyWithoutChallengeNestedInput
    prizeSets?: ChallengePrizeSetUpdateManyWithoutChallengeNestedInput
    reviewers?: ChallengeReviewerUpdateManyWithoutChallengeNestedInput
    winners?: ChallengeWinnerUpdateManyWithoutChallengeNestedInput
    attachments?: AttachmentUpdateManyWithoutChallengeNestedInput
    terms?: ChallengeTermUpdateManyWithoutChallengeNestedInput
    auditLogs?: AuditLogUpdateManyWithoutChallengeNestedInput
    memberAccesses?: MemberChallengeAccessUpdateManyWithoutChallengeNestedInput
    type?: ChallengeTypeUpdateOneRequiredWithoutChallengesNestedInput
    track?: ChallengeTrackUpdateOneRequiredWithoutChallengesNestedInput
    timelineTemplate?: TimelineTemplateUpdateOneWithoutChallengesNestedInput
  }

  export type ChallengeUncheckedUpdateWithoutSkillsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    privateDescription?: NullableStringFieldUpdateOperationsInput | string | null
    challengeSource?: NullableStringFieldUpdateOperationsInput | string | null
    descriptionFormat?: NullableStringFieldUpdateOperationsInput | string | null
    projectId?: NullableIntFieldUpdateOperationsInput | number | null
    typeId?: StringFieldUpdateOperationsInput | string
    trackId?: StringFieldUpdateOperationsInput | string
    timelineTemplateId?: NullableStringFieldUpdateOperationsInput | string | null
    overviewTotalPrizes?: NullableFloatFieldUpdateOperationsInput | number | null
    numOfRegistrants?: IntFieldUpdateOperationsInput | number
    numOfSubmissions?: IntFieldUpdateOperationsInput | number
    numOfCheckpointSubmissions?: IntFieldUpdateOperationsInput | number
    currentPhaseNames?: ChallengeUpdatecurrentPhaseNamesInput | string[]
    wiproAllowed?: BoolFieldUpdateOperationsInput | boolean
    tags?: ChallengeUpdatetagsInput | string[]
    groups?: ChallengeUpdategroupsInput | string[]
    taskIsTask?: BoolFieldUpdateOperationsInput | boolean
    taskIsAssigned?: BoolFieldUpdateOperationsInput | boolean
    taskMemberId?: NullableStringFieldUpdateOperationsInput | string | null
    submissionStartDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    submissionEndDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    registrationStartDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    registrationEndDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    startDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    endDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    legacyId?: NullableIntFieldUpdateOperationsInput | number | null
    status?: EnumChallengeStatusEnumFieldUpdateOperationsInput | $Enums.ChallengeStatusEnum
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdBy?: StringFieldUpdateOperationsInput | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedBy?: StringFieldUpdateOperationsInput | string
    billingRecord?: ChallengeBillingUncheckedUpdateOneWithoutChallengeNestedInput
    legacyRecord?: ChallengeLegacyUncheckedUpdateOneWithoutChallengeNestedInput
    constraintRecord?: ChallengeConstraintUncheckedUpdateOneWithoutChallengeNestedInput
    events?: ChallengeEventUncheckedUpdateManyWithoutChallengeNestedInput
    discussions?: ChallengeDiscussionUncheckedUpdateManyWithoutChallengeNestedInput
    metadata?: ChallengeMetadataUncheckedUpdateManyWithoutChallengeNestedInput
    phases?: ChallengePhaseUncheckedUpdateManyWithoutChallengeNestedInput
    prizeSets?: ChallengePrizeSetUncheckedUpdateManyWithoutChallengeNestedInput
    reviewers?: ChallengeReviewerUncheckedUpdateManyWithoutChallengeNestedInput
    winners?: ChallengeWinnerUncheckedUpdateManyWithoutChallengeNestedInput
    attachments?: AttachmentUncheckedUpdateManyWithoutChallengeNestedInput
    terms?: ChallengeTermUncheckedUpdateManyWithoutChallengeNestedInput
    auditLogs?: AuditLogUncheckedUpdateManyWithoutChallengeNestedInput
    memberAccesses?: MemberChallengeAccessUncheckedUpdateManyWithoutChallengeNestedInput
  }

  export type ChallengeCreateWithoutBillingRecordInput = {
    id?: string
    name: string
    description?: string | null
    privateDescription?: string | null
    challengeSource?: string | null
    descriptionFormat?: string | null
    projectId?: number | null
    overviewTotalPrizes?: number | null
    numOfRegistrants?: number
    numOfSubmissions?: number
    numOfCheckpointSubmissions?: number
    currentPhaseNames?: ChallengeCreatecurrentPhaseNamesInput | string[]
    wiproAllowed?: boolean
    tags?: ChallengeCreatetagsInput | string[]
    groups?: ChallengeCreategroupsInput | string[]
    taskIsTask?: boolean
    taskIsAssigned?: boolean
    taskMemberId?: string | null
    submissionStartDate?: Date | string | null
    submissionEndDate?: Date | string | null
    registrationStartDate?: Date | string | null
    registrationEndDate?: Date | string | null
    startDate?: Date | string | null
    endDate?: Date | string | null
    legacyId?: number | null
    status?: $Enums.ChallengeStatusEnum
    createdAt?: Date | string
    createdBy: string
    updatedAt?: Date | string
    updatedBy: string
    legacyRecord?: ChallengeLegacyCreateNestedOneWithoutChallengeInput
    constraintRecord?: ChallengeConstraintCreateNestedOneWithoutChallengeInput
    events?: ChallengeEventCreateNestedManyWithoutChallengeInput
    discussions?: ChallengeDiscussionCreateNestedManyWithoutChallengeInput
    metadata?: ChallengeMetadataCreateNestedManyWithoutChallengeInput
    phases?: ChallengePhaseCreateNestedManyWithoutChallengeInput
    prizeSets?: ChallengePrizeSetCreateNestedManyWithoutChallengeInput
    reviewers?: ChallengeReviewerCreateNestedManyWithoutChallengeInput
    winners?: ChallengeWinnerCreateNestedManyWithoutChallengeInput
    attachments?: AttachmentCreateNestedManyWithoutChallengeInput
    terms?: ChallengeTermCreateNestedManyWithoutChallengeInput
    skills?: ChallengeSkillCreateNestedManyWithoutChallengeInput
    auditLogs?: AuditLogCreateNestedManyWithoutChallengeInput
    memberAccesses?: MemberChallengeAccessCreateNestedManyWithoutChallengeInput
    type: ChallengeTypeCreateNestedOneWithoutChallengesInput
    track: ChallengeTrackCreateNestedOneWithoutChallengesInput
    timelineTemplate?: TimelineTemplateCreateNestedOneWithoutChallengesInput
  }

  export type ChallengeUncheckedCreateWithoutBillingRecordInput = {
    id?: string
    name: string
    description?: string | null
    privateDescription?: string | null
    challengeSource?: string | null
    descriptionFormat?: string | null
    projectId?: number | null
    typeId: string
    trackId: string
    timelineTemplateId?: string | null
    overviewTotalPrizes?: number | null
    numOfRegistrants?: number
    numOfSubmissions?: number
    numOfCheckpointSubmissions?: number
    currentPhaseNames?: ChallengeCreatecurrentPhaseNamesInput | string[]
    wiproAllowed?: boolean
    tags?: ChallengeCreatetagsInput | string[]
    groups?: ChallengeCreategroupsInput | string[]
    taskIsTask?: boolean
    taskIsAssigned?: boolean
    taskMemberId?: string | null
    submissionStartDate?: Date | string | null
    submissionEndDate?: Date | string | null
    registrationStartDate?: Date | string | null
    registrationEndDate?: Date | string | null
    startDate?: Date | string | null
    endDate?: Date | string | null
    legacyId?: number | null
    status?: $Enums.ChallengeStatusEnum
    createdAt?: Date | string
    createdBy: string
    updatedAt?: Date | string
    updatedBy: string
    legacyRecord?: ChallengeLegacyUncheckedCreateNestedOneWithoutChallengeInput
    constraintRecord?: ChallengeConstraintUncheckedCreateNestedOneWithoutChallengeInput
    events?: ChallengeEventUncheckedCreateNestedManyWithoutChallengeInput
    discussions?: ChallengeDiscussionUncheckedCreateNestedManyWithoutChallengeInput
    metadata?: ChallengeMetadataUncheckedCreateNestedManyWithoutChallengeInput
    phases?: ChallengePhaseUncheckedCreateNestedManyWithoutChallengeInput
    prizeSets?: ChallengePrizeSetUncheckedCreateNestedManyWithoutChallengeInput
    reviewers?: ChallengeReviewerUncheckedCreateNestedManyWithoutChallengeInput
    winners?: ChallengeWinnerUncheckedCreateNestedManyWithoutChallengeInput
    attachments?: AttachmentUncheckedCreateNestedManyWithoutChallengeInput
    terms?: ChallengeTermUncheckedCreateNestedManyWithoutChallengeInput
    skills?: ChallengeSkillUncheckedCreateNestedManyWithoutChallengeInput
    auditLogs?: AuditLogUncheckedCreateNestedManyWithoutChallengeInput
    memberAccesses?: MemberChallengeAccessUncheckedCreateNestedManyWithoutChallengeInput
  }

  export type ChallengeCreateOrConnectWithoutBillingRecordInput = {
    where: ChallengeWhereUniqueInput
    create: XOR<ChallengeCreateWithoutBillingRecordInput, ChallengeUncheckedCreateWithoutBillingRecordInput>
  }

  export type ChallengeUpsertWithoutBillingRecordInput = {
    update: XOR<ChallengeUpdateWithoutBillingRecordInput, ChallengeUncheckedUpdateWithoutBillingRecordInput>
    create: XOR<ChallengeCreateWithoutBillingRecordInput, ChallengeUncheckedCreateWithoutBillingRecordInput>
    where?: ChallengeWhereInput
  }

  export type ChallengeUpdateToOneWithWhereWithoutBillingRecordInput = {
    where?: ChallengeWhereInput
    data: XOR<ChallengeUpdateWithoutBillingRecordInput, ChallengeUncheckedUpdateWithoutBillingRecordInput>
  }

  export type ChallengeUpdateWithoutBillingRecordInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    privateDescription?: NullableStringFieldUpdateOperationsInput | string | null
    challengeSource?: NullableStringFieldUpdateOperationsInput | string | null
    descriptionFormat?: NullableStringFieldUpdateOperationsInput | string | null
    projectId?: NullableIntFieldUpdateOperationsInput | number | null
    overviewTotalPrizes?: NullableFloatFieldUpdateOperationsInput | number | null
    numOfRegistrants?: IntFieldUpdateOperationsInput | number
    numOfSubmissions?: IntFieldUpdateOperationsInput | number
    numOfCheckpointSubmissions?: IntFieldUpdateOperationsInput | number
    currentPhaseNames?: ChallengeUpdatecurrentPhaseNamesInput | string[]
    wiproAllowed?: BoolFieldUpdateOperationsInput | boolean
    tags?: ChallengeUpdatetagsInput | string[]
    groups?: ChallengeUpdategroupsInput | string[]
    taskIsTask?: BoolFieldUpdateOperationsInput | boolean
    taskIsAssigned?: BoolFieldUpdateOperationsInput | boolean
    taskMemberId?: NullableStringFieldUpdateOperationsInput | string | null
    submissionStartDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    submissionEndDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    registrationStartDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    registrationEndDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    startDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    endDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    legacyId?: NullableIntFieldUpdateOperationsInput | number | null
    status?: EnumChallengeStatusEnumFieldUpdateOperationsInput | $Enums.ChallengeStatusEnum
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdBy?: StringFieldUpdateOperationsInput | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedBy?: StringFieldUpdateOperationsInput | string
    legacyRecord?: ChallengeLegacyUpdateOneWithoutChallengeNestedInput
    constraintRecord?: ChallengeConstraintUpdateOneWithoutChallengeNestedInput
    events?: ChallengeEventUpdateManyWithoutChallengeNestedInput
    discussions?: ChallengeDiscussionUpdateManyWithoutChallengeNestedInput
    metadata?: ChallengeMetadataUpdateManyWithoutChallengeNestedInput
    phases?: ChallengePhaseUpdateManyWithoutChallengeNestedInput
    prizeSets?: ChallengePrizeSetUpdateManyWithoutChallengeNestedInput
    reviewers?: ChallengeReviewerUpdateManyWithoutChallengeNestedInput
    winners?: ChallengeWinnerUpdateManyWithoutChallengeNestedInput
    attachments?: AttachmentUpdateManyWithoutChallengeNestedInput
    terms?: ChallengeTermUpdateManyWithoutChallengeNestedInput
    skills?: ChallengeSkillUpdateManyWithoutChallengeNestedInput
    auditLogs?: AuditLogUpdateManyWithoutChallengeNestedInput
    memberAccesses?: MemberChallengeAccessUpdateManyWithoutChallengeNestedInput
    type?: ChallengeTypeUpdateOneRequiredWithoutChallengesNestedInput
    track?: ChallengeTrackUpdateOneRequiredWithoutChallengesNestedInput
    timelineTemplate?: TimelineTemplateUpdateOneWithoutChallengesNestedInput
  }

  export type ChallengeUncheckedUpdateWithoutBillingRecordInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    privateDescription?: NullableStringFieldUpdateOperationsInput | string | null
    challengeSource?: NullableStringFieldUpdateOperationsInput | string | null
    descriptionFormat?: NullableStringFieldUpdateOperationsInput | string | null
    projectId?: NullableIntFieldUpdateOperationsInput | number | null
    typeId?: StringFieldUpdateOperationsInput | string
    trackId?: StringFieldUpdateOperationsInput | string
    timelineTemplateId?: NullableStringFieldUpdateOperationsInput | string | null
    overviewTotalPrizes?: NullableFloatFieldUpdateOperationsInput | number | null
    numOfRegistrants?: IntFieldUpdateOperationsInput | number
    numOfSubmissions?: IntFieldUpdateOperationsInput | number
    numOfCheckpointSubmissions?: IntFieldUpdateOperationsInput | number
    currentPhaseNames?: ChallengeUpdatecurrentPhaseNamesInput | string[]
    wiproAllowed?: BoolFieldUpdateOperationsInput | boolean
    tags?: ChallengeUpdatetagsInput | string[]
    groups?: ChallengeUpdategroupsInput | string[]
    taskIsTask?: BoolFieldUpdateOperationsInput | boolean
    taskIsAssigned?: BoolFieldUpdateOperationsInput | boolean
    taskMemberId?: NullableStringFieldUpdateOperationsInput | string | null
    submissionStartDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    submissionEndDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    registrationStartDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    registrationEndDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    startDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    endDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    legacyId?: NullableIntFieldUpdateOperationsInput | number | null
    status?: EnumChallengeStatusEnumFieldUpdateOperationsInput | $Enums.ChallengeStatusEnum
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdBy?: StringFieldUpdateOperationsInput | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedBy?: StringFieldUpdateOperationsInput | string
    legacyRecord?: ChallengeLegacyUncheckedUpdateOneWithoutChallengeNestedInput
    constraintRecord?: ChallengeConstraintUncheckedUpdateOneWithoutChallengeNestedInput
    events?: ChallengeEventUncheckedUpdateManyWithoutChallengeNestedInput
    discussions?: ChallengeDiscussionUncheckedUpdateManyWithoutChallengeNestedInput
    metadata?: ChallengeMetadataUncheckedUpdateManyWithoutChallengeNestedInput
    phases?: ChallengePhaseUncheckedUpdateManyWithoutChallengeNestedInput
    prizeSets?: ChallengePrizeSetUncheckedUpdateManyWithoutChallengeNestedInput
    reviewers?: ChallengeReviewerUncheckedUpdateManyWithoutChallengeNestedInput
    winners?: ChallengeWinnerUncheckedUpdateManyWithoutChallengeNestedInput
    attachments?: AttachmentUncheckedUpdateManyWithoutChallengeNestedInput
    terms?: ChallengeTermUncheckedUpdateManyWithoutChallengeNestedInput
    skills?: ChallengeSkillUncheckedUpdateManyWithoutChallengeNestedInput
    auditLogs?: AuditLogUncheckedUpdateManyWithoutChallengeNestedInput
    memberAccesses?: MemberChallengeAccessUncheckedUpdateManyWithoutChallengeNestedInput
  }

  export type ChallengeCreateWithoutLegacyRecordInput = {
    id?: string
    name: string
    description?: string | null
    privateDescription?: string | null
    challengeSource?: string | null
    descriptionFormat?: string | null
    projectId?: number | null
    overviewTotalPrizes?: number | null
    numOfRegistrants?: number
    numOfSubmissions?: number
    numOfCheckpointSubmissions?: number
    currentPhaseNames?: ChallengeCreatecurrentPhaseNamesInput | string[]
    wiproAllowed?: boolean
    tags?: ChallengeCreatetagsInput | string[]
    groups?: ChallengeCreategroupsInput | string[]
    taskIsTask?: boolean
    taskIsAssigned?: boolean
    taskMemberId?: string | null
    submissionStartDate?: Date | string | null
    submissionEndDate?: Date | string | null
    registrationStartDate?: Date | string | null
    registrationEndDate?: Date | string | null
    startDate?: Date | string | null
    endDate?: Date | string | null
    legacyId?: number | null
    status?: $Enums.ChallengeStatusEnum
    createdAt?: Date | string
    createdBy: string
    updatedAt?: Date | string
    updatedBy: string
    billingRecord?: ChallengeBillingCreateNestedOneWithoutChallengeInput
    constraintRecord?: ChallengeConstraintCreateNestedOneWithoutChallengeInput
    events?: ChallengeEventCreateNestedManyWithoutChallengeInput
    discussions?: ChallengeDiscussionCreateNestedManyWithoutChallengeInput
    metadata?: ChallengeMetadataCreateNestedManyWithoutChallengeInput
    phases?: ChallengePhaseCreateNestedManyWithoutChallengeInput
    prizeSets?: ChallengePrizeSetCreateNestedManyWithoutChallengeInput
    reviewers?: ChallengeReviewerCreateNestedManyWithoutChallengeInput
    winners?: ChallengeWinnerCreateNestedManyWithoutChallengeInput
    attachments?: AttachmentCreateNestedManyWithoutChallengeInput
    terms?: ChallengeTermCreateNestedManyWithoutChallengeInput
    skills?: ChallengeSkillCreateNestedManyWithoutChallengeInput
    auditLogs?: AuditLogCreateNestedManyWithoutChallengeInput
    memberAccesses?: MemberChallengeAccessCreateNestedManyWithoutChallengeInput
    type: ChallengeTypeCreateNestedOneWithoutChallengesInput
    track: ChallengeTrackCreateNestedOneWithoutChallengesInput
    timelineTemplate?: TimelineTemplateCreateNestedOneWithoutChallengesInput
  }

  export type ChallengeUncheckedCreateWithoutLegacyRecordInput = {
    id?: string
    name: string
    description?: string | null
    privateDescription?: string | null
    challengeSource?: string | null
    descriptionFormat?: string | null
    projectId?: number | null
    typeId: string
    trackId: string
    timelineTemplateId?: string | null
    overviewTotalPrizes?: number | null
    numOfRegistrants?: number
    numOfSubmissions?: number
    numOfCheckpointSubmissions?: number
    currentPhaseNames?: ChallengeCreatecurrentPhaseNamesInput | string[]
    wiproAllowed?: boolean
    tags?: ChallengeCreatetagsInput | string[]
    groups?: ChallengeCreategroupsInput | string[]
    taskIsTask?: boolean
    taskIsAssigned?: boolean
    taskMemberId?: string | null
    submissionStartDate?: Date | string | null
    submissionEndDate?: Date | string | null
    registrationStartDate?: Date | string | null
    registrationEndDate?: Date | string | null
    startDate?: Date | string | null
    endDate?: Date | string | null
    legacyId?: number | null
    status?: $Enums.ChallengeStatusEnum
    createdAt?: Date | string
    createdBy: string
    updatedAt?: Date | string
    updatedBy: string
    billingRecord?: ChallengeBillingUncheckedCreateNestedOneWithoutChallengeInput
    constraintRecord?: ChallengeConstraintUncheckedCreateNestedOneWithoutChallengeInput
    events?: ChallengeEventUncheckedCreateNestedManyWithoutChallengeInput
    discussions?: ChallengeDiscussionUncheckedCreateNestedManyWithoutChallengeInput
    metadata?: ChallengeMetadataUncheckedCreateNestedManyWithoutChallengeInput
    phases?: ChallengePhaseUncheckedCreateNestedManyWithoutChallengeInput
    prizeSets?: ChallengePrizeSetUncheckedCreateNestedManyWithoutChallengeInput
    reviewers?: ChallengeReviewerUncheckedCreateNestedManyWithoutChallengeInput
    winners?: ChallengeWinnerUncheckedCreateNestedManyWithoutChallengeInput
    attachments?: AttachmentUncheckedCreateNestedManyWithoutChallengeInput
    terms?: ChallengeTermUncheckedCreateNestedManyWithoutChallengeInput
    skills?: ChallengeSkillUncheckedCreateNestedManyWithoutChallengeInput
    auditLogs?: AuditLogUncheckedCreateNestedManyWithoutChallengeInput
    memberAccesses?: MemberChallengeAccessUncheckedCreateNestedManyWithoutChallengeInput
  }

  export type ChallengeCreateOrConnectWithoutLegacyRecordInput = {
    where: ChallengeWhereUniqueInput
    create: XOR<ChallengeCreateWithoutLegacyRecordInput, ChallengeUncheckedCreateWithoutLegacyRecordInput>
  }

  export type ChallengeUpsertWithoutLegacyRecordInput = {
    update: XOR<ChallengeUpdateWithoutLegacyRecordInput, ChallengeUncheckedUpdateWithoutLegacyRecordInput>
    create: XOR<ChallengeCreateWithoutLegacyRecordInput, ChallengeUncheckedCreateWithoutLegacyRecordInput>
    where?: ChallengeWhereInput
  }

  export type ChallengeUpdateToOneWithWhereWithoutLegacyRecordInput = {
    where?: ChallengeWhereInput
    data: XOR<ChallengeUpdateWithoutLegacyRecordInput, ChallengeUncheckedUpdateWithoutLegacyRecordInput>
  }

  export type ChallengeUpdateWithoutLegacyRecordInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    privateDescription?: NullableStringFieldUpdateOperationsInput | string | null
    challengeSource?: NullableStringFieldUpdateOperationsInput | string | null
    descriptionFormat?: NullableStringFieldUpdateOperationsInput | string | null
    projectId?: NullableIntFieldUpdateOperationsInput | number | null
    overviewTotalPrizes?: NullableFloatFieldUpdateOperationsInput | number | null
    numOfRegistrants?: IntFieldUpdateOperationsInput | number
    numOfSubmissions?: IntFieldUpdateOperationsInput | number
    numOfCheckpointSubmissions?: IntFieldUpdateOperationsInput | number
    currentPhaseNames?: ChallengeUpdatecurrentPhaseNamesInput | string[]
    wiproAllowed?: BoolFieldUpdateOperationsInput | boolean
    tags?: ChallengeUpdatetagsInput | string[]
    groups?: ChallengeUpdategroupsInput | string[]
    taskIsTask?: BoolFieldUpdateOperationsInput | boolean
    taskIsAssigned?: BoolFieldUpdateOperationsInput | boolean
    taskMemberId?: NullableStringFieldUpdateOperationsInput | string | null
    submissionStartDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    submissionEndDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    registrationStartDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    registrationEndDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    startDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    endDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    legacyId?: NullableIntFieldUpdateOperationsInput | number | null
    status?: EnumChallengeStatusEnumFieldUpdateOperationsInput | $Enums.ChallengeStatusEnum
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdBy?: StringFieldUpdateOperationsInput | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedBy?: StringFieldUpdateOperationsInput | string
    billingRecord?: ChallengeBillingUpdateOneWithoutChallengeNestedInput
    constraintRecord?: ChallengeConstraintUpdateOneWithoutChallengeNestedInput
    events?: ChallengeEventUpdateManyWithoutChallengeNestedInput
    discussions?: ChallengeDiscussionUpdateManyWithoutChallengeNestedInput
    metadata?: ChallengeMetadataUpdateManyWithoutChallengeNestedInput
    phases?: ChallengePhaseUpdateManyWithoutChallengeNestedInput
    prizeSets?: ChallengePrizeSetUpdateManyWithoutChallengeNestedInput
    reviewers?: ChallengeReviewerUpdateManyWithoutChallengeNestedInput
    winners?: ChallengeWinnerUpdateManyWithoutChallengeNestedInput
    attachments?: AttachmentUpdateManyWithoutChallengeNestedInput
    terms?: ChallengeTermUpdateManyWithoutChallengeNestedInput
    skills?: ChallengeSkillUpdateManyWithoutChallengeNestedInput
    auditLogs?: AuditLogUpdateManyWithoutChallengeNestedInput
    memberAccesses?: MemberChallengeAccessUpdateManyWithoutChallengeNestedInput
    type?: ChallengeTypeUpdateOneRequiredWithoutChallengesNestedInput
    track?: ChallengeTrackUpdateOneRequiredWithoutChallengesNestedInput
    timelineTemplate?: TimelineTemplateUpdateOneWithoutChallengesNestedInput
  }

  export type ChallengeUncheckedUpdateWithoutLegacyRecordInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    privateDescription?: NullableStringFieldUpdateOperationsInput | string | null
    challengeSource?: NullableStringFieldUpdateOperationsInput | string | null
    descriptionFormat?: NullableStringFieldUpdateOperationsInput | string | null
    projectId?: NullableIntFieldUpdateOperationsInput | number | null
    typeId?: StringFieldUpdateOperationsInput | string
    trackId?: StringFieldUpdateOperationsInput | string
    timelineTemplateId?: NullableStringFieldUpdateOperationsInput | string | null
    overviewTotalPrizes?: NullableFloatFieldUpdateOperationsInput | number | null
    numOfRegistrants?: IntFieldUpdateOperationsInput | number
    numOfSubmissions?: IntFieldUpdateOperationsInput | number
    numOfCheckpointSubmissions?: IntFieldUpdateOperationsInput | number
    currentPhaseNames?: ChallengeUpdatecurrentPhaseNamesInput | string[]
    wiproAllowed?: BoolFieldUpdateOperationsInput | boolean
    tags?: ChallengeUpdatetagsInput | string[]
    groups?: ChallengeUpdategroupsInput | string[]
    taskIsTask?: BoolFieldUpdateOperationsInput | boolean
    taskIsAssigned?: BoolFieldUpdateOperationsInput | boolean
    taskMemberId?: NullableStringFieldUpdateOperationsInput | string | null
    submissionStartDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    submissionEndDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    registrationStartDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    registrationEndDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    startDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    endDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    legacyId?: NullableIntFieldUpdateOperationsInput | number | null
    status?: EnumChallengeStatusEnumFieldUpdateOperationsInput | $Enums.ChallengeStatusEnum
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdBy?: StringFieldUpdateOperationsInput | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedBy?: StringFieldUpdateOperationsInput | string
    billingRecord?: ChallengeBillingUncheckedUpdateOneWithoutChallengeNestedInput
    constraintRecord?: ChallengeConstraintUncheckedUpdateOneWithoutChallengeNestedInput
    events?: ChallengeEventUncheckedUpdateManyWithoutChallengeNestedInput
    discussions?: ChallengeDiscussionUncheckedUpdateManyWithoutChallengeNestedInput
    metadata?: ChallengeMetadataUncheckedUpdateManyWithoutChallengeNestedInput
    phases?: ChallengePhaseUncheckedUpdateManyWithoutChallengeNestedInput
    prizeSets?: ChallengePrizeSetUncheckedUpdateManyWithoutChallengeNestedInput
    reviewers?: ChallengeReviewerUncheckedUpdateManyWithoutChallengeNestedInput
    winners?: ChallengeWinnerUncheckedUpdateManyWithoutChallengeNestedInput
    attachments?: AttachmentUncheckedUpdateManyWithoutChallengeNestedInput
    terms?: ChallengeTermUncheckedUpdateManyWithoutChallengeNestedInput
    skills?: ChallengeSkillUncheckedUpdateManyWithoutChallengeNestedInput
    auditLogs?: AuditLogUncheckedUpdateManyWithoutChallengeNestedInput
    memberAccesses?: MemberChallengeAccessUncheckedUpdateManyWithoutChallengeNestedInput
  }

  export type ChallengeCreateWithoutEventsInput = {
    id?: string
    name: string
    description?: string | null
    privateDescription?: string | null
    challengeSource?: string | null
    descriptionFormat?: string | null
    projectId?: number | null
    overviewTotalPrizes?: number | null
    numOfRegistrants?: number
    numOfSubmissions?: number
    numOfCheckpointSubmissions?: number
    currentPhaseNames?: ChallengeCreatecurrentPhaseNamesInput | string[]
    wiproAllowed?: boolean
    tags?: ChallengeCreatetagsInput | string[]
    groups?: ChallengeCreategroupsInput | string[]
    taskIsTask?: boolean
    taskIsAssigned?: boolean
    taskMemberId?: string | null
    submissionStartDate?: Date | string | null
    submissionEndDate?: Date | string | null
    registrationStartDate?: Date | string | null
    registrationEndDate?: Date | string | null
    startDate?: Date | string | null
    endDate?: Date | string | null
    legacyId?: number | null
    status?: $Enums.ChallengeStatusEnum
    createdAt?: Date | string
    createdBy: string
    updatedAt?: Date | string
    updatedBy: string
    billingRecord?: ChallengeBillingCreateNestedOneWithoutChallengeInput
    legacyRecord?: ChallengeLegacyCreateNestedOneWithoutChallengeInput
    constraintRecord?: ChallengeConstraintCreateNestedOneWithoutChallengeInput
    discussions?: ChallengeDiscussionCreateNestedManyWithoutChallengeInput
    metadata?: ChallengeMetadataCreateNestedManyWithoutChallengeInput
    phases?: ChallengePhaseCreateNestedManyWithoutChallengeInput
    prizeSets?: ChallengePrizeSetCreateNestedManyWithoutChallengeInput
    reviewers?: ChallengeReviewerCreateNestedManyWithoutChallengeInput
    winners?: ChallengeWinnerCreateNestedManyWithoutChallengeInput
    attachments?: AttachmentCreateNestedManyWithoutChallengeInput
    terms?: ChallengeTermCreateNestedManyWithoutChallengeInput
    skills?: ChallengeSkillCreateNestedManyWithoutChallengeInput
    auditLogs?: AuditLogCreateNestedManyWithoutChallengeInput
    memberAccesses?: MemberChallengeAccessCreateNestedManyWithoutChallengeInput
    type: ChallengeTypeCreateNestedOneWithoutChallengesInput
    track: ChallengeTrackCreateNestedOneWithoutChallengesInput
    timelineTemplate?: TimelineTemplateCreateNestedOneWithoutChallengesInput
  }

  export type ChallengeUncheckedCreateWithoutEventsInput = {
    id?: string
    name: string
    description?: string | null
    privateDescription?: string | null
    challengeSource?: string | null
    descriptionFormat?: string | null
    projectId?: number | null
    typeId: string
    trackId: string
    timelineTemplateId?: string | null
    overviewTotalPrizes?: number | null
    numOfRegistrants?: number
    numOfSubmissions?: number
    numOfCheckpointSubmissions?: number
    currentPhaseNames?: ChallengeCreatecurrentPhaseNamesInput | string[]
    wiproAllowed?: boolean
    tags?: ChallengeCreatetagsInput | string[]
    groups?: ChallengeCreategroupsInput | string[]
    taskIsTask?: boolean
    taskIsAssigned?: boolean
    taskMemberId?: string | null
    submissionStartDate?: Date | string | null
    submissionEndDate?: Date | string | null
    registrationStartDate?: Date | string | null
    registrationEndDate?: Date | string | null
    startDate?: Date | string | null
    endDate?: Date | string | null
    legacyId?: number | null
    status?: $Enums.ChallengeStatusEnum
    createdAt?: Date | string
    createdBy: string
    updatedAt?: Date | string
    updatedBy: string
    billingRecord?: ChallengeBillingUncheckedCreateNestedOneWithoutChallengeInput
    legacyRecord?: ChallengeLegacyUncheckedCreateNestedOneWithoutChallengeInput
    constraintRecord?: ChallengeConstraintUncheckedCreateNestedOneWithoutChallengeInput
    discussions?: ChallengeDiscussionUncheckedCreateNestedManyWithoutChallengeInput
    metadata?: ChallengeMetadataUncheckedCreateNestedManyWithoutChallengeInput
    phases?: ChallengePhaseUncheckedCreateNestedManyWithoutChallengeInput
    prizeSets?: ChallengePrizeSetUncheckedCreateNestedManyWithoutChallengeInput
    reviewers?: ChallengeReviewerUncheckedCreateNestedManyWithoutChallengeInput
    winners?: ChallengeWinnerUncheckedCreateNestedManyWithoutChallengeInput
    attachments?: AttachmentUncheckedCreateNestedManyWithoutChallengeInput
    terms?: ChallengeTermUncheckedCreateNestedManyWithoutChallengeInput
    skills?: ChallengeSkillUncheckedCreateNestedManyWithoutChallengeInput
    auditLogs?: AuditLogUncheckedCreateNestedManyWithoutChallengeInput
    memberAccesses?: MemberChallengeAccessUncheckedCreateNestedManyWithoutChallengeInput
  }

  export type ChallengeCreateOrConnectWithoutEventsInput = {
    where: ChallengeWhereUniqueInput
    create: XOR<ChallengeCreateWithoutEventsInput, ChallengeUncheckedCreateWithoutEventsInput>
  }

  export type ChallengeUpsertWithoutEventsInput = {
    update: XOR<ChallengeUpdateWithoutEventsInput, ChallengeUncheckedUpdateWithoutEventsInput>
    create: XOR<ChallengeCreateWithoutEventsInput, ChallengeUncheckedCreateWithoutEventsInput>
    where?: ChallengeWhereInput
  }

  export type ChallengeUpdateToOneWithWhereWithoutEventsInput = {
    where?: ChallengeWhereInput
    data: XOR<ChallengeUpdateWithoutEventsInput, ChallengeUncheckedUpdateWithoutEventsInput>
  }

  export type ChallengeUpdateWithoutEventsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    privateDescription?: NullableStringFieldUpdateOperationsInput | string | null
    challengeSource?: NullableStringFieldUpdateOperationsInput | string | null
    descriptionFormat?: NullableStringFieldUpdateOperationsInput | string | null
    projectId?: NullableIntFieldUpdateOperationsInput | number | null
    overviewTotalPrizes?: NullableFloatFieldUpdateOperationsInput | number | null
    numOfRegistrants?: IntFieldUpdateOperationsInput | number
    numOfSubmissions?: IntFieldUpdateOperationsInput | number
    numOfCheckpointSubmissions?: IntFieldUpdateOperationsInput | number
    currentPhaseNames?: ChallengeUpdatecurrentPhaseNamesInput | string[]
    wiproAllowed?: BoolFieldUpdateOperationsInput | boolean
    tags?: ChallengeUpdatetagsInput | string[]
    groups?: ChallengeUpdategroupsInput | string[]
    taskIsTask?: BoolFieldUpdateOperationsInput | boolean
    taskIsAssigned?: BoolFieldUpdateOperationsInput | boolean
    taskMemberId?: NullableStringFieldUpdateOperationsInput | string | null
    submissionStartDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    submissionEndDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    registrationStartDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    registrationEndDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    startDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    endDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    legacyId?: NullableIntFieldUpdateOperationsInput | number | null
    status?: EnumChallengeStatusEnumFieldUpdateOperationsInput | $Enums.ChallengeStatusEnum
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdBy?: StringFieldUpdateOperationsInput | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedBy?: StringFieldUpdateOperationsInput | string
    billingRecord?: ChallengeBillingUpdateOneWithoutChallengeNestedInput
    legacyRecord?: ChallengeLegacyUpdateOneWithoutChallengeNestedInput
    constraintRecord?: ChallengeConstraintUpdateOneWithoutChallengeNestedInput
    discussions?: ChallengeDiscussionUpdateManyWithoutChallengeNestedInput
    metadata?: ChallengeMetadataUpdateManyWithoutChallengeNestedInput
    phases?: ChallengePhaseUpdateManyWithoutChallengeNestedInput
    prizeSets?: ChallengePrizeSetUpdateManyWithoutChallengeNestedInput
    reviewers?: ChallengeReviewerUpdateManyWithoutChallengeNestedInput
    winners?: ChallengeWinnerUpdateManyWithoutChallengeNestedInput
    attachments?: AttachmentUpdateManyWithoutChallengeNestedInput
    terms?: ChallengeTermUpdateManyWithoutChallengeNestedInput
    skills?: ChallengeSkillUpdateManyWithoutChallengeNestedInput
    auditLogs?: AuditLogUpdateManyWithoutChallengeNestedInput
    memberAccesses?: MemberChallengeAccessUpdateManyWithoutChallengeNestedInput
    type?: ChallengeTypeUpdateOneRequiredWithoutChallengesNestedInput
    track?: ChallengeTrackUpdateOneRequiredWithoutChallengesNestedInput
    timelineTemplate?: TimelineTemplateUpdateOneWithoutChallengesNestedInput
  }

  export type ChallengeUncheckedUpdateWithoutEventsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    privateDescription?: NullableStringFieldUpdateOperationsInput | string | null
    challengeSource?: NullableStringFieldUpdateOperationsInput | string | null
    descriptionFormat?: NullableStringFieldUpdateOperationsInput | string | null
    projectId?: NullableIntFieldUpdateOperationsInput | number | null
    typeId?: StringFieldUpdateOperationsInput | string
    trackId?: StringFieldUpdateOperationsInput | string
    timelineTemplateId?: NullableStringFieldUpdateOperationsInput | string | null
    overviewTotalPrizes?: NullableFloatFieldUpdateOperationsInput | number | null
    numOfRegistrants?: IntFieldUpdateOperationsInput | number
    numOfSubmissions?: IntFieldUpdateOperationsInput | number
    numOfCheckpointSubmissions?: IntFieldUpdateOperationsInput | number
    currentPhaseNames?: ChallengeUpdatecurrentPhaseNamesInput | string[]
    wiproAllowed?: BoolFieldUpdateOperationsInput | boolean
    tags?: ChallengeUpdatetagsInput | string[]
    groups?: ChallengeUpdategroupsInput | string[]
    taskIsTask?: BoolFieldUpdateOperationsInput | boolean
    taskIsAssigned?: BoolFieldUpdateOperationsInput | boolean
    taskMemberId?: NullableStringFieldUpdateOperationsInput | string | null
    submissionStartDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    submissionEndDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    registrationStartDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    registrationEndDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    startDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    endDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    legacyId?: NullableIntFieldUpdateOperationsInput | number | null
    status?: EnumChallengeStatusEnumFieldUpdateOperationsInput | $Enums.ChallengeStatusEnum
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdBy?: StringFieldUpdateOperationsInput | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedBy?: StringFieldUpdateOperationsInput | string
    billingRecord?: ChallengeBillingUncheckedUpdateOneWithoutChallengeNestedInput
    legacyRecord?: ChallengeLegacyUncheckedUpdateOneWithoutChallengeNestedInput
    constraintRecord?: ChallengeConstraintUncheckedUpdateOneWithoutChallengeNestedInput
    discussions?: ChallengeDiscussionUncheckedUpdateManyWithoutChallengeNestedInput
    metadata?: ChallengeMetadataUncheckedUpdateManyWithoutChallengeNestedInput
    phases?: ChallengePhaseUncheckedUpdateManyWithoutChallengeNestedInput
    prizeSets?: ChallengePrizeSetUncheckedUpdateManyWithoutChallengeNestedInput
    reviewers?: ChallengeReviewerUncheckedUpdateManyWithoutChallengeNestedInput
    winners?: ChallengeWinnerUncheckedUpdateManyWithoutChallengeNestedInput
    attachments?: AttachmentUncheckedUpdateManyWithoutChallengeNestedInput
    terms?: ChallengeTermUncheckedUpdateManyWithoutChallengeNestedInput
    skills?: ChallengeSkillUncheckedUpdateManyWithoutChallengeNestedInput
    auditLogs?: AuditLogUncheckedUpdateManyWithoutChallengeNestedInput
    memberAccesses?: MemberChallengeAccessUncheckedUpdateManyWithoutChallengeNestedInput
  }

  export type ChallengeCreateWithoutDiscussionsInput = {
    id?: string
    name: string
    description?: string | null
    privateDescription?: string | null
    challengeSource?: string | null
    descriptionFormat?: string | null
    projectId?: number | null
    overviewTotalPrizes?: number | null
    numOfRegistrants?: number
    numOfSubmissions?: number
    numOfCheckpointSubmissions?: number
    currentPhaseNames?: ChallengeCreatecurrentPhaseNamesInput | string[]
    wiproAllowed?: boolean
    tags?: ChallengeCreatetagsInput | string[]
    groups?: ChallengeCreategroupsInput | string[]
    taskIsTask?: boolean
    taskIsAssigned?: boolean
    taskMemberId?: string | null
    submissionStartDate?: Date | string | null
    submissionEndDate?: Date | string | null
    registrationStartDate?: Date | string | null
    registrationEndDate?: Date | string | null
    startDate?: Date | string | null
    endDate?: Date | string | null
    legacyId?: number | null
    status?: $Enums.ChallengeStatusEnum
    createdAt?: Date | string
    createdBy: string
    updatedAt?: Date | string
    updatedBy: string
    billingRecord?: ChallengeBillingCreateNestedOneWithoutChallengeInput
    legacyRecord?: ChallengeLegacyCreateNestedOneWithoutChallengeInput
    constraintRecord?: ChallengeConstraintCreateNestedOneWithoutChallengeInput
    events?: ChallengeEventCreateNestedManyWithoutChallengeInput
    metadata?: ChallengeMetadataCreateNestedManyWithoutChallengeInput
    phases?: ChallengePhaseCreateNestedManyWithoutChallengeInput
    prizeSets?: ChallengePrizeSetCreateNestedManyWithoutChallengeInput
    reviewers?: ChallengeReviewerCreateNestedManyWithoutChallengeInput
    winners?: ChallengeWinnerCreateNestedManyWithoutChallengeInput
    attachments?: AttachmentCreateNestedManyWithoutChallengeInput
    terms?: ChallengeTermCreateNestedManyWithoutChallengeInput
    skills?: ChallengeSkillCreateNestedManyWithoutChallengeInput
    auditLogs?: AuditLogCreateNestedManyWithoutChallengeInput
    memberAccesses?: MemberChallengeAccessCreateNestedManyWithoutChallengeInput
    type: ChallengeTypeCreateNestedOneWithoutChallengesInput
    track: ChallengeTrackCreateNestedOneWithoutChallengesInput
    timelineTemplate?: TimelineTemplateCreateNestedOneWithoutChallengesInput
  }

  export type ChallengeUncheckedCreateWithoutDiscussionsInput = {
    id?: string
    name: string
    description?: string | null
    privateDescription?: string | null
    challengeSource?: string | null
    descriptionFormat?: string | null
    projectId?: number | null
    typeId: string
    trackId: string
    timelineTemplateId?: string | null
    overviewTotalPrizes?: number | null
    numOfRegistrants?: number
    numOfSubmissions?: number
    numOfCheckpointSubmissions?: number
    currentPhaseNames?: ChallengeCreatecurrentPhaseNamesInput | string[]
    wiproAllowed?: boolean
    tags?: ChallengeCreatetagsInput | string[]
    groups?: ChallengeCreategroupsInput | string[]
    taskIsTask?: boolean
    taskIsAssigned?: boolean
    taskMemberId?: string | null
    submissionStartDate?: Date | string | null
    submissionEndDate?: Date | string | null
    registrationStartDate?: Date | string | null
    registrationEndDate?: Date | string | null
    startDate?: Date | string | null
    endDate?: Date | string | null
    legacyId?: number | null
    status?: $Enums.ChallengeStatusEnum
    createdAt?: Date | string
    createdBy: string
    updatedAt?: Date | string
    updatedBy: string
    billingRecord?: ChallengeBillingUncheckedCreateNestedOneWithoutChallengeInput
    legacyRecord?: ChallengeLegacyUncheckedCreateNestedOneWithoutChallengeInput
    constraintRecord?: ChallengeConstraintUncheckedCreateNestedOneWithoutChallengeInput
    events?: ChallengeEventUncheckedCreateNestedManyWithoutChallengeInput
    metadata?: ChallengeMetadataUncheckedCreateNestedManyWithoutChallengeInput
    phases?: ChallengePhaseUncheckedCreateNestedManyWithoutChallengeInput
    prizeSets?: ChallengePrizeSetUncheckedCreateNestedManyWithoutChallengeInput
    reviewers?: ChallengeReviewerUncheckedCreateNestedManyWithoutChallengeInput
    winners?: ChallengeWinnerUncheckedCreateNestedManyWithoutChallengeInput
    attachments?: AttachmentUncheckedCreateNestedManyWithoutChallengeInput
    terms?: ChallengeTermUncheckedCreateNestedManyWithoutChallengeInput
    skills?: ChallengeSkillUncheckedCreateNestedManyWithoutChallengeInput
    auditLogs?: AuditLogUncheckedCreateNestedManyWithoutChallengeInput
    memberAccesses?: MemberChallengeAccessUncheckedCreateNestedManyWithoutChallengeInput
  }

  export type ChallengeCreateOrConnectWithoutDiscussionsInput = {
    where: ChallengeWhereUniqueInput
    create: XOR<ChallengeCreateWithoutDiscussionsInput, ChallengeUncheckedCreateWithoutDiscussionsInput>
  }

  export type ChallengeDiscussionOptionCreateWithoutDiscussionInput = {
    id?: string
    optionKey: string
    optionValue: string
    createdAt?: Date | string
    createdBy: string
    updatedAt?: Date | string
    updatedBy: string
  }

  export type ChallengeDiscussionOptionUncheckedCreateWithoutDiscussionInput = {
    id?: string
    optionKey: string
    optionValue: string
    createdAt?: Date | string
    createdBy: string
    updatedAt?: Date | string
    updatedBy: string
  }

  export type ChallengeDiscussionOptionCreateOrConnectWithoutDiscussionInput = {
    where: ChallengeDiscussionOptionWhereUniqueInput
    create: XOR<ChallengeDiscussionOptionCreateWithoutDiscussionInput, ChallengeDiscussionOptionUncheckedCreateWithoutDiscussionInput>
  }

  export type ChallengeDiscussionOptionCreateManyDiscussionInputEnvelope = {
    data: ChallengeDiscussionOptionCreateManyDiscussionInput | ChallengeDiscussionOptionCreateManyDiscussionInput[]
    skipDuplicates?: boolean
  }

  export type ChallengeUpsertWithoutDiscussionsInput = {
    update: XOR<ChallengeUpdateWithoutDiscussionsInput, ChallengeUncheckedUpdateWithoutDiscussionsInput>
    create: XOR<ChallengeCreateWithoutDiscussionsInput, ChallengeUncheckedCreateWithoutDiscussionsInput>
    where?: ChallengeWhereInput
  }

  export type ChallengeUpdateToOneWithWhereWithoutDiscussionsInput = {
    where?: ChallengeWhereInput
    data: XOR<ChallengeUpdateWithoutDiscussionsInput, ChallengeUncheckedUpdateWithoutDiscussionsInput>
  }

  export type ChallengeUpdateWithoutDiscussionsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    privateDescription?: NullableStringFieldUpdateOperationsInput | string | null
    challengeSource?: NullableStringFieldUpdateOperationsInput | string | null
    descriptionFormat?: NullableStringFieldUpdateOperationsInput | string | null
    projectId?: NullableIntFieldUpdateOperationsInput | number | null
    overviewTotalPrizes?: NullableFloatFieldUpdateOperationsInput | number | null
    numOfRegistrants?: IntFieldUpdateOperationsInput | number
    numOfSubmissions?: IntFieldUpdateOperationsInput | number
    numOfCheckpointSubmissions?: IntFieldUpdateOperationsInput | number
    currentPhaseNames?: ChallengeUpdatecurrentPhaseNamesInput | string[]
    wiproAllowed?: BoolFieldUpdateOperationsInput | boolean
    tags?: ChallengeUpdatetagsInput | string[]
    groups?: ChallengeUpdategroupsInput | string[]
    taskIsTask?: BoolFieldUpdateOperationsInput | boolean
    taskIsAssigned?: BoolFieldUpdateOperationsInput | boolean
    taskMemberId?: NullableStringFieldUpdateOperationsInput | string | null
    submissionStartDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    submissionEndDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    registrationStartDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    registrationEndDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    startDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    endDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    legacyId?: NullableIntFieldUpdateOperationsInput | number | null
    status?: EnumChallengeStatusEnumFieldUpdateOperationsInput | $Enums.ChallengeStatusEnum
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdBy?: StringFieldUpdateOperationsInput | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedBy?: StringFieldUpdateOperationsInput | string
    billingRecord?: ChallengeBillingUpdateOneWithoutChallengeNestedInput
    legacyRecord?: ChallengeLegacyUpdateOneWithoutChallengeNestedInput
    constraintRecord?: ChallengeConstraintUpdateOneWithoutChallengeNestedInput
    events?: ChallengeEventUpdateManyWithoutChallengeNestedInput
    metadata?: ChallengeMetadataUpdateManyWithoutChallengeNestedInput
    phases?: ChallengePhaseUpdateManyWithoutChallengeNestedInput
    prizeSets?: ChallengePrizeSetUpdateManyWithoutChallengeNestedInput
    reviewers?: ChallengeReviewerUpdateManyWithoutChallengeNestedInput
    winners?: ChallengeWinnerUpdateManyWithoutChallengeNestedInput
    attachments?: AttachmentUpdateManyWithoutChallengeNestedInput
    terms?: ChallengeTermUpdateManyWithoutChallengeNestedInput
    skills?: ChallengeSkillUpdateManyWithoutChallengeNestedInput
    auditLogs?: AuditLogUpdateManyWithoutChallengeNestedInput
    memberAccesses?: MemberChallengeAccessUpdateManyWithoutChallengeNestedInput
    type?: ChallengeTypeUpdateOneRequiredWithoutChallengesNestedInput
    track?: ChallengeTrackUpdateOneRequiredWithoutChallengesNestedInput
    timelineTemplate?: TimelineTemplateUpdateOneWithoutChallengesNestedInput
  }

  export type ChallengeUncheckedUpdateWithoutDiscussionsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    privateDescription?: NullableStringFieldUpdateOperationsInput | string | null
    challengeSource?: NullableStringFieldUpdateOperationsInput | string | null
    descriptionFormat?: NullableStringFieldUpdateOperationsInput | string | null
    projectId?: NullableIntFieldUpdateOperationsInput | number | null
    typeId?: StringFieldUpdateOperationsInput | string
    trackId?: StringFieldUpdateOperationsInput | string
    timelineTemplateId?: NullableStringFieldUpdateOperationsInput | string | null
    overviewTotalPrizes?: NullableFloatFieldUpdateOperationsInput | number | null
    numOfRegistrants?: IntFieldUpdateOperationsInput | number
    numOfSubmissions?: IntFieldUpdateOperationsInput | number
    numOfCheckpointSubmissions?: IntFieldUpdateOperationsInput | number
    currentPhaseNames?: ChallengeUpdatecurrentPhaseNamesInput | string[]
    wiproAllowed?: BoolFieldUpdateOperationsInput | boolean
    tags?: ChallengeUpdatetagsInput | string[]
    groups?: ChallengeUpdategroupsInput | string[]
    taskIsTask?: BoolFieldUpdateOperationsInput | boolean
    taskIsAssigned?: BoolFieldUpdateOperationsInput | boolean
    taskMemberId?: NullableStringFieldUpdateOperationsInput | string | null
    submissionStartDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    submissionEndDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    registrationStartDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    registrationEndDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    startDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    endDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    legacyId?: NullableIntFieldUpdateOperationsInput | number | null
    status?: EnumChallengeStatusEnumFieldUpdateOperationsInput | $Enums.ChallengeStatusEnum
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdBy?: StringFieldUpdateOperationsInput | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedBy?: StringFieldUpdateOperationsInput | string
    billingRecord?: ChallengeBillingUncheckedUpdateOneWithoutChallengeNestedInput
    legacyRecord?: ChallengeLegacyUncheckedUpdateOneWithoutChallengeNestedInput
    constraintRecord?: ChallengeConstraintUncheckedUpdateOneWithoutChallengeNestedInput
    events?: ChallengeEventUncheckedUpdateManyWithoutChallengeNestedInput
    metadata?: ChallengeMetadataUncheckedUpdateManyWithoutChallengeNestedInput
    phases?: ChallengePhaseUncheckedUpdateManyWithoutChallengeNestedInput
    prizeSets?: ChallengePrizeSetUncheckedUpdateManyWithoutChallengeNestedInput
    reviewers?: ChallengeReviewerUncheckedUpdateManyWithoutChallengeNestedInput
    winners?: ChallengeWinnerUncheckedUpdateManyWithoutChallengeNestedInput
    attachments?: AttachmentUncheckedUpdateManyWithoutChallengeNestedInput
    terms?: ChallengeTermUncheckedUpdateManyWithoutChallengeNestedInput
    skills?: ChallengeSkillUncheckedUpdateManyWithoutChallengeNestedInput
    auditLogs?: AuditLogUncheckedUpdateManyWithoutChallengeNestedInput
    memberAccesses?: MemberChallengeAccessUncheckedUpdateManyWithoutChallengeNestedInput
  }

  export type ChallengeDiscussionOptionUpsertWithWhereUniqueWithoutDiscussionInput = {
    where: ChallengeDiscussionOptionWhereUniqueInput
    update: XOR<ChallengeDiscussionOptionUpdateWithoutDiscussionInput, ChallengeDiscussionOptionUncheckedUpdateWithoutDiscussionInput>
    create: XOR<ChallengeDiscussionOptionCreateWithoutDiscussionInput, ChallengeDiscussionOptionUncheckedCreateWithoutDiscussionInput>
  }

  export type ChallengeDiscussionOptionUpdateWithWhereUniqueWithoutDiscussionInput = {
    where: ChallengeDiscussionOptionWhereUniqueInput
    data: XOR<ChallengeDiscussionOptionUpdateWithoutDiscussionInput, ChallengeDiscussionOptionUncheckedUpdateWithoutDiscussionInput>
  }

  export type ChallengeDiscussionOptionUpdateManyWithWhereWithoutDiscussionInput = {
    where: ChallengeDiscussionOptionScalarWhereInput
    data: XOR<ChallengeDiscussionOptionUpdateManyMutationInput, ChallengeDiscussionOptionUncheckedUpdateManyWithoutDiscussionInput>
  }

  export type ChallengeDiscussionOptionScalarWhereInput = {
    AND?: ChallengeDiscussionOptionScalarWhereInput | ChallengeDiscussionOptionScalarWhereInput[]
    OR?: ChallengeDiscussionOptionScalarWhereInput[]
    NOT?: ChallengeDiscussionOptionScalarWhereInput | ChallengeDiscussionOptionScalarWhereInput[]
    id?: StringFilter<"ChallengeDiscussionOption"> | string
    discussionId?: StringFilter<"ChallengeDiscussionOption"> | string
    optionKey?: StringFilter<"ChallengeDiscussionOption"> | string
    optionValue?: StringFilter<"ChallengeDiscussionOption"> | string
    createdAt?: DateTimeFilter<"ChallengeDiscussionOption"> | Date | string
    createdBy?: StringFilter<"ChallengeDiscussionOption"> | string
    updatedAt?: DateTimeFilter<"ChallengeDiscussionOption"> | Date | string
    updatedBy?: StringFilter<"ChallengeDiscussionOption"> | string
  }

  export type ChallengeDiscussionCreateWithoutOptionsInput = {
    id?: string
    discussionId?: string | null
    name: string
    type: $Enums.DiscussionTypeEnum
    provider: string
    url?: string | null
    createdAt?: Date | string
    createdBy: string
    updatedAt?: Date | string
    updatedBy: string
    challenge: ChallengeCreateNestedOneWithoutDiscussionsInput
  }

  export type ChallengeDiscussionUncheckedCreateWithoutOptionsInput = {
    id?: string
    challengeId: string
    discussionId?: string | null
    name: string
    type: $Enums.DiscussionTypeEnum
    provider: string
    url?: string | null
    createdAt?: Date | string
    createdBy: string
    updatedAt?: Date | string
    updatedBy: string
  }

  export type ChallengeDiscussionCreateOrConnectWithoutOptionsInput = {
    where: ChallengeDiscussionWhereUniqueInput
    create: XOR<ChallengeDiscussionCreateWithoutOptionsInput, ChallengeDiscussionUncheckedCreateWithoutOptionsInput>
  }

  export type ChallengeDiscussionUpsertWithoutOptionsInput = {
    update: XOR<ChallengeDiscussionUpdateWithoutOptionsInput, ChallengeDiscussionUncheckedUpdateWithoutOptionsInput>
    create: XOR<ChallengeDiscussionCreateWithoutOptionsInput, ChallengeDiscussionUncheckedCreateWithoutOptionsInput>
    where?: ChallengeDiscussionWhereInput
  }

  export type ChallengeDiscussionUpdateToOneWithWhereWithoutOptionsInput = {
    where?: ChallengeDiscussionWhereInput
    data: XOR<ChallengeDiscussionUpdateWithoutOptionsInput, ChallengeDiscussionUncheckedUpdateWithoutOptionsInput>
  }

  export type ChallengeDiscussionUpdateWithoutOptionsInput = {
    id?: StringFieldUpdateOperationsInput | string
    discussionId?: NullableStringFieldUpdateOperationsInput | string | null
    name?: StringFieldUpdateOperationsInput | string
    type?: EnumDiscussionTypeEnumFieldUpdateOperationsInput | $Enums.DiscussionTypeEnum
    provider?: StringFieldUpdateOperationsInput | string
    url?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdBy?: StringFieldUpdateOperationsInput | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedBy?: StringFieldUpdateOperationsInput | string
    challenge?: ChallengeUpdateOneRequiredWithoutDiscussionsNestedInput
  }

  export type ChallengeDiscussionUncheckedUpdateWithoutOptionsInput = {
    id?: StringFieldUpdateOperationsInput | string
    challengeId?: StringFieldUpdateOperationsInput | string
    discussionId?: NullableStringFieldUpdateOperationsInput | string | null
    name?: StringFieldUpdateOperationsInput | string
    type?: EnumDiscussionTypeEnumFieldUpdateOperationsInput | $Enums.DiscussionTypeEnum
    provider?: StringFieldUpdateOperationsInput | string
    url?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdBy?: StringFieldUpdateOperationsInput | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedBy?: StringFieldUpdateOperationsInput | string
  }

  export type ChallengeCreateWithoutConstraintRecordInput = {
    id?: string
    name: string
    description?: string | null
    privateDescription?: string | null
    challengeSource?: string | null
    descriptionFormat?: string | null
    projectId?: number | null
    overviewTotalPrizes?: number | null
    numOfRegistrants?: number
    numOfSubmissions?: number
    numOfCheckpointSubmissions?: number
    currentPhaseNames?: ChallengeCreatecurrentPhaseNamesInput | string[]
    wiproAllowed?: boolean
    tags?: ChallengeCreatetagsInput | string[]
    groups?: ChallengeCreategroupsInput | string[]
    taskIsTask?: boolean
    taskIsAssigned?: boolean
    taskMemberId?: string | null
    submissionStartDate?: Date | string | null
    submissionEndDate?: Date | string | null
    registrationStartDate?: Date | string | null
    registrationEndDate?: Date | string | null
    startDate?: Date | string | null
    endDate?: Date | string | null
    legacyId?: number | null
    status?: $Enums.ChallengeStatusEnum
    createdAt?: Date | string
    createdBy: string
    updatedAt?: Date | string
    updatedBy: string
    billingRecord?: ChallengeBillingCreateNestedOneWithoutChallengeInput
    legacyRecord?: ChallengeLegacyCreateNestedOneWithoutChallengeInput
    events?: ChallengeEventCreateNestedManyWithoutChallengeInput
    discussions?: ChallengeDiscussionCreateNestedManyWithoutChallengeInput
    metadata?: ChallengeMetadataCreateNestedManyWithoutChallengeInput
    phases?: ChallengePhaseCreateNestedManyWithoutChallengeInput
    prizeSets?: ChallengePrizeSetCreateNestedManyWithoutChallengeInput
    reviewers?: ChallengeReviewerCreateNestedManyWithoutChallengeInput
    winners?: ChallengeWinnerCreateNestedManyWithoutChallengeInput
    attachments?: AttachmentCreateNestedManyWithoutChallengeInput
    terms?: ChallengeTermCreateNestedManyWithoutChallengeInput
    skills?: ChallengeSkillCreateNestedManyWithoutChallengeInput
    auditLogs?: AuditLogCreateNestedManyWithoutChallengeInput
    memberAccesses?: MemberChallengeAccessCreateNestedManyWithoutChallengeInput
    type: ChallengeTypeCreateNestedOneWithoutChallengesInput
    track: ChallengeTrackCreateNestedOneWithoutChallengesInput
    timelineTemplate?: TimelineTemplateCreateNestedOneWithoutChallengesInput
  }

  export type ChallengeUncheckedCreateWithoutConstraintRecordInput = {
    id?: string
    name: string
    description?: string | null
    privateDescription?: string | null
    challengeSource?: string | null
    descriptionFormat?: string | null
    projectId?: number | null
    typeId: string
    trackId: string
    timelineTemplateId?: string | null
    overviewTotalPrizes?: number | null
    numOfRegistrants?: number
    numOfSubmissions?: number
    numOfCheckpointSubmissions?: number
    currentPhaseNames?: ChallengeCreatecurrentPhaseNamesInput | string[]
    wiproAllowed?: boolean
    tags?: ChallengeCreatetagsInput | string[]
    groups?: ChallengeCreategroupsInput | string[]
    taskIsTask?: boolean
    taskIsAssigned?: boolean
    taskMemberId?: string | null
    submissionStartDate?: Date | string | null
    submissionEndDate?: Date | string | null
    registrationStartDate?: Date | string | null
    registrationEndDate?: Date | string | null
    startDate?: Date | string | null
    endDate?: Date | string | null
    legacyId?: number | null
    status?: $Enums.ChallengeStatusEnum
    createdAt?: Date | string
    createdBy: string
    updatedAt?: Date | string
    updatedBy: string
    billingRecord?: ChallengeBillingUncheckedCreateNestedOneWithoutChallengeInput
    legacyRecord?: ChallengeLegacyUncheckedCreateNestedOneWithoutChallengeInput
    events?: ChallengeEventUncheckedCreateNestedManyWithoutChallengeInput
    discussions?: ChallengeDiscussionUncheckedCreateNestedManyWithoutChallengeInput
    metadata?: ChallengeMetadataUncheckedCreateNestedManyWithoutChallengeInput
    phases?: ChallengePhaseUncheckedCreateNestedManyWithoutChallengeInput
    prizeSets?: ChallengePrizeSetUncheckedCreateNestedManyWithoutChallengeInput
    reviewers?: ChallengeReviewerUncheckedCreateNestedManyWithoutChallengeInput
    winners?: ChallengeWinnerUncheckedCreateNestedManyWithoutChallengeInput
    attachments?: AttachmentUncheckedCreateNestedManyWithoutChallengeInput
    terms?: ChallengeTermUncheckedCreateNestedManyWithoutChallengeInput
    skills?: ChallengeSkillUncheckedCreateNestedManyWithoutChallengeInput
    auditLogs?: AuditLogUncheckedCreateNestedManyWithoutChallengeInput
    memberAccesses?: MemberChallengeAccessUncheckedCreateNestedManyWithoutChallengeInput
  }

  export type ChallengeCreateOrConnectWithoutConstraintRecordInput = {
    where: ChallengeWhereUniqueInput
    create: XOR<ChallengeCreateWithoutConstraintRecordInput, ChallengeUncheckedCreateWithoutConstraintRecordInput>
  }

  export type ChallengeUpsertWithoutConstraintRecordInput = {
    update: XOR<ChallengeUpdateWithoutConstraintRecordInput, ChallengeUncheckedUpdateWithoutConstraintRecordInput>
    create: XOR<ChallengeCreateWithoutConstraintRecordInput, ChallengeUncheckedCreateWithoutConstraintRecordInput>
    where?: ChallengeWhereInput
  }

  export type ChallengeUpdateToOneWithWhereWithoutConstraintRecordInput = {
    where?: ChallengeWhereInput
    data: XOR<ChallengeUpdateWithoutConstraintRecordInput, ChallengeUncheckedUpdateWithoutConstraintRecordInput>
  }

  export type ChallengeUpdateWithoutConstraintRecordInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    privateDescription?: NullableStringFieldUpdateOperationsInput | string | null
    challengeSource?: NullableStringFieldUpdateOperationsInput | string | null
    descriptionFormat?: NullableStringFieldUpdateOperationsInput | string | null
    projectId?: NullableIntFieldUpdateOperationsInput | number | null
    overviewTotalPrizes?: NullableFloatFieldUpdateOperationsInput | number | null
    numOfRegistrants?: IntFieldUpdateOperationsInput | number
    numOfSubmissions?: IntFieldUpdateOperationsInput | number
    numOfCheckpointSubmissions?: IntFieldUpdateOperationsInput | number
    currentPhaseNames?: ChallengeUpdatecurrentPhaseNamesInput | string[]
    wiproAllowed?: BoolFieldUpdateOperationsInput | boolean
    tags?: ChallengeUpdatetagsInput | string[]
    groups?: ChallengeUpdategroupsInput | string[]
    taskIsTask?: BoolFieldUpdateOperationsInput | boolean
    taskIsAssigned?: BoolFieldUpdateOperationsInput | boolean
    taskMemberId?: NullableStringFieldUpdateOperationsInput | string | null
    submissionStartDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    submissionEndDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    registrationStartDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    registrationEndDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    startDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    endDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    legacyId?: NullableIntFieldUpdateOperationsInput | number | null
    status?: EnumChallengeStatusEnumFieldUpdateOperationsInput | $Enums.ChallengeStatusEnum
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdBy?: StringFieldUpdateOperationsInput | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedBy?: StringFieldUpdateOperationsInput | string
    billingRecord?: ChallengeBillingUpdateOneWithoutChallengeNestedInput
    legacyRecord?: ChallengeLegacyUpdateOneWithoutChallengeNestedInput
    events?: ChallengeEventUpdateManyWithoutChallengeNestedInput
    discussions?: ChallengeDiscussionUpdateManyWithoutChallengeNestedInput
    metadata?: ChallengeMetadataUpdateManyWithoutChallengeNestedInput
    phases?: ChallengePhaseUpdateManyWithoutChallengeNestedInput
    prizeSets?: ChallengePrizeSetUpdateManyWithoutChallengeNestedInput
    reviewers?: ChallengeReviewerUpdateManyWithoutChallengeNestedInput
    winners?: ChallengeWinnerUpdateManyWithoutChallengeNestedInput
    attachments?: AttachmentUpdateManyWithoutChallengeNestedInput
    terms?: ChallengeTermUpdateManyWithoutChallengeNestedInput
    skills?: ChallengeSkillUpdateManyWithoutChallengeNestedInput
    auditLogs?: AuditLogUpdateManyWithoutChallengeNestedInput
    memberAccesses?: MemberChallengeAccessUpdateManyWithoutChallengeNestedInput
    type?: ChallengeTypeUpdateOneRequiredWithoutChallengesNestedInput
    track?: ChallengeTrackUpdateOneRequiredWithoutChallengesNestedInput
    timelineTemplate?: TimelineTemplateUpdateOneWithoutChallengesNestedInput
  }

  export type ChallengeUncheckedUpdateWithoutConstraintRecordInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    privateDescription?: NullableStringFieldUpdateOperationsInput | string | null
    challengeSource?: NullableStringFieldUpdateOperationsInput | string | null
    descriptionFormat?: NullableStringFieldUpdateOperationsInput | string | null
    projectId?: NullableIntFieldUpdateOperationsInput | number | null
    typeId?: StringFieldUpdateOperationsInput | string
    trackId?: StringFieldUpdateOperationsInput | string
    timelineTemplateId?: NullableStringFieldUpdateOperationsInput | string | null
    overviewTotalPrizes?: NullableFloatFieldUpdateOperationsInput | number | null
    numOfRegistrants?: IntFieldUpdateOperationsInput | number
    numOfSubmissions?: IntFieldUpdateOperationsInput | number
    numOfCheckpointSubmissions?: IntFieldUpdateOperationsInput | number
    currentPhaseNames?: ChallengeUpdatecurrentPhaseNamesInput | string[]
    wiproAllowed?: BoolFieldUpdateOperationsInput | boolean
    tags?: ChallengeUpdatetagsInput | string[]
    groups?: ChallengeUpdategroupsInput | string[]
    taskIsTask?: BoolFieldUpdateOperationsInput | boolean
    taskIsAssigned?: BoolFieldUpdateOperationsInput | boolean
    taskMemberId?: NullableStringFieldUpdateOperationsInput | string | null
    submissionStartDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    submissionEndDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    registrationStartDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    registrationEndDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    startDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    endDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    legacyId?: NullableIntFieldUpdateOperationsInput | number | null
    status?: EnumChallengeStatusEnumFieldUpdateOperationsInput | $Enums.ChallengeStatusEnum
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdBy?: StringFieldUpdateOperationsInput | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedBy?: StringFieldUpdateOperationsInput | string
    billingRecord?: ChallengeBillingUncheckedUpdateOneWithoutChallengeNestedInput
    legacyRecord?: ChallengeLegacyUncheckedUpdateOneWithoutChallengeNestedInput
    events?: ChallengeEventUncheckedUpdateManyWithoutChallengeNestedInput
    discussions?: ChallengeDiscussionUncheckedUpdateManyWithoutChallengeNestedInput
    metadata?: ChallengeMetadataUncheckedUpdateManyWithoutChallengeNestedInput
    phases?: ChallengePhaseUncheckedUpdateManyWithoutChallengeNestedInput
    prizeSets?: ChallengePrizeSetUncheckedUpdateManyWithoutChallengeNestedInput
    reviewers?: ChallengeReviewerUncheckedUpdateManyWithoutChallengeNestedInput
    winners?: ChallengeWinnerUncheckedUpdateManyWithoutChallengeNestedInput
    attachments?: AttachmentUncheckedUpdateManyWithoutChallengeNestedInput
    terms?: ChallengeTermUncheckedUpdateManyWithoutChallengeNestedInput
    skills?: ChallengeSkillUncheckedUpdateManyWithoutChallengeNestedInput
    auditLogs?: AuditLogUncheckedUpdateManyWithoutChallengeNestedInput
    memberAccesses?: MemberChallengeAccessUncheckedUpdateManyWithoutChallengeNestedInput
  }

  export type ChallengePhaseCreateWithoutPhaseInput = {
    id?: string
    name: string
    description?: string | null
    isOpen?: boolean | null
    predecessor?: string | null
    duration?: number | null
    scheduledStartDate?: Date | string | null
    scheduledEndDate?: Date | string | null
    actualStartDate?: Date | string | null
    actualEndDate?: Date | string | null
    createdAt?: Date | string
    createdBy: string
    updatedAt?: Date | string
    updatedBy: string
    constraints?: ChallengePhaseConstraintCreateNestedManyWithoutChallengePhaseInput
    challenge: ChallengeCreateNestedOneWithoutPhasesInput
  }

  export type ChallengePhaseUncheckedCreateWithoutPhaseInput = {
    id?: string
    challengeId: string
    name: string
    description?: string | null
    isOpen?: boolean | null
    predecessor?: string | null
    duration?: number | null
    scheduledStartDate?: Date | string | null
    scheduledEndDate?: Date | string | null
    actualStartDate?: Date | string | null
    actualEndDate?: Date | string | null
    createdAt?: Date | string
    createdBy: string
    updatedAt?: Date | string
    updatedBy: string
    constraints?: ChallengePhaseConstraintUncheckedCreateNestedManyWithoutChallengePhaseInput
  }

  export type ChallengePhaseCreateOrConnectWithoutPhaseInput = {
    where: ChallengePhaseWhereUniqueInput
    create: XOR<ChallengePhaseCreateWithoutPhaseInput, ChallengePhaseUncheckedCreateWithoutPhaseInput>
  }

  export type ChallengePhaseCreateManyPhaseInputEnvelope = {
    data: ChallengePhaseCreateManyPhaseInput | ChallengePhaseCreateManyPhaseInput[]
    skipDuplicates?: boolean
  }

  export type ChallengeReviewerCreateWithoutPhaseInput = {
    id?: string
    scorecardId: string
    isMemberReview: boolean
    memberReviewerCount?: number | null
    fixedAmount?: number | null
    baseCoefficient?: number | null
    incrementalCoefficient?: number | null
    type?: $Enums.ReviewOpportunityTypeEnum | null
    aiWorkflowId?: string | null
    shouldOpenOpportunity?: boolean
    createdAt?: Date | string
    createdBy: string
    updatedAt?: Date | string
    updatedBy: string
    challenge: ChallengeCreateNestedOneWithoutReviewersInput
  }

  export type ChallengeReviewerUncheckedCreateWithoutPhaseInput = {
    id?: string
    challengeId: string
    scorecardId: string
    isMemberReview: boolean
    memberReviewerCount?: number | null
    fixedAmount?: number | null
    baseCoefficient?: number | null
    incrementalCoefficient?: number | null
    type?: $Enums.ReviewOpportunityTypeEnum | null
    aiWorkflowId?: string | null
    shouldOpenOpportunity?: boolean
    createdAt?: Date | string
    createdBy: string
    updatedAt?: Date | string
    updatedBy: string
  }

  export type ChallengeReviewerCreateOrConnectWithoutPhaseInput = {
    where: ChallengeReviewerWhereUniqueInput
    create: XOR<ChallengeReviewerCreateWithoutPhaseInput, ChallengeReviewerUncheckedCreateWithoutPhaseInput>
  }

  export type ChallengeReviewerCreateManyPhaseInputEnvelope = {
    data: ChallengeReviewerCreateManyPhaseInput | ChallengeReviewerCreateManyPhaseInput[]
    skipDuplicates?: boolean
  }

  export type DefaultChallengeReviewerCreateWithoutPhaseInput = {
    id?: string
    scorecardId?: string | null
    isMemberReview: boolean
    memberReviewerCount?: number | null
    phaseName: string
    fixedAmount?: number | null
    baseCoefficient?: number | null
    incrementalCoefficient?: number | null
    opportunityType?: $Enums.ReviewOpportunityTypeEnum | null
    aiWorkflowId?: string | null
    shouldOpenOpportunity?: boolean
    createdAt?: Date | string
    createdBy: string
    updatedAt?: Date | string
    updatedBy: string
    challengeType: ChallengeTypeCreateNestedOneWithoutDefaultReviewersInput
    challengeTrack: ChallengeTrackCreateNestedOneWithoutDefaultReviewersInput
    timelineTemplate?: TimelineTemplateCreateNestedOneWithoutDefaultChallengeReviewerInput
  }

  export type DefaultChallengeReviewerUncheckedCreateWithoutPhaseInput = {
    id?: string
    typeId: string
    trackId: string
    timelineTemplateId?: string | null
    scorecardId?: string | null
    isMemberReview: boolean
    memberReviewerCount?: number | null
    phaseName: string
    fixedAmount?: number | null
    baseCoefficient?: number | null
    incrementalCoefficient?: number | null
    opportunityType?: $Enums.ReviewOpportunityTypeEnum | null
    aiWorkflowId?: string | null
    shouldOpenOpportunity?: boolean
    createdAt?: Date | string
    createdBy: string
    updatedAt?: Date | string
    updatedBy: string
  }

  export type DefaultChallengeReviewerCreateOrConnectWithoutPhaseInput = {
    where: DefaultChallengeReviewerWhereUniqueInput
    create: XOR<DefaultChallengeReviewerCreateWithoutPhaseInput, DefaultChallengeReviewerUncheckedCreateWithoutPhaseInput>
  }

  export type DefaultChallengeReviewerCreateManyPhaseInputEnvelope = {
    data: DefaultChallengeReviewerCreateManyPhaseInput | DefaultChallengeReviewerCreateManyPhaseInput[]
    skipDuplicates?: boolean
  }

  export type ChallengePhaseUpsertWithWhereUniqueWithoutPhaseInput = {
    where: ChallengePhaseWhereUniqueInput
    update: XOR<ChallengePhaseUpdateWithoutPhaseInput, ChallengePhaseUncheckedUpdateWithoutPhaseInput>
    create: XOR<ChallengePhaseCreateWithoutPhaseInput, ChallengePhaseUncheckedCreateWithoutPhaseInput>
  }

  export type ChallengePhaseUpdateWithWhereUniqueWithoutPhaseInput = {
    where: ChallengePhaseWhereUniqueInput
    data: XOR<ChallengePhaseUpdateWithoutPhaseInput, ChallengePhaseUncheckedUpdateWithoutPhaseInput>
  }

  export type ChallengePhaseUpdateManyWithWhereWithoutPhaseInput = {
    where: ChallengePhaseScalarWhereInput
    data: XOR<ChallengePhaseUpdateManyMutationInput, ChallengePhaseUncheckedUpdateManyWithoutPhaseInput>
  }

  export type ChallengeReviewerUpsertWithWhereUniqueWithoutPhaseInput = {
    where: ChallengeReviewerWhereUniqueInput
    update: XOR<ChallengeReviewerUpdateWithoutPhaseInput, ChallengeReviewerUncheckedUpdateWithoutPhaseInput>
    create: XOR<ChallengeReviewerCreateWithoutPhaseInput, ChallengeReviewerUncheckedCreateWithoutPhaseInput>
  }

  export type ChallengeReviewerUpdateWithWhereUniqueWithoutPhaseInput = {
    where: ChallengeReviewerWhereUniqueInput
    data: XOR<ChallengeReviewerUpdateWithoutPhaseInput, ChallengeReviewerUncheckedUpdateWithoutPhaseInput>
  }

  export type ChallengeReviewerUpdateManyWithWhereWithoutPhaseInput = {
    where: ChallengeReviewerScalarWhereInput
    data: XOR<ChallengeReviewerUpdateManyMutationInput, ChallengeReviewerUncheckedUpdateManyWithoutPhaseInput>
  }

  export type DefaultChallengeReviewerUpsertWithWhereUniqueWithoutPhaseInput = {
    where: DefaultChallengeReviewerWhereUniqueInput
    update: XOR<DefaultChallengeReviewerUpdateWithoutPhaseInput, DefaultChallengeReviewerUncheckedUpdateWithoutPhaseInput>
    create: XOR<DefaultChallengeReviewerCreateWithoutPhaseInput, DefaultChallengeReviewerUncheckedCreateWithoutPhaseInput>
  }

  export type DefaultChallengeReviewerUpdateWithWhereUniqueWithoutPhaseInput = {
    where: DefaultChallengeReviewerWhereUniqueInput
    data: XOR<DefaultChallengeReviewerUpdateWithoutPhaseInput, DefaultChallengeReviewerUncheckedUpdateWithoutPhaseInput>
  }

  export type DefaultChallengeReviewerUpdateManyWithWhereWithoutPhaseInput = {
    where: DefaultChallengeReviewerScalarWhereInput
    data: XOR<DefaultChallengeReviewerUpdateManyMutationInput, DefaultChallengeReviewerUncheckedUpdateManyWithoutPhaseInput>
  }

  export type ChallengePhaseConstraintCreateWithoutChallengePhaseInput = {
    id?: string
    name: string
    value: number
    createdAt?: Date | string
    createdBy: string
    updatedAt?: Date | string
    updatedBy: string
  }

  export type ChallengePhaseConstraintUncheckedCreateWithoutChallengePhaseInput = {
    id?: string
    name: string
    value: number
    createdAt?: Date | string
    createdBy: string
    updatedAt?: Date | string
    updatedBy: string
  }

  export type ChallengePhaseConstraintCreateOrConnectWithoutChallengePhaseInput = {
    where: ChallengePhaseConstraintWhereUniqueInput
    create: XOR<ChallengePhaseConstraintCreateWithoutChallengePhaseInput, ChallengePhaseConstraintUncheckedCreateWithoutChallengePhaseInput>
  }

  export type ChallengePhaseConstraintCreateManyChallengePhaseInputEnvelope = {
    data: ChallengePhaseConstraintCreateManyChallengePhaseInput | ChallengePhaseConstraintCreateManyChallengePhaseInput[]
    skipDuplicates?: boolean
  }

  export type ChallengeCreateWithoutPhasesInput = {
    id?: string
    name: string
    description?: string | null
    privateDescription?: string | null
    challengeSource?: string | null
    descriptionFormat?: string | null
    projectId?: number | null
    overviewTotalPrizes?: number | null
    numOfRegistrants?: number
    numOfSubmissions?: number
    numOfCheckpointSubmissions?: number
    currentPhaseNames?: ChallengeCreatecurrentPhaseNamesInput | string[]
    wiproAllowed?: boolean
    tags?: ChallengeCreatetagsInput | string[]
    groups?: ChallengeCreategroupsInput | string[]
    taskIsTask?: boolean
    taskIsAssigned?: boolean
    taskMemberId?: string | null
    submissionStartDate?: Date | string | null
    submissionEndDate?: Date | string | null
    registrationStartDate?: Date | string | null
    registrationEndDate?: Date | string | null
    startDate?: Date | string | null
    endDate?: Date | string | null
    legacyId?: number | null
    status?: $Enums.ChallengeStatusEnum
    createdAt?: Date | string
    createdBy: string
    updatedAt?: Date | string
    updatedBy: string
    billingRecord?: ChallengeBillingCreateNestedOneWithoutChallengeInput
    legacyRecord?: ChallengeLegacyCreateNestedOneWithoutChallengeInput
    constraintRecord?: ChallengeConstraintCreateNestedOneWithoutChallengeInput
    events?: ChallengeEventCreateNestedManyWithoutChallengeInput
    discussions?: ChallengeDiscussionCreateNestedManyWithoutChallengeInput
    metadata?: ChallengeMetadataCreateNestedManyWithoutChallengeInput
    prizeSets?: ChallengePrizeSetCreateNestedManyWithoutChallengeInput
    reviewers?: ChallengeReviewerCreateNestedManyWithoutChallengeInput
    winners?: ChallengeWinnerCreateNestedManyWithoutChallengeInput
    attachments?: AttachmentCreateNestedManyWithoutChallengeInput
    terms?: ChallengeTermCreateNestedManyWithoutChallengeInput
    skills?: ChallengeSkillCreateNestedManyWithoutChallengeInput
    auditLogs?: AuditLogCreateNestedManyWithoutChallengeInput
    memberAccesses?: MemberChallengeAccessCreateNestedManyWithoutChallengeInput
    type: ChallengeTypeCreateNestedOneWithoutChallengesInput
    track: ChallengeTrackCreateNestedOneWithoutChallengesInput
    timelineTemplate?: TimelineTemplateCreateNestedOneWithoutChallengesInput
  }

  export type ChallengeUncheckedCreateWithoutPhasesInput = {
    id?: string
    name: string
    description?: string | null
    privateDescription?: string | null
    challengeSource?: string | null
    descriptionFormat?: string | null
    projectId?: number | null
    typeId: string
    trackId: string
    timelineTemplateId?: string | null
    overviewTotalPrizes?: number | null
    numOfRegistrants?: number
    numOfSubmissions?: number
    numOfCheckpointSubmissions?: number
    currentPhaseNames?: ChallengeCreatecurrentPhaseNamesInput | string[]
    wiproAllowed?: boolean
    tags?: ChallengeCreatetagsInput | string[]
    groups?: ChallengeCreategroupsInput | string[]
    taskIsTask?: boolean
    taskIsAssigned?: boolean
    taskMemberId?: string | null
    submissionStartDate?: Date | string | null
    submissionEndDate?: Date | string | null
    registrationStartDate?: Date | string | null
    registrationEndDate?: Date | string | null
    startDate?: Date | string | null
    endDate?: Date | string | null
    legacyId?: number | null
    status?: $Enums.ChallengeStatusEnum
    createdAt?: Date | string
    createdBy: string
    updatedAt?: Date | string
    updatedBy: string
    billingRecord?: ChallengeBillingUncheckedCreateNestedOneWithoutChallengeInput
    legacyRecord?: ChallengeLegacyUncheckedCreateNestedOneWithoutChallengeInput
    constraintRecord?: ChallengeConstraintUncheckedCreateNestedOneWithoutChallengeInput
    events?: ChallengeEventUncheckedCreateNestedManyWithoutChallengeInput
    discussions?: ChallengeDiscussionUncheckedCreateNestedManyWithoutChallengeInput
    metadata?: ChallengeMetadataUncheckedCreateNestedManyWithoutChallengeInput
    prizeSets?: ChallengePrizeSetUncheckedCreateNestedManyWithoutChallengeInput
    reviewers?: ChallengeReviewerUncheckedCreateNestedManyWithoutChallengeInput
    winners?: ChallengeWinnerUncheckedCreateNestedManyWithoutChallengeInput
    attachments?: AttachmentUncheckedCreateNestedManyWithoutChallengeInput
    terms?: ChallengeTermUncheckedCreateNestedManyWithoutChallengeInput
    skills?: ChallengeSkillUncheckedCreateNestedManyWithoutChallengeInput
    auditLogs?: AuditLogUncheckedCreateNestedManyWithoutChallengeInput
    memberAccesses?: MemberChallengeAccessUncheckedCreateNestedManyWithoutChallengeInput
  }

  export type ChallengeCreateOrConnectWithoutPhasesInput = {
    where: ChallengeWhereUniqueInput
    create: XOR<ChallengeCreateWithoutPhasesInput, ChallengeUncheckedCreateWithoutPhasesInput>
  }

  export type PhaseCreateWithoutChallengePhasesInput = {
    id?: string
    name: string
    description?: string | null
    isOpen: boolean
    duration: number
    createdAt?: Date | string
    createdBy: string
    updatedAt?: Date | string
    updatedBy: string
    ChallengeReviewer?: ChallengeReviewerCreateNestedManyWithoutPhaseInput
    DefaultChallengeReviewer?: DefaultChallengeReviewerCreateNestedManyWithoutPhaseInput
  }

  export type PhaseUncheckedCreateWithoutChallengePhasesInput = {
    id?: string
    name: string
    description?: string | null
    isOpen: boolean
    duration: number
    createdAt?: Date | string
    createdBy: string
    updatedAt?: Date | string
    updatedBy: string
    ChallengeReviewer?: ChallengeReviewerUncheckedCreateNestedManyWithoutPhaseInput
    DefaultChallengeReviewer?: DefaultChallengeReviewerUncheckedCreateNestedManyWithoutPhaseInput
  }

  export type PhaseCreateOrConnectWithoutChallengePhasesInput = {
    where: PhaseWhereUniqueInput
    create: XOR<PhaseCreateWithoutChallengePhasesInput, PhaseUncheckedCreateWithoutChallengePhasesInput>
  }

  export type ChallengePhaseConstraintUpsertWithWhereUniqueWithoutChallengePhaseInput = {
    where: ChallengePhaseConstraintWhereUniqueInput
    update: XOR<ChallengePhaseConstraintUpdateWithoutChallengePhaseInput, ChallengePhaseConstraintUncheckedUpdateWithoutChallengePhaseInput>
    create: XOR<ChallengePhaseConstraintCreateWithoutChallengePhaseInput, ChallengePhaseConstraintUncheckedCreateWithoutChallengePhaseInput>
  }

  export type ChallengePhaseConstraintUpdateWithWhereUniqueWithoutChallengePhaseInput = {
    where: ChallengePhaseConstraintWhereUniqueInput
    data: XOR<ChallengePhaseConstraintUpdateWithoutChallengePhaseInput, ChallengePhaseConstraintUncheckedUpdateWithoutChallengePhaseInput>
  }

  export type ChallengePhaseConstraintUpdateManyWithWhereWithoutChallengePhaseInput = {
    where: ChallengePhaseConstraintScalarWhereInput
    data: XOR<ChallengePhaseConstraintUpdateManyMutationInput, ChallengePhaseConstraintUncheckedUpdateManyWithoutChallengePhaseInput>
  }

  export type ChallengePhaseConstraintScalarWhereInput = {
    AND?: ChallengePhaseConstraintScalarWhereInput | ChallengePhaseConstraintScalarWhereInput[]
    OR?: ChallengePhaseConstraintScalarWhereInput[]
    NOT?: ChallengePhaseConstraintScalarWhereInput | ChallengePhaseConstraintScalarWhereInput[]
    id?: StringFilter<"ChallengePhaseConstraint"> | string
    challengePhaseId?: StringFilter<"ChallengePhaseConstraint"> | string
    name?: StringFilter<"ChallengePhaseConstraint"> | string
    value?: IntFilter<"ChallengePhaseConstraint"> | number
    createdAt?: DateTimeFilter<"ChallengePhaseConstraint"> | Date | string
    createdBy?: StringFilter<"ChallengePhaseConstraint"> | string
    updatedAt?: DateTimeFilter<"ChallengePhaseConstraint"> | Date | string
    updatedBy?: StringFilter<"ChallengePhaseConstraint"> | string
  }

  export type ChallengeUpsertWithoutPhasesInput = {
    update: XOR<ChallengeUpdateWithoutPhasesInput, ChallengeUncheckedUpdateWithoutPhasesInput>
    create: XOR<ChallengeCreateWithoutPhasesInput, ChallengeUncheckedCreateWithoutPhasesInput>
    where?: ChallengeWhereInput
  }

  export type ChallengeUpdateToOneWithWhereWithoutPhasesInput = {
    where?: ChallengeWhereInput
    data: XOR<ChallengeUpdateWithoutPhasesInput, ChallengeUncheckedUpdateWithoutPhasesInput>
  }

  export type ChallengeUpdateWithoutPhasesInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    privateDescription?: NullableStringFieldUpdateOperationsInput | string | null
    challengeSource?: NullableStringFieldUpdateOperationsInput | string | null
    descriptionFormat?: NullableStringFieldUpdateOperationsInput | string | null
    projectId?: NullableIntFieldUpdateOperationsInput | number | null
    overviewTotalPrizes?: NullableFloatFieldUpdateOperationsInput | number | null
    numOfRegistrants?: IntFieldUpdateOperationsInput | number
    numOfSubmissions?: IntFieldUpdateOperationsInput | number
    numOfCheckpointSubmissions?: IntFieldUpdateOperationsInput | number
    currentPhaseNames?: ChallengeUpdatecurrentPhaseNamesInput | string[]
    wiproAllowed?: BoolFieldUpdateOperationsInput | boolean
    tags?: ChallengeUpdatetagsInput | string[]
    groups?: ChallengeUpdategroupsInput | string[]
    taskIsTask?: BoolFieldUpdateOperationsInput | boolean
    taskIsAssigned?: BoolFieldUpdateOperationsInput | boolean
    taskMemberId?: NullableStringFieldUpdateOperationsInput | string | null
    submissionStartDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    submissionEndDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    registrationStartDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    registrationEndDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    startDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    endDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    legacyId?: NullableIntFieldUpdateOperationsInput | number | null
    status?: EnumChallengeStatusEnumFieldUpdateOperationsInput | $Enums.ChallengeStatusEnum
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdBy?: StringFieldUpdateOperationsInput | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedBy?: StringFieldUpdateOperationsInput | string
    billingRecord?: ChallengeBillingUpdateOneWithoutChallengeNestedInput
    legacyRecord?: ChallengeLegacyUpdateOneWithoutChallengeNestedInput
    constraintRecord?: ChallengeConstraintUpdateOneWithoutChallengeNestedInput
    events?: ChallengeEventUpdateManyWithoutChallengeNestedInput
    discussions?: ChallengeDiscussionUpdateManyWithoutChallengeNestedInput
    metadata?: ChallengeMetadataUpdateManyWithoutChallengeNestedInput
    prizeSets?: ChallengePrizeSetUpdateManyWithoutChallengeNestedInput
    reviewers?: ChallengeReviewerUpdateManyWithoutChallengeNestedInput
    winners?: ChallengeWinnerUpdateManyWithoutChallengeNestedInput
    attachments?: AttachmentUpdateManyWithoutChallengeNestedInput
    terms?: ChallengeTermUpdateManyWithoutChallengeNestedInput
    skills?: ChallengeSkillUpdateManyWithoutChallengeNestedInput
    auditLogs?: AuditLogUpdateManyWithoutChallengeNestedInput
    memberAccesses?: MemberChallengeAccessUpdateManyWithoutChallengeNestedInput
    type?: ChallengeTypeUpdateOneRequiredWithoutChallengesNestedInput
    track?: ChallengeTrackUpdateOneRequiredWithoutChallengesNestedInput
    timelineTemplate?: TimelineTemplateUpdateOneWithoutChallengesNestedInput
  }

  export type ChallengeUncheckedUpdateWithoutPhasesInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    privateDescription?: NullableStringFieldUpdateOperationsInput | string | null
    challengeSource?: NullableStringFieldUpdateOperationsInput | string | null
    descriptionFormat?: NullableStringFieldUpdateOperationsInput | string | null
    projectId?: NullableIntFieldUpdateOperationsInput | number | null
    typeId?: StringFieldUpdateOperationsInput | string
    trackId?: StringFieldUpdateOperationsInput | string
    timelineTemplateId?: NullableStringFieldUpdateOperationsInput | string | null
    overviewTotalPrizes?: NullableFloatFieldUpdateOperationsInput | number | null
    numOfRegistrants?: IntFieldUpdateOperationsInput | number
    numOfSubmissions?: IntFieldUpdateOperationsInput | number
    numOfCheckpointSubmissions?: IntFieldUpdateOperationsInput | number
    currentPhaseNames?: ChallengeUpdatecurrentPhaseNamesInput | string[]
    wiproAllowed?: BoolFieldUpdateOperationsInput | boolean
    tags?: ChallengeUpdatetagsInput | string[]
    groups?: ChallengeUpdategroupsInput | string[]
    taskIsTask?: BoolFieldUpdateOperationsInput | boolean
    taskIsAssigned?: BoolFieldUpdateOperationsInput | boolean
    taskMemberId?: NullableStringFieldUpdateOperationsInput | string | null
    submissionStartDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    submissionEndDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    registrationStartDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    registrationEndDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    startDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    endDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    legacyId?: NullableIntFieldUpdateOperationsInput | number | null
    status?: EnumChallengeStatusEnumFieldUpdateOperationsInput | $Enums.ChallengeStatusEnum
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdBy?: StringFieldUpdateOperationsInput | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedBy?: StringFieldUpdateOperationsInput | string
    billingRecord?: ChallengeBillingUncheckedUpdateOneWithoutChallengeNestedInput
    legacyRecord?: ChallengeLegacyUncheckedUpdateOneWithoutChallengeNestedInput
    constraintRecord?: ChallengeConstraintUncheckedUpdateOneWithoutChallengeNestedInput
    events?: ChallengeEventUncheckedUpdateManyWithoutChallengeNestedInput
    discussions?: ChallengeDiscussionUncheckedUpdateManyWithoutChallengeNestedInput
    metadata?: ChallengeMetadataUncheckedUpdateManyWithoutChallengeNestedInput
    prizeSets?: ChallengePrizeSetUncheckedUpdateManyWithoutChallengeNestedInput
    reviewers?: ChallengeReviewerUncheckedUpdateManyWithoutChallengeNestedInput
    winners?: ChallengeWinnerUncheckedUpdateManyWithoutChallengeNestedInput
    attachments?: AttachmentUncheckedUpdateManyWithoutChallengeNestedInput
    terms?: ChallengeTermUncheckedUpdateManyWithoutChallengeNestedInput
    skills?: ChallengeSkillUncheckedUpdateManyWithoutChallengeNestedInput
    auditLogs?: AuditLogUncheckedUpdateManyWithoutChallengeNestedInput
    memberAccesses?: MemberChallengeAccessUncheckedUpdateManyWithoutChallengeNestedInput
  }

  export type PhaseUpsertWithoutChallengePhasesInput = {
    update: XOR<PhaseUpdateWithoutChallengePhasesInput, PhaseUncheckedUpdateWithoutChallengePhasesInput>
    create: XOR<PhaseCreateWithoutChallengePhasesInput, PhaseUncheckedCreateWithoutChallengePhasesInput>
    where?: PhaseWhereInput
  }

  export type PhaseUpdateToOneWithWhereWithoutChallengePhasesInput = {
    where?: PhaseWhereInput
    data: XOR<PhaseUpdateWithoutChallengePhasesInput, PhaseUncheckedUpdateWithoutChallengePhasesInput>
  }

  export type PhaseUpdateWithoutChallengePhasesInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    isOpen?: BoolFieldUpdateOperationsInput | boolean
    duration?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdBy?: StringFieldUpdateOperationsInput | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedBy?: StringFieldUpdateOperationsInput | string
    ChallengeReviewer?: ChallengeReviewerUpdateManyWithoutPhaseNestedInput
    DefaultChallengeReviewer?: DefaultChallengeReviewerUpdateManyWithoutPhaseNestedInput
  }

  export type PhaseUncheckedUpdateWithoutChallengePhasesInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    isOpen?: BoolFieldUpdateOperationsInput | boolean
    duration?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdBy?: StringFieldUpdateOperationsInput | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedBy?: StringFieldUpdateOperationsInput | string
    ChallengeReviewer?: ChallengeReviewerUncheckedUpdateManyWithoutPhaseNestedInput
    DefaultChallengeReviewer?: DefaultChallengeReviewerUncheckedUpdateManyWithoutPhaseNestedInput
  }

  export type ChallengePhaseCreateWithoutConstraintsInput = {
    id?: string
    name: string
    description?: string | null
    isOpen?: boolean | null
    predecessor?: string | null
    duration?: number | null
    scheduledStartDate?: Date | string | null
    scheduledEndDate?: Date | string | null
    actualStartDate?: Date | string | null
    actualEndDate?: Date | string | null
    createdAt?: Date | string
    createdBy: string
    updatedAt?: Date | string
    updatedBy: string
    challenge: ChallengeCreateNestedOneWithoutPhasesInput
    phase: PhaseCreateNestedOneWithoutChallengePhasesInput
  }

  export type ChallengePhaseUncheckedCreateWithoutConstraintsInput = {
    id?: string
    challengeId: string
    phaseId: string
    name: string
    description?: string | null
    isOpen?: boolean | null
    predecessor?: string | null
    duration?: number | null
    scheduledStartDate?: Date | string | null
    scheduledEndDate?: Date | string | null
    actualStartDate?: Date | string | null
    actualEndDate?: Date | string | null
    createdAt?: Date | string
    createdBy: string
    updatedAt?: Date | string
    updatedBy: string
  }

  export type ChallengePhaseCreateOrConnectWithoutConstraintsInput = {
    where: ChallengePhaseWhereUniqueInput
    create: XOR<ChallengePhaseCreateWithoutConstraintsInput, ChallengePhaseUncheckedCreateWithoutConstraintsInput>
  }

  export type ChallengePhaseUpsertWithoutConstraintsInput = {
    update: XOR<ChallengePhaseUpdateWithoutConstraintsInput, ChallengePhaseUncheckedUpdateWithoutConstraintsInput>
    create: XOR<ChallengePhaseCreateWithoutConstraintsInput, ChallengePhaseUncheckedCreateWithoutConstraintsInput>
    where?: ChallengePhaseWhereInput
  }

  export type ChallengePhaseUpdateToOneWithWhereWithoutConstraintsInput = {
    where?: ChallengePhaseWhereInput
    data: XOR<ChallengePhaseUpdateWithoutConstraintsInput, ChallengePhaseUncheckedUpdateWithoutConstraintsInput>
  }

  export type ChallengePhaseUpdateWithoutConstraintsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    isOpen?: NullableBoolFieldUpdateOperationsInput | boolean | null
    predecessor?: NullableStringFieldUpdateOperationsInput | string | null
    duration?: NullableIntFieldUpdateOperationsInput | number | null
    scheduledStartDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    scheduledEndDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    actualStartDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    actualEndDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdBy?: StringFieldUpdateOperationsInput | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedBy?: StringFieldUpdateOperationsInput | string
    challenge?: ChallengeUpdateOneRequiredWithoutPhasesNestedInput
    phase?: PhaseUpdateOneRequiredWithoutChallengePhasesNestedInput
  }

  export type ChallengePhaseUncheckedUpdateWithoutConstraintsInput = {
    id?: StringFieldUpdateOperationsInput | string
    challengeId?: StringFieldUpdateOperationsInput | string
    phaseId?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    isOpen?: NullableBoolFieldUpdateOperationsInput | boolean | null
    predecessor?: NullableStringFieldUpdateOperationsInput | string | null
    duration?: NullableIntFieldUpdateOperationsInput | number | null
    scheduledStartDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    scheduledEndDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    actualStartDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    actualEndDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdBy?: StringFieldUpdateOperationsInput | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedBy?: StringFieldUpdateOperationsInput | string
  }

  export type PrizeCreateWithoutPrizeSetInput = {
    id?: string
    description?: string | null
    type: string
    value: number
    createdAt?: Date | string
    createdBy: string
    updatedAt?: Date | string
    updatedBy: string
  }

  export type PrizeUncheckedCreateWithoutPrizeSetInput = {
    id?: string
    description?: string | null
    type: string
    value: number
    createdAt?: Date | string
    createdBy: string
    updatedAt?: Date | string
    updatedBy: string
  }

  export type PrizeCreateOrConnectWithoutPrizeSetInput = {
    where: PrizeWhereUniqueInput
    create: XOR<PrizeCreateWithoutPrizeSetInput, PrizeUncheckedCreateWithoutPrizeSetInput>
  }

  export type PrizeCreateManyPrizeSetInputEnvelope = {
    data: PrizeCreateManyPrizeSetInput | PrizeCreateManyPrizeSetInput[]
    skipDuplicates?: boolean
  }

  export type ChallengeCreateWithoutPrizeSetsInput = {
    id?: string
    name: string
    description?: string | null
    privateDescription?: string | null
    challengeSource?: string | null
    descriptionFormat?: string | null
    projectId?: number | null
    overviewTotalPrizes?: number | null
    numOfRegistrants?: number
    numOfSubmissions?: number
    numOfCheckpointSubmissions?: number
    currentPhaseNames?: ChallengeCreatecurrentPhaseNamesInput | string[]
    wiproAllowed?: boolean
    tags?: ChallengeCreatetagsInput | string[]
    groups?: ChallengeCreategroupsInput | string[]
    taskIsTask?: boolean
    taskIsAssigned?: boolean
    taskMemberId?: string | null
    submissionStartDate?: Date | string | null
    submissionEndDate?: Date | string | null
    registrationStartDate?: Date | string | null
    registrationEndDate?: Date | string | null
    startDate?: Date | string | null
    endDate?: Date | string | null
    legacyId?: number | null
    status?: $Enums.ChallengeStatusEnum
    createdAt?: Date | string
    createdBy: string
    updatedAt?: Date | string
    updatedBy: string
    billingRecord?: ChallengeBillingCreateNestedOneWithoutChallengeInput
    legacyRecord?: ChallengeLegacyCreateNestedOneWithoutChallengeInput
    constraintRecord?: ChallengeConstraintCreateNestedOneWithoutChallengeInput
    events?: ChallengeEventCreateNestedManyWithoutChallengeInput
    discussions?: ChallengeDiscussionCreateNestedManyWithoutChallengeInput
    metadata?: ChallengeMetadataCreateNestedManyWithoutChallengeInput
    phases?: ChallengePhaseCreateNestedManyWithoutChallengeInput
    reviewers?: ChallengeReviewerCreateNestedManyWithoutChallengeInput
    winners?: ChallengeWinnerCreateNestedManyWithoutChallengeInput
    attachments?: AttachmentCreateNestedManyWithoutChallengeInput
    terms?: ChallengeTermCreateNestedManyWithoutChallengeInput
    skills?: ChallengeSkillCreateNestedManyWithoutChallengeInput
    auditLogs?: AuditLogCreateNestedManyWithoutChallengeInput
    memberAccesses?: MemberChallengeAccessCreateNestedManyWithoutChallengeInput
    type: ChallengeTypeCreateNestedOneWithoutChallengesInput
    track: ChallengeTrackCreateNestedOneWithoutChallengesInput
    timelineTemplate?: TimelineTemplateCreateNestedOneWithoutChallengesInput
  }

  export type ChallengeUncheckedCreateWithoutPrizeSetsInput = {
    id?: string
    name: string
    description?: string | null
    privateDescription?: string | null
    challengeSource?: string | null
    descriptionFormat?: string | null
    projectId?: number | null
    typeId: string
    trackId: string
    timelineTemplateId?: string | null
    overviewTotalPrizes?: number | null
    numOfRegistrants?: number
    numOfSubmissions?: number
    numOfCheckpointSubmissions?: number
    currentPhaseNames?: ChallengeCreatecurrentPhaseNamesInput | string[]
    wiproAllowed?: boolean
    tags?: ChallengeCreatetagsInput | string[]
    groups?: ChallengeCreategroupsInput | string[]
    taskIsTask?: boolean
    taskIsAssigned?: boolean
    taskMemberId?: string | null
    submissionStartDate?: Date | string | null
    submissionEndDate?: Date | string | null
    registrationStartDate?: Date | string | null
    registrationEndDate?: Date | string | null
    startDate?: Date | string | null
    endDate?: Date | string | null
    legacyId?: number | null
    status?: $Enums.ChallengeStatusEnum
    createdAt?: Date | string
    createdBy: string
    updatedAt?: Date | string
    updatedBy: string
    billingRecord?: ChallengeBillingUncheckedCreateNestedOneWithoutChallengeInput
    legacyRecord?: ChallengeLegacyUncheckedCreateNestedOneWithoutChallengeInput
    constraintRecord?: ChallengeConstraintUncheckedCreateNestedOneWithoutChallengeInput
    events?: ChallengeEventUncheckedCreateNestedManyWithoutChallengeInput
    discussions?: ChallengeDiscussionUncheckedCreateNestedManyWithoutChallengeInput
    metadata?: ChallengeMetadataUncheckedCreateNestedManyWithoutChallengeInput
    phases?: ChallengePhaseUncheckedCreateNestedManyWithoutChallengeInput
    reviewers?: ChallengeReviewerUncheckedCreateNestedManyWithoutChallengeInput
    winners?: ChallengeWinnerUncheckedCreateNestedManyWithoutChallengeInput
    attachments?: AttachmentUncheckedCreateNestedManyWithoutChallengeInput
    terms?: ChallengeTermUncheckedCreateNestedManyWithoutChallengeInput
    skills?: ChallengeSkillUncheckedCreateNestedManyWithoutChallengeInput
    auditLogs?: AuditLogUncheckedCreateNestedManyWithoutChallengeInput
    memberAccesses?: MemberChallengeAccessUncheckedCreateNestedManyWithoutChallengeInput
  }

  export type ChallengeCreateOrConnectWithoutPrizeSetsInput = {
    where: ChallengeWhereUniqueInput
    create: XOR<ChallengeCreateWithoutPrizeSetsInput, ChallengeUncheckedCreateWithoutPrizeSetsInput>
  }

  export type PrizeUpsertWithWhereUniqueWithoutPrizeSetInput = {
    where: PrizeWhereUniqueInput
    update: XOR<PrizeUpdateWithoutPrizeSetInput, PrizeUncheckedUpdateWithoutPrizeSetInput>
    create: XOR<PrizeCreateWithoutPrizeSetInput, PrizeUncheckedCreateWithoutPrizeSetInput>
  }

  export type PrizeUpdateWithWhereUniqueWithoutPrizeSetInput = {
    where: PrizeWhereUniqueInput
    data: XOR<PrizeUpdateWithoutPrizeSetInput, PrizeUncheckedUpdateWithoutPrizeSetInput>
  }

  export type PrizeUpdateManyWithWhereWithoutPrizeSetInput = {
    where: PrizeScalarWhereInput
    data: XOR<PrizeUpdateManyMutationInput, PrizeUncheckedUpdateManyWithoutPrizeSetInput>
  }

  export type PrizeScalarWhereInput = {
    AND?: PrizeScalarWhereInput | PrizeScalarWhereInput[]
    OR?: PrizeScalarWhereInput[]
    NOT?: PrizeScalarWhereInput | PrizeScalarWhereInput[]
    id?: StringFilter<"Prize"> | string
    description?: StringNullableFilter<"Prize"> | string | null
    prizeSetId?: StringFilter<"Prize"> | string
    type?: StringFilter<"Prize"> | string
    value?: FloatFilter<"Prize"> | number
    createdAt?: DateTimeFilter<"Prize"> | Date | string
    createdBy?: StringFilter<"Prize"> | string
    updatedAt?: DateTimeFilter<"Prize"> | Date | string
    updatedBy?: StringFilter<"Prize"> | string
  }

  export type ChallengeUpsertWithoutPrizeSetsInput = {
    update: XOR<ChallengeUpdateWithoutPrizeSetsInput, ChallengeUncheckedUpdateWithoutPrizeSetsInput>
    create: XOR<ChallengeCreateWithoutPrizeSetsInput, ChallengeUncheckedCreateWithoutPrizeSetsInput>
    where?: ChallengeWhereInput
  }

  export type ChallengeUpdateToOneWithWhereWithoutPrizeSetsInput = {
    where?: ChallengeWhereInput
    data: XOR<ChallengeUpdateWithoutPrizeSetsInput, ChallengeUncheckedUpdateWithoutPrizeSetsInput>
  }

  export type ChallengeUpdateWithoutPrizeSetsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    privateDescription?: NullableStringFieldUpdateOperationsInput | string | null
    challengeSource?: NullableStringFieldUpdateOperationsInput | string | null
    descriptionFormat?: NullableStringFieldUpdateOperationsInput | string | null
    projectId?: NullableIntFieldUpdateOperationsInput | number | null
    overviewTotalPrizes?: NullableFloatFieldUpdateOperationsInput | number | null
    numOfRegistrants?: IntFieldUpdateOperationsInput | number
    numOfSubmissions?: IntFieldUpdateOperationsInput | number
    numOfCheckpointSubmissions?: IntFieldUpdateOperationsInput | number
    currentPhaseNames?: ChallengeUpdatecurrentPhaseNamesInput | string[]
    wiproAllowed?: BoolFieldUpdateOperationsInput | boolean
    tags?: ChallengeUpdatetagsInput | string[]
    groups?: ChallengeUpdategroupsInput | string[]
    taskIsTask?: BoolFieldUpdateOperationsInput | boolean
    taskIsAssigned?: BoolFieldUpdateOperationsInput | boolean
    taskMemberId?: NullableStringFieldUpdateOperationsInput | string | null
    submissionStartDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    submissionEndDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    registrationStartDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    registrationEndDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    startDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    endDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    legacyId?: NullableIntFieldUpdateOperationsInput | number | null
    status?: EnumChallengeStatusEnumFieldUpdateOperationsInput | $Enums.ChallengeStatusEnum
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdBy?: StringFieldUpdateOperationsInput | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedBy?: StringFieldUpdateOperationsInput | string
    billingRecord?: ChallengeBillingUpdateOneWithoutChallengeNestedInput
    legacyRecord?: ChallengeLegacyUpdateOneWithoutChallengeNestedInput
    constraintRecord?: ChallengeConstraintUpdateOneWithoutChallengeNestedInput
    events?: ChallengeEventUpdateManyWithoutChallengeNestedInput
    discussions?: ChallengeDiscussionUpdateManyWithoutChallengeNestedInput
    metadata?: ChallengeMetadataUpdateManyWithoutChallengeNestedInput
    phases?: ChallengePhaseUpdateManyWithoutChallengeNestedInput
    reviewers?: ChallengeReviewerUpdateManyWithoutChallengeNestedInput
    winners?: ChallengeWinnerUpdateManyWithoutChallengeNestedInput
    attachments?: AttachmentUpdateManyWithoutChallengeNestedInput
    terms?: ChallengeTermUpdateManyWithoutChallengeNestedInput
    skills?: ChallengeSkillUpdateManyWithoutChallengeNestedInput
    auditLogs?: AuditLogUpdateManyWithoutChallengeNestedInput
    memberAccesses?: MemberChallengeAccessUpdateManyWithoutChallengeNestedInput
    type?: ChallengeTypeUpdateOneRequiredWithoutChallengesNestedInput
    track?: ChallengeTrackUpdateOneRequiredWithoutChallengesNestedInput
    timelineTemplate?: TimelineTemplateUpdateOneWithoutChallengesNestedInput
  }

  export type ChallengeUncheckedUpdateWithoutPrizeSetsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    privateDescription?: NullableStringFieldUpdateOperationsInput | string | null
    challengeSource?: NullableStringFieldUpdateOperationsInput | string | null
    descriptionFormat?: NullableStringFieldUpdateOperationsInput | string | null
    projectId?: NullableIntFieldUpdateOperationsInput | number | null
    typeId?: StringFieldUpdateOperationsInput | string
    trackId?: StringFieldUpdateOperationsInput | string
    timelineTemplateId?: NullableStringFieldUpdateOperationsInput | string | null
    overviewTotalPrizes?: NullableFloatFieldUpdateOperationsInput | number | null
    numOfRegistrants?: IntFieldUpdateOperationsInput | number
    numOfSubmissions?: IntFieldUpdateOperationsInput | number
    numOfCheckpointSubmissions?: IntFieldUpdateOperationsInput | number
    currentPhaseNames?: ChallengeUpdatecurrentPhaseNamesInput | string[]
    wiproAllowed?: BoolFieldUpdateOperationsInput | boolean
    tags?: ChallengeUpdatetagsInput | string[]
    groups?: ChallengeUpdategroupsInput | string[]
    taskIsTask?: BoolFieldUpdateOperationsInput | boolean
    taskIsAssigned?: BoolFieldUpdateOperationsInput | boolean
    taskMemberId?: NullableStringFieldUpdateOperationsInput | string | null
    submissionStartDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    submissionEndDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    registrationStartDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    registrationEndDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    startDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    endDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    legacyId?: NullableIntFieldUpdateOperationsInput | number | null
    status?: EnumChallengeStatusEnumFieldUpdateOperationsInput | $Enums.ChallengeStatusEnum
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdBy?: StringFieldUpdateOperationsInput | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedBy?: StringFieldUpdateOperationsInput | string
    billingRecord?: ChallengeBillingUncheckedUpdateOneWithoutChallengeNestedInput
    legacyRecord?: ChallengeLegacyUncheckedUpdateOneWithoutChallengeNestedInput
    constraintRecord?: ChallengeConstraintUncheckedUpdateOneWithoutChallengeNestedInput
    events?: ChallengeEventUncheckedUpdateManyWithoutChallengeNestedInput
    discussions?: ChallengeDiscussionUncheckedUpdateManyWithoutChallengeNestedInput
    metadata?: ChallengeMetadataUncheckedUpdateManyWithoutChallengeNestedInput
    phases?: ChallengePhaseUncheckedUpdateManyWithoutChallengeNestedInput
    reviewers?: ChallengeReviewerUncheckedUpdateManyWithoutChallengeNestedInput
    winners?: ChallengeWinnerUncheckedUpdateManyWithoutChallengeNestedInput
    attachments?: AttachmentUncheckedUpdateManyWithoutChallengeNestedInput
    terms?: ChallengeTermUncheckedUpdateManyWithoutChallengeNestedInput
    skills?: ChallengeSkillUncheckedUpdateManyWithoutChallengeNestedInput
    auditLogs?: AuditLogUncheckedUpdateManyWithoutChallengeNestedInput
    memberAccesses?: MemberChallengeAccessUncheckedUpdateManyWithoutChallengeNestedInput
  }

  export type ChallengeCreateWithoutReviewersInput = {
    id?: string
    name: string
    description?: string | null
    privateDescription?: string | null
    challengeSource?: string | null
    descriptionFormat?: string | null
    projectId?: number | null
    overviewTotalPrizes?: number | null
    numOfRegistrants?: number
    numOfSubmissions?: number
    numOfCheckpointSubmissions?: number
    currentPhaseNames?: ChallengeCreatecurrentPhaseNamesInput | string[]
    wiproAllowed?: boolean
    tags?: ChallengeCreatetagsInput | string[]
    groups?: ChallengeCreategroupsInput | string[]
    taskIsTask?: boolean
    taskIsAssigned?: boolean
    taskMemberId?: string | null
    submissionStartDate?: Date | string | null
    submissionEndDate?: Date | string | null
    registrationStartDate?: Date | string | null
    registrationEndDate?: Date | string | null
    startDate?: Date | string | null
    endDate?: Date | string | null
    legacyId?: number | null
    status?: $Enums.ChallengeStatusEnum
    createdAt?: Date | string
    createdBy: string
    updatedAt?: Date | string
    updatedBy: string
    billingRecord?: ChallengeBillingCreateNestedOneWithoutChallengeInput
    legacyRecord?: ChallengeLegacyCreateNestedOneWithoutChallengeInput
    constraintRecord?: ChallengeConstraintCreateNestedOneWithoutChallengeInput
    events?: ChallengeEventCreateNestedManyWithoutChallengeInput
    discussions?: ChallengeDiscussionCreateNestedManyWithoutChallengeInput
    metadata?: ChallengeMetadataCreateNestedManyWithoutChallengeInput
    phases?: ChallengePhaseCreateNestedManyWithoutChallengeInput
    prizeSets?: ChallengePrizeSetCreateNestedManyWithoutChallengeInput
    winners?: ChallengeWinnerCreateNestedManyWithoutChallengeInput
    attachments?: AttachmentCreateNestedManyWithoutChallengeInput
    terms?: ChallengeTermCreateNestedManyWithoutChallengeInput
    skills?: ChallengeSkillCreateNestedManyWithoutChallengeInput
    auditLogs?: AuditLogCreateNestedManyWithoutChallengeInput
    memberAccesses?: MemberChallengeAccessCreateNestedManyWithoutChallengeInput
    type: ChallengeTypeCreateNestedOneWithoutChallengesInput
    track: ChallengeTrackCreateNestedOneWithoutChallengesInput
    timelineTemplate?: TimelineTemplateCreateNestedOneWithoutChallengesInput
  }

  export type ChallengeUncheckedCreateWithoutReviewersInput = {
    id?: string
    name: string
    description?: string | null
    privateDescription?: string | null
    challengeSource?: string | null
    descriptionFormat?: string | null
    projectId?: number | null
    typeId: string
    trackId: string
    timelineTemplateId?: string | null
    overviewTotalPrizes?: number | null
    numOfRegistrants?: number
    numOfSubmissions?: number
    numOfCheckpointSubmissions?: number
    currentPhaseNames?: ChallengeCreatecurrentPhaseNamesInput | string[]
    wiproAllowed?: boolean
    tags?: ChallengeCreatetagsInput | string[]
    groups?: ChallengeCreategroupsInput | string[]
    taskIsTask?: boolean
    taskIsAssigned?: boolean
    taskMemberId?: string | null
    submissionStartDate?: Date | string | null
    submissionEndDate?: Date | string | null
    registrationStartDate?: Date | string | null
    registrationEndDate?: Date | string | null
    startDate?: Date | string | null
    endDate?: Date | string | null
    legacyId?: number | null
    status?: $Enums.ChallengeStatusEnum
    createdAt?: Date | string
    createdBy: string
    updatedAt?: Date | string
    updatedBy: string
    billingRecord?: ChallengeBillingUncheckedCreateNestedOneWithoutChallengeInput
    legacyRecord?: ChallengeLegacyUncheckedCreateNestedOneWithoutChallengeInput
    constraintRecord?: ChallengeConstraintUncheckedCreateNestedOneWithoutChallengeInput
    events?: ChallengeEventUncheckedCreateNestedManyWithoutChallengeInput
    discussions?: ChallengeDiscussionUncheckedCreateNestedManyWithoutChallengeInput
    metadata?: ChallengeMetadataUncheckedCreateNestedManyWithoutChallengeInput
    phases?: ChallengePhaseUncheckedCreateNestedManyWithoutChallengeInput
    prizeSets?: ChallengePrizeSetUncheckedCreateNestedManyWithoutChallengeInput
    winners?: ChallengeWinnerUncheckedCreateNestedManyWithoutChallengeInput
    attachments?: AttachmentUncheckedCreateNestedManyWithoutChallengeInput
    terms?: ChallengeTermUncheckedCreateNestedManyWithoutChallengeInput
    skills?: ChallengeSkillUncheckedCreateNestedManyWithoutChallengeInput
    auditLogs?: AuditLogUncheckedCreateNestedManyWithoutChallengeInput
    memberAccesses?: MemberChallengeAccessUncheckedCreateNestedManyWithoutChallengeInput
  }

  export type ChallengeCreateOrConnectWithoutReviewersInput = {
    where: ChallengeWhereUniqueInput
    create: XOR<ChallengeCreateWithoutReviewersInput, ChallengeUncheckedCreateWithoutReviewersInput>
  }

  export type PhaseCreateWithoutChallengeReviewerInput = {
    id?: string
    name: string
    description?: string | null
    isOpen: boolean
    duration: number
    createdAt?: Date | string
    createdBy: string
    updatedAt?: Date | string
    updatedBy: string
    challengePhases?: ChallengePhaseCreateNestedManyWithoutPhaseInput
    DefaultChallengeReviewer?: DefaultChallengeReviewerCreateNestedManyWithoutPhaseInput
  }

  export type PhaseUncheckedCreateWithoutChallengeReviewerInput = {
    id?: string
    name: string
    description?: string | null
    isOpen: boolean
    duration: number
    createdAt?: Date | string
    createdBy: string
    updatedAt?: Date | string
    updatedBy: string
    challengePhases?: ChallengePhaseUncheckedCreateNestedManyWithoutPhaseInput
    DefaultChallengeReviewer?: DefaultChallengeReviewerUncheckedCreateNestedManyWithoutPhaseInput
  }

  export type PhaseCreateOrConnectWithoutChallengeReviewerInput = {
    where: PhaseWhereUniqueInput
    create: XOR<PhaseCreateWithoutChallengeReviewerInput, PhaseUncheckedCreateWithoutChallengeReviewerInput>
  }

  export type ChallengeUpsertWithoutReviewersInput = {
    update: XOR<ChallengeUpdateWithoutReviewersInput, ChallengeUncheckedUpdateWithoutReviewersInput>
    create: XOR<ChallengeCreateWithoutReviewersInput, ChallengeUncheckedCreateWithoutReviewersInput>
    where?: ChallengeWhereInput
  }

  export type ChallengeUpdateToOneWithWhereWithoutReviewersInput = {
    where?: ChallengeWhereInput
    data: XOR<ChallengeUpdateWithoutReviewersInput, ChallengeUncheckedUpdateWithoutReviewersInput>
  }

  export type ChallengeUpdateWithoutReviewersInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    privateDescription?: NullableStringFieldUpdateOperationsInput | string | null
    challengeSource?: NullableStringFieldUpdateOperationsInput | string | null
    descriptionFormat?: NullableStringFieldUpdateOperationsInput | string | null
    projectId?: NullableIntFieldUpdateOperationsInput | number | null
    overviewTotalPrizes?: NullableFloatFieldUpdateOperationsInput | number | null
    numOfRegistrants?: IntFieldUpdateOperationsInput | number
    numOfSubmissions?: IntFieldUpdateOperationsInput | number
    numOfCheckpointSubmissions?: IntFieldUpdateOperationsInput | number
    currentPhaseNames?: ChallengeUpdatecurrentPhaseNamesInput | string[]
    wiproAllowed?: BoolFieldUpdateOperationsInput | boolean
    tags?: ChallengeUpdatetagsInput | string[]
    groups?: ChallengeUpdategroupsInput | string[]
    taskIsTask?: BoolFieldUpdateOperationsInput | boolean
    taskIsAssigned?: BoolFieldUpdateOperationsInput | boolean
    taskMemberId?: NullableStringFieldUpdateOperationsInput | string | null
    submissionStartDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    submissionEndDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    registrationStartDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    registrationEndDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    startDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    endDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    legacyId?: NullableIntFieldUpdateOperationsInput | number | null
    status?: EnumChallengeStatusEnumFieldUpdateOperationsInput | $Enums.ChallengeStatusEnum
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdBy?: StringFieldUpdateOperationsInput | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedBy?: StringFieldUpdateOperationsInput | string
    billingRecord?: ChallengeBillingUpdateOneWithoutChallengeNestedInput
    legacyRecord?: ChallengeLegacyUpdateOneWithoutChallengeNestedInput
    constraintRecord?: ChallengeConstraintUpdateOneWithoutChallengeNestedInput
    events?: ChallengeEventUpdateManyWithoutChallengeNestedInput
    discussions?: ChallengeDiscussionUpdateManyWithoutChallengeNestedInput
    metadata?: ChallengeMetadataUpdateManyWithoutChallengeNestedInput
    phases?: ChallengePhaseUpdateManyWithoutChallengeNestedInput
    prizeSets?: ChallengePrizeSetUpdateManyWithoutChallengeNestedInput
    winners?: ChallengeWinnerUpdateManyWithoutChallengeNestedInput
    attachments?: AttachmentUpdateManyWithoutChallengeNestedInput
    terms?: ChallengeTermUpdateManyWithoutChallengeNestedInput
    skills?: ChallengeSkillUpdateManyWithoutChallengeNestedInput
    auditLogs?: AuditLogUpdateManyWithoutChallengeNestedInput
    memberAccesses?: MemberChallengeAccessUpdateManyWithoutChallengeNestedInput
    type?: ChallengeTypeUpdateOneRequiredWithoutChallengesNestedInput
    track?: ChallengeTrackUpdateOneRequiredWithoutChallengesNestedInput
    timelineTemplate?: TimelineTemplateUpdateOneWithoutChallengesNestedInput
  }

  export type ChallengeUncheckedUpdateWithoutReviewersInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    privateDescription?: NullableStringFieldUpdateOperationsInput | string | null
    challengeSource?: NullableStringFieldUpdateOperationsInput | string | null
    descriptionFormat?: NullableStringFieldUpdateOperationsInput | string | null
    projectId?: NullableIntFieldUpdateOperationsInput | number | null
    typeId?: StringFieldUpdateOperationsInput | string
    trackId?: StringFieldUpdateOperationsInput | string
    timelineTemplateId?: NullableStringFieldUpdateOperationsInput | string | null
    overviewTotalPrizes?: NullableFloatFieldUpdateOperationsInput | number | null
    numOfRegistrants?: IntFieldUpdateOperationsInput | number
    numOfSubmissions?: IntFieldUpdateOperationsInput | number
    numOfCheckpointSubmissions?: IntFieldUpdateOperationsInput | number
    currentPhaseNames?: ChallengeUpdatecurrentPhaseNamesInput | string[]
    wiproAllowed?: BoolFieldUpdateOperationsInput | boolean
    tags?: ChallengeUpdatetagsInput | string[]
    groups?: ChallengeUpdategroupsInput | string[]
    taskIsTask?: BoolFieldUpdateOperationsInput | boolean
    taskIsAssigned?: BoolFieldUpdateOperationsInput | boolean
    taskMemberId?: NullableStringFieldUpdateOperationsInput | string | null
    submissionStartDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    submissionEndDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    registrationStartDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    registrationEndDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    startDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    endDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    legacyId?: NullableIntFieldUpdateOperationsInput | number | null
    status?: EnumChallengeStatusEnumFieldUpdateOperationsInput | $Enums.ChallengeStatusEnum
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdBy?: StringFieldUpdateOperationsInput | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedBy?: StringFieldUpdateOperationsInput | string
    billingRecord?: ChallengeBillingUncheckedUpdateOneWithoutChallengeNestedInput
    legacyRecord?: ChallengeLegacyUncheckedUpdateOneWithoutChallengeNestedInput
    constraintRecord?: ChallengeConstraintUncheckedUpdateOneWithoutChallengeNestedInput
    events?: ChallengeEventUncheckedUpdateManyWithoutChallengeNestedInput
    discussions?: ChallengeDiscussionUncheckedUpdateManyWithoutChallengeNestedInput
    metadata?: ChallengeMetadataUncheckedUpdateManyWithoutChallengeNestedInput
    phases?: ChallengePhaseUncheckedUpdateManyWithoutChallengeNestedInput
    prizeSets?: ChallengePrizeSetUncheckedUpdateManyWithoutChallengeNestedInput
    winners?: ChallengeWinnerUncheckedUpdateManyWithoutChallengeNestedInput
    attachments?: AttachmentUncheckedUpdateManyWithoutChallengeNestedInput
    terms?: ChallengeTermUncheckedUpdateManyWithoutChallengeNestedInput
    skills?: ChallengeSkillUncheckedUpdateManyWithoutChallengeNestedInput
    auditLogs?: AuditLogUncheckedUpdateManyWithoutChallengeNestedInput
    memberAccesses?: MemberChallengeAccessUncheckedUpdateManyWithoutChallengeNestedInput
  }

  export type PhaseUpsertWithoutChallengeReviewerInput = {
    update: XOR<PhaseUpdateWithoutChallengeReviewerInput, PhaseUncheckedUpdateWithoutChallengeReviewerInput>
    create: XOR<PhaseCreateWithoutChallengeReviewerInput, PhaseUncheckedCreateWithoutChallengeReviewerInput>
    where?: PhaseWhereInput
  }

  export type PhaseUpdateToOneWithWhereWithoutChallengeReviewerInput = {
    where?: PhaseWhereInput
    data: XOR<PhaseUpdateWithoutChallengeReviewerInput, PhaseUncheckedUpdateWithoutChallengeReviewerInput>
  }

  export type PhaseUpdateWithoutChallengeReviewerInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    isOpen?: BoolFieldUpdateOperationsInput | boolean
    duration?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdBy?: StringFieldUpdateOperationsInput | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedBy?: StringFieldUpdateOperationsInput | string
    challengePhases?: ChallengePhaseUpdateManyWithoutPhaseNestedInput
    DefaultChallengeReviewer?: DefaultChallengeReviewerUpdateManyWithoutPhaseNestedInput
  }

  export type PhaseUncheckedUpdateWithoutChallengeReviewerInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    isOpen?: BoolFieldUpdateOperationsInput | boolean
    duration?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdBy?: StringFieldUpdateOperationsInput | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedBy?: StringFieldUpdateOperationsInput | string
    challengePhases?: ChallengePhaseUncheckedUpdateManyWithoutPhaseNestedInput
    DefaultChallengeReviewer?: DefaultChallengeReviewerUncheckedUpdateManyWithoutPhaseNestedInput
  }

  export type ChallengeTypeCreateWithoutDefaultReviewersInput = {
    id?: string
    name: string
    description?: string | null
    isActive?: boolean
    isTask?: boolean
    abbreviation: string
    createdAt?: Date | string
    createdBy: string
    updatedAt?: Date | string
    updatedBy: string
    challenges?: ChallengeCreateNestedManyWithoutTypeInput
    timelineTemplates?: ChallengeTimelineTemplateCreateNestedManyWithoutTypeInput
  }

  export type ChallengeTypeUncheckedCreateWithoutDefaultReviewersInput = {
    id?: string
    name: string
    description?: string | null
    isActive?: boolean
    isTask?: boolean
    abbreviation: string
    createdAt?: Date | string
    createdBy: string
    updatedAt?: Date | string
    updatedBy: string
    challenges?: ChallengeUncheckedCreateNestedManyWithoutTypeInput
    timelineTemplates?: ChallengeTimelineTemplateUncheckedCreateNestedManyWithoutTypeInput
  }

  export type ChallengeTypeCreateOrConnectWithoutDefaultReviewersInput = {
    where: ChallengeTypeWhereUniqueInput
    create: XOR<ChallengeTypeCreateWithoutDefaultReviewersInput, ChallengeTypeUncheckedCreateWithoutDefaultReviewersInput>
  }

  export type ChallengeTrackCreateWithoutDefaultReviewersInput = {
    id?: string
    name: string
    description?: string | null
    isActive: boolean
    abbreviation: string
    legacyId?: number | null
    track?: $Enums.ChallengeTrackEnum | null
    createdAt?: Date | string
    createdBy: string
    updatedAt?: Date | string
    updatedBy: string
    challenges?: ChallengeCreateNestedManyWithoutTrackInput
    timelineTemplates?: ChallengeTimelineTemplateCreateNestedManyWithoutTrackInput
  }

  export type ChallengeTrackUncheckedCreateWithoutDefaultReviewersInput = {
    id?: string
    name: string
    description?: string | null
    isActive: boolean
    abbreviation: string
    legacyId?: number | null
    track?: $Enums.ChallengeTrackEnum | null
    createdAt?: Date | string
    createdBy: string
    updatedAt?: Date | string
    updatedBy: string
    challenges?: ChallengeUncheckedCreateNestedManyWithoutTrackInput
    timelineTemplates?: ChallengeTimelineTemplateUncheckedCreateNestedManyWithoutTrackInput
  }

  export type ChallengeTrackCreateOrConnectWithoutDefaultReviewersInput = {
    where: ChallengeTrackWhereUniqueInput
    create: XOR<ChallengeTrackCreateWithoutDefaultReviewersInput, ChallengeTrackUncheckedCreateWithoutDefaultReviewersInput>
  }

  export type TimelineTemplateCreateWithoutDefaultChallengeReviewerInput = {
    id?: string
    name: string
    description?: string | null
    isActive?: boolean
    createdAt?: Date | string
    createdBy: string
    updatedAt?: Date | string
    updatedBy: string
    phases?: TimelineTemplatePhaseCreateNestedManyWithoutTimelineTemplateInput
    challengeTimelineTemplates?: ChallengeTimelineTemplateCreateNestedManyWithoutTimelineTemplateInput
    challenges?: ChallengeCreateNestedManyWithoutTimelineTemplateInput
  }

  export type TimelineTemplateUncheckedCreateWithoutDefaultChallengeReviewerInput = {
    id?: string
    name: string
    description?: string | null
    isActive?: boolean
    createdAt?: Date | string
    createdBy: string
    updatedAt?: Date | string
    updatedBy: string
    phases?: TimelineTemplatePhaseUncheckedCreateNestedManyWithoutTimelineTemplateInput
    challengeTimelineTemplates?: ChallengeTimelineTemplateUncheckedCreateNestedManyWithoutTimelineTemplateInput
    challenges?: ChallengeUncheckedCreateNestedManyWithoutTimelineTemplateInput
  }

  export type TimelineTemplateCreateOrConnectWithoutDefaultChallengeReviewerInput = {
    where: TimelineTemplateWhereUniqueInput
    create: XOR<TimelineTemplateCreateWithoutDefaultChallengeReviewerInput, TimelineTemplateUncheckedCreateWithoutDefaultChallengeReviewerInput>
  }

  export type PhaseCreateWithoutDefaultChallengeReviewerInput = {
    id?: string
    name: string
    description?: string | null
    isOpen: boolean
    duration: number
    createdAt?: Date | string
    createdBy: string
    updatedAt?: Date | string
    updatedBy: string
    challengePhases?: ChallengePhaseCreateNestedManyWithoutPhaseInput
    ChallengeReviewer?: ChallengeReviewerCreateNestedManyWithoutPhaseInput
  }

  export type PhaseUncheckedCreateWithoutDefaultChallengeReviewerInput = {
    id?: string
    name: string
    description?: string | null
    isOpen: boolean
    duration: number
    createdAt?: Date | string
    createdBy: string
    updatedAt?: Date | string
    updatedBy: string
    challengePhases?: ChallengePhaseUncheckedCreateNestedManyWithoutPhaseInput
    ChallengeReviewer?: ChallengeReviewerUncheckedCreateNestedManyWithoutPhaseInput
  }

  export type PhaseCreateOrConnectWithoutDefaultChallengeReviewerInput = {
    where: PhaseWhereUniqueInput
    create: XOR<PhaseCreateWithoutDefaultChallengeReviewerInput, PhaseUncheckedCreateWithoutDefaultChallengeReviewerInput>
  }

  export type ChallengeTypeUpsertWithoutDefaultReviewersInput = {
    update: XOR<ChallengeTypeUpdateWithoutDefaultReviewersInput, ChallengeTypeUncheckedUpdateWithoutDefaultReviewersInput>
    create: XOR<ChallengeTypeCreateWithoutDefaultReviewersInput, ChallengeTypeUncheckedCreateWithoutDefaultReviewersInput>
    where?: ChallengeTypeWhereInput
  }

  export type ChallengeTypeUpdateToOneWithWhereWithoutDefaultReviewersInput = {
    where?: ChallengeTypeWhereInput
    data: XOR<ChallengeTypeUpdateWithoutDefaultReviewersInput, ChallengeTypeUncheckedUpdateWithoutDefaultReviewersInput>
  }

  export type ChallengeTypeUpdateWithoutDefaultReviewersInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    isTask?: BoolFieldUpdateOperationsInput | boolean
    abbreviation?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdBy?: StringFieldUpdateOperationsInput | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedBy?: StringFieldUpdateOperationsInput | string
    challenges?: ChallengeUpdateManyWithoutTypeNestedInput
    timelineTemplates?: ChallengeTimelineTemplateUpdateManyWithoutTypeNestedInput
  }

  export type ChallengeTypeUncheckedUpdateWithoutDefaultReviewersInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    isTask?: BoolFieldUpdateOperationsInput | boolean
    abbreviation?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdBy?: StringFieldUpdateOperationsInput | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedBy?: StringFieldUpdateOperationsInput | string
    challenges?: ChallengeUncheckedUpdateManyWithoutTypeNestedInput
    timelineTemplates?: ChallengeTimelineTemplateUncheckedUpdateManyWithoutTypeNestedInput
  }

  export type ChallengeTrackUpsertWithoutDefaultReviewersInput = {
    update: XOR<ChallengeTrackUpdateWithoutDefaultReviewersInput, ChallengeTrackUncheckedUpdateWithoutDefaultReviewersInput>
    create: XOR<ChallengeTrackCreateWithoutDefaultReviewersInput, ChallengeTrackUncheckedCreateWithoutDefaultReviewersInput>
    where?: ChallengeTrackWhereInput
  }

  export type ChallengeTrackUpdateToOneWithWhereWithoutDefaultReviewersInput = {
    where?: ChallengeTrackWhereInput
    data: XOR<ChallengeTrackUpdateWithoutDefaultReviewersInput, ChallengeTrackUncheckedUpdateWithoutDefaultReviewersInput>
  }

  export type ChallengeTrackUpdateWithoutDefaultReviewersInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    abbreviation?: StringFieldUpdateOperationsInput | string
    legacyId?: NullableIntFieldUpdateOperationsInput | number | null
    track?: NullableEnumChallengeTrackEnumFieldUpdateOperationsInput | $Enums.ChallengeTrackEnum | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdBy?: StringFieldUpdateOperationsInput | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedBy?: StringFieldUpdateOperationsInput | string
    challenges?: ChallengeUpdateManyWithoutTrackNestedInput
    timelineTemplates?: ChallengeTimelineTemplateUpdateManyWithoutTrackNestedInput
  }

  export type ChallengeTrackUncheckedUpdateWithoutDefaultReviewersInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    abbreviation?: StringFieldUpdateOperationsInput | string
    legacyId?: NullableIntFieldUpdateOperationsInput | number | null
    track?: NullableEnumChallengeTrackEnumFieldUpdateOperationsInput | $Enums.ChallengeTrackEnum | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdBy?: StringFieldUpdateOperationsInput | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedBy?: StringFieldUpdateOperationsInput | string
    challenges?: ChallengeUncheckedUpdateManyWithoutTrackNestedInput
    timelineTemplates?: ChallengeTimelineTemplateUncheckedUpdateManyWithoutTrackNestedInput
  }

  export type TimelineTemplateUpsertWithoutDefaultChallengeReviewerInput = {
    update: XOR<TimelineTemplateUpdateWithoutDefaultChallengeReviewerInput, TimelineTemplateUncheckedUpdateWithoutDefaultChallengeReviewerInput>
    create: XOR<TimelineTemplateCreateWithoutDefaultChallengeReviewerInput, TimelineTemplateUncheckedCreateWithoutDefaultChallengeReviewerInput>
    where?: TimelineTemplateWhereInput
  }

  export type TimelineTemplateUpdateToOneWithWhereWithoutDefaultChallengeReviewerInput = {
    where?: TimelineTemplateWhereInput
    data: XOR<TimelineTemplateUpdateWithoutDefaultChallengeReviewerInput, TimelineTemplateUncheckedUpdateWithoutDefaultChallengeReviewerInput>
  }

  export type TimelineTemplateUpdateWithoutDefaultChallengeReviewerInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdBy?: StringFieldUpdateOperationsInput | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedBy?: StringFieldUpdateOperationsInput | string
    phases?: TimelineTemplatePhaseUpdateManyWithoutTimelineTemplateNestedInput
    challengeTimelineTemplates?: ChallengeTimelineTemplateUpdateManyWithoutTimelineTemplateNestedInput
    challenges?: ChallengeUpdateManyWithoutTimelineTemplateNestedInput
  }

  export type TimelineTemplateUncheckedUpdateWithoutDefaultChallengeReviewerInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdBy?: StringFieldUpdateOperationsInput | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedBy?: StringFieldUpdateOperationsInput | string
    phases?: TimelineTemplatePhaseUncheckedUpdateManyWithoutTimelineTemplateNestedInput
    challengeTimelineTemplates?: ChallengeTimelineTemplateUncheckedUpdateManyWithoutTimelineTemplateNestedInput
    challenges?: ChallengeUncheckedUpdateManyWithoutTimelineTemplateNestedInput
  }

  export type PhaseUpsertWithoutDefaultChallengeReviewerInput = {
    update: XOR<PhaseUpdateWithoutDefaultChallengeReviewerInput, PhaseUncheckedUpdateWithoutDefaultChallengeReviewerInput>
    create: XOR<PhaseCreateWithoutDefaultChallengeReviewerInput, PhaseUncheckedCreateWithoutDefaultChallengeReviewerInput>
    where?: PhaseWhereInput
  }

  export type PhaseUpdateToOneWithWhereWithoutDefaultChallengeReviewerInput = {
    where?: PhaseWhereInput
    data: XOR<PhaseUpdateWithoutDefaultChallengeReviewerInput, PhaseUncheckedUpdateWithoutDefaultChallengeReviewerInput>
  }

  export type PhaseUpdateWithoutDefaultChallengeReviewerInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    isOpen?: BoolFieldUpdateOperationsInput | boolean
    duration?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdBy?: StringFieldUpdateOperationsInput | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedBy?: StringFieldUpdateOperationsInput | string
    challengePhases?: ChallengePhaseUpdateManyWithoutPhaseNestedInput
    ChallengeReviewer?: ChallengeReviewerUpdateManyWithoutPhaseNestedInput
  }

  export type PhaseUncheckedUpdateWithoutDefaultChallengeReviewerInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    isOpen?: BoolFieldUpdateOperationsInput | boolean
    duration?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdBy?: StringFieldUpdateOperationsInput | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedBy?: StringFieldUpdateOperationsInput | string
    challengePhases?: ChallengePhaseUncheckedUpdateManyWithoutPhaseNestedInput
    ChallengeReviewer?: ChallengeReviewerUncheckedUpdateManyWithoutPhaseNestedInput
  }

  export type TimelineTemplatePhaseCreateWithoutTimelineTemplateInput = {
    id?: string
    phaseId: string
    predecessor?: string | null
    defaultDuration: number
    createdAt?: Date | string
    createdBy: string
    updatedAt?: Date | string
    updatedBy: string
  }

  export type TimelineTemplatePhaseUncheckedCreateWithoutTimelineTemplateInput = {
    id?: string
    phaseId: string
    predecessor?: string | null
    defaultDuration: number
    createdAt?: Date | string
    createdBy: string
    updatedAt?: Date | string
    updatedBy: string
  }

  export type TimelineTemplatePhaseCreateOrConnectWithoutTimelineTemplateInput = {
    where: TimelineTemplatePhaseWhereUniqueInput
    create: XOR<TimelineTemplatePhaseCreateWithoutTimelineTemplateInput, TimelineTemplatePhaseUncheckedCreateWithoutTimelineTemplateInput>
  }

  export type TimelineTemplatePhaseCreateManyTimelineTemplateInputEnvelope = {
    data: TimelineTemplatePhaseCreateManyTimelineTemplateInput | TimelineTemplatePhaseCreateManyTimelineTemplateInput[]
    skipDuplicates?: boolean
  }

  export type ChallengeTimelineTemplateCreateWithoutTimelineTemplateInput = {
    id?: string
    isDefault?: boolean
    createdAt?: Date | string
    createdBy: string
    updatedAt?: Date | string
    updatedBy: string
    track: ChallengeTrackCreateNestedOneWithoutTimelineTemplatesInput
    type: ChallengeTypeCreateNestedOneWithoutTimelineTemplatesInput
  }

  export type ChallengeTimelineTemplateUncheckedCreateWithoutTimelineTemplateInput = {
    id?: string
    typeId: string
    trackId: string
    isDefault?: boolean
    createdAt?: Date | string
    createdBy: string
    updatedAt?: Date | string
    updatedBy: string
  }

  export type ChallengeTimelineTemplateCreateOrConnectWithoutTimelineTemplateInput = {
    where: ChallengeTimelineTemplateWhereUniqueInput
    create: XOR<ChallengeTimelineTemplateCreateWithoutTimelineTemplateInput, ChallengeTimelineTemplateUncheckedCreateWithoutTimelineTemplateInput>
  }

  export type ChallengeTimelineTemplateCreateManyTimelineTemplateInputEnvelope = {
    data: ChallengeTimelineTemplateCreateManyTimelineTemplateInput | ChallengeTimelineTemplateCreateManyTimelineTemplateInput[]
    skipDuplicates?: boolean
  }

  export type ChallengeCreateWithoutTimelineTemplateInput = {
    id?: string
    name: string
    description?: string | null
    privateDescription?: string | null
    challengeSource?: string | null
    descriptionFormat?: string | null
    projectId?: number | null
    overviewTotalPrizes?: number | null
    numOfRegistrants?: number
    numOfSubmissions?: number
    numOfCheckpointSubmissions?: number
    currentPhaseNames?: ChallengeCreatecurrentPhaseNamesInput | string[]
    wiproAllowed?: boolean
    tags?: ChallengeCreatetagsInput | string[]
    groups?: ChallengeCreategroupsInput | string[]
    taskIsTask?: boolean
    taskIsAssigned?: boolean
    taskMemberId?: string | null
    submissionStartDate?: Date | string | null
    submissionEndDate?: Date | string | null
    registrationStartDate?: Date | string | null
    registrationEndDate?: Date | string | null
    startDate?: Date | string | null
    endDate?: Date | string | null
    legacyId?: number | null
    status?: $Enums.ChallengeStatusEnum
    createdAt?: Date | string
    createdBy: string
    updatedAt?: Date | string
    updatedBy: string
    billingRecord?: ChallengeBillingCreateNestedOneWithoutChallengeInput
    legacyRecord?: ChallengeLegacyCreateNestedOneWithoutChallengeInput
    constraintRecord?: ChallengeConstraintCreateNestedOneWithoutChallengeInput
    events?: ChallengeEventCreateNestedManyWithoutChallengeInput
    discussions?: ChallengeDiscussionCreateNestedManyWithoutChallengeInput
    metadata?: ChallengeMetadataCreateNestedManyWithoutChallengeInput
    phases?: ChallengePhaseCreateNestedManyWithoutChallengeInput
    prizeSets?: ChallengePrizeSetCreateNestedManyWithoutChallengeInput
    reviewers?: ChallengeReviewerCreateNestedManyWithoutChallengeInput
    winners?: ChallengeWinnerCreateNestedManyWithoutChallengeInput
    attachments?: AttachmentCreateNestedManyWithoutChallengeInput
    terms?: ChallengeTermCreateNestedManyWithoutChallengeInput
    skills?: ChallengeSkillCreateNestedManyWithoutChallengeInput
    auditLogs?: AuditLogCreateNestedManyWithoutChallengeInput
    memberAccesses?: MemberChallengeAccessCreateNestedManyWithoutChallengeInput
    type: ChallengeTypeCreateNestedOneWithoutChallengesInput
    track: ChallengeTrackCreateNestedOneWithoutChallengesInput
  }

  export type ChallengeUncheckedCreateWithoutTimelineTemplateInput = {
    id?: string
    name: string
    description?: string | null
    privateDescription?: string | null
    challengeSource?: string | null
    descriptionFormat?: string | null
    projectId?: number | null
    typeId: string
    trackId: string
    overviewTotalPrizes?: number | null
    numOfRegistrants?: number
    numOfSubmissions?: number
    numOfCheckpointSubmissions?: number
    currentPhaseNames?: ChallengeCreatecurrentPhaseNamesInput | string[]
    wiproAllowed?: boolean
    tags?: ChallengeCreatetagsInput | string[]
    groups?: ChallengeCreategroupsInput | string[]
    taskIsTask?: boolean
    taskIsAssigned?: boolean
    taskMemberId?: string | null
    submissionStartDate?: Date | string | null
    submissionEndDate?: Date | string | null
    registrationStartDate?: Date | string | null
    registrationEndDate?: Date | string | null
    startDate?: Date | string | null
    endDate?: Date | string | null
    legacyId?: number | null
    status?: $Enums.ChallengeStatusEnum
    createdAt?: Date | string
    createdBy: string
    updatedAt?: Date | string
    updatedBy: string
    billingRecord?: ChallengeBillingUncheckedCreateNestedOneWithoutChallengeInput
    legacyRecord?: ChallengeLegacyUncheckedCreateNestedOneWithoutChallengeInput
    constraintRecord?: ChallengeConstraintUncheckedCreateNestedOneWithoutChallengeInput
    events?: ChallengeEventUncheckedCreateNestedManyWithoutChallengeInput
    discussions?: ChallengeDiscussionUncheckedCreateNestedManyWithoutChallengeInput
    metadata?: ChallengeMetadataUncheckedCreateNestedManyWithoutChallengeInput
    phases?: ChallengePhaseUncheckedCreateNestedManyWithoutChallengeInput
    prizeSets?: ChallengePrizeSetUncheckedCreateNestedManyWithoutChallengeInput
    reviewers?: ChallengeReviewerUncheckedCreateNestedManyWithoutChallengeInput
    winners?: ChallengeWinnerUncheckedCreateNestedManyWithoutChallengeInput
    attachments?: AttachmentUncheckedCreateNestedManyWithoutChallengeInput
    terms?: ChallengeTermUncheckedCreateNestedManyWithoutChallengeInput
    skills?: ChallengeSkillUncheckedCreateNestedManyWithoutChallengeInput
    auditLogs?: AuditLogUncheckedCreateNestedManyWithoutChallengeInput
    memberAccesses?: MemberChallengeAccessUncheckedCreateNestedManyWithoutChallengeInput
  }

  export type ChallengeCreateOrConnectWithoutTimelineTemplateInput = {
    where: ChallengeWhereUniqueInput
    create: XOR<ChallengeCreateWithoutTimelineTemplateInput, ChallengeUncheckedCreateWithoutTimelineTemplateInput>
  }

  export type ChallengeCreateManyTimelineTemplateInputEnvelope = {
    data: ChallengeCreateManyTimelineTemplateInput | ChallengeCreateManyTimelineTemplateInput[]
    skipDuplicates?: boolean
  }

  export type DefaultChallengeReviewerCreateWithoutTimelineTemplateInput = {
    id?: string
    scorecardId?: string | null
    isMemberReview: boolean
    memberReviewerCount?: number | null
    phaseName: string
    fixedAmount?: number | null
    baseCoefficient?: number | null
    incrementalCoefficient?: number | null
    opportunityType?: $Enums.ReviewOpportunityTypeEnum | null
    aiWorkflowId?: string | null
    shouldOpenOpportunity?: boolean
    createdAt?: Date | string
    createdBy: string
    updatedAt?: Date | string
    updatedBy: string
    challengeType: ChallengeTypeCreateNestedOneWithoutDefaultReviewersInput
    challengeTrack: ChallengeTrackCreateNestedOneWithoutDefaultReviewersInput
    phase?: PhaseCreateNestedOneWithoutDefaultChallengeReviewerInput
  }

  export type DefaultChallengeReviewerUncheckedCreateWithoutTimelineTemplateInput = {
    id?: string
    typeId: string
    trackId: string
    scorecardId?: string | null
    isMemberReview: boolean
    memberReviewerCount?: number | null
    phaseName: string
    phaseId?: string | null
    fixedAmount?: number | null
    baseCoefficient?: number | null
    incrementalCoefficient?: number | null
    opportunityType?: $Enums.ReviewOpportunityTypeEnum | null
    aiWorkflowId?: string | null
    shouldOpenOpportunity?: boolean
    createdAt?: Date | string
    createdBy: string
    updatedAt?: Date | string
    updatedBy: string
  }

  export type DefaultChallengeReviewerCreateOrConnectWithoutTimelineTemplateInput = {
    where: DefaultChallengeReviewerWhereUniqueInput
    create: XOR<DefaultChallengeReviewerCreateWithoutTimelineTemplateInput, DefaultChallengeReviewerUncheckedCreateWithoutTimelineTemplateInput>
  }

  export type DefaultChallengeReviewerCreateManyTimelineTemplateInputEnvelope = {
    data: DefaultChallengeReviewerCreateManyTimelineTemplateInput | DefaultChallengeReviewerCreateManyTimelineTemplateInput[]
    skipDuplicates?: boolean
  }

  export type TimelineTemplatePhaseUpsertWithWhereUniqueWithoutTimelineTemplateInput = {
    where: TimelineTemplatePhaseWhereUniqueInput
    update: XOR<TimelineTemplatePhaseUpdateWithoutTimelineTemplateInput, TimelineTemplatePhaseUncheckedUpdateWithoutTimelineTemplateInput>
    create: XOR<TimelineTemplatePhaseCreateWithoutTimelineTemplateInput, TimelineTemplatePhaseUncheckedCreateWithoutTimelineTemplateInput>
  }

  export type TimelineTemplatePhaseUpdateWithWhereUniqueWithoutTimelineTemplateInput = {
    where: TimelineTemplatePhaseWhereUniqueInput
    data: XOR<TimelineTemplatePhaseUpdateWithoutTimelineTemplateInput, TimelineTemplatePhaseUncheckedUpdateWithoutTimelineTemplateInput>
  }

  export type TimelineTemplatePhaseUpdateManyWithWhereWithoutTimelineTemplateInput = {
    where: TimelineTemplatePhaseScalarWhereInput
    data: XOR<TimelineTemplatePhaseUpdateManyMutationInput, TimelineTemplatePhaseUncheckedUpdateManyWithoutTimelineTemplateInput>
  }

  export type TimelineTemplatePhaseScalarWhereInput = {
    AND?: TimelineTemplatePhaseScalarWhereInput | TimelineTemplatePhaseScalarWhereInput[]
    OR?: TimelineTemplatePhaseScalarWhereInput[]
    NOT?: TimelineTemplatePhaseScalarWhereInput | TimelineTemplatePhaseScalarWhereInput[]
    id?: StringFilter<"TimelineTemplatePhase"> | string
    timelineTemplateId?: StringFilter<"TimelineTemplatePhase"> | string
    phaseId?: StringFilter<"TimelineTemplatePhase"> | string
    predecessor?: StringNullableFilter<"TimelineTemplatePhase"> | string | null
    defaultDuration?: IntFilter<"TimelineTemplatePhase"> | number
    createdAt?: DateTimeFilter<"TimelineTemplatePhase"> | Date | string
    createdBy?: StringFilter<"TimelineTemplatePhase"> | string
    updatedAt?: DateTimeFilter<"TimelineTemplatePhase"> | Date | string
    updatedBy?: StringFilter<"TimelineTemplatePhase"> | string
  }

  export type ChallengeTimelineTemplateUpsertWithWhereUniqueWithoutTimelineTemplateInput = {
    where: ChallengeTimelineTemplateWhereUniqueInput
    update: XOR<ChallengeTimelineTemplateUpdateWithoutTimelineTemplateInput, ChallengeTimelineTemplateUncheckedUpdateWithoutTimelineTemplateInput>
    create: XOR<ChallengeTimelineTemplateCreateWithoutTimelineTemplateInput, ChallengeTimelineTemplateUncheckedCreateWithoutTimelineTemplateInput>
  }

  export type ChallengeTimelineTemplateUpdateWithWhereUniqueWithoutTimelineTemplateInput = {
    where: ChallengeTimelineTemplateWhereUniqueInput
    data: XOR<ChallengeTimelineTemplateUpdateWithoutTimelineTemplateInput, ChallengeTimelineTemplateUncheckedUpdateWithoutTimelineTemplateInput>
  }

  export type ChallengeTimelineTemplateUpdateManyWithWhereWithoutTimelineTemplateInput = {
    where: ChallengeTimelineTemplateScalarWhereInput
    data: XOR<ChallengeTimelineTemplateUpdateManyMutationInput, ChallengeTimelineTemplateUncheckedUpdateManyWithoutTimelineTemplateInput>
  }

  export type ChallengeUpsertWithWhereUniqueWithoutTimelineTemplateInput = {
    where: ChallengeWhereUniqueInput
    update: XOR<ChallengeUpdateWithoutTimelineTemplateInput, ChallengeUncheckedUpdateWithoutTimelineTemplateInput>
    create: XOR<ChallengeCreateWithoutTimelineTemplateInput, ChallengeUncheckedCreateWithoutTimelineTemplateInput>
  }

  export type ChallengeUpdateWithWhereUniqueWithoutTimelineTemplateInput = {
    where: ChallengeWhereUniqueInput
    data: XOR<ChallengeUpdateWithoutTimelineTemplateInput, ChallengeUncheckedUpdateWithoutTimelineTemplateInput>
  }

  export type ChallengeUpdateManyWithWhereWithoutTimelineTemplateInput = {
    where: ChallengeScalarWhereInput
    data: XOR<ChallengeUpdateManyMutationInput, ChallengeUncheckedUpdateManyWithoutTimelineTemplateInput>
  }

  export type DefaultChallengeReviewerUpsertWithWhereUniqueWithoutTimelineTemplateInput = {
    where: DefaultChallengeReviewerWhereUniqueInput
    update: XOR<DefaultChallengeReviewerUpdateWithoutTimelineTemplateInput, DefaultChallengeReviewerUncheckedUpdateWithoutTimelineTemplateInput>
    create: XOR<DefaultChallengeReviewerCreateWithoutTimelineTemplateInput, DefaultChallengeReviewerUncheckedCreateWithoutTimelineTemplateInput>
  }

  export type DefaultChallengeReviewerUpdateWithWhereUniqueWithoutTimelineTemplateInput = {
    where: DefaultChallengeReviewerWhereUniqueInput
    data: XOR<DefaultChallengeReviewerUpdateWithoutTimelineTemplateInput, DefaultChallengeReviewerUncheckedUpdateWithoutTimelineTemplateInput>
  }

  export type DefaultChallengeReviewerUpdateManyWithWhereWithoutTimelineTemplateInput = {
    where: DefaultChallengeReviewerScalarWhereInput
    data: XOR<DefaultChallengeReviewerUpdateManyMutationInput, DefaultChallengeReviewerUncheckedUpdateManyWithoutTimelineTemplateInput>
  }

  export type TimelineTemplateCreateWithoutPhasesInput = {
    id?: string
    name: string
    description?: string | null
    isActive?: boolean
    createdAt?: Date | string
    createdBy: string
    updatedAt?: Date | string
    updatedBy: string
    challengeTimelineTemplates?: ChallengeTimelineTemplateCreateNestedManyWithoutTimelineTemplateInput
    challenges?: ChallengeCreateNestedManyWithoutTimelineTemplateInput
    DefaultChallengeReviewer?: DefaultChallengeReviewerCreateNestedManyWithoutTimelineTemplateInput
  }

  export type TimelineTemplateUncheckedCreateWithoutPhasesInput = {
    id?: string
    name: string
    description?: string | null
    isActive?: boolean
    createdAt?: Date | string
    createdBy: string
    updatedAt?: Date | string
    updatedBy: string
    challengeTimelineTemplates?: ChallengeTimelineTemplateUncheckedCreateNestedManyWithoutTimelineTemplateInput
    challenges?: ChallengeUncheckedCreateNestedManyWithoutTimelineTemplateInput
    DefaultChallengeReviewer?: DefaultChallengeReviewerUncheckedCreateNestedManyWithoutTimelineTemplateInput
  }

  export type TimelineTemplateCreateOrConnectWithoutPhasesInput = {
    where: TimelineTemplateWhereUniqueInput
    create: XOR<TimelineTemplateCreateWithoutPhasesInput, TimelineTemplateUncheckedCreateWithoutPhasesInput>
  }

  export type TimelineTemplateUpsertWithoutPhasesInput = {
    update: XOR<TimelineTemplateUpdateWithoutPhasesInput, TimelineTemplateUncheckedUpdateWithoutPhasesInput>
    create: XOR<TimelineTemplateCreateWithoutPhasesInput, TimelineTemplateUncheckedCreateWithoutPhasesInput>
    where?: TimelineTemplateWhereInput
  }

  export type TimelineTemplateUpdateToOneWithWhereWithoutPhasesInput = {
    where?: TimelineTemplateWhereInput
    data: XOR<TimelineTemplateUpdateWithoutPhasesInput, TimelineTemplateUncheckedUpdateWithoutPhasesInput>
  }

  export type TimelineTemplateUpdateWithoutPhasesInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdBy?: StringFieldUpdateOperationsInput | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedBy?: StringFieldUpdateOperationsInput | string
    challengeTimelineTemplates?: ChallengeTimelineTemplateUpdateManyWithoutTimelineTemplateNestedInput
    challenges?: ChallengeUpdateManyWithoutTimelineTemplateNestedInput
    DefaultChallengeReviewer?: DefaultChallengeReviewerUpdateManyWithoutTimelineTemplateNestedInput
  }

  export type TimelineTemplateUncheckedUpdateWithoutPhasesInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdBy?: StringFieldUpdateOperationsInput | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedBy?: StringFieldUpdateOperationsInput | string
    challengeTimelineTemplates?: ChallengeTimelineTemplateUncheckedUpdateManyWithoutTimelineTemplateNestedInput
    challenges?: ChallengeUncheckedUpdateManyWithoutTimelineTemplateNestedInput
    DefaultChallengeReviewer?: DefaultChallengeReviewerUncheckedUpdateManyWithoutTimelineTemplateNestedInput
  }

  export type ChallengeEventCreateManyChallengeInput = {
    id?: string
    eventId: number
    name?: string | null
    key?: string | null
    createdAt?: Date | string
    createdBy: string
    updatedAt?: Date | string
    updatedBy: string
  }

  export type ChallengeDiscussionCreateManyChallengeInput = {
    id?: string
    discussionId?: string | null
    name: string
    type: $Enums.DiscussionTypeEnum
    provider: string
    url?: string | null
    createdAt?: Date | string
    createdBy: string
    updatedAt?: Date | string
    updatedBy: string
  }

  export type ChallengeMetadataCreateManyChallengeInput = {
    id?: string
    name: string
    value: string
    createdAt?: Date | string
    createdBy: string
    updatedAt?: Date | string
    updatedBy: string
  }

  export type ChallengePhaseCreateManyChallengeInput = {
    id?: string
    phaseId: string
    name: string
    description?: string | null
    isOpen?: boolean | null
    predecessor?: string | null
    duration?: number | null
    scheduledStartDate?: Date | string | null
    scheduledEndDate?: Date | string | null
    actualStartDate?: Date | string | null
    actualEndDate?: Date | string | null
    createdAt?: Date | string
    createdBy: string
    updatedAt?: Date | string
    updatedBy: string
  }

  export type ChallengePrizeSetCreateManyChallengeInput = {
    id?: string
    type: $Enums.PrizeSetTypeEnum
    description?: string | null
    createdAt?: Date | string
    createdBy: string
    updatedAt?: Date | string
    updatedBy: string
  }

  export type ChallengeReviewerCreateManyChallengeInput = {
    id?: string
    scorecardId: string
    isMemberReview: boolean
    memberReviewerCount?: number | null
    phaseId: string
    fixedAmount?: number | null
    baseCoefficient?: number | null
    incrementalCoefficient?: number | null
    type?: $Enums.ReviewOpportunityTypeEnum | null
    aiWorkflowId?: string | null
    shouldOpenOpportunity?: boolean
    createdAt?: Date | string
    createdBy: string
    updatedAt?: Date | string
    updatedBy: string
  }

  export type ChallengeWinnerCreateManyChallengeInput = {
    id?: string
    userId: number
    handle: string
    placement: number
    type: $Enums.PrizeSetTypeEnum
    createdAt?: Date | string
    createdBy: string
    updatedAt?: Date | string
    updatedBy: string
  }

  export type AttachmentCreateManyChallengeInput = {
    id?: string
    name: string
    fileSize: number
    url: string
    description?: string | null
    createdAt?: Date | string
    createdBy: string
    updatedAt?: Date | string
    updatedBy: string
  }

  export type ChallengeTermCreateManyChallengeInput = {
    id?: string
    termId: string
    roleId: string
    createdAt?: Date | string
    createdBy: string
    updatedAt?: Date | string
    updatedBy: string
  }

  export type ChallengeSkillCreateManyChallengeInput = {
    id?: string
    skillId: string
    createdAt?: Date | string
    createdBy: string
    updatedAt?: Date | string
    updatedBy: string
  }

  export type AuditLogCreateManyChallengeInput = {
    id?: string
    fieldName: string
    oldValue?: string | null
    newValue?: string | null
    createdAt?: Date | string
    createdBy: string
    memberId?: string | null
  }

  export type ChallengeEventUpdateWithoutChallengeInput = {
    id?: StringFieldUpdateOperationsInput | string
    eventId?: IntFieldUpdateOperationsInput | number
    name?: NullableStringFieldUpdateOperationsInput | string | null
    key?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdBy?: StringFieldUpdateOperationsInput | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedBy?: StringFieldUpdateOperationsInput | string
  }

  export type ChallengeEventUncheckedUpdateWithoutChallengeInput = {
    id?: StringFieldUpdateOperationsInput | string
    eventId?: IntFieldUpdateOperationsInput | number
    name?: NullableStringFieldUpdateOperationsInput | string | null
    key?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdBy?: StringFieldUpdateOperationsInput | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedBy?: StringFieldUpdateOperationsInput | string
  }

  export type ChallengeEventUncheckedUpdateManyWithoutChallengeInput = {
    id?: StringFieldUpdateOperationsInput | string
    eventId?: IntFieldUpdateOperationsInput | number
    name?: NullableStringFieldUpdateOperationsInput | string | null
    key?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdBy?: StringFieldUpdateOperationsInput | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedBy?: StringFieldUpdateOperationsInput | string
  }

  export type ChallengeDiscussionUpdateWithoutChallengeInput = {
    id?: StringFieldUpdateOperationsInput | string
    discussionId?: NullableStringFieldUpdateOperationsInput | string | null
    name?: StringFieldUpdateOperationsInput | string
    type?: EnumDiscussionTypeEnumFieldUpdateOperationsInput | $Enums.DiscussionTypeEnum
    provider?: StringFieldUpdateOperationsInput | string
    url?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdBy?: StringFieldUpdateOperationsInput | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedBy?: StringFieldUpdateOperationsInput | string
    options?: ChallengeDiscussionOptionUpdateManyWithoutDiscussionNestedInput
  }

  export type ChallengeDiscussionUncheckedUpdateWithoutChallengeInput = {
    id?: StringFieldUpdateOperationsInput | string
    discussionId?: NullableStringFieldUpdateOperationsInput | string | null
    name?: StringFieldUpdateOperationsInput | string
    type?: EnumDiscussionTypeEnumFieldUpdateOperationsInput | $Enums.DiscussionTypeEnum
    provider?: StringFieldUpdateOperationsInput | string
    url?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdBy?: StringFieldUpdateOperationsInput | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedBy?: StringFieldUpdateOperationsInput | string
    options?: ChallengeDiscussionOptionUncheckedUpdateManyWithoutDiscussionNestedInput
  }

  export type ChallengeDiscussionUncheckedUpdateManyWithoutChallengeInput = {
    id?: StringFieldUpdateOperationsInput | string
    discussionId?: NullableStringFieldUpdateOperationsInput | string | null
    name?: StringFieldUpdateOperationsInput | string
    type?: EnumDiscussionTypeEnumFieldUpdateOperationsInput | $Enums.DiscussionTypeEnum
    provider?: StringFieldUpdateOperationsInput | string
    url?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdBy?: StringFieldUpdateOperationsInput | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedBy?: StringFieldUpdateOperationsInput | string
  }

  export type ChallengeMetadataUpdateWithoutChallengeInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    value?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdBy?: StringFieldUpdateOperationsInput | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedBy?: StringFieldUpdateOperationsInput | string
  }

  export type ChallengeMetadataUncheckedUpdateWithoutChallengeInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    value?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdBy?: StringFieldUpdateOperationsInput | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedBy?: StringFieldUpdateOperationsInput | string
  }

  export type ChallengeMetadataUncheckedUpdateManyWithoutChallengeInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    value?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdBy?: StringFieldUpdateOperationsInput | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedBy?: StringFieldUpdateOperationsInput | string
  }

  export type ChallengePhaseUpdateWithoutChallengeInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    isOpen?: NullableBoolFieldUpdateOperationsInput | boolean | null
    predecessor?: NullableStringFieldUpdateOperationsInput | string | null
    duration?: NullableIntFieldUpdateOperationsInput | number | null
    scheduledStartDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    scheduledEndDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    actualStartDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    actualEndDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdBy?: StringFieldUpdateOperationsInput | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedBy?: StringFieldUpdateOperationsInput | string
    constraints?: ChallengePhaseConstraintUpdateManyWithoutChallengePhaseNestedInput
    phase?: PhaseUpdateOneRequiredWithoutChallengePhasesNestedInput
  }

  export type ChallengePhaseUncheckedUpdateWithoutChallengeInput = {
    id?: StringFieldUpdateOperationsInput | string
    phaseId?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    isOpen?: NullableBoolFieldUpdateOperationsInput | boolean | null
    predecessor?: NullableStringFieldUpdateOperationsInput | string | null
    duration?: NullableIntFieldUpdateOperationsInput | number | null
    scheduledStartDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    scheduledEndDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    actualStartDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    actualEndDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdBy?: StringFieldUpdateOperationsInput | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedBy?: StringFieldUpdateOperationsInput | string
    constraints?: ChallengePhaseConstraintUncheckedUpdateManyWithoutChallengePhaseNestedInput
  }

  export type ChallengePhaseUncheckedUpdateManyWithoutChallengeInput = {
    id?: StringFieldUpdateOperationsInput | string
    phaseId?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    isOpen?: NullableBoolFieldUpdateOperationsInput | boolean | null
    predecessor?: NullableStringFieldUpdateOperationsInput | string | null
    duration?: NullableIntFieldUpdateOperationsInput | number | null
    scheduledStartDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    scheduledEndDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    actualStartDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    actualEndDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdBy?: StringFieldUpdateOperationsInput | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedBy?: StringFieldUpdateOperationsInput | string
  }

  export type ChallengePrizeSetUpdateWithoutChallengeInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: EnumPrizeSetTypeEnumFieldUpdateOperationsInput | $Enums.PrizeSetTypeEnum
    description?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdBy?: StringFieldUpdateOperationsInput | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedBy?: StringFieldUpdateOperationsInput | string
    prizes?: PrizeUpdateManyWithoutPrizeSetNestedInput
  }

  export type ChallengePrizeSetUncheckedUpdateWithoutChallengeInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: EnumPrizeSetTypeEnumFieldUpdateOperationsInput | $Enums.PrizeSetTypeEnum
    description?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdBy?: StringFieldUpdateOperationsInput | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedBy?: StringFieldUpdateOperationsInput | string
    prizes?: PrizeUncheckedUpdateManyWithoutPrizeSetNestedInput
  }

  export type ChallengePrizeSetUncheckedUpdateManyWithoutChallengeInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: EnumPrizeSetTypeEnumFieldUpdateOperationsInput | $Enums.PrizeSetTypeEnum
    description?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdBy?: StringFieldUpdateOperationsInput | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedBy?: StringFieldUpdateOperationsInput | string
  }

  export type ChallengeReviewerUpdateWithoutChallengeInput = {
    id?: StringFieldUpdateOperationsInput | string
    scorecardId?: StringFieldUpdateOperationsInput | string
    isMemberReview?: BoolFieldUpdateOperationsInput | boolean
    memberReviewerCount?: NullableIntFieldUpdateOperationsInput | number | null
    fixedAmount?: NullableFloatFieldUpdateOperationsInput | number | null
    baseCoefficient?: NullableFloatFieldUpdateOperationsInput | number | null
    incrementalCoefficient?: NullableFloatFieldUpdateOperationsInput | number | null
    type?: NullableEnumReviewOpportunityTypeEnumFieldUpdateOperationsInput | $Enums.ReviewOpportunityTypeEnum | null
    aiWorkflowId?: NullableStringFieldUpdateOperationsInput | string | null
    shouldOpenOpportunity?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdBy?: StringFieldUpdateOperationsInput | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedBy?: StringFieldUpdateOperationsInput | string
    phase?: PhaseUpdateOneRequiredWithoutChallengeReviewerNestedInput
  }

  export type ChallengeReviewerUncheckedUpdateWithoutChallengeInput = {
    id?: StringFieldUpdateOperationsInput | string
    scorecardId?: StringFieldUpdateOperationsInput | string
    isMemberReview?: BoolFieldUpdateOperationsInput | boolean
    memberReviewerCount?: NullableIntFieldUpdateOperationsInput | number | null
    phaseId?: StringFieldUpdateOperationsInput | string
    fixedAmount?: NullableFloatFieldUpdateOperationsInput | number | null
    baseCoefficient?: NullableFloatFieldUpdateOperationsInput | number | null
    incrementalCoefficient?: NullableFloatFieldUpdateOperationsInput | number | null
    type?: NullableEnumReviewOpportunityTypeEnumFieldUpdateOperationsInput | $Enums.ReviewOpportunityTypeEnum | null
    aiWorkflowId?: NullableStringFieldUpdateOperationsInput | string | null
    shouldOpenOpportunity?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdBy?: StringFieldUpdateOperationsInput | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedBy?: StringFieldUpdateOperationsInput | string
  }

  export type ChallengeReviewerUncheckedUpdateManyWithoutChallengeInput = {
    id?: StringFieldUpdateOperationsInput | string
    scorecardId?: StringFieldUpdateOperationsInput | string
    isMemberReview?: BoolFieldUpdateOperationsInput | boolean
    memberReviewerCount?: NullableIntFieldUpdateOperationsInput | number | null
    phaseId?: StringFieldUpdateOperationsInput | string
    fixedAmount?: NullableFloatFieldUpdateOperationsInput | number | null
    baseCoefficient?: NullableFloatFieldUpdateOperationsInput | number | null
    incrementalCoefficient?: NullableFloatFieldUpdateOperationsInput | number | null
    type?: NullableEnumReviewOpportunityTypeEnumFieldUpdateOperationsInput | $Enums.ReviewOpportunityTypeEnum | null
    aiWorkflowId?: NullableStringFieldUpdateOperationsInput | string | null
    shouldOpenOpportunity?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdBy?: StringFieldUpdateOperationsInput | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedBy?: StringFieldUpdateOperationsInput | string
  }

  export type ChallengeWinnerUpdateWithoutChallengeInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: IntFieldUpdateOperationsInput | number
    handle?: StringFieldUpdateOperationsInput | string
    placement?: IntFieldUpdateOperationsInput | number
    type?: EnumPrizeSetTypeEnumFieldUpdateOperationsInput | $Enums.PrizeSetTypeEnum
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdBy?: StringFieldUpdateOperationsInput | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedBy?: StringFieldUpdateOperationsInput | string
  }

  export type ChallengeWinnerUncheckedUpdateWithoutChallengeInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: IntFieldUpdateOperationsInput | number
    handle?: StringFieldUpdateOperationsInput | string
    placement?: IntFieldUpdateOperationsInput | number
    type?: EnumPrizeSetTypeEnumFieldUpdateOperationsInput | $Enums.PrizeSetTypeEnum
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdBy?: StringFieldUpdateOperationsInput | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedBy?: StringFieldUpdateOperationsInput | string
  }

  export type ChallengeWinnerUncheckedUpdateManyWithoutChallengeInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: IntFieldUpdateOperationsInput | number
    handle?: StringFieldUpdateOperationsInput | string
    placement?: IntFieldUpdateOperationsInput | number
    type?: EnumPrizeSetTypeEnumFieldUpdateOperationsInput | $Enums.PrizeSetTypeEnum
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdBy?: StringFieldUpdateOperationsInput | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedBy?: StringFieldUpdateOperationsInput | string
  }

  export type AttachmentUpdateWithoutChallengeInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    fileSize?: IntFieldUpdateOperationsInput | number
    url?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdBy?: StringFieldUpdateOperationsInput | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedBy?: StringFieldUpdateOperationsInput | string
  }

  export type AttachmentUncheckedUpdateWithoutChallengeInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    fileSize?: IntFieldUpdateOperationsInput | number
    url?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdBy?: StringFieldUpdateOperationsInput | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedBy?: StringFieldUpdateOperationsInput | string
  }

  export type AttachmentUncheckedUpdateManyWithoutChallengeInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    fileSize?: IntFieldUpdateOperationsInput | number
    url?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdBy?: StringFieldUpdateOperationsInput | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedBy?: StringFieldUpdateOperationsInput | string
  }

  export type ChallengeTermUpdateWithoutChallengeInput = {
    id?: StringFieldUpdateOperationsInput | string
    termId?: StringFieldUpdateOperationsInput | string
    roleId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdBy?: StringFieldUpdateOperationsInput | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedBy?: StringFieldUpdateOperationsInput | string
  }

  export type ChallengeTermUncheckedUpdateWithoutChallengeInput = {
    id?: StringFieldUpdateOperationsInput | string
    termId?: StringFieldUpdateOperationsInput | string
    roleId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdBy?: StringFieldUpdateOperationsInput | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedBy?: StringFieldUpdateOperationsInput | string
  }

  export type ChallengeTermUncheckedUpdateManyWithoutChallengeInput = {
    id?: StringFieldUpdateOperationsInput | string
    termId?: StringFieldUpdateOperationsInput | string
    roleId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdBy?: StringFieldUpdateOperationsInput | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedBy?: StringFieldUpdateOperationsInput | string
  }

  export type ChallengeSkillUpdateWithoutChallengeInput = {
    id?: StringFieldUpdateOperationsInput | string
    skillId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdBy?: StringFieldUpdateOperationsInput | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedBy?: StringFieldUpdateOperationsInput | string
  }

  export type ChallengeSkillUncheckedUpdateWithoutChallengeInput = {
    id?: StringFieldUpdateOperationsInput | string
    skillId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdBy?: StringFieldUpdateOperationsInput | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedBy?: StringFieldUpdateOperationsInput | string
  }

  export type ChallengeSkillUncheckedUpdateManyWithoutChallengeInput = {
    id?: StringFieldUpdateOperationsInput | string
    skillId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdBy?: StringFieldUpdateOperationsInput | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedBy?: StringFieldUpdateOperationsInput | string
  }

  export type AuditLogUpdateWithoutChallengeInput = {
    id?: StringFieldUpdateOperationsInput | string
    fieldName?: StringFieldUpdateOperationsInput | string
    oldValue?: NullableStringFieldUpdateOperationsInput | string | null
    newValue?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdBy?: StringFieldUpdateOperationsInput | string
    memberId?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type AuditLogUncheckedUpdateWithoutChallengeInput = {
    id?: StringFieldUpdateOperationsInput | string
    fieldName?: StringFieldUpdateOperationsInput | string
    oldValue?: NullableStringFieldUpdateOperationsInput | string | null
    newValue?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdBy?: StringFieldUpdateOperationsInput | string
    memberId?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type AuditLogUncheckedUpdateManyWithoutChallengeInput = {
    id?: StringFieldUpdateOperationsInput | string
    fieldName?: StringFieldUpdateOperationsInput | string
    oldValue?: NullableStringFieldUpdateOperationsInput | string | null
    newValue?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdBy?: StringFieldUpdateOperationsInput | string
    memberId?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type MemberChallengeAccessUpdateWithoutChallengeInput = {
    memberId?: StringFieldUpdateOperationsInput | string
  }

  export type MemberChallengeAccessUncheckedUpdateWithoutChallengeInput = {
    memberId?: StringFieldUpdateOperationsInput | string
  }

  export type MemberChallengeAccessUpdateManyMutationInput = {
    memberId?: StringFieldUpdateOperationsInput | string
  }

  export type MemberChallengeAccessUncheckedUpdateManyWithoutChallengeInput = {
    memberId?: StringFieldUpdateOperationsInput | string
  }

  export type ChallengeCreateManyTypeInput = {
    id?: string
    name: string
    description?: string | null
    privateDescription?: string | null
    challengeSource?: string | null
    descriptionFormat?: string | null
    projectId?: number | null
    trackId: string
    timelineTemplateId?: string | null
    overviewTotalPrizes?: number | null
    numOfRegistrants?: number
    numOfSubmissions?: number
    numOfCheckpointSubmissions?: number
    currentPhaseNames?: ChallengeCreatecurrentPhaseNamesInput | string[]
    wiproAllowed?: boolean
    tags?: ChallengeCreatetagsInput | string[]
    groups?: ChallengeCreategroupsInput | string[]
    taskIsTask?: boolean
    taskIsAssigned?: boolean
    taskMemberId?: string | null
    submissionStartDate?: Date | string | null
    submissionEndDate?: Date | string | null
    registrationStartDate?: Date | string | null
    registrationEndDate?: Date | string | null
    startDate?: Date | string | null
    endDate?: Date | string | null
    legacyId?: number | null
    status?: $Enums.ChallengeStatusEnum
    createdAt?: Date | string
    createdBy: string
    updatedAt?: Date | string
    updatedBy: string
  }

  export type ChallengeTimelineTemplateCreateManyTypeInput = {
    id?: string
    trackId: string
    timelineTemplateId: string
    isDefault?: boolean
    createdAt?: Date | string
    createdBy: string
    updatedAt?: Date | string
    updatedBy: string
  }

  export type DefaultChallengeReviewerCreateManyChallengeTypeInput = {
    id?: string
    trackId: string
    timelineTemplateId?: string | null
    scorecardId?: string | null
    isMemberReview: boolean
    memberReviewerCount?: number | null
    phaseName: string
    phaseId?: string | null
    fixedAmount?: number | null
    baseCoefficient?: number | null
    incrementalCoefficient?: number | null
    opportunityType?: $Enums.ReviewOpportunityTypeEnum | null
    aiWorkflowId?: string | null
    shouldOpenOpportunity?: boolean
    createdAt?: Date | string
    createdBy: string
    updatedAt?: Date | string
    updatedBy: string
  }

  export type ChallengeUpdateWithoutTypeInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    privateDescription?: NullableStringFieldUpdateOperationsInput | string | null
    challengeSource?: NullableStringFieldUpdateOperationsInput | string | null
    descriptionFormat?: NullableStringFieldUpdateOperationsInput | string | null
    projectId?: NullableIntFieldUpdateOperationsInput | number | null
    overviewTotalPrizes?: NullableFloatFieldUpdateOperationsInput | number | null
    numOfRegistrants?: IntFieldUpdateOperationsInput | number
    numOfSubmissions?: IntFieldUpdateOperationsInput | number
    numOfCheckpointSubmissions?: IntFieldUpdateOperationsInput | number
    currentPhaseNames?: ChallengeUpdatecurrentPhaseNamesInput | string[]
    wiproAllowed?: BoolFieldUpdateOperationsInput | boolean
    tags?: ChallengeUpdatetagsInput | string[]
    groups?: ChallengeUpdategroupsInput | string[]
    taskIsTask?: BoolFieldUpdateOperationsInput | boolean
    taskIsAssigned?: BoolFieldUpdateOperationsInput | boolean
    taskMemberId?: NullableStringFieldUpdateOperationsInput | string | null
    submissionStartDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    submissionEndDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    registrationStartDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    registrationEndDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    startDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    endDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    legacyId?: NullableIntFieldUpdateOperationsInput | number | null
    status?: EnumChallengeStatusEnumFieldUpdateOperationsInput | $Enums.ChallengeStatusEnum
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdBy?: StringFieldUpdateOperationsInput | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedBy?: StringFieldUpdateOperationsInput | string
    billingRecord?: ChallengeBillingUpdateOneWithoutChallengeNestedInput
    legacyRecord?: ChallengeLegacyUpdateOneWithoutChallengeNestedInput
    constraintRecord?: ChallengeConstraintUpdateOneWithoutChallengeNestedInput
    events?: ChallengeEventUpdateManyWithoutChallengeNestedInput
    discussions?: ChallengeDiscussionUpdateManyWithoutChallengeNestedInput
    metadata?: ChallengeMetadataUpdateManyWithoutChallengeNestedInput
    phases?: ChallengePhaseUpdateManyWithoutChallengeNestedInput
    prizeSets?: ChallengePrizeSetUpdateManyWithoutChallengeNestedInput
    reviewers?: ChallengeReviewerUpdateManyWithoutChallengeNestedInput
    winners?: ChallengeWinnerUpdateManyWithoutChallengeNestedInput
    attachments?: AttachmentUpdateManyWithoutChallengeNestedInput
    terms?: ChallengeTermUpdateManyWithoutChallengeNestedInput
    skills?: ChallengeSkillUpdateManyWithoutChallengeNestedInput
    auditLogs?: AuditLogUpdateManyWithoutChallengeNestedInput
    memberAccesses?: MemberChallengeAccessUpdateManyWithoutChallengeNestedInput
    track?: ChallengeTrackUpdateOneRequiredWithoutChallengesNestedInput
    timelineTemplate?: TimelineTemplateUpdateOneWithoutChallengesNestedInput
  }

  export type ChallengeUncheckedUpdateWithoutTypeInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    privateDescription?: NullableStringFieldUpdateOperationsInput | string | null
    challengeSource?: NullableStringFieldUpdateOperationsInput | string | null
    descriptionFormat?: NullableStringFieldUpdateOperationsInput | string | null
    projectId?: NullableIntFieldUpdateOperationsInput | number | null
    trackId?: StringFieldUpdateOperationsInput | string
    timelineTemplateId?: NullableStringFieldUpdateOperationsInput | string | null
    overviewTotalPrizes?: NullableFloatFieldUpdateOperationsInput | number | null
    numOfRegistrants?: IntFieldUpdateOperationsInput | number
    numOfSubmissions?: IntFieldUpdateOperationsInput | number
    numOfCheckpointSubmissions?: IntFieldUpdateOperationsInput | number
    currentPhaseNames?: ChallengeUpdatecurrentPhaseNamesInput | string[]
    wiproAllowed?: BoolFieldUpdateOperationsInput | boolean
    tags?: ChallengeUpdatetagsInput | string[]
    groups?: ChallengeUpdategroupsInput | string[]
    taskIsTask?: BoolFieldUpdateOperationsInput | boolean
    taskIsAssigned?: BoolFieldUpdateOperationsInput | boolean
    taskMemberId?: NullableStringFieldUpdateOperationsInput | string | null
    submissionStartDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    submissionEndDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    registrationStartDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    registrationEndDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    startDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    endDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    legacyId?: NullableIntFieldUpdateOperationsInput | number | null
    status?: EnumChallengeStatusEnumFieldUpdateOperationsInput | $Enums.ChallengeStatusEnum
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdBy?: StringFieldUpdateOperationsInput | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedBy?: StringFieldUpdateOperationsInput | string
    billingRecord?: ChallengeBillingUncheckedUpdateOneWithoutChallengeNestedInput
    legacyRecord?: ChallengeLegacyUncheckedUpdateOneWithoutChallengeNestedInput
    constraintRecord?: ChallengeConstraintUncheckedUpdateOneWithoutChallengeNestedInput
    events?: ChallengeEventUncheckedUpdateManyWithoutChallengeNestedInput
    discussions?: ChallengeDiscussionUncheckedUpdateManyWithoutChallengeNestedInput
    metadata?: ChallengeMetadataUncheckedUpdateManyWithoutChallengeNestedInput
    phases?: ChallengePhaseUncheckedUpdateManyWithoutChallengeNestedInput
    prizeSets?: ChallengePrizeSetUncheckedUpdateManyWithoutChallengeNestedInput
    reviewers?: ChallengeReviewerUncheckedUpdateManyWithoutChallengeNestedInput
    winners?: ChallengeWinnerUncheckedUpdateManyWithoutChallengeNestedInput
    attachments?: AttachmentUncheckedUpdateManyWithoutChallengeNestedInput
    terms?: ChallengeTermUncheckedUpdateManyWithoutChallengeNestedInput
    skills?: ChallengeSkillUncheckedUpdateManyWithoutChallengeNestedInput
    auditLogs?: AuditLogUncheckedUpdateManyWithoutChallengeNestedInput
    memberAccesses?: MemberChallengeAccessUncheckedUpdateManyWithoutChallengeNestedInput
  }

  export type ChallengeUncheckedUpdateManyWithoutTypeInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    privateDescription?: NullableStringFieldUpdateOperationsInput | string | null
    challengeSource?: NullableStringFieldUpdateOperationsInput | string | null
    descriptionFormat?: NullableStringFieldUpdateOperationsInput | string | null
    projectId?: NullableIntFieldUpdateOperationsInput | number | null
    trackId?: StringFieldUpdateOperationsInput | string
    timelineTemplateId?: NullableStringFieldUpdateOperationsInput | string | null
    overviewTotalPrizes?: NullableFloatFieldUpdateOperationsInput | number | null
    numOfRegistrants?: IntFieldUpdateOperationsInput | number
    numOfSubmissions?: IntFieldUpdateOperationsInput | number
    numOfCheckpointSubmissions?: IntFieldUpdateOperationsInput | number
    currentPhaseNames?: ChallengeUpdatecurrentPhaseNamesInput | string[]
    wiproAllowed?: BoolFieldUpdateOperationsInput | boolean
    tags?: ChallengeUpdatetagsInput | string[]
    groups?: ChallengeUpdategroupsInput | string[]
    taskIsTask?: BoolFieldUpdateOperationsInput | boolean
    taskIsAssigned?: BoolFieldUpdateOperationsInput | boolean
    taskMemberId?: NullableStringFieldUpdateOperationsInput | string | null
    submissionStartDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    submissionEndDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    registrationStartDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    registrationEndDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    startDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    endDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    legacyId?: NullableIntFieldUpdateOperationsInput | number | null
    status?: EnumChallengeStatusEnumFieldUpdateOperationsInput | $Enums.ChallengeStatusEnum
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdBy?: StringFieldUpdateOperationsInput | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedBy?: StringFieldUpdateOperationsInput | string
  }

  export type ChallengeTimelineTemplateUpdateWithoutTypeInput = {
    id?: StringFieldUpdateOperationsInput | string
    isDefault?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdBy?: StringFieldUpdateOperationsInput | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedBy?: StringFieldUpdateOperationsInput | string
    timelineTemplate?: TimelineTemplateUpdateOneRequiredWithoutChallengeTimelineTemplatesNestedInput
    track?: ChallengeTrackUpdateOneRequiredWithoutTimelineTemplatesNestedInput
  }

  export type ChallengeTimelineTemplateUncheckedUpdateWithoutTypeInput = {
    id?: StringFieldUpdateOperationsInput | string
    trackId?: StringFieldUpdateOperationsInput | string
    timelineTemplateId?: StringFieldUpdateOperationsInput | string
    isDefault?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdBy?: StringFieldUpdateOperationsInput | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedBy?: StringFieldUpdateOperationsInput | string
  }

  export type ChallengeTimelineTemplateUncheckedUpdateManyWithoutTypeInput = {
    id?: StringFieldUpdateOperationsInput | string
    trackId?: StringFieldUpdateOperationsInput | string
    timelineTemplateId?: StringFieldUpdateOperationsInput | string
    isDefault?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdBy?: StringFieldUpdateOperationsInput | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedBy?: StringFieldUpdateOperationsInput | string
  }

  export type DefaultChallengeReviewerUpdateWithoutChallengeTypeInput = {
    id?: StringFieldUpdateOperationsInput | string
    scorecardId?: NullableStringFieldUpdateOperationsInput | string | null
    isMemberReview?: BoolFieldUpdateOperationsInput | boolean
    memberReviewerCount?: NullableIntFieldUpdateOperationsInput | number | null
    phaseName?: StringFieldUpdateOperationsInput | string
    fixedAmount?: NullableFloatFieldUpdateOperationsInput | number | null
    baseCoefficient?: NullableFloatFieldUpdateOperationsInput | number | null
    incrementalCoefficient?: NullableFloatFieldUpdateOperationsInput | number | null
    opportunityType?: NullableEnumReviewOpportunityTypeEnumFieldUpdateOperationsInput | $Enums.ReviewOpportunityTypeEnum | null
    aiWorkflowId?: NullableStringFieldUpdateOperationsInput | string | null
    shouldOpenOpportunity?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdBy?: StringFieldUpdateOperationsInput | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedBy?: StringFieldUpdateOperationsInput | string
    challengeTrack?: ChallengeTrackUpdateOneRequiredWithoutDefaultReviewersNestedInput
    timelineTemplate?: TimelineTemplateUpdateOneWithoutDefaultChallengeReviewerNestedInput
    phase?: PhaseUpdateOneWithoutDefaultChallengeReviewerNestedInput
  }

  export type DefaultChallengeReviewerUncheckedUpdateWithoutChallengeTypeInput = {
    id?: StringFieldUpdateOperationsInput | string
    trackId?: StringFieldUpdateOperationsInput | string
    timelineTemplateId?: NullableStringFieldUpdateOperationsInput | string | null
    scorecardId?: NullableStringFieldUpdateOperationsInput | string | null
    isMemberReview?: BoolFieldUpdateOperationsInput | boolean
    memberReviewerCount?: NullableIntFieldUpdateOperationsInput | number | null
    phaseName?: StringFieldUpdateOperationsInput | string
    phaseId?: NullableStringFieldUpdateOperationsInput | string | null
    fixedAmount?: NullableFloatFieldUpdateOperationsInput | number | null
    baseCoefficient?: NullableFloatFieldUpdateOperationsInput | number | null
    incrementalCoefficient?: NullableFloatFieldUpdateOperationsInput | number | null
    opportunityType?: NullableEnumReviewOpportunityTypeEnumFieldUpdateOperationsInput | $Enums.ReviewOpportunityTypeEnum | null
    aiWorkflowId?: NullableStringFieldUpdateOperationsInput | string | null
    shouldOpenOpportunity?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdBy?: StringFieldUpdateOperationsInput | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedBy?: StringFieldUpdateOperationsInput | string
  }

  export type DefaultChallengeReviewerUncheckedUpdateManyWithoutChallengeTypeInput = {
    id?: StringFieldUpdateOperationsInput | string
    trackId?: StringFieldUpdateOperationsInput | string
    timelineTemplateId?: NullableStringFieldUpdateOperationsInput | string | null
    scorecardId?: NullableStringFieldUpdateOperationsInput | string | null
    isMemberReview?: BoolFieldUpdateOperationsInput | boolean
    memberReviewerCount?: NullableIntFieldUpdateOperationsInput | number | null
    phaseName?: StringFieldUpdateOperationsInput | string
    phaseId?: NullableStringFieldUpdateOperationsInput | string | null
    fixedAmount?: NullableFloatFieldUpdateOperationsInput | number | null
    baseCoefficient?: NullableFloatFieldUpdateOperationsInput | number | null
    incrementalCoefficient?: NullableFloatFieldUpdateOperationsInput | number | null
    opportunityType?: NullableEnumReviewOpportunityTypeEnumFieldUpdateOperationsInput | $Enums.ReviewOpportunityTypeEnum | null
    aiWorkflowId?: NullableStringFieldUpdateOperationsInput | string | null
    shouldOpenOpportunity?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdBy?: StringFieldUpdateOperationsInput | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedBy?: StringFieldUpdateOperationsInput | string
  }

  export type ChallengeCreateManyTrackInput = {
    id?: string
    name: string
    description?: string | null
    privateDescription?: string | null
    challengeSource?: string | null
    descriptionFormat?: string | null
    projectId?: number | null
    typeId: string
    timelineTemplateId?: string | null
    overviewTotalPrizes?: number | null
    numOfRegistrants?: number
    numOfSubmissions?: number
    numOfCheckpointSubmissions?: number
    currentPhaseNames?: ChallengeCreatecurrentPhaseNamesInput | string[]
    wiproAllowed?: boolean
    tags?: ChallengeCreatetagsInput | string[]
    groups?: ChallengeCreategroupsInput | string[]
    taskIsTask?: boolean
    taskIsAssigned?: boolean
    taskMemberId?: string | null
    submissionStartDate?: Date | string | null
    submissionEndDate?: Date | string | null
    registrationStartDate?: Date | string | null
    registrationEndDate?: Date | string | null
    startDate?: Date | string | null
    endDate?: Date | string | null
    legacyId?: number | null
    status?: $Enums.ChallengeStatusEnum
    createdAt?: Date | string
    createdBy: string
    updatedAt?: Date | string
    updatedBy: string
  }

  export type ChallengeTimelineTemplateCreateManyTrackInput = {
    id?: string
    typeId: string
    timelineTemplateId: string
    isDefault?: boolean
    createdAt?: Date | string
    createdBy: string
    updatedAt?: Date | string
    updatedBy: string
  }

  export type DefaultChallengeReviewerCreateManyChallengeTrackInput = {
    id?: string
    typeId: string
    timelineTemplateId?: string | null
    scorecardId?: string | null
    isMemberReview: boolean
    memberReviewerCount?: number | null
    phaseName: string
    phaseId?: string | null
    fixedAmount?: number | null
    baseCoefficient?: number | null
    incrementalCoefficient?: number | null
    opportunityType?: $Enums.ReviewOpportunityTypeEnum | null
    aiWorkflowId?: string | null
    shouldOpenOpportunity?: boolean
    createdAt?: Date | string
    createdBy: string
    updatedAt?: Date | string
    updatedBy: string
  }

  export type ChallengeUpdateWithoutTrackInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    privateDescription?: NullableStringFieldUpdateOperationsInput | string | null
    challengeSource?: NullableStringFieldUpdateOperationsInput | string | null
    descriptionFormat?: NullableStringFieldUpdateOperationsInput | string | null
    projectId?: NullableIntFieldUpdateOperationsInput | number | null
    overviewTotalPrizes?: NullableFloatFieldUpdateOperationsInput | number | null
    numOfRegistrants?: IntFieldUpdateOperationsInput | number
    numOfSubmissions?: IntFieldUpdateOperationsInput | number
    numOfCheckpointSubmissions?: IntFieldUpdateOperationsInput | number
    currentPhaseNames?: ChallengeUpdatecurrentPhaseNamesInput | string[]
    wiproAllowed?: BoolFieldUpdateOperationsInput | boolean
    tags?: ChallengeUpdatetagsInput | string[]
    groups?: ChallengeUpdategroupsInput | string[]
    taskIsTask?: BoolFieldUpdateOperationsInput | boolean
    taskIsAssigned?: BoolFieldUpdateOperationsInput | boolean
    taskMemberId?: NullableStringFieldUpdateOperationsInput | string | null
    submissionStartDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    submissionEndDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    registrationStartDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    registrationEndDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    startDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    endDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    legacyId?: NullableIntFieldUpdateOperationsInput | number | null
    status?: EnumChallengeStatusEnumFieldUpdateOperationsInput | $Enums.ChallengeStatusEnum
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdBy?: StringFieldUpdateOperationsInput | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedBy?: StringFieldUpdateOperationsInput | string
    billingRecord?: ChallengeBillingUpdateOneWithoutChallengeNestedInput
    legacyRecord?: ChallengeLegacyUpdateOneWithoutChallengeNestedInput
    constraintRecord?: ChallengeConstraintUpdateOneWithoutChallengeNestedInput
    events?: ChallengeEventUpdateManyWithoutChallengeNestedInput
    discussions?: ChallengeDiscussionUpdateManyWithoutChallengeNestedInput
    metadata?: ChallengeMetadataUpdateManyWithoutChallengeNestedInput
    phases?: ChallengePhaseUpdateManyWithoutChallengeNestedInput
    prizeSets?: ChallengePrizeSetUpdateManyWithoutChallengeNestedInput
    reviewers?: ChallengeReviewerUpdateManyWithoutChallengeNestedInput
    winners?: ChallengeWinnerUpdateManyWithoutChallengeNestedInput
    attachments?: AttachmentUpdateManyWithoutChallengeNestedInput
    terms?: ChallengeTermUpdateManyWithoutChallengeNestedInput
    skills?: ChallengeSkillUpdateManyWithoutChallengeNestedInput
    auditLogs?: AuditLogUpdateManyWithoutChallengeNestedInput
    memberAccesses?: MemberChallengeAccessUpdateManyWithoutChallengeNestedInput
    type?: ChallengeTypeUpdateOneRequiredWithoutChallengesNestedInput
    timelineTemplate?: TimelineTemplateUpdateOneWithoutChallengesNestedInput
  }

  export type ChallengeUncheckedUpdateWithoutTrackInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    privateDescription?: NullableStringFieldUpdateOperationsInput | string | null
    challengeSource?: NullableStringFieldUpdateOperationsInput | string | null
    descriptionFormat?: NullableStringFieldUpdateOperationsInput | string | null
    projectId?: NullableIntFieldUpdateOperationsInput | number | null
    typeId?: StringFieldUpdateOperationsInput | string
    timelineTemplateId?: NullableStringFieldUpdateOperationsInput | string | null
    overviewTotalPrizes?: NullableFloatFieldUpdateOperationsInput | number | null
    numOfRegistrants?: IntFieldUpdateOperationsInput | number
    numOfSubmissions?: IntFieldUpdateOperationsInput | number
    numOfCheckpointSubmissions?: IntFieldUpdateOperationsInput | number
    currentPhaseNames?: ChallengeUpdatecurrentPhaseNamesInput | string[]
    wiproAllowed?: BoolFieldUpdateOperationsInput | boolean
    tags?: ChallengeUpdatetagsInput | string[]
    groups?: ChallengeUpdategroupsInput | string[]
    taskIsTask?: BoolFieldUpdateOperationsInput | boolean
    taskIsAssigned?: BoolFieldUpdateOperationsInput | boolean
    taskMemberId?: NullableStringFieldUpdateOperationsInput | string | null
    submissionStartDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    submissionEndDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    registrationStartDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    registrationEndDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    startDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    endDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    legacyId?: NullableIntFieldUpdateOperationsInput | number | null
    status?: EnumChallengeStatusEnumFieldUpdateOperationsInput | $Enums.ChallengeStatusEnum
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdBy?: StringFieldUpdateOperationsInput | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedBy?: StringFieldUpdateOperationsInput | string
    billingRecord?: ChallengeBillingUncheckedUpdateOneWithoutChallengeNestedInput
    legacyRecord?: ChallengeLegacyUncheckedUpdateOneWithoutChallengeNestedInput
    constraintRecord?: ChallengeConstraintUncheckedUpdateOneWithoutChallengeNestedInput
    events?: ChallengeEventUncheckedUpdateManyWithoutChallengeNestedInput
    discussions?: ChallengeDiscussionUncheckedUpdateManyWithoutChallengeNestedInput
    metadata?: ChallengeMetadataUncheckedUpdateManyWithoutChallengeNestedInput
    phases?: ChallengePhaseUncheckedUpdateManyWithoutChallengeNestedInput
    prizeSets?: ChallengePrizeSetUncheckedUpdateManyWithoutChallengeNestedInput
    reviewers?: ChallengeReviewerUncheckedUpdateManyWithoutChallengeNestedInput
    winners?: ChallengeWinnerUncheckedUpdateManyWithoutChallengeNestedInput
    attachments?: AttachmentUncheckedUpdateManyWithoutChallengeNestedInput
    terms?: ChallengeTermUncheckedUpdateManyWithoutChallengeNestedInput
    skills?: ChallengeSkillUncheckedUpdateManyWithoutChallengeNestedInput
    auditLogs?: AuditLogUncheckedUpdateManyWithoutChallengeNestedInput
    memberAccesses?: MemberChallengeAccessUncheckedUpdateManyWithoutChallengeNestedInput
  }

  export type ChallengeUncheckedUpdateManyWithoutTrackInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    privateDescription?: NullableStringFieldUpdateOperationsInput | string | null
    challengeSource?: NullableStringFieldUpdateOperationsInput | string | null
    descriptionFormat?: NullableStringFieldUpdateOperationsInput | string | null
    projectId?: NullableIntFieldUpdateOperationsInput | number | null
    typeId?: StringFieldUpdateOperationsInput | string
    timelineTemplateId?: NullableStringFieldUpdateOperationsInput | string | null
    overviewTotalPrizes?: NullableFloatFieldUpdateOperationsInput | number | null
    numOfRegistrants?: IntFieldUpdateOperationsInput | number
    numOfSubmissions?: IntFieldUpdateOperationsInput | number
    numOfCheckpointSubmissions?: IntFieldUpdateOperationsInput | number
    currentPhaseNames?: ChallengeUpdatecurrentPhaseNamesInput | string[]
    wiproAllowed?: BoolFieldUpdateOperationsInput | boolean
    tags?: ChallengeUpdatetagsInput | string[]
    groups?: ChallengeUpdategroupsInput | string[]
    taskIsTask?: BoolFieldUpdateOperationsInput | boolean
    taskIsAssigned?: BoolFieldUpdateOperationsInput | boolean
    taskMemberId?: NullableStringFieldUpdateOperationsInput | string | null
    submissionStartDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    submissionEndDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    registrationStartDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    registrationEndDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    startDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    endDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    legacyId?: NullableIntFieldUpdateOperationsInput | number | null
    status?: EnumChallengeStatusEnumFieldUpdateOperationsInput | $Enums.ChallengeStatusEnum
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdBy?: StringFieldUpdateOperationsInput | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedBy?: StringFieldUpdateOperationsInput | string
  }

  export type ChallengeTimelineTemplateUpdateWithoutTrackInput = {
    id?: StringFieldUpdateOperationsInput | string
    isDefault?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdBy?: StringFieldUpdateOperationsInput | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedBy?: StringFieldUpdateOperationsInput | string
    timelineTemplate?: TimelineTemplateUpdateOneRequiredWithoutChallengeTimelineTemplatesNestedInput
    type?: ChallengeTypeUpdateOneRequiredWithoutTimelineTemplatesNestedInput
  }

  export type ChallengeTimelineTemplateUncheckedUpdateWithoutTrackInput = {
    id?: StringFieldUpdateOperationsInput | string
    typeId?: StringFieldUpdateOperationsInput | string
    timelineTemplateId?: StringFieldUpdateOperationsInput | string
    isDefault?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdBy?: StringFieldUpdateOperationsInput | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedBy?: StringFieldUpdateOperationsInput | string
  }

  export type ChallengeTimelineTemplateUncheckedUpdateManyWithoutTrackInput = {
    id?: StringFieldUpdateOperationsInput | string
    typeId?: StringFieldUpdateOperationsInput | string
    timelineTemplateId?: StringFieldUpdateOperationsInput | string
    isDefault?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdBy?: StringFieldUpdateOperationsInput | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedBy?: StringFieldUpdateOperationsInput | string
  }

  export type DefaultChallengeReviewerUpdateWithoutChallengeTrackInput = {
    id?: StringFieldUpdateOperationsInput | string
    scorecardId?: NullableStringFieldUpdateOperationsInput | string | null
    isMemberReview?: BoolFieldUpdateOperationsInput | boolean
    memberReviewerCount?: NullableIntFieldUpdateOperationsInput | number | null
    phaseName?: StringFieldUpdateOperationsInput | string
    fixedAmount?: NullableFloatFieldUpdateOperationsInput | number | null
    baseCoefficient?: NullableFloatFieldUpdateOperationsInput | number | null
    incrementalCoefficient?: NullableFloatFieldUpdateOperationsInput | number | null
    opportunityType?: NullableEnumReviewOpportunityTypeEnumFieldUpdateOperationsInput | $Enums.ReviewOpportunityTypeEnum | null
    aiWorkflowId?: NullableStringFieldUpdateOperationsInput | string | null
    shouldOpenOpportunity?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdBy?: StringFieldUpdateOperationsInput | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedBy?: StringFieldUpdateOperationsInput | string
    challengeType?: ChallengeTypeUpdateOneRequiredWithoutDefaultReviewersNestedInput
    timelineTemplate?: TimelineTemplateUpdateOneWithoutDefaultChallengeReviewerNestedInput
    phase?: PhaseUpdateOneWithoutDefaultChallengeReviewerNestedInput
  }

  export type DefaultChallengeReviewerUncheckedUpdateWithoutChallengeTrackInput = {
    id?: StringFieldUpdateOperationsInput | string
    typeId?: StringFieldUpdateOperationsInput | string
    timelineTemplateId?: NullableStringFieldUpdateOperationsInput | string | null
    scorecardId?: NullableStringFieldUpdateOperationsInput | string | null
    isMemberReview?: BoolFieldUpdateOperationsInput | boolean
    memberReviewerCount?: NullableIntFieldUpdateOperationsInput | number | null
    phaseName?: StringFieldUpdateOperationsInput | string
    phaseId?: NullableStringFieldUpdateOperationsInput | string | null
    fixedAmount?: NullableFloatFieldUpdateOperationsInput | number | null
    baseCoefficient?: NullableFloatFieldUpdateOperationsInput | number | null
    incrementalCoefficient?: NullableFloatFieldUpdateOperationsInput | number | null
    opportunityType?: NullableEnumReviewOpportunityTypeEnumFieldUpdateOperationsInput | $Enums.ReviewOpportunityTypeEnum | null
    aiWorkflowId?: NullableStringFieldUpdateOperationsInput | string | null
    shouldOpenOpportunity?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdBy?: StringFieldUpdateOperationsInput | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedBy?: StringFieldUpdateOperationsInput | string
  }

  export type DefaultChallengeReviewerUncheckedUpdateManyWithoutChallengeTrackInput = {
    id?: StringFieldUpdateOperationsInput | string
    typeId?: StringFieldUpdateOperationsInput | string
    timelineTemplateId?: NullableStringFieldUpdateOperationsInput | string | null
    scorecardId?: NullableStringFieldUpdateOperationsInput | string | null
    isMemberReview?: BoolFieldUpdateOperationsInput | boolean
    memberReviewerCount?: NullableIntFieldUpdateOperationsInput | number | null
    phaseName?: StringFieldUpdateOperationsInput | string
    phaseId?: NullableStringFieldUpdateOperationsInput | string | null
    fixedAmount?: NullableFloatFieldUpdateOperationsInput | number | null
    baseCoefficient?: NullableFloatFieldUpdateOperationsInput | number | null
    incrementalCoefficient?: NullableFloatFieldUpdateOperationsInput | number | null
    opportunityType?: NullableEnumReviewOpportunityTypeEnumFieldUpdateOperationsInput | $Enums.ReviewOpportunityTypeEnum | null
    aiWorkflowId?: NullableStringFieldUpdateOperationsInput | string | null
    shouldOpenOpportunity?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdBy?: StringFieldUpdateOperationsInput | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedBy?: StringFieldUpdateOperationsInput | string
  }

  export type ChallengeDiscussionOptionCreateManyDiscussionInput = {
    id?: string
    optionKey: string
    optionValue: string
    createdAt?: Date | string
    createdBy: string
    updatedAt?: Date | string
    updatedBy: string
  }

  export type ChallengeDiscussionOptionUpdateWithoutDiscussionInput = {
    id?: StringFieldUpdateOperationsInput | string
    optionKey?: StringFieldUpdateOperationsInput | string
    optionValue?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdBy?: StringFieldUpdateOperationsInput | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedBy?: StringFieldUpdateOperationsInput | string
  }

  export type ChallengeDiscussionOptionUncheckedUpdateWithoutDiscussionInput = {
    id?: StringFieldUpdateOperationsInput | string
    optionKey?: StringFieldUpdateOperationsInput | string
    optionValue?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdBy?: StringFieldUpdateOperationsInput | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedBy?: StringFieldUpdateOperationsInput | string
  }

  export type ChallengeDiscussionOptionUncheckedUpdateManyWithoutDiscussionInput = {
    id?: StringFieldUpdateOperationsInput | string
    optionKey?: StringFieldUpdateOperationsInput | string
    optionValue?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdBy?: StringFieldUpdateOperationsInput | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedBy?: StringFieldUpdateOperationsInput | string
  }

  export type ChallengePhaseCreateManyPhaseInput = {
    id?: string
    challengeId: string
    name: string
    description?: string | null
    isOpen?: boolean | null
    predecessor?: string | null
    duration?: number | null
    scheduledStartDate?: Date | string | null
    scheduledEndDate?: Date | string | null
    actualStartDate?: Date | string | null
    actualEndDate?: Date | string | null
    createdAt?: Date | string
    createdBy: string
    updatedAt?: Date | string
    updatedBy: string
  }

  export type ChallengeReviewerCreateManyPhaseInput = {
    id?: string
    challengeId: string
    scorecardId: string
    isMemberReview: boolean
    memberReviewerCount?: number | null
    fixedAmount?: number | null
    baseCoefficient?: number | null
    incrementalCoefficient?: number | null
    type?: $Enums.ReviewOpportunityTypeEnum | null
    aiWorkflowId?: string | null
    shouldOpenOpportunity?: boolean
    createdAt?: Date | string
    createdBy: string
    updatedAt?: Date | string
    updatedBy: string
  }

  export type DefaultChallengeReviewerCreateManyPhaseInput = {
    id?: string
    typeId: string
    trackId: string
    timelineTemplateId?: string | null
    scorecardId?: string | null
    isMemberReview: boolean
    memberReviewerCount?: number | null
    phaseName: string
    fixedAmount?: number | null
    baseCoefficient?: number | null
    incrementalCoefficient?: number | null
    opportunityType?: $Enums.ReviewOpportunityTypeEnum | null
    aiWorkflowId?: string | null
    shouldOpenOpportunity?: boolean
    createdAt?: Date | string
    createdBy: string
    updatedAt?: Date | string
    updatedBy: string
  }

  export type ChallengePhaseUpdateWithoutPhaseInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    isOpen?: NullableBoolFieldUpdateOperationsInput | boolean | null
    predecessor?: NullableStringFieldUpdateOperationsInput | string | null
    duration?: NullableIntFieldUpdateOperationsInput | number | null
    scheduledStartDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    scheduledEndDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    actualStartDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    actualEndDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdBy?: StringFieldUpdateOperationsInput | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedBy?: StringFieldUpdateOperationsInput | string
    constraints?: ChallengePhaseConstraintUpdateManyWithoutChallengePhaseNestedInput
    challenge?: ChallengeUpdateOneRequiredWithoutPhasesNestedInput
  }

  export type ChallengePhaseUncheckedUpdateWithoutPhaseInput = {
    id?: StringFieldUpdateOperationsInput | string
    challengeId?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    isOpen?: NullableBoolFieldUpdateOperationsInput | boolean | null
    predecessor?: NullableStringFieldUpdateOperationsInput | string | null
    duration?: NullableIntFieldUpdateOperationsInput | number | null
    scheduledStartDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    scheduledEndDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    actualStartDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    actualEndDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdBy?: StringFieldUpdateOperationsInput | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedBy?: StringFieldUpdateOperationsInput | string
    constraints?: ChallengePhaseConstraintUncheckedUpdateManyWithoutChallengePhaseNestedInput
  }

  export type ChallengePhaseUncheckedUpdateManyWithoutPhaseInput = {
    id?: StringFieldUpdateOperationsInput | string
    challengeId?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    isOpen?: NullableBoolFieldUpdateOperationsInput | boolean | null
    predecessor?: NullableStringFieldUpdateOperationsInput | string | null
    duration?: NullableIntFieldUpdateOperationsInput | number | null
    scheduledStartDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    scheduledEndDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    actualStartDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    actualEndDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdBy?: StringFieldUpdateOperationsInput | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedBy?: StringFieldUpdateOperationsInput | string
  }

  export type ChallengeReviewerUpdateWithoutPhaseInput = {
    id?: StringFieldUpdateOperationsInput | string
    scorecardId?: StringFieldUpdateOperationsInput | string
    isMemberReview?: BoolFieldUpdateOperationsInput | boolean
    memberReviewerCount?: NullableIntFieldUpdateOperationsInput | number | null
    fixedAmount?: NullableFloatFieldUpdateOperationsInput | number | null
    baseCoefficient?: NullableFloatFieldUpdateOperationsInput | number | null
    incrementalCoefficient?: NullableFloatFieldUpdateOperationsInput | number | null
    type?: NullableEnumReviewOpportunityTypeEnumFieldUpdateOperationsInput | $Enums.ReviewOpportunityTypeEnum | null
    aiWorkflowId?: NullableStringFieldUpdateOperationsInput | string | null
    shouldOpenOpportunity?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdBy?: StringFieldUpdateOperationsInput | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedBy?: StringFieldUpdateOperationsInput | string
    challenge?: ChallengeUpdateOneRequiredWithoutReviewersNestedInput
  }

  export type ChallengeReviewerUncheckedUpdateWithoutPhaseInput = {
    id?: StringFieldUpdateOperationsInput | string
    challengeId?: StringFieldUpdateOperationsInput | string
    scorecardId?: StringFieldUpdateOperationsInput | string
    isMemberReview?: BoolFieldUpdateOperationsInput | boolean
    memberReviewerCount?: NullableIntFieldUpdateOperationsInput | number | null
    fixedAmount?: NullableFloatFieldUpdateOperationsInput | number | null
    baseCoefficient?: NullableFloatFieldUpdateOperationsInput | number | null
    incrementalCoefficient?: NullableFloatFieldUpdateOperationsInput | number | null
    type?: NullableEnumReviewOpportunityTypeEnumFieldUpdateOperationsInput | $Enums.ReviewOpportunityTypeEnum | null
    aiWorkflowId?: NullableStringFieldUpdateOperationsInput | string | null
    shouldOpenOpportunity?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdBy?: StringFieldUpdateOperationsInput | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedBy?: StringFieldUpdateOperationsInput | string
  }

  export type ChallengeReviewerUncheckedUpdateManyWithoutPhaseInput = {
    id?: StringFieldUpdateOperationsInput | string
    challengeId?: StringFieldUpdateOperationsInput | string
    scorecardId?: StringFieldUpdateOperationsInput | string
    isMemberReview?: BoolFieldUpdateOperationsInput | boolean
    memberReviewerCount?: NullableIntFieldUpdateOperationsInput | number | null
    fixedAmount?: NullableFloatFieldUpdateOperationsInput | number | null
    baseCoefficient?: NullableFloatFieldUpdateOperationsInput | number | null
    incrementalCoefficient?: NullableFloatFieldUpdateOperationsInput | number | null
    type?: NullableEnumReviewOpportunityTypeEnumFieldUpdateOperationsInput | $Enums.ReviewOpportunityTypeEnum | null
    aiWorkflowId?: NullableStringFieldUpdateOperationsInput | string | null
    shouldOpenOpportunity?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdBy?: StringFieldUpdateOperationsInput | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedBy?: StringFieldUpdateOperationsInput | string
  }

  export type DefaultChallengeReviewerUpdateWithoutPhaseInput = {
    id?: StringFieldUpdateOperationsInput | string
    scorecardId?: NullableStringFieldUpdateOperationsInput | string | null
    isMemberReview?: BoolFieldUpdateOperationsInput | boolean
    memberReviewerCount?: NullableIntFieldUpdateOperationsInput | number | null
    phaseName?: StringFieldUpdateOperationsInput | string
    fixedAmount?: NullableFloatFieldUpdateOperationsInput | number | null
    baseCoefficient?: NullableFloatFieldUpdateOperationsInput | number | null
    incrementalCoefficient?: NullableFloatFieldUpdateOperationsInput | number | null
    opportunityType?: NullableEnumReviewOpportunityTypeEnumFieldUpdateOperationsInput | $Enums.ReviewOpportunityTypeEnum | null
    aiWorkflowId?: NullableStringFieldUpdateOperationsInput | string | null
    shouldOpenOpportunity?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdBy?: StringFieldUpdateOperationsInput | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedBy?: StringFieldUpdateOperationsInput | string
    challengeType?: ChallengeTypeUpdateOneRequiredWithoutDefaultReviewersNestedInput
    challengeTrack?: ChallengeTrackUpdateOneRequiredWithoutDefaultReviewersNestedInput
    timelineTemplate?: TimelineTemplateUpdateOneWithoutDefaultChallengeReviewerNestedInput
  }

  export type DefaultChallengeReviewerUncheckedUpdateWithoutPhaseInput = {
    id?: StringFieldUpdateOperationsInput | string
    typeId?: StringFieldUpdateOperationsInput | string
    trackId?: StringFieldUpdateOperationsInput | string
    timelineTemplateId?: NullableStringFieldUpdateOperationsInput | string | null
    scorecardId?: NullableStringFieldUpdateOperationsInput | string | null
    isMemberReview?: BoolFieldUpdateOperationsInput | boolean
    memberReviewerCount?: NullableIntFieldUpdateOperationsInput | number | null
    phaseName?: StringFieldUpdateOperationsInput | string
    fixedAmount?: NullableFloatFieldUpdateOperationsInput | number | null
    baseCoefficient?: NullableFloatFieldUpdateOperationsInput | number | null
    incrementalCoefficient?: NullableFloatFieldUpdateOperationsInput | number | null
    opportunityType?: NullableEnumReviewOpportunityTypeEnumFieldUpdateOperationsInput | $Enums.ReviewOpportunityTypeEnum | null
    aiWorkflowId?: NullableStringFieldUpdateOperationsInput | string | null
    shouldOpenOpportunity?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdBy?: StringFieldUpdateOperationsInput | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedBy?: StringFieldUpdateOperationsInput | string
  }

  export type DefaultChallengeReviewerUncheckedUpdateManyWithoutPhaseInput = {
    id?: StringFieldUpdateOperationsInput | string
    typeId?: StringFieldUpdateOperationsInput | string
    trackId?: StringFieldUpdateOperationsInput | string
    timelineTemplateId?: NullableStringFieldUpdateOperationsInput | string | null
    scorecardId?: NullableStringFieldUpdateOperationsInput | string | null
    isMemberReview?: BoolFieldUpdateOperationsInput | boolean
    memberReviewerCount?: NullableIntFieldUpdateOperationsInput | number | null
    phaseName?: StringFieldUpdateOperationsInput | string
    fixedAmount?: NullableFloatFieldUpdateOperationsInput | number | null
    baseCoefficient?: NullableFloatFieldUpdateOperationsInput | number | null
    incrementalCoefficient?: NullableFloatFieldUpdateOperationsInput | number | null
    opportunityType?: NullableEnumReviewOpportunityTypeEnumFieldUpdateOperationsInput | $Enums.ReviewOpportunityTypeEnum | null
    aiWorkflowId?: NullableStringFieldUpdateOperationsInput | string | null
    shouldOpenOpportunity?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdBy?: StringFieldUpdateOperationsInput | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedBy?: StringFieldUpdateOperationsInput | string
  }

  export type ChallengePhaseConstraintCreateManyChallengePhaseInput = {
    id?: string
    name: string
    value: number
    createdAt?: Date | string
    createdBy: string
    updatedAt?: Date | string
    updatedBy: string
  }

  export type ChallengePhaseConstraintUpdateWithoutChallengePhaseInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    value?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdBy?: StringFieldUpdateOperationsInput | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedBy?: StringFieldUpdateOperationsInput | string
  }

  export type ChallengePhaseConstraintUncheckedUpdateWithoutChallengePhaseInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    value?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdBy?: StringFieldUpdateOperationsInput | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedBy?: StringFieldUpdateOperationsInput | string
  }

  export type ChallengePhaseConstraintUncheckedUpdateManyWithoutChallengePhaseInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    value?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdBy?: StringFieldUpdateOperationsInput | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedBy?: StringFieldUpdateOperationsInput | string
  }

  export type PrizeCreateManyPrizeSetInput = {
    id?: string
    description?: string | null
    type: string
    value: number
    createdAt?: Date | string
    createdBy: string
    updatedAt?: Date | string
    updatedBy: string
  }

  export type PrizeUpdateWithoutPrizeSetInput = {
    id?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    type?: StringFieldUpdateOperationsInput | string
    value?: FloatFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdBy?: StringFieldUpdateOperationsInput | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedBy?: StringFieldUpdateOperationsInput | string
  }

  export type PrizeUncheckedUpdateWithoutPrizeSetInput = {
    id?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    type?: StringFieldUpdateOperationsInput | string
    value?: FloatFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdBy?: StringFieldUpdateOperationsInput | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedBy?: StringFieldUpdateOperationsInput | string
  }

  export type PrizeUncheckedUpdateManyWithoutPrizeSetInput = {
    id?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    type?: StringFieldUpdateOperationsInput | string
    value?: FloatFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdBy?: StringFieldUpdateOperationsInput | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedBy?: StringFieldUpdateOperationsInput | string
  }

  export type TimelineTemplatePhaseCreateManyTimelineTemplateInput = {
    id?: string
    phaseId: string
    predecessor?: string | null
    defaultDuration: number
    createdAt?: Date | string
    createdBy: string
    updatedAt?: Date | string
    updatedBy: string
  }

  export type ChallengeTimelineTemplateCreateManyTimelineTemplateInput = {
    id?: string
    typeId: string
    trackId: string
    isDefault?: boolean
    createdAt?: Date | string
    createdBy: string
    updatedAt?: Date | string
    updatedBy: string
  }

  export type ChallengeCreateManyTimelineTemplateInput = {
    id?: string
    name: string
    description?: string | null
    privateDescription?: string | null
    challengeSource?: string | null
    descriptionFormat?: string | null
    projectId?: number | null
    typeId: string
    trackId: string
    overviewTotalPrizes?: number | null
    numOfRegistrants?: number
    numOfSubmissions?: number
    numOfCheckpointSubmissions?: number
    currentPhaseNames?: ChallengeCreatecurrentPhaseNamesInput | string[]
    wiproAllowed?: boolean
    tags?: ChallengeCreatetagsInput | string[]
    groups?: ChallengeCreategroupsInput | string[]
    taskIsTask?: boolean
    taskIsAssigned?: boolean
    taskMemberId?: string | null
    submissionStartDate?: Date | string | null
    submissionEndDate?: Date | string | null
    registrationStartDate?: Date | string | null
    registrationEndDate?: Date | string | null
    startDate?: Date | string | null
    endDate?: Date | string | null
    legacyId?: number | null
    status?: $Enums.ChallengeStatusEnum
    createdAt?: Date | string
    createdBy: string
    updatedAt?: Date | string
    updatedBy: string
  }

  export type DefaultChallengeReviewerCreateManyTimelineTemplateInput = {
    id?: string
    typeId: string
    trackId: string
    scorecardId?: string | null
    isMemberReview: boolean
    memberReviewerCount?: number | null
    phaseName: string
    phaseId?: string | null
    fixedAmount?: number | null
    baseCoefficient?: number | null
    incrementalCoefficient?: number | null
    opportunityType?: $Enums.ReviewOpportunityTypeEnum | null
    aiWorkflowId?: string | null
    shouldOpenOpportunity?: boolean
    createdAt?: Date | string
    createdBy: string
    updatedAt?: Date | string
    updatedBy: string
  }

  export type TimelineTemplatePhaseUpdateWithoutTimelineTemplateInput = {
    id?: StringFieldUpdateOperationsInput | string
    phaseId?: StringFieldUpdateOperationsInput | string
    predecessor?: NullableStringFieldUpdateOperationsInput | string | null
    defaultDuration?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdBy?: StringFieldUpdateOperationsInput | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedBy?: StringFieldUpdateOperationsInput | string
  }

  export type TimelineTemplatePhaseUncheckedUpdateWithoutTimelineTemplateInput = {
    id?: StringFieldUpdateOperationsInput | string
    phaseId?: StringFieldUpdateOperationsInput | string
    predecessor?: NullableStringFieldUpdateOperationsInput | string | null
    defaultDuration?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdBy?: StringFieldUpdateOperationsInput | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedBy?: StringFieldUpdateOperationsInput | string
  }

  export type TimelineTemplatePhaseUncheckedUpdateManyWithoutTimelineTemplateInput = {
    id?: StringFieldUpdateOperationsInput | string
    phaseId?: StringFieldUpdateOperationsInput | string
    predecessor?: NullableStringFieldUpdateOperationsInput | string | null
    defaultDuration?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdBy?: StringFieldUpdateOperationsInput | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedBy?: StringFieldUpdateOperationsInput | string
  }

  export type ChallengeTimelineTemplateUpdateWithoutTimelineTemplateInput = {
    id?: StringFieldUpdateOperationsInput | string
    isDefault?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdBy?: StringFieldUpdateOperationsInput | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedBy?: StringFieldUpdateOperationsInput | string
    track?: ChallengeTrackUpdateOneRequiredWithoutTimelineTemplatesNestedInput
    type?: ChallengeTypeUpdateOneRequiredWithoutTimelineTemplatesNestedInput
  }

  export type ChallengeTimelineTemplateUncheckedUpdateWithoutTimelineTemplateInput = {
    id?: StringFieldUpdateOperationsInput | string
    typeId?: StringFieldUpdateOperationsInput | string
    trackId?: StringFieldUpdateOperationsInput | string
    isDefault?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdBy?: StringFieldUpdateOperationsInput | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedBy?: StringFieldUpdateOperationsInput | string
  }

  export type ChallengeTimelineTemplateUncheckedUpdateManyWithoutTimelineTemplateInput = {
    id?: StringFieldUpdateOperationsInput | string
    typeId?: StringFieldUpdateOperationsInput | string
    trackId?: StringFieldUpdateOperationsInput | string
    isDefault?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdBy?: StringFieldUpdateOperationsInput | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedBy?: StringFieldUpdateOperationsInput | string
  }

  export type ChallengeUpdateWithoutTimelineTemplateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    privateDescription?: NullableStringFieldUpdateOperationsInput | string | null
    challengeSource?: NullableStringFieldUpdateOperationsInput | string | null
    descriptionFormat?: NullableStringFieldUpdateOperationsInput | string | null
    projectId?: NullableIntFieldUpdateOperationsInput | number | null
    overviewTotalPrizes?: NullableFloatFieldUpdateOperationsInput | number | null
    numOfRegistrants?: IntFieldUpdateOperationsInput | number
    numOfSubmissions?: IntFieldUpdateOperationsInput | number
    numOfCheckpointSubmissions?: IntFieldUpdateOperationsInput | number
    currentPhaseNames?: ChallengeUpdatecurrentPhaseNamesInput | string[]
    wiproAllowed?: BoolFieldUpdateOperationsInput | boolean
    tags?: ChallengeUpdatetagsInput | string[]
    groups?: ChallengeUpdategroupsInput | string[]
    taskIsTask?: BoolFieldUpdateOperationsInput | boolean
    taskIsAssigned?: BoolFieldUpdateOperationsInput | boolean
    taskMemberId?: NullableStringFieldUpdateOperationsInput | string | null
    submissionStartDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    submissionEndDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    registrationStartDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    registrationEndDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    startDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    endDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    legacyId?: NullableIntFieldUpdateOperationsInput | number | null
    status?: EnumChallengeStatusEnumFieldUpdateOperationsInput | $Enums.ChallengeStatusEnum
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdBy?: StringFieldUpdateOperationsInput | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedBy?: StringFieldUpdateOperationsInput | string
    billingRecord?: ChallengeBillingUpdateOneWithoutChallengeNestedInput
    legacyRecord?: ChallengeLegacyUpdateOneWithoutChallengeNestedInput
    constraintRecord?: ChallengeConstraintUpdateOneWithoutChallengeNestedInput
    events?: ChallengeEventUpdateManyWithoutChallengeNestedInput
    discussions?: ChallengeDiscussionUpdateManyWithoutChallengeNestedInput
    metadata?: ChallengeMetadataUpdateManyWithoutChallengeNestedInput
    phases?: ChallengePhaseUpdateManyWithoutChallengeNestedInput
    prizeSets?: ChallengePrizeSetUpdateManyWithoutChallengeNestedInput
    reviewers?: ChallengeReviewerUpdateManyWithoutChallengeNestedInput
    winners?: ChallengeWinnerUpdateManyWithoutChallengeNestedInput
    attachments?: AttachmentUpdateManyWithoutChallengeNestedInput
    terms?: ChallengeTermUpdateManyWithoutChallengeNestedInput
    skills?: ChallengeSkillUpdateManyWithoutChallengeNestedInput
    auditLogs?: AuditLogUpdateManyWithoutChallengeNestedInput
    memberAccesses?: MemberChallengeAccessUpdateManyWithoutChallengeNestedInput
    type?: ChallengeTypeUpdateOneRequiredWithoutChallengesNestedInput
    track?: ChallengeTrackUpdateOneRequiredWithoutChallengesNestedInput
  }

  export type ChallengeUncheckedUpdateWithoutTimelineTemplateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    privateDescription?: NullableStringFieldUpdateOperationsInput | string | null
    challengeSource?: NullableStringFieldUpdateOperationsInput | string | null
    descriptionFormat?: NullableStringFieldUpdateOperationsInput | string | null
    projectId?: NullableIntFieldUpdateOperationsInput | number | null
    typeId?: StringFieldUpdateOperationsInput | string
    trackId?: StringFieldUpdateOperationsInput | string
    overviewTotalPrizes?: NullableFloatFieldUpdateOperationsInput | number | null
    numOfRegistrants?: IntFieldUpdateOperationsInput | number
    numOfSubmissions?: IntFieldUpdateOperationsInput | number
    numOfCheckpointSubmissions?: IntFieldUpdateOperationsInput | number
    currentPhaseNames?: ChallengeUpdatecurrentPhaseNamesInput | string[]
    wiproAllowed?: BoolFieldUpdateOperationsInput | boolean
    tags?: ChallengeUpdatetagsInput | string[]
    groups?: ChallengeUpdategroupsInput | string[]
    taskIsTask?: BoolFieldUpdateOperationsInput | boolean
    taskIsAssigned?: BoolFieldUpdateOperationsInput | boolean
    taskMemberId?: NullableStringFieldUpdateOperationsInput | string | null
    submissionStartDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    submissionEndDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    registrationStartDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    registrationEndDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    startDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    endDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    legacyId?: NullableIntFieldUpdateOperationsInput | number | null
    status?: EnumChallengeStatusEnumFieldUpdateOperationsInput | $Enums.ChallengeStatusEnum
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdBy?: StringFieldUpdateOperationsInput | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedBy?: StringFieldUpdateOperationsInput | string
    billingRecord?: ChallengeBillingUncheckedUpdateOneWithoutChallengeNestedInput
    legacyRecord?: ChallengeLegacyUncheckedUpdateOneWithoutChallengeNestedInput
    constraintRecord?: ChallengeConstraintUncheckedUpdateOneWithoutChallengeNestedInput
    events?: ChallengeEventUncheckedUpdateManyWithoutChallengeNestedInput
    discussions?: ChallengeDiscussionUncheckedUpdateManyWithoutChallengeNestedInput
    metadata?: ChallengeMetadataUncheckedUpdateManyWithoutChallengeNestedInput
    phases?: ChallengePhaseUncheckedUpdateManyWithoutChallengeNestedInput
    prizeSets?: ChallengePrizeSetUncheckedUpdateManyWithoutChallengeNestedInput
    reviewers?: ChallengeReviewerUncheckedUpdateManyWithoutChallengeNestedInput
    winners?: ChallengeWinnerUncheckedUpdateManyWithoutChallengeNestedInput
    attachments?: AttachmentUncheckedUpdateManyWithoutChallengeNestedInput
    terms?: ChallengeTermUncheckedUpdateManyWithoutChallengeNestedInput
    skills?: ChallengeSkillUncheckedUpdateManyWithoutChallengeNestedInput
    auditLogs?: AuditLogUncheckedUpdateManyWithoutChallengeNestedInput
    memberAccesses?: MemberChallengeAccessUncheckedUpdateManyWithoutChallengeNestedInput
  }

  export type ChallengeUncheckedUpdateManyWithoutTimelineTemplateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    privateDescription?: NullableStringFieldUpdateOperationsInput | string | null
    challengeSource?: NullableStringFieldUpdateOperationsInput | string | null
    descriptionFormat?: NullableStringFieldUpdateOperationsInput | string | null
    projectId?: NullableIntFieldUpdateOperationsInput | number | null
    typeId?: StringFieldUpdateOperationsInput | string
    trackId?: StringFieldUpdateOperationsInput | string
    overviewTotalPrizes?: NullableFloatFieldUpdateOperationsInput | number | null
    numOfRegistrants?: IntFieldUpdateOperationsInput | number
    numOfSubmissions?: IntFieldUpdateOperationsInput | number
    numOfCheckpointSubmissions?: IntFieldUpdateOperationsInput | number
    currentPhaseNames?: ChallengeUpdatecurrentPhaseNamesInput | string[]
    wiproAllowed?: BoolFieldUpdateOperationsInput | boolean
    tags?: ChallengeUpdatetagsInput | string[]
    groups?: ChallengeUpdategroupsInput | string[]
    taskIsTask?: BoolFieldUpdateOperationsInput | boolean
    taskIsAssigned?: BoolFieldUpdateOperationsInput | boolean
    taskMemberId?: NullableStringFieldUpdateOperationsInput | string | null
    submissionStartDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    submissionEndDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    registrationStartDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    registrationEndDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    startDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    endDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    legacyId?: NullableIntFieldUpdateOperationsInput | number | null
    status?: EnumChallengeStatusEnumFieldUpdateOperationsInput | $Enums.ChallengeStatusEnum
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdBy?: StringFieldUpdateOperationsInput | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedBy?: StringFieldUpdateOperationsInput | string
  }

  export type DefaultChallengeReviewerUpdateWithoutTimelineTemplateInput = {
    id?: StringFieldUpdateOperationsInput | string
    scorecardId?: NullableStringFieldUpdateOperationsInput | string | null
    isMemberReview?: BoolFieldUpdateOperationsInput | boolean
    memberReviewerCount?: NullableIntFieldUpdateOperationsInput | number | null
    phaseName?: StringFieldUpdateOperationsInput | string
    fixedAmount?: NullableFloatFieldUpdateOperationsInput | number | null
    baseCoefficient?: NullableFloatFieldUpdateOperationsInput | number | null
    incrementalCoefficient?: NullableFloatFieldUpdateOperationsInput | number | null
    opportunityType?: NullableEnumReviewOpportunityTypeEnumFieldUpdateOperationsInput | $Enums.ReviewOpportunityTypeEnum | null
    aiWorkflowId?: NullableStringFieldUpdateOperationsInput | string | null
    shouldOpenOpportunity?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdBy?: StringFieldUpdateOperationsInput | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedBy?: StringFieldUpdateOperationsInput | string
    challengeType?: ChallengeTypeUpdateOneRequiredWithoutDefaultReviewersNestedInput
    challengeTrack?: ChallengeTrackUpdateOneRequiredWithoutDefaultReviewersNestedInput
    phase?: PhaseUpdateOneWithoutDefaultChallengeReviewerNestedInput
  }

  export type DefaultChallengeReviewerUncheckedUpdateWithoutTimelineTemplateInput = {
    id?: StringFieldUpdateOperationsInput | string
    typeId?: StringFieldUpdateOperationsInput | string
    trackId?: StringFieldUpdateOperationsInput | string
    scorecardId?: NullableStringFieldUpdateOperationsInput | string | null
    isMemberReview?: BoolFieldUpdateOperationsInput | boolean
    memberReviewerCount?: NullableIntFieldUpdateOperationsInput | number | null
    phaseName?: StringFieldUpdateOperationsInput | string
    phaseId?: NullableStringFieldUpdateOperationsInput | string | null
    fixedAmount?: NullableFloatFieldUpdateOperationsInput | number | null
    baseCoefficient?: NullableFloatFieldUpdateOperationsInput | number | null
    incrementalCoefficient?: NullableFloatFieldUpdateOperationsInput | number | null
    opportunityType?: NullableEnumReviewOpportunityTypeEnumFieldUpdateOperationsInput | $Enums.ReviewOpportunityTypeEnum | null
    aiWorkflowId?: NullableStringFieldUpdateOperationsInput | string | null
    shouldOpenOpportunity?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdBy?: StringFieldUpdateOperationsInput | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedBy?: StringFieldUpdateOperationsInput | string
  }

  export type DefaultChallengeReviewerUncheckedUpdateManyWithoutTimelineTemplateInput = {
    id?: StringFieldUpdateOperationsInput | string
    typeId?: StringFieldUpdateOperationsInput | string
    trackId?: StringFieldUpdateOperationsInput | string
    scorecardId?: NullableStringFieldUpdateOperationsInput | string | null
    isMemberReview?: BoolFieldUpdateOperationsInput | boolean
    memberReviewerCount?: NullableIntFieldUpdateOperationsInput | number | null
    phaseName?: StringFieldUpdateOperationsInput | string
    phaseId?: NullableStringFieldUpdateOperationsInput | string | null
    fixedAmount?: NullableFloatFieldUpdateOperationsInput | number | null
    baseCoefficient?: NullableFloatFieldUpdateOperationsInput | number | null
    incrementalCoefficient?: NullableFloatFieldUpdateOperationsInput | number | null
    opportunityType?: NullableEnumReviewOpportunityTypeEnumFieldUpdateOperationsInput | $Enums.ReviewOpportunityTypeEnum | null
    aiWorkflowId?: NullableStringFieldUpdateOperationsInput | string | null
    shouldOpenOpportunity?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdBy?: StringFieldUpdateOperationsInput | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedBy?: StringFieldUpdateOperationsInput | string
  }



  /**
   * Batch Payload for updateMany & deleteMany & createMany
   */

  export type BatchPayload = {
    count: number
  }

  /**
   * DMMF
   */
  export const dmmf: runtime.BaseDMMF
}